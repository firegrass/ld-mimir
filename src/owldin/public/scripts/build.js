(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var moment = require('moment');

var box = document.createElement('div');



module.exports = {
  log : function (str){
    box.innerHTML += "<p><em>" + moment().format('h:mm:ss a')+"</em>: " + str + "</p>";
    box.parentNode.scrollTop = box.parentNode.scrollHeight;
  },
  error : function (str){
    box.innerHTML += "<p class='error'><em>" + moment().format('h:mm:ss a')+"</em>: " + str + "</p>";
    box.parentNode.scrollTop = box.parentNode.scrollHeight; 
  },
  appendTo : function (element){

    element.appendChild(box);
    element.style.OverflowY = "scroll";
    element.style.OverflowX = "hidden";

  }
}


module.exports.element = box;


},{"moment":62}],2:[function(require,module,exports){
/*
  
  Simple wrapper around ACE. It triggers 'save' signals and can only edit one thing at once.
  Something else needs to deal with updating this.

*/

var ace = require('brace');
require('brace/mode/json');
require('brace/mode/javascript');
require('brace/mode/markdown');
require('brace/theme/monokai');

var dom = require('green-mesa-dom');

module.exports = function (app, contentView){

  var emitter = new (require('events')).EventEmitter();

  var $element = dom('<div></div>');

  $element.css({
    display : 'none',
    width : contentView.size().x + "px",
    height : contentView.size().y + "px",
    position: 'absolute',
    top : '0px',
    left : '0px'
  });


  contentView.addElement($element.els[0]);
  
  app.layout.on('resize', function (width, height){

    // for this to work we'll have to go through and find all the editor instances. 
    // and call resize... 
    for (var id in editSessions){
      if (editSessions.hasOwnProperty(id)){
        editSessions[id].$container.css({
          width: contentView.size().x + "px",
          height : contentView.size().y + "px"
        });
        editSessions[id].editor.resize();
      }
    }

  });

  var editSessions = {};
  // we keep a track of which session is active so that if the global 'save entity' signal comes along, 
  // we know if the editor is active and that the user wishes to save their work.
  var currentSession = false;

  function findSessions (path){
    for (var session in editSessions){
      if (editSessions.hasOwnProperty(session)){
        if (editSessions[session].entity.path === path){
          return editSessions[session];
        }
      }
    }
  }

  app.on('entity-updated', function (type, path){

    // let's attempt to match this path to a session..
    var session = findSessions(path);
    //if (currentSession){

    if (session){

      if (type === "update"){
        // let's load the file... ALTHOUGH at this point it's highly likely that the entity data is out of date...
        app.vfs.readFile(path, function (err, entity, body){

              // okay, first of all, let's see if the user has any local changes:
          if (session.bodies.user === session.bodies.persisted){
            // no. They don't have any changes. Therefore we will just automatically
            // update them to this latest version from the server.
            session.bodies.conflict = false;
            session.bodies.persisted = session.bodies.user = body;

          } else {

            session.bodies.persisted = body;
            session.bodies.conflict = (body !== session.bodies.saving);

          }

          if (session.bodies.user === session.bodies.persisted){
            app.emit('session-synchronised', session.entity._sessionId);
          } else {
            app.emit('session-desynchronised', session.entity._sessionId);
          }

          if (currentSession && currentSession.entity._sessionId === session.entity._sessionId){
            emitter.resume(session.entity);
          }


        });

      } else if (type === "delete"){

        session.bodies.persisted = "";
        if (currentSession && currentSession.entity._sessionId === session.entity._sessionId){
          emitter.resume(session.entity);
          app.emit('session-desynchronised', session.entity._sessionId);
        }

      }

    }

    //}

  });

app.on('entity-renamed', function (type, path, oldPath){

  var session = findSessions(oldPath);

  if (session){

    debugger;

  }

});

  app.on('save-entity', function (){

    // we only want to save if we're the active session...
    if (currentSession && !currentSession.synchronised){

      currentSession.cursor = currentSession.editor.getCursorPosition();

      app.emit('session-synchronising', currentSession.entity._sessionId);

      var saveSession = currentSession;

      currentSession.bodies.saving = currentSession.bodies.user;
      app.vfs.writeFile(currentSession.entity.path, currentSession.bodies.user, function (err, response){
        
        saveSession.bodies.persisted = saveSession.bodies.saving;
        //if (saveSession.bodies.persisted === saveSession.bodies.user){
        //  app.emit('session-synchronised', saveSession.entity._sessionId);
        //}
        // send 'new' and 'old'
        //app.emit('entity-updated', 'update', saveSession.entity.path);

      });
    }

  });



  emitter.create = function createEditSession (entity, callback){

    var session = editSessions[entity._sessionId] = {
      entity : entity,
      bodies : {},
      synchronised : false
    };

    var $container = dom('<div></div>');
    $container.css({
      position : 'absolute',
      top : '0px',
      left : '0px',
      width : contentView.size().x + "px",
      height : contentView.size().y + "px",
      display : 'none'
    });

    session.$container = $container;

    $element.append($container);

    var editor = ace.edit($container.els[0]);
    editor.setTheme('ace/theme/monokai');
    editor.getSession().setUseWrapMode(true);
    editor.setShowPrintMargin(false);

    editor.on('change', function (){

      if (currentSession){
        currentSession.bodies.user = editor.getValue();
        if (currentSession.synchronised && currentSession.bodies.user !== currentSession.bodies.persisted){
          currentSession.synchronised = false;
          app.emit('session-desynchronised', currentSession.entity._sessionId);
        } else if (!currentSession.synchronised && (currentSession.bodies.user === currentSession.bodies.persisted)){
          currentSession.synchronised = true;
          app.emit('session-synchronised', currentSession.entity._sessionId);
        }
      }

    });

    session.editor = editor;

    app.emit('session-synchronising', entity._sessionId);

    app.vfs.readFile(entity.path, function (err, response, body){

      if (err){
        callback (false, err);
        return;
      }

      session.bodies.persisted = session.bodies.user =  body;
      session.bodies.saving = false;

      app.emit('session-synchronised', entity._sessionId);

      session.synchronised = true;

      callback(true);

    });

  }

  emitter.resume = function resumeEditSession (entity){

    currentSession = editSessions[entity._sessionId];

    if (!currentSession){
      return;
    }

    if (currentSession.entity.mime === "text/x-markdown"){
      currentSession.editor.getSession().setMode('ace/mode/markdown');
    } else if (currentSession.entity.mime === "application/json"){
      currentSession.editor.getSession().setMode('ace/mode/json');
    } else if (currentSession.entity.mime === "application/javascript"){
      currentSession.editor.getSession().setMode('ace/mode/javascript');
    }

    currentSession.$container.css({
      display : ''
    })

    currentSession.editor.setValue(currentSession.bodies.user, 1);
    if (currentSession.cursor){
      currentSession.editor.moveCursorToPosition(currentSession.cursor);
    }
    currentSession.editor.focus();

    $element.css({
      display : ''
    })

  }

  emitter.pause = function pauseEditSession (entity){

    var session = editSessions[entity._sessionId];
    session.cursor = session.editor.getCursorPosition();

    session.$container.css({
      display : 'none'
    });

    currentSession = false;


    $element.css({
      display: 'none'
    });


  }

  emitter.destroy = function destroyEditSession (entity, callback){

    // this is where we figure out whether it's okay to close this thing...
    var session = editSessions[entity._sessionId];


    if (!session){

      callback(true);

    } else {

      if (session.bodies.persisted !== session.bodies.user){
        var close = confirm('You have unsaved changes! Close anyway?');

        if (!close){
          callback(false);
          return;
        }
      }

      session.editor.destroy();
      session.$container.remove();

      editSessions[entity._sessionId] = null;
      delete editSessions[entity._sessionId];
      
      $element.css({
        display : 'none'
      });
      callback(true);

    }

  }

  return emitter;

}
},{"brace":"brace","brace/mode/javascript":19,"brace/mode/json":"brace/mode/json","brace/mode/markdown":"brace/mode/markdown","brace/theme/monokai":"brace/theme/monokai","events":53,"green-mesa-dom":33}],3:[function(require,module,exports){
var dom = require('green-mesa-dom');

module.exports = function (app, contentView){

  /*
  var term = new Terminal({
    cols: 80,
    rows: 24,
    screenKeys: true
  });
*/

  var $element = dom('<div></div>');

  var runT = function(o){
    return [
      '<div class="edit-file-info">',
      '<form class="edit">',
      '<fieldset>',
      '<legend>Run command</legend>',
      '<ul>',
      '<li><label>Name:</label><input type="text" name="command" value="" placeholder="Command to run on the server"></input></li>',
      '<li><label></label><button>Run</button></li>',
      '</ul>',
      '</fieldset>',
      '</form>',
      '<div class="output"></div>',
      '</div>'
    ].join('\n');

  };


  $element.addClass('commands');
  $element.css({
    display : 'none',
    'min-width' : contentView.size().x + 'px',
    'min-height' : contentView.size().y + 'px',
    position : 'absolute',
    top : 0,
    left : 0
  });

  $element.appendTo(contentView.element);

  var commandSessions = {};

  var commands = {};

  //term.open($element.els[0]);

  app.on('command-stdout', function (o){

    // actually this is 
    if (commandSessions[o.id]) commandSessions[o.id].$el.append('<pre>' + o.packet + '</pre>');


  });

  app.on('command-stderr', function (o){

    // actually this is 
    if (commandSessions[o.id]) commandSessions[o.id].$el.append('<pre class="error">' + o.packet + '</pre>');

  });

  app.on('command-close', function (o){
    if (commandSessions[o.id]) commandSessions[o.id].$el.append('<p>Completed with error code ' + o.packet + '</p>');
  });

  var requestId = 0;

  app.layout.on('resize', function (width, height){

    $element.css({
      'min-width' : contentView.size().x + 'px',
      'min-height' : contentView.size().y + 'px',
    });

  });


  var emitter = {};

  emitter.create = function createCommandSession (entity, callback){

    var session = commandSessions[entity._sessionId] = {
      entity : entity
    }

    session.$el = dom(runT());
    $element.append(session.$el);

    session.$el.css({ display: 'none'});

    app.emit('session-synchronised', entity._sessionId);
    /*

*/

    dom('form', session.$el).on('submit', function (e){

      e.preventDefault();

      var command = dom('input[name="command"]', session.$el).val();

      if (command !== ""){

        session.$el.remove();
        session.$el = dom('<div class="output"></div>');
        $element.append(session.$el);

        app.remoteSend('run-command', {
          id : entity._sessionId,
          cmd : command
        });

      }

    })

    callback(true);

  }

  emitter.pause = function pauseCommandSession (entity){

    var session = commandSessions[entity._sessionId];

    session.$el.css({
      display : 'none'
    });

    // hides the main terminals editor..
    $element.css({
      display : 'none',
    });


  }

  emitter.resume = function resumeCommandSession (entity){

    var session = commandSessions[entity._sessionId];

    session.$el.css({
      display : ''
    });

    $element.css({
      display : ''
    });

  }

  emitter.destroy = function destroyCommandSession (entity, callback){

    var session = commandSessions[entity._sessionId];

    session.$el.remove();

    app.remoteSend('terminate-command', entity._sessionId);

    commandSessions[entity._sessionId] = null;

    delete commandSessions[entity._sessionId];

    $element.css({
      display : 'none',
    });
    // callback true = okay to destroy this session...
    callback(true);

  }

  return emitter;

}
},{"green-mesa-dom":33}],4:[function(require,module,exports){
var dom = require('green-mesa-dom');
var each = require('foreach');

module.exports = function (app, contentView){

  /*
  var term = new Terminal({
    cols: 80,
    rows: 24,
    screenKeys: true
  });
*/

  var $element = dom('<div></div>');

  var staging = function (){

    return [
      '<div class ="output">',
      '<form>',
        '<table>',
          '<thead>',
            '<tr>',
              '<th>Commit?</th>',
              '<th>File</th>',
              '<th>Change</th>',
            '</tr>',
          '</thead>',
          '<tbody>',
          '</tbody>',
        '</table>',
        '<ul>',
        '<li><label>Commit message</label></li>',
        '<li><textarea name="commit-message"></textarea></li>',
        '<li><button>Commit</button></li>',
        '</ul>',
      '</form>',
      '</div>'
    ].join('\n')

  }

  var entityT = function (file, status){

    var state = "Added";

    /*
      ' ' = unmodified

      M = modified

      A = added

      D = deleted

      R = renamed

      C = copied

      U = updated but unmerged
    */

    if (typeof status.type != "undefined"){

      switch (status.type){

        case " ":
          state = "Unmodified";
          break;
        case "M":
          state = "Modified";
          break;
        case "A":
          state = "Added";
          break;
        case "R":
          state = "Renamed";
          break;
        case "C":
          state = "Copied";
          break;
        case "U":
          state = "Updated but unmerged"
          break;
      }

    }


    debugger;

    return [
      '<tr>',
      '<td><input type="checkbox" name="files" value="' + file.replace('"','').trim() +' " checked="checked"></input></td>',
      '<td>' + file + '</td>',
      '<td>' + state + '</td>',
      '</tr>'
    ].join('\n');

  }


  $element.addClass('commit');
  $element.css({
    display : 'none',
    'min-width' : contentView.size().x + 'px',
    'min-height' : contentView.size().y + 'px',
    position : 'absolute',
    top : 0,
    left : 0
  });

  $element.appendTo(contentView.element);

  var sessions = {};

  //term.open($element.els[0]);

  app.on('git-status', function (o){

    if (sessions[o.id]){

      var status = o.packet;

      sessions[o.id].status = status;

      each(status, function (status, file){

        sessions[o.id].$el.find('tbody').append(dom(entityT(file, status)));

      });

    }

  });

  app.on('git-commit', function (o){

    if (sessions[o.id]){

      var status = o.packet;

      sessions[o.id].$el.html('<pre>' + o.packet +  '</pre>');

    }

  });


  app.layout.on('resize', function (width, height){

    $element.css({
      'min-width' : contentView.size().x + 'px',
      'min-height' : contentView.size().y + 'px',
    });

  });

  var emitter = {};

  emitter.create = function createCommandSession (entity, callback){

    var session = sessions[entity._sessionId] = {
      entity : entity
    }


        //session.$el.remove();
    session.$el = dom(staging());
    $element.append(session.$el);

    session.$el.find('form').on('submit', function (e){

      e.preventDefault();

      var form = dom(e.target);
      var list = [];

      var msg = form.find('textarea[name="commit-message"]').val().trim();

      if (msg !== ""){

        each(e.target.elements, function (el){

          el = dom(el);

          if (el.attr('name') === "files"){
            list.push(el.val().trim());
          }

        });

      }

      app.remoteSend('git-commit', {
        id : entity._sessionId,
        msg : msg,
        stage : list
      });


    });

    app.remoteSend('git-status', {
      id : entity._sessionId
    });

    session.$el.css({ display: 'none'});

    app.emit('session-synchronised', entity._sessionId);


    callback(true);

  }

  emitter.pause = function pauseCommandSession (entity){

    var session = sessions[entity._sessionId];

    session.$el.css({
      display : 'none'
    });

    // hides the main terminals editor..
    $element.css({
      display : 'none',
    });


  }

  emitter.resume = function resumeCommandSession (entity){

    var session = sessions[entity._sessionId];

    session.$el.css({
      display : ''
    });

    $element.css({
      display : ''
    });

  }

  emitter.destroy = function destroyCommandSession (entity, callback){

    var session = sessions[entity._sessionId];

    session.$el.remove();



    sessions[entity._sessionId] = null;

    delete sessions[entity._sessionId];

    $element.css({
      display : 'none',
    });
    // callback true = okay to destroy this session...
    callback(true);

  }

  return emitter;

}
},{"foreach":31,"green-mesa-dom":33}],5:[function(require,module,exports){
var marked = require('marked');
var moment = require('moment');
var filesize = require('filesize');

var dom = require('green-mesa-dom');

module.exports = function (app, contentView){

  var emitter = new (require('events')).EventEmitter();

  var $element = dom('<div></div>');

  $element.addClass('info');
  $element.css({
    display : 'none',
    'min-width' : contentView.size().x + 'px',
    'min-height' : contentView.size().y + 'px',
    position : 'absolute',
    top : 0,
    left : 0
  });

  $element.appendTo(contentView.element);

  app.layout.on('resize', function (width, height){

    $element.css({
      'min-width' : contentView.size().x + 'px',
      'min-height' : contentView.size().y + 'px'
    });

  });

  var fileT = function(o){
    return [
      '<div class="edit-file-info">',
      '<form class="edit">',
      '<fieldset>',
      '<legend>Properties</legend>',
      '<ul>',
      '<li><label>Name:</label><input type="text" name="name" value="' + o.name + '"></input></li>',
      '<li><label>Path:</label>' + o.path + '</li>',
      '<li><label>Mime type:</label>' + o.mime + '</li>',
      '<li><label>Modified:</label>' + moment(o.mtime).format('MMMM Do YYYY, h:mm:ss a') + '</li>',
      '<li><label>Size:</label>' + filesize(o.size) + '</li>',
      '<li><label></label><button>Update</button></li>',
      '</ul>',
      '</fieldset>',
      '</form>',
      '<form class="delete">',
      '<fieldset>',
      '<legend>Delete</legend>',
      '<ul>',
      '<li><label></label><button>Delete</button></li>',
      '</ul>',
      '</fieldset>',
      '</form>',
      '</div>'
    ].join('\n');

  };


  var folderT = function(o){
    return [
      '<div class="edit-file-info">',
      '<form class="edit">',
      '<fieldset>',
      '<legend>Properties</legend>',
      '<ul>',
      '<li><label>Name:</label><input type="text" name="name" value="' + o.name + '"></input></li>',
      '<li><label>Path:</label>' + o.path + '</li>',
      '<li><label></label><button>Update</button></li>',
      '</ul>',
      '</fieldset>',
      '</form>',
      '<form class="delete">',
      '<fieldset>',
      '<legend>Delete</legend>',
      '<ul>',
      '<li><label></label><button>Delete</button></li>',
      '</ul>',
      '</fieldset>',
      '</form>',
      '</div>'
    ].join('\n');

  };


  var sessions = {};
  var currentSession = false;

  function makeFileSession (session){

    var $el = session.$el = dom(fileT(session.entity));

  }

  function makeFolderSession (session){

    var $el = session.$el = dom(folderT(session.entity));


  }

  app.on('entity-updated', function (type, path){

    // okay worry about this later... first of all I need to be able to 
    // load the file metadata from the VFS...

  });

  emitter.create = function (entity, callback){

    // the entity shoudl contain all the metadata we need for this

    var session = sessions[entity._sessionId] = {
      entity : entity,
      synchronised : false
    }

    if (session.entity.type === 'file'){

      makeFileSession(session);

    } else if (session.entity.type === 'folder'){

      makeFolderSession(session);

    }

    session.$el.css({ display : 'none'});

    dom('form.edit', session.$el).on('submit', function (e){

      e.preventDefault();

      //app.emit('rename-entity', session.entity, dom('form.edit input[name="name"]').val());

      /* 
        Let's actually just go ahead and rename it. Because this is hte only place that can do that.
      */
      if (session.entity.type === 'file'){

        app.vfs.renameFile(session.entity.path, dom('form.edit input[name="name"]').val(), function (err, newEntity, oldEntity){

          app.emit('request-terminate-session', entity._sessionId);

        });
      } else if (session.entity.type === 'folder'){

        app.vfs.renameFolder(session.entity.path, dom('form.edit input[name="name"]').val(), function (err, newEntity, oldEntity){

          app.emit('request-terminate-session', entity._sessionId);

        });      
      }

    });

    dom('form.delete', session.$el).on('submit', function (e){

      e.preventDefault();

      if (session.entity.type === 'file'){

        app.vfs.deleteFile(session.entity.path, function (err, newEntity, oldEntity){
          app.emit('request-terminate-session', entity._sessionId);
        });
      } else if (session.entity.type === 'folder'){

        app.vfs.deleteFolder(session.entity.path, function (err, newEntity, oldEntity){

          app.emit('request-terminate-session', entity._sessionId);

        });      
      }

      //app.emit('delete-entity', session.entity);
      app.emit('request-terminate-session', entity._sessionId);

    });

    $element.append(session.$el);

    app.emit('session-synchronised', entity._sessionId);

    callback(true);


  }

  emitter.resume = function resumeInfoSession (entity){
    // we actually keep a track of our sessions that are currently being actively 
    // looked at by the user!
    currentSession = sessions[entity._sessionId];

    // show this session..
    currentSession.$el.css({ display : ''});
    // show our editor...
    $element.css({ display : ''});

  }

  emitter.pause = function pauseInfoSession (entity){

    currentSession = false;

    var session = sessions[entity._sessionId];

    // hide the session..
    session.$el.css({ display : 'none'});

    // hide the editor as well.
    $element.css({ display : 'none'});

  }

  emitter.destroy = function destroyInfoSession (entity, callback){

    var session = sessions[entity._sessionId];

    // remove that element
    session.$el.remove();

    sessions[entity._sessionId] = null;
    delete sessions[entity._sessionId];

    $element.css({
      display : 'none'
    });

    callback('okay to close');

  };

  return emitter;

}
},{"events":53,"filesize":30,"green-mesa-dom":33,"marked":61,"moment":62}],6:[function(require,module,exports){
var marked = require('marked');
var moment = require('moment');
var filesize = require('filesize');

var dom = require('green-mesa-dom');

module.exports = function (app, contentView){

  var emitter = new (require('events')).EventEmitter();

  var $element = dom('<div></div>');

  $element.addClass('info');
  $element.css({
    display : 'none',
    'min-width' : contentView.size().x + 'px',
    'min-height' : contentView.size().y + 'px',
    position : 'absolute',
    top : 0,
    left : 0
  });

  $element.appendTo(contentView.element);

  app.layout.on('resize', function (width, height){

    $element.css({
      'min-width' : contentView.size().x + 'px',
      'min-height' : contentView.size().y + 'px'
    });

  });

  var folderT = function(o){
    return [
      '<div class="edit-file-info">',
      '<form class="edit">',
      '<fieldset>',
      '<legend>New document properties</legend>',
      '<ul>',
      '<li><label>Name:</label><input type="text" name="name" value="Untitled.md"></input></li>',
      '<li><label>Path:</label>' + o.path + '</li>',
      '<li><label></label><button>Create</button></li>',
      '</ul>',
      '</fieldset>',
      '</form>',
      '</div>'
    ].join('\n');

  };


  var sessions = {};
  var currentSession = false;

  function makeFileSession (session){

    var $el = session.$el = dom(folderT(session.entity));

  }

  emitter.create = function (entity, callback){

    // the entity shoudl contain all the metadata we need for this

    var session = sessions[entity._sessionId] = {
      entity : entity,
      synchronised : false
    }

    makeFileSession(session);

    session.$el.css({ display : 'none'});

    dom('form.edit', session.$el).on('submit', function (e){

      e.preventDefault();

      var folderName = dom('form.edit input[name="name"]').val();

      if (folderName !== "" && folderName.substr(0,1) !== "."){

        app.vfs.createFile(session.entity.path, folderName, function (err){

          if (!err){
            app.emit('request-terminate-session', entity._sessionId);
          }

        })

      }

      //app.emit('rename-entity', session.entity, dom('form.edit input[name="name"]').val());

      /* 
        Let's actually just go ahead and rename it. Because this is hte only place that can do that.
      */

      /*
      if (session.entity.type === 'file'){

        app.vfs.renameFile(session.entity.path, dom('form.edit input[name="name"]').val(), function (err, newEntity, oldEntity){

          app.emit('request-terminate-session', entity._sessionId);

        });
      } else if (session.entity.type === 'folder'){

        app.vfs.renameFolder(session.entity.path, dom('form.edit input[name="name"]').val(), function (err, newEntity, oldEntity){

          app.emit('request-terminate-session', entity._sessionId);

        });      
      }
      */

    });

    $element.append(session.$el);

    app.emit('session-synchronised', entity._sessionId);

    callback(true);


  }

  emitter.resume = function resumeInfoSession (entity){
    // we actually keep a track of our sessions that are currently being actively 
    // looked at by the user!
    currentSession = sessions[entity._sessionId];

    // show this session..
    currentSession.$el.css({ display : ''});
    // show our editor...
    $element.css({ display : ''});

  }

  emitter.pause = function pauseInfoSession (entity){

    currentSession = false;

    var session = sessions[entity._sessionId];

    // hide the session..
    session.$el.css({ display : 'none'});

    // hide the editor as well.
    $element.css({ display : 'none'});

  }

  emitter.destroy = function destroyInfoSession (entity, callback){

    var session = sessions[entity._sessionId];

    // remove that element
    session.$el.remove();

    sessions[entity._sessionId] = null;
    delete sessions[entity._sessionId];

    $element.css({
      display : 'none'
    });

    callback('okay to close');

  };

  return emitter;

}
},{"events":53,"filesize":30,"green-mesa-dom":33,"marked":61,"moment":62}],7:[function(require,module,exports){
var marked = require('marked');
var moment = require('moment');
var filesize = require('filesize');

var dom = require('green-mesa-dom');

module.exports = function (app, contentView){

  var emitter = new (require('events')).EventEmitter();

  var $element = dom('<div></div>');

  $element.addClass('info');
  $element.css({
    display : 'none',
    'min-width' : contentView.size().x + 'px',
    'min-height' : contentView.size().y + 'px',
    position : 'absolute',
    top : 0,
    left : 0
  });

  $element.appendTo(contentView.element);

  app.layout.on('resize', function (width, height){

    $element.css({
      'min-width' : contentView.size().x + 'px',
      'min-height' : contentView.size().y + 'px'
    });

  });

  var folderT = function(o){
    return [
      '<div class="edit-file-info">',
      '<form class="edit">',
      '<fieldset>',
      '<legend>New folder properties</legend>',
      '<ul>',
      '<li><label>Name:</label><input type="text" name="name" value="New folder"></input></li>',
      '<li><label>Path:</label>' + o.path + '</li>',
      '<li><label></label><button>Create</button></li>',
      '</ul>',
      '</fieldset>',
      '</form>',
      '</div>'
    ].join('\n');

  };


  var sessions = {};
  var currentSession = false;

  function makeFolderSession (session){

    var $el = session.$el = dom(folderT(session.entity));

  }

  emitter.create = function (entity, callback){

    // the entity shoudl contain all the metadata we need for this

    var session = sessions[entity._sessionId] = {
      entity : entity,
      synchronised : false
    }

    makeFolderSession(session);

    session.$el.css({ display : 'none'});

    dom('form.edit', session.$el).on('submit', function (e){

      e.preventDefault();

      var folderName = dom('form.edit input[name="name"]').val();

      if (folderName !== "" && folderName.substr(0,1) !== "."){

        app.vfs.writeFolder(session.entity.path, folderName, function (err){

          if (!err){
            app.emit('request-terminate-session', entity._sessionId);
          }

        })

      }

      //app.emit('rename-entity', session.entity, dom('form.edit input[name="name"]').val());

      /* 
        Let's actually just go ahead and rename it. Because this is hte only place that can do that.
      */

      /*
      if (session.entity.type === 'file'){

        app.vfs.renameFile(session.entity.path, dom('form.edit input[name="name"]').val(), function (err, newEntity, oldEntity){

          app.emit('request-terminate-session', entity._sessionId);

        });
      } else if (session.entity.type === 'folder'){

        app.vfs.renameFolder(session.entity.path, dom('form.edit input[name="name"]').val(), function (err, newEntity, oldEntity){

          app.emit('request-terminate-session', entity._sessionId);

        });      
      }
      */

    });

    $element.append(session.$el);

    app.emit('session-synchronised', entity._sessionId);

    callback(true);


  }

  emitter.resume = function resumeInfoSession (entity){
    // we actually keep a track of our sessions that are currently being actively 
    // looked at by the user!
    currentSession = sessions[entity._sessionId];

    // show this session..
    currentSession.$el.css({ display : ''});
    // show our editor...
    $element.css({ display : ''});

  }

  emitter.pause = function pauseInfoSession (entity){

    currentSession = false;

    var session = sessions[entity._sessionId];

    // hide the session..
    session.$el.css({ display : 'none'});

    // hide the editor as well.
    $element.css({ display : 'none'});

  }

  emitter.destroy = function destroyInfoSession (entity, callback){

    var session = sessions[entity._sessionId];

    // remove that element
    session.$el.remove();

    sessions[entity._sessionId] = null;
    delete sessions[entity._sessionId];

    $element.css({
      display : 'none'
    });

    callback('okay to close');

  };

  return emitter;

}
},{"events":53,"filesize":30,"green-mesa-dom":33,"marked":61,"moment":62}],8:[function(require,module,exports){
var marked = require('marked');

var dom = require('green-mesa-dom');

var path = require('path');
var svgPanZoom = require('svg-pan-zoom');

module.exports = function (app, contentView){

  var emitter = new (require('events')).EventEmitter();

  var $element = dom('<div></div>');

  $element.addClass('preview');
  $element.css({
    display : 'none',
    'width' : contentView.size().x + 'px',
    'height' : contentView.size().y + 'px',
    position : 'absolute',
    overflow : 'scroll',
    top : 0,
    left : 0
  });

  $element.appendTo(contentView.element);

  app.layout.on('resize', function (width, height){

    $element.css({
      'width' : contentView.size().x + 'px',
      'height' : contentView.size().y + 'px'
    });

  });

  var previewSessions = {};
  var currentSession = false;

  app.on('command-stdout', function (o){

    if (o.id.indexOf && o.id.indexOf('-preview') !== -1){

      var id = o.id.replace('-preview', '');

      // actually this is 
      if (previewSessions[id]){

        previewSessions[id].converted += o.packet;
      }

    }

  });

  app.on('command-stderr', function (o){

    if (o.id.indexOf && o.id.indexOf('-preview') !== -1){

      var id = o.id.replace('-preview', '');

      // actually this is 
      if (previewSessions[id]){
        // what should we do with errors? Probably just stop and display "sorry!";
        // let's actually get the session synchronised anyway...
        app.emit('session-synchronised', id);
      }

    }

  });

  app.on('command-close', function (o){

    if (o.id.indexOf && o.id.indexOf('-preview') !== -1){

      var id = o.id.replace('-preview', '');

      // actually this is 
      if (previewSessions[id]){

        previewSessions[id].body = previewSessions[id].converted;
        previewSessions[id].complete = true;

        // only if the session is teh current session...
        app.emit('session-synchronised', id);

        if (previewSessions[id] === currentSession){
          $element.html(previewSessions[id].body);
          //$element.css({ display : ''});
          svgPanZoom($element.find('svg').els[0], { minZoom: 0.1});
          $element.find('svg').attr('width', parseFloat($element.find('svg').attr('width'), 10) / 2 + "pt");
          $element.find('svg').attr('height', parseFloat($element.find('svg').attr('height'), 10) / 2 + "pt");
        }

      }

    }

  });

  emitter.create = function createPreviewSession (entity, callback){
    var session = previewSessions[entity._sessionId] = {
      entity : entity,
      body : {}
    };

    var fileExt = path.extname(entity.name);

    if (fileExt === ".md" || fileExt === ".txt" || fileExt === "" || fileExt === ".html"){

      app.vfs.readFile(entity.path, function (err, response, body){

        if (err){
          callback (false, err);
          return;
        }

        session.body = body;

        app.emit('session-synchronised', entity._sessionId);

        callback(true);

      });

    } else if (fileExt === ".png" || fileExt === ".jpg" || fileExt === ".gif") {

      app.vfs.readFileAsBase64(entity.path, function (err, response, body){

        if (err){
          callback (false, err);
          return
        }

        session.body = body;

        app.emit('session-synchronised', entity._sessionId);

        callback(true);

      });

    } else if (fileExt === ".ttl") {

      session.converted = "";
      session.complete = false;

      app.remoteSend('run-command', {
        id : entity._sessionId + '-preview',
        cmd : 'rapper -i turtle ' + path.join('.', entity.path) + ' -o dot | dot -Tsvg'
      });

      app.emit('session-synchronised', entity._sessionId);

      callback(true);

    } else {
      // no load...
      session.body = ""
      app.emit('session-synchronised', entity._sessionId);
      callback(true);

    }


  }

  emitter.resume = function resumePreviewSession (entity){

    currentSession = previewSessions[entity._sessionId];

    if (!currentSession){
      return false;
    }

    if (currentSession.entity.mime === "text/x-markdown"){
      $element.html('<div class="md-preview-content">' + marked(currentSession.body) + '</div>');
    } else if (currentSession.entity.mime === "application/json"){
      $element.html('<div class="md-preview-content">' + marked('~~~json\n' + JSON.stringify(JSON.parse(currentSession.body), false, 4) + '~~~\n') + '</div>');

    } else {

      var fileExt = path.extname(entity.name);

      if (fileExt === ".png" || fileExt === ".gif" || fileExt === ".jpg"){

        $element.html('<img></img>');
        $element.find('img').attr('src', currentSession.body);

      } else if (fileExt === ".ttl"){
        // the body should be an SVG at this point...

        // will have to look up how to render an SVG document directly in the browser, haven't done it 
        // in a while if I'm honest...
        if (currentSession.complete){

          $element.html(currentSession.body);
          $element.css({ display : ''});
          svgPanZoom($element.find('svg').els[0], { minZoom: 0.1});
          $element.find('svg').attr('width', parseFloat($element.find('svg').attr('width'), 10) / 2 + "pt");
          $element.find('svg').attr('height', parseFloat($element.find('svg').attr('height'), 10) / 2 + "pt");
        } else {
          $element.html('<div class="md-preview-content">Please wait while we convert this turtle file</div>')
        }
        
      } else if (fileExt === ".html"){

        $element.html('<div class="md-preview-content">' + currentSession.body + '</div>');  
        

      } else {

        $element.html('<div class="md-preview-content">There is no built-in viewer for this type of file. <a href="' + app.vfs.getURI(currentSession.entity.path) + '" target="blank">Download ' + currentSession.entity.name + '</a></div>');
      
      }
    }

    $element.css({ display : ''});

  }

  emitter.pause = function pausePreviewSession (entity){

    currentSession = false;
    $element.css({ display : 'none'});

  }

  emitter.destroy = function destroyPreviewSession (entity, callback){

    if (previewSessions[entity._sessionId]){
      previewSessions[entity._sessionId] = null;
      delete previewSessions[entity._sessionId];
      callback(true); // always okay to close!
    }

    $element.css({
      display : 'none'
    });


  }

  return emitter;

}
},{"events":53,"green-mesa-dom":33,"marked":61,"path":54,"svg-pan-zoom":63}],9:[function(require,module,exports){
var Terminal = require('term.js');
var dom = require('green-mesa-dom');

module.exports = function (app, contentView){

  /*
  var term = new Terminal({
    cols: 80,
    rows: 24,
    screenKeys: true
  });
*/

  var $element = dom('<div></div>');

  $element.addClass('terminals');
  $element.css({
    display : 'none',
    'min-width' : contentView.size().x + 'px',
    'min-height' : contentView.size().y + 'px',
    position : 'absolute',
    top : 0,
    left : 0
  });



  $element.appendTo(contentView.element);

  var terminalSessions = {};

  var terminals = {};

  //term.open($element.els[0]);

  app.on('term', function (o){

    terminals[o.id].write(o.packet);

  });

  var requestId = 0;

  app.layout.on('resize', function (width, height){

    $element.css({
      'min-width' : contentView.size().x + 'px',
      'min-height' : contentView.size().y + 'px',
    });

  });


  var emitter = {};

  emitter.create = function createTerminalSession (entity, callback){

    var session = terminalSessions[entity._sessionId] = {
      entity : entity
    }

    var sizes = testSizes();

    app.once('terminal-created', function (msg){

      var term = new Terminal({
        cols : sizes.cols,
        rows : sizes.rows,
        screenKeys : true
      });


      // for direct communications from the server...
      terminals[msg.id] = term;

      term.on('data', function(data) {
        app.remoteSend('term', {
          id : msg.id,
          packet : data
        });
      });
        

      var $term = dom('<div></div>');
      $element.append($term);
      term.open($term.els[0]);

      $term.css({
        display : 'none'
      });

      // for the session...
      session.termId = msg.id
      session.terminal = term;
      session.$term = $term;

      app.emit('session-synchronised', entity._sessionId);

      callback(true);

    });

    app.remoteSend('create-term', {
      id : entity._sessionId,
      rows : sizes.rows,
      cols : sizes.cols
    });

  }

  emitter.pause = function pauseTerminalSession (entity){

    var session = terminalSessions[entity._sessionId];

    session.$term.css({
      display : 'none'
    });

    // hides the main terminals editor..
    $element.css({
      display : 'none',
    });


  }

  emitter.resume = function resumeTerminalSession (entity){

    var session = terminalSessions[entity._sessionId];

    session.$term.css({
      display : ''
    });

    $element.css({
      display : ''
    });

  }

  emitter.destroy = function destroyTerminalSession (entity, callback){

    var session = terminalSessions[entity._sessionId];

    session.terminal.destroy();
    session.$term.remove();

    app.remoteSend('kill-term', session.termId);

    terminals[session.termId] = null;
    terminalSessions[entity._sessionId] = null;

    delete terminalSessions[entity._sessionId];
    delete terminals[session.termId];

    $element.css({
      display : 'none',
    });
    // callback true = okay to destroy this session...
    callback(true);

  }


  function testSizes (){

      $element.css({display : ''});

      var $tester = dom('<div>0</div>');
      $tester.css({
        display: 'inline-block'
      })
      $element.append($tester);
        //var $el

      var charWidth = $tester.els[0].clientWidth;
      var charHeight = $tester.els[0].clientHeight;

      $element.css({display : 'none'});
      $tester.remove();

      return {
        cols : Math.floor( ((contentView.size().x / charWidth) / 10) ) * 10,
        rows : Math.floor(contentView.size().y / charHeight)
      }

  }

  return emitter;

}
},{"green-mesa-dom":33,"term.js":70}],10:[function(require,module,exports){
var domify = require('domify');
var dom = require('green-mesa-dom');

module.exports = function (app, box){

  var files = domify('<ul></ul>')
  files.className = "box-inner files";
  box.addElement(files);

  var currentTree = false;

  // this event gets triggered whenever the virtual file system has finished synchronising with the server
  app.on('sync', function (path){

    app.vfs.getAll(refreshTree);

  });

  function deleteChildren (node){
    var fn = function (){ this.remove(); this.onclick = null; };
    var fns = [];
    forEach.call( node.childNodes , function (node){ 
      fns.push(fn.bind(node))
    });
    forEach.call(fns, function(fn){fn()});
  }

  function fileT (o){
    return '<li class="file">' +
        '<span class="typcn typcn-document-text"></span>' +
        '<a href="#">' + 
          o.name +
        '</a>' +
        '<span class="typcn typcn-hover typcn-eye-outline"></span>' + 
        '<span class="typcn typcn-hover typcn-info-large"></span>' + 
      '</li>';
  }

  function folderT (o){
    return '<li>' +
        '<span class="typcn typcn-folder"></span>' +
        '<span class="typcn typcn-folder-open"></span>' +
        '<a href="#">' + 
          o.name + 
        '</a>' +
        '<span class="typcn typcn-hover typcn-document-add"></span>' +
        '<span class="typcn typcn-hover typcn-folder-add"></span>' + 
        '<span class="typcn typcn-hover typcn-info-large"></span>' + 
      '</li>';

  }

  function refreshTree (tree){

    //deleteChildren(files);

    currentTree = tree;

    dom('li', files).remove();
    var $files = dom(files);

    function showContents (tree, $parent, level){

      //var el = domify(newFolder());
    //  $newFolder = dom('a', el);
     // $parent.append(el);

      tree.forEach(function (entity){

        var el, $a, $ul = false;

        if (entity.type === "file"){

          el = domify(fileT(entity));
          $a = dom('a', el);

          $preview = dom('span.typcn-eye-outline', el);
          $info = dom('span.typcn-info-large', el);

          $a.on('mouseup', (function (entity, $el, event){

            if (event.which === 1){

              app.emit('edit-entity', entity);

            } else if (event.which === 3){

              fileContextMenu(entity, $el);

            }

          }).bind({}, entity, dom(el)))

          $preview.on('click', (function (entity, event){

            event.preventDefault();

            app.emit('preview-entity', entity);

          }).bind({}, entity));

          $info.on('click', (function (entity, event){

            event.preventDefault();

            app.emit('edit-entity-info', entity, 'file');

          }).bind({}, entity));


        } else if (entity.type === "folder"){

          el = domify(folderT(entity));
          $a = dom('a', el);

          $info = dom('span.typcn-info-large', el);
          $newFolder = dom('span.typcn-folder-add', el);
          $newFile = dom('span.typcn-document-add', el);

          if (entity.path === "/"){
            $info.css({ display: 'none'})
          }
          
          $ul = dom('<ul class="level-' + (level + 1)+ '"></ul>');

          //$el.addClass('open');
          $ul.addClass('open');
          dom(el).addClass('open');

          $a.on('mouseup', (function(entity, $el, $ul, event){

            if (event.which === 1){
              $el.toggleClass('open');
              $ul.toggleClass('open');
            }

          }).bind({}, entity, dom(el), $ul));

          $newFolder.on('click', (function (entity, event){

            event.preventDefault();

            app.emit('begin-new-folder-session', entity);

          }).bind({}, entity));

          $newFile.on('click', (function (entity, event){

            event.preventDefault();

            app.emit('begin-new-document-session', entity);

          }).bind({}, entity));

          $info.on('click', (function (entity, event){

            event.preventDefault();

            app.emit('edit-entity-info', entity, 'folder');

          }).bind({}, entity));

          showContents(entity.contents, $ul, level + 1);

        }

        $parent.append(el);
        if ($ul){
          $parent.append($ul);
        }

      });

    }

    showContents(tree, $files, 0);

    dom('ul.files  > li', box.element).addClass('open');
    dom('ul.files > ul.level-1', box.element).addClass('open');

  }

  function fileContextMenu(entity, $el){

    console.log('Content menu not implemented');

  }

};
},{"domify":29,"green-mesa-dom":33}],11:[function(require,module,exports){
var $ = document.querySelector.bind(document);
var console = require('./console.js');

module.exports = function screenInitialiser (){

  /*
      --top menu-------------
      -n---tabs--------------
      -a--                  -
      -v-- edit window      -
      - --                  -
      --footer---------------
  */

  var emitter = new (require('events')).EventEmitter;

  // heights config.. 
  var topMenuHeight = 30;
  var fileNavigationWidth = 400;
  var editorTabHeight = 25;
  var consoleHeight = 100;

  // some css classes config... 
  var fileNavigationClass = 'file-nav';
  var pageClass = 'page';
  var topMenuClass = 'top-menu';
  var editorWrapperClass = 'content-view';
  var editorTabsClass = 'tabs';
  var editorViewClass = 'editor';
  var consoleClass = 'console';

  // create an outer wrapper..
  var page = createBox(pageClass);
  page.element.style.overflow = "hidden";

  var topMenu = createBox(topMenuClass);
  page.addBox(topMenu);

  var fileNavigation = createBox(fileNavigationClass);
  page.addBox(fileNavigation);

  var editorWrapper = createBox(editorWrapperClass);
  page.addBox(editorWrapper);

  var editorTabs = createBox(editorTabsClass);
  editorWrapper.addBox(editorTabs);

  var editorView = createBox(editorViewClass);
  editorWrapper.addBox(editorView);

  var consoleView = createBox(consoleClass);
  page.addBox(consoleView);

  require('./console.js').appendTo(consoleView.element);

  //consoleView.addElement(console.element);

  // now append to the actual body...
  page.appendToElement(document.querySelector('body'));

  var gr = (1 + Math.sqrt(5)) / 2;
  // make sure we have a handler...
  function handleResize (e){

    var innerWidth = window.innerWidth;
    var innerHeight = window.innerHeight;

    //fileNavigationWidth = window.innerWidth - (window.innerWidth / gr);

    page.size(innerWidth, innerHeight);
    page.position(0, 0);

    topMenu.size(innerWidth, topMenuHeight);
    topMenu.position(0, 0);

    consoleView.size(innerWidth, consoleHeight);
    consoleView.position(0, innerHeight - consoleHeight);

    fileNavigation.size(fileNavigationWidth - 10, innerHeight - topMenu.size().y - consoleView.size().y - 10);
    fileNavigation.position(0, (topMenu.size().y));

    editorWrapper.size(innerWidth - (fileNavigationWidth + 1), innerHeight - topMenu.size().y - consoleView.size().y);
    editorWrapper.position(fileNavigationWidth + 1,(topMenu.size().y));

    editorTabs.size(editorWrapper.size().x, editorTabHeight);
    editorTabs.position(0, 0);

    editorView.size(editorWrapper.size().x, editorWrapper.size().y - editorTabHeight);
    editorView.position(0, editorTabHeight);

    emitter.emit('resize', innerWidth, innerHeight);

  }

  window.addEventListener('resize', handleResize, false);

  emitter.page = page;
  emitter.menu = topMenu;
  emitter.nav = fileNavigation;
  emitter.tabs = editorTabs;
  emitter.editor = editorView;
  emitter.console = consoleView;

  // trigger a resize manually to get initial positions and sizes... 
  handleResize();

  return emitter;

}

function createBox (className){

  var el = document.createElement('div');
  var style = el.style;
  el.className = "box " + className ;
  style.position = "absolute";
  style.top = "0px";
  style.left = "0px";
  style.width = "0px";
  style.height = "0px";

  return {
    element : el,
    position : function (x, y){
      if (!arguments.length){
        return {
          x : parseInt(style.left, 10),
          y : parseInt(style.top, 10)
        }
      } 
      style.top = y + "px";
      style.left = x + "px";
    },
    size : function (x, y){
      if (!arguments.length){
        return {
          x : parseInt(style.width, 10),
          y : parseInt(style.height, 10)
        }
      } 
      style.height = y + "px";
      style.width = x + "px";
    },
    addBox : function (box){
      box.appendToElement(el);
    },
    addElement : function (element){
      el.appendChild(element);
    },
    appendToElement : function (element){
      element.appendChild(el);
    }
  }

}
},{"./console.js":1,"events":53}],12:[function(require,module,exports){
var dom = require('green-mesa-dom');
var each = require('foreach');

var backdrop = '<div class="modal-backdrop fade"></div>';
var button = function (o){ return '<button class="btn btn-mini ' + o.classes +'">' + o.option +'</button>'; };

var modal = function (o){ return '' + 
  '<div class="modal fade">' +
  ' <div class="modal-header">' +
  '   <h3>'+ o.header + '</h3>' +
  ' </div>' + 
  ' <div class="modal-body">' +
  '   <div>' + o.message + '</div>' +
  ' </div>' +
  ' <div class="modal-footer">' +
  '   <div class="btn-group">' +
  '   </div>' +
  '</div>' +
  '</div>'
};

var loading = '' +
'<div class="modal fade">' +
' <div class="modal-header">Loading... please wait</div>' +
' <div class="modal-footer"></div>' +
'</div>';

function Popups (){

  this.backdrop = dom(backdrop);
  this.loader = dom(loading);

  return this;

}

Popups.prototype = {
  loading : function (){

    clearTimeout(this.timeout);

    dom('body').append(this.backdrop);
    dom('body').append(this.loader);

    this.timeout = setTimeout((function (){

      this.backdrop.addClass('in');
      this.loader.addClass('in');

    }).bind(this), 100);
  },
  notLoading : function (){

    clearTimeout(this.timeout);

    this.backdrop.removeClass('in');
    this.loader.removeClass('in');

    this.backdrop.remove();
    this.loader.remove();

  },
  message : function (header, message, fn){

    console.log(message);
    fn();

  },
  confirm : function (header, message, options){

    var confirmBox = dom(modal({ header : header, message: message }));

    var btnGroup = dom(confirmBox).find('.btn-group');

    dom('body').append(this.backdrop);
    dom('body').append(confirmBox);

    this.backdrop.css({
      height : window.innerHeight + "px"
    })

    each(options, function (option){

      var btn = dom(button({option : option.text, classes: option.classes ? option.classes : ""}));

      btnGroup.append(btn);

      btn.on('click', (function (e){

        e.preventDefault();

        this.backdrop.remove();
        confirmBox.remove();

        option.callback();

      }).bind(this));

    }, this);

    setTimeout((function (){ 
      confirmBox.addClass('in');
      this.backdrop.addClass('in');
    }).bind(this),10);

  }

};

var popups = new Popups();

module.exports = popups;
},{"foreach":31,"green-mesa-dom":33}],13:[function(require,module,exports){
var console = require('./console.js');
var domify = require('domify');
var dom = require('green-mesa-dom');
var popups = require('./modal.js');
var filesize = require('filesize');
var DiffMatchPatch = require('diff-match-patch');
var dmp = new DiffMatchPatch();
var cloneDeep = require('clone-deep');

module.exports = function (app, sessionHandlers, box){

  // Right, let's keep this simple.
  // Session Handlers should have a consistent API
  // because we're not at all DRY here atm.
  // 
  // We also want to remove all the dealing with 
  // entity changes here. All that sessions should 
  // deal with is creating, pausing, resuming and destroying
  // sessions, looking after the tabs.

  var ul = domify('<ul class="tabs"></ul>');
  box.addElement(ul);
  $ul = dom(ul);

  // we use an array because ordering is useful here.
  var sessions = [];

  // counters/ids
  var sessionId = 0;
  var terminalSessionCount = 0;
  var commandSessionCount = 0;
  var commitSessionCount = 0;

  function getEditor (editor){

    if (editor === "ace"){
      return sessionHandlers.ace;
    } else if (editor === "info"){
      return sessionHandlers.info;
    } else if (editor === "preview"){
      return sessionHandlers.preview;
    } else if (editor === "terminal"){
      return sessionHandlers.terminals;
    } else if (editor === "new-document"){
      return sessionHandlers.newDocument;
    } else if (editor === "new-folder"){
      return sessionHandlers.newFolder;
    } else if (editor === "command"){
      return sessionHandlers.commands;
    } else if (editor === "commit"){
      return sessionHandlers.commit;
    }
  }

  function initialiseSession (entity, title, editor, callback){

    entity = cloneDeep(entity);

    var session = {
      editor : getEditor(editor),
      type : editor,
      entity : entity,
      sessionId : ++sessionId,
      title : title,
      path : entity.path,
      $tab : dom('<li class="' + editor +'"><a href="#">' + title +'</a><span class="typcn typcn-power"></span><span class="typcn typcn-media-record"></span><span class="typcn typcn-arrow-sync"></span></li>')
    }


    session.$tab.addClass('synchronising');

    session.entity._sessionId = session.sessionId;

    $ul.append(session.$tab);

    dom('a', session.$tab).on('click', function (e){

      resumeSession(session);

    });

    dom('span', session.$tab).on('click', function (e){

      destroySession(session);

    });

    sessions.push(session);

    session.editor.create(session.entity, function (createdOkay){

      if (createdOkay){
        callback(session);
      }

    });

    return session;

  }

  function resumeSession (session){

    // when we resume a session we need to pause the existing session
    if (sessions[0].active && sessions[0].sessionId !== session.sessionId){
      pauseSession(sessions[0]);
    }

    sessions.unshift(sessions.splice(sessions.indexOf(session), 1)[0]);
    session.editor.resume(session.entity);
    session.$tab.addClass('active');
    session.active = true;
  }

  function pauseSession (session){

    session.editor.pause(session.entity);
    session.$tab.removeClass('active');
    session.active = false;
  }

  function destroySession (session){

    // async.. could require user input before closing... 
    session.editor.destroy(session.entity, function (okayToClose){
      if (okayToClose){
        session.$tab.remove();
        session.$tab = null;
        session.editor = null;
      }
      sessions.splice(sessions.indexOf(session), 1);

      if (sessions[0]){
        resumeSession(sessions[0]);
      }
    });

  }

  function findSession (entity, type){

    for (var i = 0; i < sessions.length; i++){
      if (sessions[i].type === type && sessions[i].path === entity.path){
        return sessions[i];
      }
    }

    return false;

  }

  function findSessionById (id){
    for (var i = 0; i < sessions.length; i++){
      if (sessions[i].sessionId === id) return sessions[i];
    }
    return false;
  }

  // this only fire once.
  app.on('edit-entity', function (entity){

    var session = findSession (entity, 'ace');

    if (!session){

      if (entity.mime !== "application/json" && entity.mime !== "text/x-markdown" && entity.mime !== "application/javascript"){

        initialiseSession(entity, entity.name, 'preview', function (session){

          resumeSession(session);

        })

      } else {

        initialiseSession(entity, entity.name, 'ace', function (session){

          resumeSession(session);

        });

      }

    } else {

      resumeSession(session);

    }


  });

  app.on('begin-new-document-session', function (entity){

    var session = findSession (entity, 'new-document');

    if (!session){

      initialiseSession(entity, entity.name, 'new-document', function (session){
        resumeSession(session);
      });

    }

  });


  app.on('begin-new-folder-session', function (entity){

    var session = findSession (entity, 'new-folder');

    if (!session){

      initialiseSession(entity, entity.name, 'new-folder', function (session){
        resumeSession(session);
      });

    }

  });

  app.on('preview-entity', function (entity){

    var session = findSession (entity, 'preview');

    if (!session){

      initialiseSession(entity, entity.name, 'preview', function (session){

        resumeSession(session);

      });

    } else {

      resumeSession(session);

    }


  });

  app.on('edit-entity-info', function (entity){

    var session = findSession (entity, 'info');

    if (!session){

      initialiseSession(entity, entity.name, 'info', function (session){

        resumeSession(session);

      });

    } else {

      resumeSession(session);

    }


  });

  app.on('new-command-session', function (){

    var commandId = 'command-' + (++commandSessionCount);

    var session = initialiseSession({ path : commandId}, commandId, 'command', function (session){

      resumeSession(session);

    });

  });

  app.on('new-commit-session', function (){

    var commitId = 'commit-' + (++commitSessionCount);

    var session = initialiseSession({ path : commitId}, commitId, 'commit', function (session){

      resumeSession(session);

    });

  });

  app.on('new-terminal-session', function (){

    var termId = 'terminal-' + (++terminalSessionCount);

    var session = initialiseSession({ path : termId }, termId, 'terminal', function (){

      resumeSession(session);

    });

  });

  app.on('request-terminate-session', function (sessionId){

    var session = findSessionById(sessionId);
    if (session){
      destroySession(session);
    }

  });

  app.on('session-desynchronised', function (sessionId){

    var session = findSessionById(sessionId);
    if (session){
      session.$tab.addClass('desync');
      session.$tab.removeClass('synchronising');
    }

  });

  app.on('session-synchronised', function (sessionId){

    var session = findSessionById(sessionId);
    if (session){
      session.$tab.removeClass('desync');
      session.$tab.removeClass('synchronising');
    }

  });

  app.on('session-syncrhonising', function (sessionId){

    var session = findSessionById(sessionId);
    if (session){
      session.$tab.removeClass('desync');
      session.$tab.addClass('synchronising');
    }

  });

};
},{"./console.js":1,"./modal.js":12,"clone-deep":22,"diff-match-patch":28,"domify":29,"filesize":30,"green-mesa-dom":33}],14:[function(require,module,exports){
var dom = require('green-mesa-dom');

module.exports = function (app, box){

  var $menu = dom('' + 
    '<ul class="box-inner menu-content">' +
    '<li><span class="typcn typcn-th-menu"></span>' + 
      '<ul>' + 
        '<li><a href="#" rel="rels/save-file"><span class="typcn typcn-arrow-sync"></span>Save all</a></li>' + 
        '<li><a href="#" rel="rels/commit-session"><span class="typcn typcn-arrow-sync"></span>Commit</a></li>' + 
        '<li><a href="#" rel="rels/new-terminal"><span class="typcn typcn-device-desktop"></span>New Terminal</a></li>' + 
        '<li><a href="#" rel="rels/new-command"><span class="typcn typcn-spanner"></span>Run command</a></li>' + 
      '</ul>' + 
    '</li>' +
  '</ul>');

  $menu.appendTo(box.element);

  dom('a[rel="rels/save-file"]', $menu).on('click', function (e){

    e.preventDefault();
    app.emit('save-entity');

  });

  dom('a[rel="rels/commit-session"]', $menu).on('click', function (e){

    e.preventDefault();
    app.emit('new-commit-session');

  });

  dom('a[rel="rels/new-terminal"]', $menu).on('click', function (e){

    e.preventDefault();
    app.emit('new-terminal-session');

  });

  dom('a[rel="rels/new-command"]', $menu).on('click', function (e){

    e.preventDefault();
    app.emit('new-command-session');

  });

}
},{"green-mesa-dom":33}],15:[function(require,module,exports){
// probably want to move this to a config file at some point..
var vfsRoot = window.location.protocol + "//" + window.location.host + "/vfs";
var sockRoot = window.location.protocol + "//" + window.location.host + "/comms"

// application level broker... 
var app = new (require('events')).EventEmitter();

// layout manages the screen
var layout = app.layout = require('./components/layout.js')();

// set up the socket communications with the server for terminals/file updates
var remote = require('./lib/remote.js')(app, sockRoot);
// get the virtual file system working...
app.vfs = require('./lib/file-system').initialiseFileSystem(app, vfsRoot);
// initialise the entity selector. This MUST happen before the first vfs:sync event.
var entitySelector = require('./components/entity-selector.js')(app, layout.nav);


var topMenu = require('./components/top-menu.js')(app, layout.menu);

var sessionHandlers = {
  ace : require('./components/editors/ace.js')(app, layout.editor),
  info : require('./components/editors/info.js')(app, layout.editor),
  preview : require('./components/editors/previewer.js')(app, layout.editor),
  terminals : require('./components/editors/terminals.js')(app, layout.editor),
  newFolder : require('./components/editors/new-folder.js')(app, layout.editor),
  newDocument : require('./components/editors/new-document.js')(app, layout.editor),
  commands : require('./components/editors/command.js')(app, layout.editor),
  commit : require('./components/editors/commit.js')(app, layout.editor)
}

var sessions = require('./components/sessions.js')(app, sessionHandlers, layout.tabs);

// system wide save event
window.onkeydown = function (e){
  if((e.ctrlKey || e.metaKey)){
    if (e.which == 83) {
      e.preventDefault();
      app.emit('save-entity');
    }
  }
}



// the entity selector (or 'file navigation thing' to you and I, but we can't call it that)



/*

var $ = document.querySelector.bind(document);

$('body').oncontextmenu = function (event) {
    event.preventDefault();
    event.stopPropagation();
    return false;
  };


var SocksJS = require('./lib/socks.js');





var ace = require('brace');
require('brace/mode/json');
require('brace/mode/markdown');
require('brace/theme/monokai');

var fileSystem = {
  children : {
    root : {
      entities : [],
      name : "/",
      href : vfsRoot + "/",
      children : {},
      parent : false
    }
  }
};

var socket = new SocksJS(sockRoot);

socket.onopen = function (){
  console.log('socket open!');
}
socket.onmessage = function (e){

  var msg = JSON.parse(e.data);

  for (var i in msg){

    console.log(msg[i], i)

  }

}

var editSessions = {};
var activeDirectory = false;
var activeSession = false;
var directoryCache = {};

var fileSystemViewElements = {};
var forEach = Array.prototype.forEach;

var page = createBox('page');
page.position(0,0);
page.size(window.innerWidth, window.innerHeight);
page.appendToElement(document.querySelector('body'));

var topMenu = createBox('top-menu');
topMenu.position(0,0);
topMenu.size(window.innerWidth, 30);

var topMenuContent = domify([
  '<ul class="box-inner menu-content">',
  '<li><span>File</span><ul><li><a href="#" rel="rels/new-file">New file</a></li><li><a href="#" rel="rels/new-folder">New folder</a></li></ul></li>',
  '</ul>'
].join('\n'));

topMenu.addElement(topMenuContent);

var fileNavigation = createBox('file-nav');
fileNavigation.position(0,(topMenu.size().y));
fileNavigation.size(301, window.innerHeight - topMenu.size().y);
page.addBox(fileNavigation);

var files = document.createElement('ul');
files.className = "box-inner files";
fileNavigation.addElement(files);


var contentView = createBox('content-view');
contentView.position(301,(topMenu.size().y));
contentView.size(window.innerWidth - 302, window.innerHeight - topMenu.size().y);
page.addBox(contentView);

var content = domify([
  '<div class="box-inner content">',
  '<ul class="tabs"></ul>',
  '<ul class="tab-bodies"></ul>',
  '</div>'
].join('\n'));


  
  // doesn't belong here...
  var topMenuContent = domify([
    '<ul class="box-inner menu-content">',
    '<li><span>File</span><ul><li><a href="#" rel="rels/new-file">New file</a></li><li><a href="#" rel="rels/new-folder">New folder</a></li></ul></li>',
    '</ul>'
  ].join('\n'));

  topMenu.addElement(topMenuContent);
  

contentView.addElement(content);

page.addBox(topMenu);

var delegate = new Delegate(document.body);

delegate.on('click', 'ul.menu-content li ul li a', function (e){

  var rel = e.target.getAttribute('rel');

  switch (rel){

    case "rels/new-folder": 

      createFolder(activeDirectory);

      break;

    case "rels/new-file":

      createFile(activeDirectory);

      break;

  }

});


function getContentViewSize (){
  var headerHeight = content.querySelector('ul.tabs').offsetHeight;
  var pageSize = contentView.size();
  return {
    x : pageSize.x,
    y : pageSize.y,
    headerHeight : headerHeight
  }

};

window.onresize = function (event){
  page.size(window.innerWidth, window.innerHeight);
  fileNavigation.size(300, window.innerHeight);
  contentView.size(window.innerWidth - 301, window.innerHeight);
}

window.onkeydown = function (e){
  if((e.ctrlKey || e.metaKey) && e.which == 83) {
      // Save Function
      e.preventDefault();
      saveSession();
      return false;
  };
}



function saveSession (){

  var val = activeSession.editor.getSession().getValue();

  if (val !== activeSession.originalValue){
  
    var beingSaved = activeSession;

    saveFile(activeSession.path, val, function (err, response){

      if (!err){

        var currentVal = beingSaved.editor.getSession().getValue();
        if (currentVal === val){
          beingSaved.tabHeader.querySelector('a').innerText = beingSaved.entity.name
        }

      } else {
        alert(err);
      }

    })

  }

}

function endSession (entity){

  var session = editSessions[entity.href];

  var val = session.editor.getSession().getValue();

  if (val !== session.originalValue){
    if(!confirm('You will lose changes. Are you sure you wish to quit?')){
      return;

    }
  }

  session.editor.destroy();
  session.tabHeader.parentNode.removeChild(session.tabHeader);
  session.tab.parentNode.removeChild(session.tab);
  session.tab = null;
  session.tabHeader.querySelector('a').onclick = null;
  session.tabHeader.querySelector('span.typcn-delete').onclick = null;
  session.tabHeader = null;
  delete editSessions[entity.href];

}

function createBox (className){

  var el = document.createElement('div');
  var style = el.style;
  el.className = "box " + className ;
  style.position = "absolute";
  style.top = "0px";
  style.left = "0px";
  style.width = "0px";
  style.height = "0px";

  return {
    element : el,
    position : function (x, y){
      if (!arguments.length){
        return {
          x : parseInt(style.left, 10),
          y : parseInt(style.top, 10)
        }
      } 
      style.top = y + "px";
      style.left = x + "px";
    },
    size : function (x, y){
      if (!arguments.length){
        return {
          x : parseInt(style.width, 10),
          y : parseInt(style.height, 10)
        }
      } 
      style.height = y + "px";
      style.width = x + "px";
    },
    addBox : function (box){
      box.appendToElement(el);
    },
    addElement : function (element){
      el.appendChild(element);
    },
    appendToElement : function (element){
      element.appendChild(el);
    }
  }

}

function createAceInstance (element){
  var editor = ace.edit(element);
  editor.getSession().setMode('ace/mode/markdown');
  editor.setTheme('ace/theme/monokai');
  editor.setShowPrintMargin(false);
  return editor;
}



function insertText (node, text){
  node.appendChild(document.createTextNode(text));
}

function makeEditSessionActive (entity){

  var session;

  session = editSessions[entity.href];

  forEach.call(content.querySelectorAll('ul.tab-bodies li'), function (li){
    li.style.display = 'none';
  });

  forEach.call(content.querySelectorAll('ul.tabs li.active'), function (li){
    li.className = li.className.replace('active', '');
  });

  session.tab.style.display = 'block';
  session.tabHeader.className += "active";

  activeSession = session;

}

function editFile (entity, element, event){

  if (!event || (event.which === 1 && event.target.tagName !== "INPUT")){

    var session;

    if (!editSessions[entity.href]){
      session = createEditSession(entity);
    } else {
      session = editSessions[entity.href];
    }

    loadFile(entity.href, function (err, response){

      var originalValue = response; 
      session.originalValue = originalValue;
      session.editor.setValue(originalValue);

      session.editor.getSession().on('change', function (e){
        var currentValue = session.editor.getValue();
        if (currentValue !== originalValue){
          session.tabHeader.querySelector('a').innerText = session.entity.name + " * " 
        } else {
          session.tabHeader.querySelector('a').innerText = session.entity.name
        }
      })

      forEach.call(content.querySelectorAll('ul.tab-bodies li'), function (li){
        li.style.display = 'none';
      });

      forEach.call(content.querySelectorAll('ul.tabs li.active'), function (li){
        li.className = li.className.replace('active', '');
      });

      session.tab.style.display = 'block';
      session.tabHeader.className += "active";

      activeSession = session;

    });

  } else if (event.which === 3){

    var clickShield = domify('<div></div>');
    clickShield.style.width = window.innerWidth + "px";
    clickShield.style.height = window.innerHeight + "px";
    clickShield.style.position = "absolute";
    clickShield.style.top = "0px";
    clickShield.style.left = "0px";

    $('body').appendChild(clickShield);

    var reset = function reset(){
      clickShield.removeEventListener('click', reset);
      $('body').removeChild(clickShield);
      $('body').removeChild(contextMenu)
    }

    clickShield.addEventListener('click', reset);

    // right...
    var contextMenu = domify('<ul class="context-menu">' +
      '<li><a href="#" rel="rels/rename-file">Rename</a></li>' +
      '<li><a href="#" rel="rels/delete-file">Delete</a></li>' +
      '</ul>')

    $('body').appendChild(contextMenu);

    contextMenu.style.top = event.clientY + "px";
    contextMenu.style.left = event.clientX + "px";

    var del = new Delegate(contextMenu);
    del.on('click', 'a', function (e){
      e.preventDefault();
      reset();
      //alert(e.target.getAttribute('rel'))
      switch (e.target.getAttribute('rel')){

        case "rels/open-file" :
          editFile(entity);
          break;
        case "rels/rename-file" : 
          element.style.display = "none";
          var input = document.createElement('input')
          element.parentNode.appendChild(input);
          input.value = entity.name;
          input.focus();
          input.onkeydown = function (e){
            if (e.which === 13 && input.value !== ""){
              renameFile (entity, input.value);
              element.style.display = "";
              element.parentNode.removeChild(input);
              input.onkeydown = null;
              input.onclick = false;
              input = null;


            }
          }
          input.onclick = function (e){
            e.preventDefault();
            e.stopPropagation();
          }
          break;
        case "rels/delete-file":
          deleteFile(entity);
          break;
      }

    });

  }

}

function renameFile (entity, newName){

  var uri = entity.href.replace(entity.name, newName);

  var oldUri = entity.href.replace(vfsRoot, '');

  var session = false;

  if (editSessions[entity.href]){
    session = editSessions[entity.href];
  }

  request({ method: 'POST', url : uri, json : { renameFrom : oldUri }}, function (err, response, body){
    loadDirectory(activeDirectory);
    if (session){
      editSessions[uri] = session;
      editSessions[uri].path = uri;
      editSessions[entity.href] = null;
      editSessions[uri].tabHeader.querySelector('a').innerText = newName;
    }
  });
}

function renameFolder (currentPath, oldFolderName, newFolderName){

  var uri = currentPath.replace(oldFolderName, newFolderName);

  var oldUri = currentPath.replace(vfsRoot, '');

  request({ method: 'POST', url: uri, json : { renameFrom : oldUri}}, function (err, response, body){
    loadDirectory(activeDirectory);
  });


}

function deleteFile (entity){
  alert('delete file');
}

function createFolder (path){
  request({ method : 'PUT', url : path + "New folder/"}, function (err, response, body){
    if (!err){
      loadDirectory(activeDirectory);
    } else {
      alert(err);
    }

  })
}

function createFile (path){
  request({ method : 'PUT', url : path + 'Untitled.md', body : ''}, function (err, response, body){
    if (!err){
      loadDirectory(activeDirectory);

    } else {
      alert(err);
    }
  })
}

function createEditSession (entity){

  var path = entity.href;

  var container = domify('<li></li>');
  var tabHeader = domify('<li><a href="#">' + entity.name +'</a><span class="typcn typcn-delete"><span></li>');
  tabHeader.querySelector('a').onclick = makeEditSessionActive.bind({}, entity);
  content.querySelector('ul.tabs').appendChild(tabHeader);

  var size = getContentViewSize();

  var tabBody = createBox('edit-window');
  tabBody.size(size.x, size.y - size.headerHeight);
  tabBody.position(0, size.headerHeight);
  tabBody.appendToElement(container);
  content.querySelector('ul.tab-bodies').appendChild(container);

  var editor = ace.edit(tabBody.element);
  if (entity.name.match(/\.md$/)){
  editor.getSession().setMode('ace/mode/markdown');
  } else {
    editor.getSession().setMode('ace/mode/json');
  }
  editor.setTheme('ace/theme/monokai');
  editor.setShowPrintMargin(false);

  editSessions[path] = {
    editor : editor,
    path : path,
    box : tabBody,
    tab : container,
    entity : entity,
    tabHeader : tabHeader
  }

  tabHeader.querySelector('span.typcn-delete').onclick = function (e){

    endSession(entity);

  };

  editor.on('change', function (){

    var currline = editor.getSelectionRange().start.row;
    var wholelinetext = editor.session.getLine(currline);
    var currchar = editor.getSelectionRange().start.column;

    var doSearch = false;
    var uri = false;
    var mode = false;

    if (currchar === (wholelinetext.length - 1) && (/recommendations:$/.test(wholelinetext))){

      doSearch = true;
      uri = "something";
      mode = "recommendations";

    } else if (currchar === (wholelinetext.length - 1) && (/qualitystatements:$/.test(wholelinetext))){

      doSearch = true;
      uri = "somethingelse";
      mode = "Quality statements";

    }

    if (doSearch){

      var offset = editor.renderer.scroller.getBoundingClientRect();
      var padding = editor.renderer.$padding;
      var cur = editor.getCursorPosition();

      // get the x and y position of 
      var x = Math.ceil((cur.column + 1) * editor.renderer.characterWidth) + offset.left + padding;
      var y = Math.ceil(cur.row * editor.renderer.lineHeight) + offset.top;

      var input = domify('<input placeholder="Search for concepts" class="autocomplete-input" type="text"></input>');
      //input.style.position = "absolute";
      //input.style.zIndex = 1;
      input.style.left = x + "px";
      input.style.top = y + "px";

      document.body.appendChild(input);

      input.focus();

      var lastVal = "";
      var requestInProgress = false;

      var container;

      function getResults (term){
          request('/ld/concepts/' + term, function (err, response, body){
            requestInProgress = false;
             processResults(err, JSON.parse(body));
          });
      };

      function processResults (err, body){
        requestInProgress = false;
        if (lastVal !== input.value){
          lastVal = input.value;
          getResults(lastVal);
        }
        var rect = input.getBoundingClientRect();

        if (container){
          document.body.removeChild(container);
        }

        container = domify('<ul class="autocomplete-popup"></ul>');
        container.style.position = "absolute";
        container.style.top = rect.bottom + "px";
        container.style.left = rect.left + "px";

        body.forEach(function (concept, index){

          var li = domify('<li>' + concept.value.object +'</li>');
          li.onclick = function (e){
            e.preventDefault();

            // remove event handlers from other lis..
            var fns = [];
            Array.prototype.forEach.call(container.querySelectorAll('li'), function (li){
              //input.value = concept.value.object;
              currentVal = lastVal = input.value = concept.value.object;
              li.onclick = false;
              fns.push(function (){
                container.removeChild(li);
              });
            });
            fns.forEach(function (fn){ fn(); });

            document.body.removeChild(input);

            var loading = domify('<li class="loading">Searching for ' + mode + ' for ' + concept.value.object +'</li>');
            container.appendChild(loading);

            container.style.top = rect.top + "px";

            searchForThings(concept.value.object);


            //document.body.removeChild(container);
            //editor.focus();
            //editor.insert(concept.value.subject);
            //document.body.removeChild(input);
          }
          container.appendChild(li);

        });

        document.body.appendChild(container);

        //console.log(input.calculateBoundingRect())
        //console.log(body);
      };

      function searchForThings (tag){
        if (mode === "recommendations"){
          request('/ld/recommendations/' + tag, function (err, res){
            var triples = JSON.parse(res.body);
            console.log(triples);
            var rect = container.getBoundingClientRect();

            var results = domify('<div class="ld-result"><h3>Recommendations</h3><ul></ul></div>');
            var ul = results.querySelector('ul');

            results.style.top = rect.top + "px";
            results.style.left = rect.left + "px";
            results.style.maxHeight = (window.innerHeight - rect.top - 200) + 'px'

            document.body.removeChild(container);
            container = "";

            triples.forEach(function (triple){

              var li = domify('<li></li>');
              var id = domify('<p class="id">' + triple.subject + '</p>');
              var text = domify('<div>' + marked(triple.object.replace(/\n\?\s/g, '\n- ')) + '</div>');
              var insert = domify('<a href="#">Insert a link to this recommendation</a>');

              insert.onclick = function (e){

                e.preventDefault();
                editor.focus();
                editor.insert(triple.subject);

                // 
                Array.prototype.forEach.call(results.querySelectorAll('a'), function (a){
                  a.onclick = "";
                });

                document.body.removeChild(results);
                results = null;

              }

              li.appendChild(id);
              li.appendChild(text);
              li.appendChild(insert);

              ul.appendChild(li);

            });

            document.body.appendChild(results);

          })
        }
      }

      input.onkeyup = function (e){

        var currentVal = input.value.trim();

        if (currentVal !== ""){

          // get the options

          if (lastVal !== currentVal && !requestInProgress){
            requestInProgress = true;
            lastVal = currentVal;
            getResults(lastVal);
          }

        } else {

          // clear the options...

        }

      }

    
      // looking for recommendations


      // comedy proof of concept...

      //setTimeout(function (){

      //  editor.focus();
      //  editor.insert(input.value);
       // document.body.removeChild(input);

     // }, 10000)


    }


  });

  return editSessions[path];

}

function saveFile(path, body, callback){
  request.put({ uri : path, body : body}, function (err, response){
    callback(err, response);
  });
}

function loadFile(path, callback){
  request(path, function (err, response, body){
    callback(err, body);
  });
}

function loadDirectory(path, obj, element, event){

  if (event && event.which === 3){

    var clickShield = domify('<div></div>');
    clickShield.style.width = window.innerWidth + "px";
    clickShield.style.height = window.innerHeight + "px";
    clickShield.style.position = "absolute";
    clickShield.style.top = "0px";
    clickShield.style.left = "0px";

    $('body').appendChild(clickShield);

    var reset = function reset(){
      clickShield.removeEventListener('click', reset);
      $('body').removeChild(clickShield);
      $('body').removeChild(contextMenu)
    }

    clickShield.addEventListener('click', reset);

    // right...
    var contextMenu = domify('<ul class="context-menu">' +
      '<li><a href="#" rel="rels/rename-folder">Rename</a></li>' +
      '<li><a href="#" rel="rels/delete-file">Delete</a></li>' +
      '</ul>')

    $('body').appendChild(contextMenu);

    contextMenu.style.top = event.clientY + "px";
    contextMenu.style.left = event.clientX + "px";

    var del = new Delegate(contextMenu);
    del.on('click', 'a', function (e){
      e.preventDefault();

      reset();

      var rel = e.target.getAttribute('rel');

      switch (rel){
        case "rels/rename-folder" :
          element.style.display = "none";
          var input = document.createElement('input')
          element.parentNode.appendChild(input);
          input.value = obj.name;
          input.focus();
          input.onkeydown = function (e){
            if (e.which === 13 && input.value !== ""){
              renameFolder (path, obj.name, input.value);
              element.style.display = "";
              element.parentNode.removeChild(input);
              input.onkeydown = null;
              input.onclick = false;
              input = null;

            }
          }
          break;

      }

    });

  } else if (!event || (event.which === 1 && event.target.tagName !== "INPUT")) {

    activeDirectory = path;

    request(path, function (err, response, body){

      if (!err){

        if (response.getResponseHeader('Content-TYpe') === "application/json"){
          body = JSON.parse(body);
        }

        directoryCache[activeDirectory] = body;

        var reference = getDirectoryReference(path);
        updateFileSystem(path, body);
        renderCurrentDirectory(reference);

      } else {
        alert(err);
      }

    });

  }
}

function getDirectoryReference(path){
    // pop off the first and last

  path = path.replace(vfsRoot, '');

  var pathChunks = path.split('/');
  var pointer = fileSystem;

  pathChunks.shift(); 
  pathChunks.pop();
  pathChunks.unshift('root');

  pathChunks.forEach(function (chunk){
    if (pointer.children[chunk]){
      pointer.children[chunk].parent = pointer;
      pointer = pointer.children[chunk];
    } else {
      throw new Error('omg');
    }
  });

  return pointer;

}

function updateFileSystem(path, entities){

  var pointer = getDirectoryReference(path);

  pointer.entities.splice(0, pointer.entities.length);

  entities.forEach(function (entity){
    if (entity.mime === "inode/directory"){
      if (!pointer.children[entity.name]){
        pointer.children[entity.name] = {
          name : entity.name,
          href : entity.href,
          entities : [],
          children : {}
        }
      }
    } else {
      // add it as an entity...
      pointer.entities.push(entity);

    }
    
  });

  for (var child in pointer.children){
    if (pointer.children.hasOwnProperty(child)){
      var exists = false;
      entities.forEach(function (entity){
        if (entity.name === child){
          exists = true;
        }
      });
      if (!exists){
        delete pointer.children[child];
      }
    }
  }
}



loadDirectory(fileSystem.children.root.href);
*/
},{"./components/editors/ace.js":2,"./components/editors/command.js":3,"./components/editors/commit.js":4,"./components/editors/info.js":5,"./components/editors/new-document.js":6,"./components/editors/new-folder.js":7,"./components/editors/previewer.js":8,"./components/editors/terminals.js":9,"./components/entity-selector.js":10,"./components/layout.js":11,"./components/sessions.js":13,"./components/top-menu.js":14,"./lib/file-system":16,"./lib/remote.js":17,"events":53}],16:[function(require,module,exports){
var request = require('browser-request');
var Gather = require('gm-gather');
var cloneDeep = require('clone-deep');
var path = require('path')

var console = require('../components/console.js');

module.exports.initialiseFileSystem = function initialiseFileSystem (app, vfsRoot){

  var system = new (require('events')).EventEmitter;

  // global application events... 
  app.on('remote-entity-update', function (msg){

    app.emit('entity-updated', 'update', msg.path);

    loadFileSystem(data.children.root.href, function (err){

      if (!err){

        console.log('Remote file system synchronised');

        app.emit('sync', data.children.root.relPath);

      } else {

        app.emit('sync-error', 'Unable to synchronise with remote file system', err);

      }

    });

  });

  app.on('remote-entity-rename', function (msg){

    app.emit('entity-renamed', 'rename', msg.path, msg.oldPath);

    loadFileSystem(data.children.root.href, function (err){

      if (!err){

        console.log('Remote file system synchronised');

        app.emit('sync', data.children.root.relPath);

      } else {

        app.emit('sync-error', 'Unable to synchronise with remote file system', err);

      }

    });


  })

  app.on('remote-entity-create', function (msg){

    app.emit('entity-updated', 'create', msg.path);

    // you know, 

    loadFileSystem(data.children.root.href, function (err){

      if (!err){

        console.log('Remote file system synchronised');

        app.emit('sync', data.children.root.relPath);

      } else {

        app.emit('sync-error', 'Unable to synchronise with remote file system', err);

      }

    });

  });

  app.on('remote-entity-delete', function (msg){

    app.emit('entity-updated', 'delete', msg.path);

    loadFileSystem(data.children.root.href, function (err){

      if (!err){

        console.log('Remote file system synchronised');

        app.emit('sync', data.children.root.relPath);

      } else {

        app.emit('sync-error', 'Unable to synchronise with remote file system', err);

      }

    });

  });


  // our internal data structure...
  var data = {
    entities : [],
    children : {
      root : {
        entities : [],
        name : "Project root",
        relPath : "/",
        href : vfsRoot + "/",
        children : {},
        parent : false
      }
    }
  };

  var entityLookup = {};

  system.getURI = function getURI (pathName){

    return vfsRoot + pathName;

  } 

  system.readFile = function readFile (pathName, fn){

    var entity = entityLookup[pathName];

    // technically if this doesn't exist...

    if (!entity){ // doesn't exist?
      var parentPath = path.join(path.dirname(pathName), '/');
      //parent = entityLookup[parentPath];

      entity = {
        parent : parentPath,
        href : vfsRoot + pathName,
        mime : '',
        size : 0,
        mtime : 0
      }
    }

    request(entity.href, function (err, response){

      //var headers = response.getAllResponseHeaders();

      if (!err){

        var body = response.body;

        request(vfsRoot + entity.parent, function (err, response){

          if (!err && (response.status === 200 || response.status === 304)){
            var meta = JSON.parse(response.body);
            for (var i = 0; i < meta.length; i++){
              if (meta[i].name === entity.name){
                entity.mime = meta[i].mime;
                entity.size = meta[i].size;
                entity.mtime = meta[i].mtime;
                fn (false, entity, body);
                break;
              }
            }
          } else {
            fn (err, entity);
          }

        });

      } else {
        fn (err, entity);
      }

    });

  };

  system.readFileAsBase64 = function readFileAsBase64 (pathName, fn){

    var entity = entityLookup[pathName];

    // have to go grizzly for this...

    var xhr = new XMLHttpRequest();
    xhr.open('GET', entity.href, true);
    xhr.responseType = 'blob';
    xhr.onload = function (){

      var blob = xhr.response;
      var body = URL.createObjectURL(blob);

      request(vfsRoot + entity.parent, function (err, response){

        if (!err){
          var meta = JSON.parse(response.body);
          for (var i = 0; i < meta.length; i++){
            if (meta[i].name === entity.name){
              entity.mime = meta[i].mime;
              entity.size = meta[i].size;
              entity.mtime = meta[i].mtime;
              fn (false, entity, body);
              break;
            }
          }
        } else {
          fn (err, entity);
        }

      });

    }
    xhr.onerror = function (){
      fn (response.status, entity);
    }

    xhr.send();

  }



  system.writeFile = function writeFile(pathName, body, fn){

    var entity = entityLookup[pathName];

    if (entity){

      request.put({ uri : entity.href, body : body}, function (err, response){
        if (!err){
          fn (false, entity);
          app.emit('entity-updated', 'update', pathName);
        } else {
          fn (err);
        }
      });

    } else {

      var entity = {
        href : vfsRoot + pathName,
        parent : path.dirname(pathName) + "/"
      }

      request.put({ uri : vfsRoot + pathName, body : body}, function (err, response){
        if (!err){

          var p = pathName.split('/'); var name = p.pop(); p.shift(); 
          var folder = "/" + p.join('/');

          if (!/\/$/.test(folder)){
            folder += "/";
          }

          request.get(vfsRoot + folder, function (err, response){

            var ref = getDirectoryReference(folder);

            var body = JSON.parse(response.body);

            for (var i = 0; i < body.length; i++){
              if (body[i].name === name){
                entity.name = body[i].name;
                entity.size = body[i].size;
                entity.mime = body[i].mime;
                entity.mtime = body[i].mtime;
                break;
              }
            }

            entityLookup[pathName] = entity;

            ref.entities.push(entity);

            fn (false, entity);
            app.emit('sync', data.children.root.relPath);
            app.emit('entity-updated', 'update', pathName);


          });


        } else {
          fn (err);
        }

      });

    }

  };

  system.renameFile = function renameFile (pathName, newName, fn){

    var entity = entityLookup[pathName];

    var oldPath = entity.relPath;
    var newPath = entity.href.replace(entity.name, newName);

    request({ method: 'POST', url : newPath, json : { renameFrom : oldPath }}, function (err, response, body){
      // load new metadata... 
      if (response.status === 200){
        var newEntity = cloneDeep(entity);
        newEntity.relPath = newPath.replace(vfsRoot, '');
        newEntity.href = newPath;
        newEntity.name = newName;

        delete entityLookup[pathName];

        entityLookup[newEntity.relPath] = newEntity;

        fn (false, newEntity, entity);
      } else {
        fn (err);
      }
      //fn(err, newName, entity.name );

    });
  };

  system.deleteFile = function deleteFile (pathName, fn){

    var entity = entityLookup[pathName];

    request({ method : 'delete', url : entity.href}, function (err, response){

      fn(err);

    })

  };

  system.readFolder = function readFolder (pathName, fn){

  };

  system.writeFolder = function writeFolder (pathName, newFolderName, fn){

    var entity = entityLookup[pathName];

    var newPath = entity.href + "/" + newFolderName + "/";

    request({ method: 'put', url : newPath}, function (err, response){

      fn (err, newFolderName);

    });

  };

  system.createFile = function writeFolder (pathName, newFileName, fn){

    var entity = entityLookup[pathName];

    var newPath = entity.href + "/" + newFileName;

    request({ method: 'put', url : newPath}, function (err, response){

      fn (err, newFileName);

    });

  };

  system.renameFolder = function renameFolder (path, newName, fn){

    var entity = entityLookup[pathName];

    var newPath = entity.href.replace(entity.name + "/", newName);
    var oldPath = entity.relPath;

    request({ method : 'POST', url : newPath, json : {renameFrom : oldPath}}, function (err, response, body){
      fn (err, newName, entity.name);
    });
/*
  var uri = currentPath.replace(oldFolderName, newFolderName);

  var oldUri = currentPath.replace(vfsRoot, '');

  request({ method: 'POST', url: uri, json : { renameFrom : oldUri}}, function (err, response, body){
    loadDirectory(activeDirectory);
  });
*/

  };

  system.deleteFolder = function deleteFolder (pathName, fn){

    var entity = entityLookup[pathName];

    request({ method : 'delete', url : entity.href}, function (err, response){

      fn(err);

    });

  };

  system.getAll = function getAll(fn){

    function getContents (node, contents){

      for (var folder in node.children){
        if (node.children.hasOwnProperty(folder)){
          var folderObject = {
            type : 'folder',
            name : node.children[folder].name,
            path : node.children[folder].relPath,
            contents : []
          } 
          contents.push(folderObject);
          getContents(node.children[folder], folderObject.contents);
        }
      }

      for (var i = 0; i < node.entities.length; i++){

        contents.push({
          type : 'file',
          name : node.entities[i].name,
          path : node.entities[i].href.replace(vfsRoot, ''),
          mime : node.entities[i].mime,
          mtime : node.entities[i].mtime,
          size : node.entities[i].size,
          parent : node.relPath
        });

      }

    }

    var tree = [];

    getContents(data, tree);

    fn(tree);

  };

  // however we're doing to load the entire file system in now.

  function loadFileSystem (pathName, fn){

    request(pathName, function (err, response, body){

      if (!err){

        if (response.getResponseHeader('Content-Type') === "application/json"){
          body = JSON.parse(body);
        }

        //directoryCache[activeDirectory] = body;

        updateFileSystem(pathName, body);
  
        var pointer = getDirectoryReference(pathName);

        var gatherer = new Gather();

        var childCount = 0;

        for (var child in pointer.children){
          if (pointer.children.hasOwnProperty(child)){
            childCount ++;
            gatherer.task((function (href){

              return function (done, error){

                loadFileSystem(href, function (err){

                  if (!err){

                    done();

                  } else {

                    error(err);

                  }

                });

              };

            })(pointer.children[child].href));

          }
        }

        if (childCount > 0){
          gatherer.run(function (err){
            if (err){
              fn(err);
            } else {
              fn(false);
            }

          });
        } else {
          fn (false);
        }

        //renderCurrentDirectory(reference);

      } else {
        fn (err);
      }

    });
  };

  loadFileSystem(data.children.root.href, function (err){

    if (!err){

      console.log('Remote file system synchronised');

      app.emit('sync', data.children.root.relPath);

    } else {

      app.emit('sync-error', 'Unable to synchronise with remote file system', err);

    }

  });

  function getDirectoryReference (pathName){
      // pop off the first and last

    pathName = pathName.replace(vfsRoot, '');

    var pathChunks = pathName.split('/');
    var pointer = data;

    pathChunks.shift(); 
    pathChunks.pop();
    pathChunks.unshift('root');

    pathChunks.forEach(function (chunk){
      if (pointer.children[chunk]){
        pointer.children[chunk].parent = pointer;
        pointer = pointer.children[chunk];
      } else {
        throw new Error('omg');
      }
    });

    return pointer;

  }

  function updateFileSystem(pathName, entities){

    // Okay the objective here is to get all the changes...

    var pointer = getDirectoryReference(pathName);

    var currentEntities = pointer.entities.splice(0, pointer.entities.length);

    currentEntities.forEach(function (entity){

      delete entityLookup[entity.relPath];

    });

    entities.forEach(function (entity){
      if (entity.mime === "inode/directory"){
        if (!pointer.children[entity.name] && entity.name.substr(0, 1) !== "."){
          pointer.children[entity.name] = {
            name : entity.name,
            href : entity.href,
            relPath : entity.href.replace(vfsRoot, ''),
            entities : [],
            children : {}
          }
          // create a lookup by path...
          entityLookup[pointer.children[entity.name].relPath] = pointer.children[entity.name];
        }
      } else if (entity.name.substr(0,1) !== ".") {

        // create a relpath..
        entity.relPath = entity.href.replace(vfsRoot, '');
        entity.parent = pathName.replace(vfsRoot, '');
        // create a lookup by relpath.. 
        entityLookup[entity.relPath] = entity;

        // add it as an entity
        pointer.entities.push(entity);

      }
      
    });


    // check for any folders that have been removed..
    for (var child in pointer.children){
      if (pointer.children.hasOwnProperty(child)){
        var exists = false;
        entities.forEach(function (entity){
          if (entity.name === child){
            exists = true;
          }
        });
        if (!exists){
          delete pointer.children[child];
        }
      }
    }

    entityLookup['/'] = data.children.root;
  }

  return system;

}



/*

  - Status one: Nothing is loaded.
  - Status two: 

*/
},{"../components/console.js":1,"browser-request":21,"clone-deep":22,"events":53,"gm-gather":32,"path":54}],17:[function(require,module,exports){
var SocksJS = require('./socks.js');
var console = require('../components/console.js');

module.exports = function (app, sockRoot){

  var socket = new SocksJS(sockRoot);

  socket.onopen = function (){
    console.log('Remote file server is online.');
  }
  socket.onmessage = function (e){

    var msg = JSON.parse(e.data);

    for (var i in msg){
      if (msg.hasOwnProperty(i)) app.emit(i, msg[i]);
    }

  }

  app.remoteSend = function (signal, msg){

    var o = {};
    o[signal] = msg;

    socket.send(JSON.stringify(o));

  };

}
},{"../components/console.js":1,"./socks.js":18}],18:[function(require,module,exports){
/* SockJS client, version 0.3.4, http://sockjs.org, MIT License

Copyright (c) 2011-2012 VMware, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

//     [*] Including lib/index.js
// Public object
SockJS = (function(){
              var _document = document;
              var _window = window;
              var utils = {};


//         [*] Including lib/reventtarget.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */
var REventTarget = function() {};
REventTarget.prototype.addEventListener = function (eventType, listener) {
    if(!this._listeners) {
         this._listeners = {};
    }
    if(!(eventType in this._listeners)) {
        this._listeners[eventType] = [];
    }
    var arr = this._listeners[eventType];
    if(utils.arrIndexOf(arr, listener) === -1) {
        arr.push(listener);
    }
    return;
};

REventTarget.prototype.removeEventListener = function (eventType, listener) {
    if(!(this._listeners && (eventType in this._listeners))) {
        return;
    }
    var arr = this._listeners[eventType];
    var idx = utils.arrIndexOf(arr, listener);
    if (idx !== -1) {
        if(arr.length > 1) {
            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );
        } else {
            delete this._listeners[eventType];
        }
        return;
    }
    return;
};

REventTarget.prototype.dispatchEvent = function (event) {
    var t = event.type;
    var args = Array.prototype.slice.call(arguments, 0);
    if (this['on'+t]) {
        this['on'+t].apply(this, args);
    }
    if (this._listeners && t in this._listeners) {
        for(var i=0; i < this._listeners[t].length; i++) {
            this._listeners[t][i].apply(this, args);
        }
    }
};
//         [*] End of lib/reventtarget.js


//         [*] Including lib/simpleevent.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var SimpleEvent = function(type, obj) {
    this.type = type;
    if (typeof obj !== 'undefined') {
        for(var k in obj) {
            if (!obj.hasOwnProperty(k)) continue;
            this[k] = obj[k];
        }
    }
};

SimpleEvent.prototype.toString = function() {
    var r = [];
    for(var k in this) {
        if (!this.hasOwnProperty(k)) continue;
        var v = this[k];
        if (typeof v === 'function') v = '[function]';
        r.push(k + '=' + v);
    }
    return 'SimpleEvent(' + r.join(', ') + ')';
};
//         [*] End of lib/simpleevent.js


//         [*] Including lib/eventemitter.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventEmitter = function(events) {
    var that = this;
    that._events = events || [];
    that._listeners = {};
};
EventEmitter.prototype.emit = function(type) {
    var that = this;
    that._verifyType(type);
    if (that._nuked) return;

    var args = Array.prototype.slice.call(arguments, 1);
    if (that['on'+type]) {
        that['on'+type].apply(that, args);
    }
    if (type in that._listeners) {
        for(var i = 0; i < that._listeners[type].length; i++) {
            that._listeners[type][i].apply(that, args);
        }
    }
};

EventEmitter.prototype.on = function(type, callback) {
    var that = this;
    that._verifyType(type);
    if (that._nuked) return;

    if (!(type in that._listeners)) {
        that._listeners[type] = [];
    }
    that._listeners[type].push(callback);
};

EventEmitter.prototype._verifyType = function(type) {
    var that = this;
    if (utils.arrIndexOf(that._events, type) === -1) {
        utils.log('Event ' + JSON.stringify(type) +
                  ' not listed ' + JSON.stringify(that._events) +
                  ' in ' + that);
    }
};

EventEmitter.prototype.nuke = function() {
    var that = this;
    that._nuked = true;
    for(var i=0; i<that._events.length; i++) {
        delete that[that._events[i]];
    }
    that._listeners = {};
};
//         [*] End of lib/eventemitter.js


//         [*] Including lib/utils.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';
utils.random_string = function(length, max) {
    max = max || random_string_chars.length;
    var i, ret = [];
    for(i=0; i < length; i++) {
        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );
    }
    return ret.join('');
};
utils.random_number = function(max) {
    return Math.floor(Math.random() * max);
};
utils.random_number_string = function(max) {
    var t = (''+(max - 1)).length;
    var p = Array(t+1).join('0');
    return (p + utils.random_number(max)).slice(-t);
};

// Assuming that url looks like: http://asdasd:111/asd
utils.getOrigin = function(url) {
    url += '/';
    var parts = url.split('/').slice(0, 3);
    return parts.join('/');
};

utils.isSameOriginUrl = function(url_a, url_b) {
    // location.origin would do, but it's not always available.
    if (!url_b) url_b = _window.location.href;

    return (url_a.split('/').slice(0,3).join('/')
                ===
            url_b.split('/').slice(0,3).join('/'));
};

utils.getParentDomain = function(url) {
    // ipv4 ip address
    if (/^[0-9.]*$/.test(url)) return url;
    // ipv6 ip address
    if (/^\[/.test(url)) return url;
    // no dots
    if (!(/[.]/.test(url))) return url;

    var parts = url.split('.').slice(1);
    return parts.join('.');
};

utils.objectExtend = function(dst, src) {
    for(var k in src) {
        if (src.hasOwnProperty(k)) {
            dst[k] = src[k];
        }
    }
    return dst;
};

var WPrefix = '_jp';

utils.polluteGlobalNamespace = function() {
    if (!(WPrefix in _window)) {
        _window[WPrefix] = {};
    }
};

utils.closeFrame = function (code, reason) {
    return 'c'+JSON.stringify([code, reason]);
};

utils.userSetCode = function (code) {
    return code === 1000 || (code >= 3000 && code <= 4999);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
utils.countRTO = function (rtt) {
    var rto;
    if (rtt > 100) {
        rto = 3 * rtt; // rto > 300msec
    } else {
        rto = rtt + 200; // 200msec < rto <= 300msec
    }
    return rto;
}

utils.log = function() {
    if (_window.console && console.log && console.log.apply) {
        console.log.apply(console, arguments);
    }
};

utils.bind = function(fun, that) {
    if (fun.bind) {
        return fun.bind(that);
    } else {
        return function() {
            return fun.apply(that, arguments);
        };
    }
};

utils.flatUrl = function(url) {
    return url.indexOf('?') === -1 && url.indexOf('#') === -1;
};

utils.amendUrl = function(url) {
    var dl = _document.location;
    if (!url) {
        throw new Error('Wrong url for SockJS');
    }
    if (!utils.flatUrl(url)) {
        throw new Error('Only basic urls are supported in SockJS');
    }

    //  '//abc' --> 'http://abc'
    if (url.indexOf('//') === 0) {
        url = dl.protocol + url;
    }
    // '/abc' --> 'http://localhost:80/abc'
    if (url.indexOf('/') === 0) {
        url = dl.protocol + '//' + dl.host + url;
    }
    // strip trailing slashes
    url = url.replace(/[/]+$/,'');
    return url;
};

// IE doesn't support [].indexOf.
utils.arrIndexOf = function(arr, obj){
    for(var i=0; i < arr.length; i++){
        if(arr[i] === obj){
            return i;
        }
    }
    return -1;
};

utils.arrSkip = function(arr, obj) {
    var idx = utils.arrIndexOf(arr, obj);
    if (idx === -1) {
        return arr.slice();
    } else {
        var dst = arr.slice(0, idx);
        return dst.concat(arr.slice(idx+1));
    }
};

// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df
utils.isArray = Array.isArray || function(value) {
    return {}.toString.call(value).indexOf('Array') >= 0
};

utils.delay = function(t, fun) {
    if(typeof t === 'function') {
        fun = t;
        t = 0;
    }
    return setTimeout(fun, t);
};


// Chars worth escaping, as defined by Douglas Crockford:
//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196
var json_escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    json_lookup = {
"\u0000":"\\u0000","\u0001":"\\u0001","\u0002":"\\u0002","\u0003":"\\u0003",
"\u0004":"\\u0004","\u0005":"\\u0005","\u0006":"\\u0006","\u0007":"\\u0007",
"\b":"\\b","\t":"\\t","\n":"\\n","\u000b":"\\u000b","\f":"\\f","\r":"\\r",
"\u000e":"\\u000e","\u000f":"\\u000f","\u0010":"\\u0010","\u0011":"\\u0011",
"\u0012":"\\u0012","\u0013":"\\u0013","\u0014":"\\u0014","\u0015":"\\u0015",
"\u0016":"\\u0016","\u0017":"\\u0017","\u0018":"\\u0018","\u0019":"\\u0019",
"\u001a":"\\u001a","\u001b":"\\u001b","\u001c":"\\u001c","\u001d":"\\u001d",
"\u001e":"\\u001e","\u001f":"\\u001f","\"":"\\\"","\\":"\\\\",
"\u007f":"\\u007f","\u0080":"\\u0080","\u0081":"\\u0081","\u0082":"\\u0082",
"\u0083":"\\u0083","\u0084":"\\u0084","\u0085":"\\u0085","\u0086":"\\u0086",
"\u0087":"\\u0087","\u0088":"\\u0088","\u0089":"\\u0089","\u008a":"\\u008a",
"\u008b":"\\u008b","\u008c":"\\u008c","\u008d":"\\u008d","\u008e":"\\u008e",
"\u008f":"\\u008f","\u0090":"\\u0090","\u0091":"\\u0091","\u0092":"\\u0092",
"\u0093":"\\u0093","\u0094":"\\u0094","\u0095":"\\u0095","\u0096":"\\u0096",
"\u0097":"\\u0097","\u0098":"\\u0098","\u0099":"\\u0099","\u009a":"\\u009a",
"\u009b":"\\u009b","\u009c":"\\u009c","\u009d":"\\u009d","\u009e":"\\u009e",
"\u009f":"\\u009f","\u00ad":"\\u00ad","\u0600":"\\u0600","\u0601":"\\u0601",
"\u0602":"\\u0602","\u0603":"\\u0603","\u0604":"\\u0604","\u070f":"\\u070f",
"\u17b4":"\\u17b4","\u17b5":"\\u17b5","\u200c":"\\u200c","\u200d":"\\u200d",
"\u200e":"\\u200e","\u200f":"\\u200f","\u2028":"\\u2028","\u2029":"\\u2029",
"\u202a":"\\u202a","\u202b":"\\u202b","\u202c":"\\u202c","\u202d":"\\u202d",
"\u202e":"\\u202e","\u202f":"\\u202f","\u2060":"\\u2060","\u2061":"\\u2061",
"\u2062":"\\u2062","\u2063":"\\u2063","\u2064":"\\u2064","\u2065":"\\u2065",
"\u2066":"\\u2066","\u2067":"\\u2067","\u2068":"\\u2068","\u2069":"\\u2069",
"\u206a":"\\u206a","\u206b":"\\u206b","\u206c":"\\u206c","\u206d":"\\u206d",
"\u206e":"\\u206e","\u206f":"\\u206f","\ufeff":"\\ufeff","\ufff0":"\\ufff0",
"\ufff1":"\\ufff1","\ufff2":"\\ufff2","\ufff3":"\\ufff3","\ufff4":"\\ufff4",
"\ufff5":"\\ufff5","\ufff6":"\\ufff6","\ufff7":"\\ufff7","\ufff8":"\\ufff8",
"\ufff9":"\\ufff9","\ufffa":"\\ufffa","\ufffb":"\\ufffb","\ufffc":"\\ufffc",
"\ufffd":"\\ufffd","\ufffe":"\\ufffe","\uffff":"\\uffff"};

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
var extra_escapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
    extra_lookup;

// JSON Quote string. Use native implementation when possible.
var JSONQuote = (JSON && JSON.stringify) || function(string) {
    json_escapable.lastIndex = 0;
    if (json_escapable.test(string)) {
        string = string.replace(json_escapable, function(a) {
            return json_lookup[a];
        });
    }
    return '"' + string + '"';
};

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unroll_lookup = function(escapable) {
    var i;
    var unrolled = {}
    var c = []
    for(i=0; i<65536; i++) {
        c.push( String.fromCharCode(i) );
    }
    escapable.lastIndex = 0;
    c.join('').replace(escapable, function (a) {
        unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        return '';
    });
    escapable.lastIndex = 0;
    return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
utils.quote = function(string) {
    var quoted = JSONQuote(string);

    // In most cases this should be very fast and good enough.
    extra_escapable.lastIndex = 0;
    if(!extra_escapable.test(quoted)) {
        return quoted;
    }

    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);

    return quoted.replace(extra_escapable, function(a) {
        return extra_lookup[a];
    });
}

var _all_protocols = ['websocket',
                      'xdr-streaming',
                      'xhr-streaming',
                      'iframe-eventsource',
                      'iframe-htmlfile',
                      'xdr-polling',
                      'xhr-polling',
                      'iframe-xhr-polling',
                      'jsonp-polling'];

utils.probeProtocols = function() {
    var probed = {};
    for(var i=0; i<_all_protocols.length; i++) {
        var protocol = _all_protocols[i];
        // User can have a typo in protocol name.
        probed[protocol] = SockJS[protocol] &&
                           SockJS[protocol].enabled();
    }
    return probed;
};

utils.detectProtocols = function(probed, protocols_whitelist, info) {
    var pe = {},
        protocols = [];
    if (!protocols_whitelist) protocols_whitelist = _all_protocols;
    for(var i=0; i<protocols_whitelist.length; i++) {
        var protocol = protocols_whitelist[i];
        pe[protocol] = probed[protocol];
    }
    var maybe_push = function(protos) {
        var proto = protos.shift();
        if (pe[proto]) {
            protocols.push(proto);
        } else {
            if (protos.length > 0) {
                maybe_push(protos);
            }
        }
    }

    // 1. Websocket
    if (info.websocket !== false) {
        maybe_push(['websocket']);
    }

    // 2. Streaming
    if (pe['xhr-streaming'] && !info.null_origin) {
        protocols.push('xhr-streaming');
    } else {
        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {
            protocols.push('xdr-streaming');
        } else {
            maybe_push(['iframe-eventsource',
                        'iframe-htmlfile']);
        }
    }

    // 3. Polling
    if (pe['xhr-polling'] && !info.null_origin) {
        protocols.push('xhr-polling');
    } else {
        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {
            protocols.push('xdr-polling');
        } else {
            maybe_push(['iframe-xhr-polling',
                        'jsonp-polling']);
        }
    }
    return protocols;
}
//         [*] End of lib/utils.js


//         [*] Including lib/dom.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// May be used by htmlfile jsonp and transports.
var MPrefix = '_sockjs_global';
utils.createHook = function() {
    var window_id = 'a' + utils.random_string(8);
    if (!(MPrefix in _window)) {
        var map = {};
        _window[MPrefix] = function(window_id) {
            if (!(window_id in map)) {
                map[window_id] = {
                    id: window_id,
                    del: function() {delete map[window_id];}
                };
            }
            return map[window_id];
        }
    }
    return _window[MPrefix](window_id);
};



utils.attachMessage = function(listener) {
    utils.attachEvent('message', listener);
};
utils.attachEvent = function(event, listener) {
    if (typeof _window.addEventListener !== 'undefined') {
        _window.addEventListener(event, listener, false);
    } else {
        // IE quirks.
        // According to: http://stevesouders.com/misc/test-postmessage.php
        // the message gets delivered only to 'document', not 'window'.
        _document.attachEvent("on" + event, listener);
        // I get 'window' for ie8.
        _window.attachEvent("on" + event, listener);
    }
};

utils.detachMessage = function(listener) {
    utils.detachEvent('message', listener);
};
utils.detachEvent = function(event, listener) {
    if (typeof _window.addEventListener !== 'undefined') {
        _window.removeEventListener(event, listener, false);
    } else {
        _document.detachEvent("on" + event, listener);
        _window.detachEvent("on" + event, listener);
    }
};


var on_unload = {};
// Things registered after beforeunload are to be called immediately.
var after_unload = false;

var trigger_unload_callbacks = function() {
    for(var ref in on_unload) {
        on_unload[ref]();
        delete on_unload[ref];
    };
};

var unload_triggered = function() {
    if(after_unload) return;
    after_unload = true;
    trigger_unload_callbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
utils.attachEvent('unload', unload_triggered);

utils.unload_add = function(listener) {
    var ref = utils.random_string(8);
    on_unload[ref] = listener;
    if (after_unload) {
        utils.delay(trigger_unload_callbacks);
    }
    return ref;
};
utils.unload_del = function(ref) {
    if (ref in on_unload)
        delete on_unload[ref];
};


utils.createIframe = function (iframe_url, error_callback) {
    var iframe = _document.createElement('iframe');
    var tref, unload_ref;
    var unattach = function() {
        clearTimeout(tref);
        // Explorer had problems with that.
        try {iframe.onload = null;} catch (x) {}
        iframe.onerror = null;
    };
    var cleanup = function() {
        if (iframe) {
            unattach();
            // This timeout makes chrome fire onbeforeunload event
            // within iframe. Without the timeout it goes straight to
            // onunload.
            setTimeout(function() {
                if(iframe) {
                    iframe.parentNode.removeChild(iframe);
                }
                iframe = null;
            }, 0);
            utils.unload_del(unload_ref);
        }
    };
    var onerror = function(r) {
        if (iframe) {
            cleanup();
            error_callback(r);
        }
    };
    var post = function(msg, origin) {
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(msg, origin);
            }
        } catch (x) {};
    };

    iframe.src = iframe_url;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function(){onerror('onerror');};
    iframe.onload = function() {
        // `onload` is triggered before scripts on the iframe are
        // executed. Give it few seconds to actually load stuff.
        clearTimeout(tref);
        tref = setTimeout(function(){onerror('onload timeout');}, 2000);
    };
    _document.body.appendChild(iframe);
    tref = setTimeout(function(){onerror('timeout');}, 15000);
    unload_ref = utils.unload_add(cleanup);
    return {
        post: post,
        cleanup: cleanup,
        loaded: unattach
    };
};

utils.createHtmlfile = function (iframe_url, error_callback) {
    var doc = new ActiveXObject('htmlfile');
    var tref, unload_ref;
    var iframe;
    var unattach = function() {
        clearTimeout(tref);
    };
    var cleanup = function() {
        if (doc) {
            unattach();
            utils.unload_del(unload_ref);
            iframe.parentNode.removeChild(iframe);
            iframe = doc = null;
            CollectGarbage();
        }
    };
    var onerror = function(r)  {
        if (doc) {
            cleanup();
            error_callback(r);
        }
    };
    var post = function(msg, origin) {
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(msg, origin);
            }
        } catch (x) {};
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[WPrefix] = _window[WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframe_url;
    tref = setTimeout(function(){onerror('timeout');}, 15000);
    unload_ref = utils.unload_add(cleanup);
    return {
        post: post,
        cleanup: cleanup,
        loaded: unattach
    };
};
//         [*] End of lib/dom.js


//         [*] Including lib/dom2.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var AbstractXHRObject = function(){};
AbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
    var that = this;

    try {
        that.xhr = new XMLHttpRequest();
    } catch(x) {};

    if (!that.xhr) {
        try {
            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');
        } catch(x) {};
    }
    if (_window.ActiveXObject || _window.XDomainRequest) {
        // IE8 caches even POSTs
        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);
    }

    // Explorer tends to keep connection open, even after the
    // tab gets closed: http://bugs.jquery.com/ticket/5280
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});
    try {
        that.xhr.open(method, url, true);
    } catch(e) {
        // IE raises an exception on wrong port.
        that.emit('finish', 0, '');
        that._cleanup();
        return;
    };

    if (!opts || !opts.no_credentials) {
        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
        // "This never affects same-site requests."
        that.xhr.withCredentials = 'true';
    }
    if (opts && opts.headers) {
        for(var key in opts.headers) {
            that.xhr.setRequestHeader(key, opts.headers[key]);
        }
    }

    that.xhr.onreadystatechange = function() {
        if (that.xhr) {
            var x = that.xhr;
            switch (x.readyState) {
            case 3:
                // IE doesn't like peeking into responseText or status
                // on Microsoft.XMLHTTP and readystate=3
                try {
                    var status = x.status;
                    var text = x.responseText;
                } catch (x) {};
                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
                if (status === 1223) status = 204;

                // IE does return readystate == 3 for 404 answers.
                if (text && text.length > 0) {
                    that.emit('chunk', status, text);
                }
                break;
            case 4:
                var status = x.status;
                // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
                if (status === 1223) status = 204;

                that.emit('finish', status, x.responseText);
                that._cleanup(false);
                break;
            }
        }
    };
    that.xhr.send(payload);
};

AbstractXHRObject.prototype._cleanup = function(abort) {
    var that = this;
    if (!that.xhr) return;
    utils.unload_del(that.unload_ref);

    // IE needs this field to be a function
    that.xhr.onreadystatechange = function(){};

    if (abort) {
        try {
            that.xhr.abort();
        } catch(x) {};
    }
    that.unload_ref = that.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
    var that = this;
    that.nuke();
    that._cleanup(true);
};

var XHRCorsObject = utils.XHRCorsObject = function() {
    var that = this, args = arguments;
    utils.delay(function(){that._start.apply(that, args);});
};
XHRCorsObject.prototype = new AbstractXHRObject();

var XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {
    var that = this;
    utils.delay(function(){
        that._start(method, url, payload, {
            no_credentials: true
        });
    });
};
XHRLocalObject.prototype = new AbstractXHRObject();



// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx
var XDRObject = utils.XDRObject = function(method, url, payload) {
    var that = this;
    utils.delay(function(){that._start(method, url, payload);});
};
XDRObject.prototype = new EventEmitter(['chunk', 'finish']);
XDRObject.prototype._start = function(method, url, payload) {
    var that = this;
    var xdr = new XDomainRequest();
    // IE caches even POSTs
    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);

    var onerror = xdr.ontimeout = xdr.onerror = function() {
        that.emit('finish', 0, '');
        that._cleanup(false);
    };
    xdr.onprogress = function() {
        that.emit('chunk', 200, xdr.responseText);
    };
    xdr.onload = function() {
        that.emit('finish', 200, xdr.responseText);
        that._cleanup(false);
    };
    that.xdr = xdr;
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});
    try {
        // Fails with AccessDenied if port number is bogus
        that.xdr.open(method, url);
        that.xdr.send(payload);
    } catch(x) {
        onerror();
    }
};

XDRObject.prototype._cleanup = function(abort) {
    var that = this;
    if (!that.xdr) return;
    utils.unload_del(that.unload_ref);

    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =
        that.xdr.onload = null;
    if (abort) {
        try {
            that.xdr.abort();
        } catch(x) {};
    }
    that.unload_ref = that.xdr = null;
};

XDRObject.prototype.close = function() {
    var that = this;
    that.nuke();
    that._cleanup(true);
};

// 1. Is natively via XHR
// 2. Is natively via XDR
// 3. Nope, but postMessage is there so it should work via the Iframe.
// 4. Nope, sorry.
utils.isXHRCorsCapable = function() {
    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {
        return 1;
    }
    // XDomainRequest doesn't work if page is served from file://
    if (_window.XDomainRequest && _document.domain) {
        return 2;
    }
    if (IframeTransport.enabled()) {
        return 3;
    }
    return 4;
};
//         [*] End of lib/dom2.js


//         [*] Including lib/sockjs.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var SockJS = function(url, dep_protocols_whitelist, options) {
    if (this === _window) {
        // makes `new` optional
        return new SockJS(url, dep_protocols_whitelist, options);
    }
    
    var that = this, protocols_whitelist;
    that._options = {devel: false, debug: false, protocols_whitelist: [],
                     info: undefined, rtt: undefined};
    if (options) {
        utils.objectExtend(that._options, options);
    }
    that._base_url = utils.amendUrl(url);
    that._server = that._options.server || utils.random_number_string(1000);
    if (that._options.protocols_whitelist &&
        that._options.protocols_whitelist.length) {
        protocols_whitelist = that._options.protocols_whitelist;
    } else {
        // Deprecated API
        if (typeof dep_protocols_whitelist === 'string' &&
            dep_protocols_whitelist.length > 0) {
            protocols_whitelist = [dep_protocols_whitelist];
        } else if (utils.isArray(dep_protocols_whitelist)) {
            protocols_whitelist = dep_protocols_whitelist
        } else {
            protocols_whitelist = null;
        }
        if (protocols_whitelist) {
            that._debug('Deprecated API: Use "protocols_whitelist" option ' +
                        'instead of supplying protocol list as a second ' +
                        'parameter to SockJS constructor.');
        }
    }
    that._protocols = [];
    that.protocol = null;
    that.readyState = SockJS.CONNECTING;
    that._ir = createInfoReceiver(that._base_url);
    that._ir.onfinish = function(info, rtt) {
        that._ir = null;
        if (info) {
            if (that._options.info) {
                // Override if user supplies the option
                info = utils.objectExtend(info, that._options.info);
            }
            if (that._options.rtt) {
                rtt = that._options.rtt;
            }
            that._applyInfo(info, rtt, protocols_whitelist);
            that._didClose();
        } else {
            that._didClose(1002, 'Can\'t connect to server', true);
        }
    };
};
// Inheritance
SockJS.prototype = new REventTarget();

SockJS.version = "0.3.4";

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._debug = function() {
    if (this._options.debug)
        utils.log.apply(utils, arguments);
};

SockJS.prototype._dispatchOpen = function() {
    var that = this;
    if (that.readyState === SockJS.CONNECTING) {
        if (that._transport_tref) {
            clearTimeout(that._transport_tref);
            that._transport_tref = null;
        }
        that.readyState = SockJS.OPEN;
        that.dispatchEvent(new SimpleEvent("open"));
    } else {
        // The server might have been restarted, and lost track of our
        // connection.
        that._didClose(1006, "Server lost session");
    }
};

SockJS.prototype._dispatchMessage = function(data) {
    var that = this;
    if (that.readyState !== SockJS.OPEN)
            return;
    that.dispatchEvent(new SimpleEvent("message", {data: data}));
};

SockJS.prototype._dispatchHeartbeat = function(data) {
    var that = this;
    if (that.readyState !== SockJS.OPEN)
        return;
    that.dispatchEvent(new SimpleEvent('heartbeat', {}));
};

SockJS.prototype._didClose = function(code, reason, force) {
    var that = this;
    if (that.readyState !== SockJS.CONNECTING &&
        that.readyState !== SockJS.OPEN &&
        that.readyState !== SockJS.CLOSING)
            throw new Error('INVALID_STATE_ERR');
    if (that._ir) {
        that._ir.nuke();
        that._ir = null;
    }

    if (that._transport) {
        that._transport.doCleanup();
        that._transport = null;
    }

    var close_event = new SimpleEvent("close", {
        code: code,
        reason: reason,
        wasClean: utils.userSetCode(code)});

    if (!utils.userSetCode(code) &&
        that.readyState === SockJS.CONNECTING && !force) {
        if (that._try_next_protocol(close_event)) {
            return;
        }
        close_event = new SimpleEvent("close", {code: 2000,
                                                reason: "All transports failed",
                                                wasClean: false,
                                                last_event: close_event});
    }
    that.readyState = SockJS.CLOSED;

    utils.delay(function() {
                   that.dispatchEvent(close_event);
                });
};

SockJS.prototype._didMessage = function(data) {
    var that = this;
    var type = data.slice(0, 1);
    switch(type) {
    case 'o':
        that._dispatchOpen();
        break;
    case 'a':
        var payload = JSON.parse(data.slice(1) || '[]');
        for(var i=0; i < payload.length; i++){
            that._dispatchMessage(payload[i]);
        }
        break;
    case 'm':
        var payload = JSON.parse(data.slice(1) || 'null');
        that._dispatchMessage(payload);
        break;
    case 'c':
        var payload = JSON.parse(data.slice(1) || '[]');
        that._didClose(payload[0], payload[1]);
        break;
    case 'h':
        that._dispatchHeartbeat();
        break;
    }
};

SockJS.prototype._try_next_protocol = function(close_event) {
    var that = this;
    if (that.protocol) {
        that._debug('Closed transport:', that.protocol, ''+close_event);
        that.protocol = null;
    }
    if (that._transport_tref) {
        clearTimeout(that._transport_tref);
        that._transport_tref = null;
    }

    while(1) {
        var protocol = that.protocol = that._protocols.shift();
        if (!protocol) {
            return false;
        }
        // Some protocols require access to `body`, what if were in
        // the `head`?
        if (SockJS[protocol] &&
            SockJS[protocol].need_body === true &&
            (!_document.body ||
             (typeof _document.readyState !== 'undefined'
              && _document.readyState !== 'complete'))) {
            that._protocols.unshift(protocol);
            that.protocol = 'waiting-for-load';
            utils.attachEvent('load', function(){
                that._try_next_protocol();
            });
            return true;
        }

        if (!SockJS[protocol] ||
              !SockJS[protocol].enabled(that._options)) {
            that._debug('Skipping transport:', protocol);
        } else {
            var roundTrips = SockJS[protocol].roundTrips || 1;
            var to = ((that._options.rto || 0) * roundTrips) || 5000;
            that._transport_tref = utils.delay(to, function() {
                if (that.readyState === SockJS.CONNECTING) {
                    // I can't understand how it is possible to run
                    // this timer, when the state is CLOSED, but
                    // apparently in IE everythin is possible.
                    that._didClose(2007, "Transport timeouted");
                }
            });

            var connid = utils.random_string(8);
            var trans_url = that._base_url + '/' + that._server + '/' + connid;
            that._debug('Opening transport:', protocol, ' url:'+trans_url,
                        ' RTO:'+that._options.rto);
            that._transport = new SockJS[protocol](that, trans_url,
                                                   that._base_url);
            return true;
        }
    }
};

SockJS.prototype.close = function(code, reason) {
    var that = this;
    if (code && !utils.userSetCode(code))
        throw new Error("INVALID_ACCESS_ERR");
    if(that.readyState !== SockJS.CONNECTING &&
       that.readyState !== SockJS.OPEN) {
        return false;
    }
    that.readyState = SockJS.CLOSING;
    that._didClose(code || 1000, reason || "Normal closure");
    return true;
};

SockJS.prototype.send = function(data) {
    var that = this;
    if (that.readyState === SockJS.CONNECTING)
        throw new Error('INVALID_STATE_ERR');
    if (that.readyState === SockJS.OPEN) {
        that._transport.doSend(utils.quote('' + data));
    }
    return true;
};

SockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {
    var that = this;
    that._options.info = info;
    that._options.rtt = rtt;
    that._options.rto = utils.countRTO(rtt);
    that._options.info.null_origin = !_document.domain;
    var probed = utils.probeProtocols();
    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);
};
//         [*] End of lib/sockjs.js


//         [*] Including lib/trans-websocket.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var WebSocketTransport = SockJS.websocket = function(ri, trans_url) {
    var that = this;
    var url = trans_url + '/websocket';
    if (url.slice(0, 5) === 'https') {
        url = 'wss' + url.slice(5);
    } else {
        url = 'ws' + url.slice(4);
    }
    that.ri = ri;
    that.url = url;
    var Constructor = _window.WebSocket || _window.MozWebSocket;

    that.ws = new Constructor(that.url);
    that.ws.onmessage = function(e) {
        that.ri._didMessage(e.data);
    };
    // Firefox has an interesting bug. If a websocket connection is
    // created after onunload, it stays alive even when user
    // navigates away from the page. In such situation let's lie -
    // let's not open the ws connection at all. See:
    // https://github.com/sockjs/sockjs-client/issues/28
    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
    that.unload_ref = utils.unload_add(function(){that.ws.close()});
    that.ws.onclose = function() {
        that.ri._didMessage(utils.closeFrame(1006, "WebSocket connection broken"));
    };
};

WebSocketTransport.prototype.doSend = function(data) {
    this.ws.send('[' + data + ']');
};

WebSocketTransport.prototype.doCleanup = function() {
    var that = this;
    var ws = that.ws;
    if (ws) {
        ws.onmessage = ws.onclose = null;
        ws.close();
        utils.unload_del(that.unload_ref);
        that.unload_ref = that.ri = that.ws = null;
    }
};

WebSocketTransport.enabled = function() {
    return !!(_window.WebSocket || _window.MozWebSocket);
};

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;
//         [*] End of lib/trans-websocket.js


//         [*] Including lib/trans-sender.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var BufferedSender = function() {};
BufferedSender.prototype.send_constructor = function(sender) {
    var that = this;
    that.send_buffer = [];
    that.sender = sender;
};
BufferedSender.prototype.doSend = function(message) {
    var that = this;
    that.send_buffer.push(message);
    if (!that.send_stop) {
        that.send_schedule();
    }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.send_schedule_wait = function() {
    var that = this;
    var tref;
    that.send_stop = function() {
        that.send_stop = null;
        clearTimeout(tref);
    };
    tref = utils.delay(25, function() {
        that.send_stop = null;
        that.send_schedule();
    });
};

BufferedSender.prototype.send_schedule = function() {
    var that = this;
    if (that.send_buffer.length > 0) {
        var payload = '[' + that.send_buffer.join(',') + ']';
        that.send_stop = that.sender(that.trans_url, payload, function(success, abort_reason) {
            that.send_stop = null;
            if (success === false) {
                that.ri._didClose(1006, 'Sending error ' + abort_reason);
            } else {
                that.send_schedule_wait();
            }
        });
        that.send_buffer = [];
    }
};

BufferedSender.prototype.send_destructor = function() {
    var that = this;
    if (that._send_stop) {
        that._send_stop();
    }
    that._send_stop = null;
};

var jsonPGenericSender = function(url, payload, callback) {
    var that = this;

    if (!('_send_form' in that)) {
        var form = that._send_form = _document.createElement('form');
        var area = that._send_area = _document.createElement('textarea');
        area.name = 'd';
        form.style.display = 'none';
        form.style.position = 'absolute';
        form.method = 'POST';
        form.enctype = 'application/x-www-form-urlencoded';
        form.acceptCharset = "UTF-8";
        form.appendChild(area);
        _document.body.appendChild(form);
    }
    var form = that._send_form;
    var area = that._send_area;
    var id = 'a' + utils.random_string(8);
    form.target = id;
    form.action = url + '/jsonp_send?i=' + id;

    var iframe;
    try {
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
        iframe = _document.createElement('<iframe name="'+ id +'">');
    } catch(x) {
        iframe = _document.createElement('iframe');
        iframe.name = id;
    }
    iframe.id = id;
    form.appendChild(iframe);
    iframe.style.display = 'none';

    try {
        area.value = payload;
    } catch(e) {
        utils.log('Your browser is seriously broken. Go home! ' + e.message);
    }
    form.submit();

    var completed = function(e) {
        if (!iframe.onerror) return;
        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
        // Opera mini doesn't like if we GC iframe
        // immediately, thus this timeout.
        utils.delay(500, function() {
                       iframe.parentNode.removeChild(iframe);
                       iframe = null;
                   });
        area.value = '';
        // It is not possible to detect if the iframe succeeded or
        // failed to submit our form.
        callback(true);
    };
    iframe.onerror = iframe.onload = completed;
    iframe.onreadystatechange = function(e) {
        if (iframe.readyState == 'complete') completed();
    };
    return completed;
};

var createAjaxSender = function(AjaxObject) {
    return function(url, payload, callback) {
        var xo = new AjaxObject('POST', url + '/xhr_send', payload);
        xo.onfinish = function(status, text) {
            callback(status === 200 || status === 204,
                     'http status ' + status);
        };
        return function(abort_reason) {
            callback(false, abort_reason);
        };
    };
};
//         [*] End of lib/trans-sender.js


//         [*] Including lib/trans-jsonp-receiver.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// Parts derived from Socket.io:
//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js
// and jQuery-JSONP:
//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js
var jsonPGenericReceiver = function(url, callback) {
    var tref;
    var script = _document.createElement('script');
    var script2;  // Opera synchronous load trick.
    var close_script = function(frame) {
        if (script2) {
            script2.parentNode.removeChild(script2);
            script2 = null;
        }
        if (script) {
            clearTimeout(tref);
            // Unfortunately, you can't really abort script loading of
            // the script.
            script.parentNode.removeChild(script);
            script.onreadystatechange = script.onerror =
                script.onload = script.onclick = null;
            script = null;
            callback(frame);
            callback = null;
        }
    };

    // IE9 fires 'error' event after orsc or before, in random order.
    var loaded_okay = false;
    var error_timer = null;

    script.id = 'a' + utils.random_string(8);
    script.src = url;
    script.type = 'text/javascript';
    script.charset = 'UTF-8';
    script.onerror = function(e) {
        if (!error_timer) {
            // Delay firing close_script.
            error_timer = setTimeout(function() {
                if (!loaded_okay) {
                    close_script(utils.closeFrame(
                        1006,
                        "JSONP script loaded abnormally (onerror)"));
                }
            }, 1000);
        }
    };
    script.onload = function(e) {
        close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onload)"));
    };

    script.onreadystatechange = function(e) {
        if (/loaded|closed/.test(script.readyState)) {
            if (script && script.htmlFor && script.onclick) {
                loaded_okay = true;
                try {
                    // In IE, actually execute the script.
                    script.onclick();
                } catch (x) {}
            }
            if (script) {
                close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onreadystatechange)"));
            }
        }
    };
    // IE: event/htmlFor/onclick trick.
    // One can't rely on proper order for onreadystatechange. In order to
    // make sure, set a 'htmlFor' and 'event' properties, so that
    // script code will be installed as 'onclick' handler for the
    // script object. Later, onreadystatechange, manually execute this
    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
    // set. For reference see:
    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
    // Also, read on that about script ordering:
    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
    if (typeof script.async === 'undefined' && _document.attachEvent) {
        // According to mozilla docs, in recent browsers script.async defaults
        // to 'true', so we may use it to detect a good browser:
        // https://developer.mozilla.org/en/HTML/Element/script
        if (!/opera/i.test(navigator.userAgent)) {
            // Naively assume we're in IE
            try {
                script.htmlFor = script.id;
                script.event = "onclick";
            } catch (x) {}
            script.async = true;
        } else {
            // Opera, second sync script hack
            script2 = _document.createElement('script');
            script2.text = "try{var a = document.getElementById('"+script.id+"'); if(a)a.onerror();}catch(x){};";
            script.async = script2.async = false;
        }
    }
    if (typeof script.async !== 'undefined') {
        script.async = true;
    }

    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
    tref = setTimeout(function() {
                          close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (timeout)"));
                      }, 35000);

    var head = _document.getElementsByTagName('head')[0];
    head.insertBefore(script, head.firstChild);
    if (script2) {
        head.insertBefore(script2, head.firstChild);
    }
    return close_script;
};
//         [*] End of lib/trans-jsonp-receiver.js


//         [*] Including lib/trans-jsonp-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// mssage could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors


var JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {
    utils.polluteGlobalNamespace();
    var that = this;
    that.ri = ri;
    that.trans_url = trans_url;
    that.send_constructor(jsonPGenericSender);
    that._schedule_recv();
};

// Inheritnace
JsonPTransport.prototype = new BufferedSender();

JsonPTransport.prototype._schedule_recv = function() {
    var that = this;
    var callback = function(data) {
        that._recv_stop = null;
        if (data) {
            // no data - heartbeat;
            if (!that._is_closing) {
                that.ri._didMessage(data);
            }
        }
        // The message can be a close message, and change is_closing state.
        if (!that._is_closing) {
            that._schedule_recv();
        }
    };
    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',
                                           jsonPGenericReceiver, callback);
};

JsonPTransport.enabled = function() {
    return true;
};

JsonPTransport.need_body = true;


JsonPTransport.prototype.doCleanup = function() {
    var that = this;
    that._is_closing = true;
    if (that._recv_stop) {
        that._recv_stop();
    }
    that.ri = that._recv_stop = null;
    that.send_destructor();
};


// Abstract away code that handles global namespace pollution.
var jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {
    var id = 'a' + utils.random_string(6);
    var url_id = url + '?c=' + escape(WPrefix + '.' + id);

    // Unfortunately it is not possible to abort loading of the
    // script. We need to keep track of frake close frames.
    var aborting = 0;

    // Callback will be called exactly once.
    var callback = function(frame) {
        switch(aborting) {
        case 0:
            // Normal behaviour - delete hook _and_ emit message.
            delete _window[WPrefix][id];
            user_callback(frame);
            break;
        case 1:
            // Fake close frame - emit but don't delete hook.
            user_callback(frame);
            aborting = 2;
            break;
        case 2:
            // Got frame after connection was closed, delete hook, don't emit.
            delete _window[WPrefix][id];
            break;
        }
    };

    var close_script = constructReceiver(url_id, callback);
    _window[WPrefix][id] = close_script;
    var stop = function() {
        if (_window[WPrefix][id]) {
            aborting = 1;
            _window[WPrefix][id](utils.closeFrame(1000, "JSONP user aborted read"));
        }
    };
    return stop;
};
//         [*] End of lib/trans-jsonp-polling.js


//         [*] Including lib/trans-xhr.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var AjaxBasedTransport = function() {};
AjaxBasedTransport.prototype = new BufferedSender();

AjaxBasedTransport.prototype.run = function(ri, trans_url,
                                            url_suffix, Receiver, AjaxObject) {
    var that = this;
    that.ri = ri;
    that.trans_url = trans_url;
    that.send_constructor(createAjaxSender(AjaxObject));
    that.poll = new Polling(ri, Receiver,
                            trans_url + url_suffix, AjaxObject);
};

AjaxBasedTransport.prototype.doCleanup = function() {
    var that = this;
    if (that.poll) {
        that.poll.abort();
        that.poll = null;
    }
};

// xhr-streaming
var XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);
};

XhrStreamingTransport.prototype = new AjaxBasedTransport();

XhrStreamingTransport.enabled = function() {
    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but
    // doesn't do streaming.
    return (_window.XMLHttpRequest &&
            'withCredentials' in new XMLHttpRequest() &&
            (!/opera/i.test(navigator.userAgent)));
};
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
XhrStreamingTransport.need_body = true;


// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/


// xdr-streaming
var XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);
};

XdrStreamingTransport.prototype = new AjaxBasedTransport();

XdrStreamingTransport.enabled = function() {
    return !!_window.XDomainRequest;
};
XdrStreamingTransport.roundTrips = 2; // preflight, ajax



// xhr-polling
var XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);
};

XhrPollingTransport.prototype = new AjaxBasedTransport();

XhrPollingTransport.enabled = XhrStreamingTransport.enabled;
XhrPollingTransport.roundTrips = 2; // preflight, ajax


// xdr-polling
var XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);
};

XdrPollingTransport.prototype = new AjaxBasedTransport();

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.roundTrips = 2; // preflight, ajax
//         [*] End of lib/trans-xhr.js


//         [*] Including lib/trans-iframe.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// Few cool transports do work only for same-origin. In order to make
// them working cross-domain we shall use iframe, served form the
// remote domain. New browsers, have capabilities to communicate with
// cross domain iframe, using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var IframeTransport = function() {};

IframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {
    var that = this;
    that.ri = ri;
    that.origin = utils.getOrigin(base_url);
    that.base_url = base_url;
    that.trans_url = trans_url;

    var iframe_url = base_url + '/iframe.html';
    if (that.ri._options.devel) {
        iframe_url += '?t=' + (+new Date);
    }
    that.window_id = utils.random_string(8);
    iframe_url += '#' + that.window_id;

    that.iframeObj = utils.createIframe(iframe_url, function(r) {
                                            that.ri._didClose(1006, "Unable to load an iframe (" + r + ")");
                                        });

    that.onmessage_cb = utils.bind(that.onmessage, that);
    utils.attachMessage(that.onmessage_cb);
};

IframeTransport.prototype.doCleanup = function() {
    var that = this;
    if (that.iframeObj) {
        utils.detachMessage(that.onmessage_cb);
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (that.iframeObj.iframe.contentWindow) {
                that.postMessage('c');
            }
        } catch (x) {}
        that.iframeObj.cleanup();
        that.iframeObj = null;
        that.onmessage_cb = that.iframeObj = null;
    }
};

IframeTransport.prototype.onmessage = function(e) {
    var that = this;
    if (e.origin !== that.origin) return;
    var window_id = e.data.slice(0, 8);
    var type = e.data.slice(8, 9);
    var data = e.data.slice(9);

    if (window_id !== that.window_id) return;

    switch(type) {
    case 's':
        that.iframeObj.loaded();
        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));
        break;
    case 't':
        that.ri._didMessage(data);
        break;
    }
};

IframeTransport.prototype.postMessage = function(type, data) {
    var that = this;
    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);
};

IframeTransport.prototype.doSend = function (message) {
    this.postMessage('m', message);
};

IframeTransport.enabled = function() {
    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
    // huge delay, or not at all.
    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;
    return ((typeof _window.postMessage === 'function' ||
            typeof _window.postMessage === 'object') && (!konqueror));
};
//         [*] End of lib/trans-iframe.js


//         [*] Including lib/trans-iframe-within.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var curr_window_id;

var postMessage = function (type, data) {
    if(parent !== _window) {
        parent.postMessage(curr_window_id + type + (data || ''), '*');
    } else {
        utils.log("Can't postMessage, no parent window.", type, data);
    }
};

var FacadeJS = function() {};
FacadeJS.prototype._didClose = function (code, reason) {
    postMessage('t', utils.closeFrame(code, reason));
};
FacadeJS.prototype._didMessage = function (frame) {
    postMessage('t', frame);
};
FacadeJS.prototype._doSend = function (data) {
    this._transport.doSend(data);
};
FacadeJS.prototype._doCleanup = function () {
    this._transport.doCleanup();
};

utils.parent_origin = undefined;

SockJS.bootstrap_iframe = function() {
    var facade;
    curr_window_id = _document.location.hash.slice(1);
    var onMessage = function(e) {
        if(e.source !== parent) return;
        if(typeof utils.parent_origin === 'undefined')
            utils.parent_origin = e.origin;
        if (e.origin !== utils.parent_origin) return;

        var window_id = e.data.slice(0, 8);
        var type = e.data.slice(8, 9);
        var data = e.data.slice(9);
        if (window_id !== curr_window_id) return;
        switch(type) {
        case 's':
            var p = JSON.parse(data);
            var version = p[0];
            var protocol = p[1];
            var trans_url = p[2];
            var base_url = p[3];
            if (version !== SockJS.version) {
                utils.log("Incompatibile SockJS! Main site uses:" +
                          " \"" + version + "\", the iframe:" +
                          " \"" + SockJS.version + "\".");
            }
            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {
                utils.log("Only basic urls are supported in SockJS");
                return;
            }

            if (!utils.isSameOriginUrl(trans_url) ||
                !utils.isSameOriginUrl(base_url)) {
                utils.log("Can't connect to different domain from within an " +
                          "iframe. (" + JSON.stringify([_window.location.href, trans_url, base_url]) +
                          ")");
                return;
            }
            facade = new FacadeJS();
            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);
            break;
        case 'm':
            facade._doSend(data);
            break;
        case 'c':
            if (facade)
                facade._doCleanup();
            facade = null;
            break;
        }
    };

    // alert('test ticker');
    // facade = new FacadeJS();
    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');

    utils.attachMessage(onMessage);

    // Start
    postMessage('s');
};
//         [*] End of lib/trans-iframe-within.js


//         [*] Including lib/info.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var InfoReceiver = function(base_url, AjaxObject) {
    var that = this;
    utils.delay(function(){that.doXhr(base_url, AjaxObject);});
};

InfoReceiver.prototype = new EventEmitter(['finish']);

InfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {
    var that = this;
    var t0 = (new Date()).getTime();
    var xo = new AjaxObject('GET', base_url + '/info');

    var tref = utils.delay(8000,
                           function(){xo.ontimeout();});

    xo.onfinish = function(status, text) {
        clearTimeout(tref);
        tref = null;
        if (status === 200) {
            var rtt = (new Date()).getTime() - t0;
            var info = JSON.parse(text);
            if (typeof info !== 'object') info = {};
            that.emit('finish', info, rtt);
        } else {
            that.emit('finish');
        }
    };
    xo.ontimeout = function() {
        xo.close();
        that.emit('finish');
    };
};

var InfoReceiverIframe = function(base_url) {
    var that = this;
    var go = function() {
        var ifr = new IframeTransport();
        ifr.protocol = 'w-iframe-info-receiver';
        var fun = function(r) {
            if (typeof r === 'string' && r.substr(0,1) === 'm') {
                var d = JSON.parse(r.substr(1));
                var info = d[0], rtt = d[1];
                that.emit('finish', info, rtt);
            } else {
                that.emit('finish');
            }
            ifr.doCleanup();
            ifr = null;
        };
        var mock_ri = {
            _options: {},
            _didClose: fun,
            _didMessage: fun
        };
        ifr.i_constructor(mock_ri, base_url, base_url);
    }
    if(!_document.body) {
        utils.attachEvent('load', go);
    } else {
        go();
    }
};
InfoReceiverIframe.prototype = new EventEmitter(['finish']);


var InfoReceiverFake = function() {
    // It may not be possible to do cross domain AJAX to get the info
    // data, for example for IE7. But we want to run JSONP, so let's
    // fake the response, with rtt=2s (rto=6s).
    var that = this;
    utils.delay(function() {
        that.emit('finish', {}, 2000);
    });
};
InfoReceiverFake.prototype = new EventEmitter(['finish']);

var createInfoReceiver = function(base_url) {
    if (utils.isSameOriginUrl(base_url)) {
        // If, for some reason, we have SockJS locally - there's no
        // need to start up the complex machinery. Just use ajax.
        return new InfoReceiver(base_url, utils.XHRLocalObject);
    }
    switch (utils.isXHRCorsCapable()) {
    case 1:
        // XHRLocalObject -> no_credentials=true
        return new InfoReceiver(base_url, utils.XHRLocalObject);
    case 2:
        return new InfoReceiver(base_url, utils.XDRObject);
    case 3:
        // Opera
        return new InfoReceiverIframe(base_url);
    default:
        // IE 7
        return new InfoReceiverFake();
    };
};


var WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {
    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);
    ir.onfinish = function(info, rtt) {
        ri._didMessage('m'+JSON.stringify([info, rtt]));
        ri._didClose();
    }
};
WInfoReceiverIframe.prototype.doCleanup = function() {};
//         [*] End of lib/info.js


//         [*] Including lib/trans-iframe-eventsource.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {
    var that = this;
    that.protocol = 'w-iframe-eventsource';
    that.i_constructor.apply(that, arguments);
};

EventSourceIframeTransport.prototype = new IframeTransport();

EventSourceIframeTransport.enabled = function () {
    return ('EventSource' in _window) && IframeTransport.enabled();
};

EventSourceIframeTransport.need_body = true;
EventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource


// w-iframe-eventsource
var EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);
}
EventSourceTransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-eventsource.js


//         [*] Including lib/trans-iframe-xhr-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {
    var that = this;
    that.protocol = 'w-iframe-xhr-polling';
    that.i_constructor.apply(that, arguments);
};

XhrPollingIframeTransport.prototype = new IframeTransport();

XhrPollingIframeTransport.enabled = function () {
    return _window.XMLHttpRequest && IframeTransport.enabled();
};

XhrPollingIframeTransport.need_body = true;
XhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr


// w-iframe-xhr-polling
var XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);
};

XhrPollingITransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-xhr-polling.js


//         [*] Including lib/trans-iframe-htmlfile.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// This transport generally works in any browser, but will cause a
// spinning cursor to appear in any browser other than IE.
// We may test this transport in all browsers - why not, but in
// production it should be only run in IE.

var HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {
    var that = this;
    that.protocol = 'w-iframe-htmlfile';
    that.i_constructor.apply(that, arguments);
};

// Inheritance.
HtmlFileIframeTransport.prototype = new IframeTransport();

HtmlFileIframeTransport.enabled = function() {
    return IframeTransport.enabled();
};

HtmlFileIframeTransport.need_body = true;
HtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile


// w-iframe-htmlfile
var HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);
};
HtmlFileTransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-htmlfile.js


//         [*] Including lib/trans-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var Polling = function(ri, Receiver, recv_url, AjaxObject) {
    var that = this;
    that.ri = ri;
    that.Receiver = Receiver;
    that.recv_url = recv_url;
    that.AjaxObject = AjaxObject;
    that._scheduleRecv();
};

Polling.prototype._scheduleRecv = function() {
    var that = this;
    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);
    var msg_counter = 0;
    poll.onmessage = function(e) {
        msg_counter += 1;
        that.ri._didMessage(e.data);
    };
    poll.onclose = function(e) {
        that.poll = poll = poll.onmessage = poll.onclose = null;
        if (!that.poll_is_closing) {
            if (e.reason === 'permanent') {
                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');
            } else {
                that._scheduleRecv();
            }
        }
    };
};

Polling.prototype.abort = function() {
    var that = this;
    that.poll_is_closing = true;
    if (that.poll) {
        that.poll.abort();
    }
};
//         [*] End of lib/trans-polling.js


//         [*] Including lib/trans-receiver-eventsource.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventSourceReceiver = function(url) {
    var that = this;
    var es = new EventSource(url);
    es.onmessage = function(e) {
        that.dispatchEvent(new SimpleEvent('message',
                                           {'data': unescape(e.data)}));
    };
    that.es_close = es.onerror = function(e, abort_reason) {
        // ES on reconnection has readyState = 0 or 1.
        // on network error it's CLOSED = 2
        var reason = abort_reason ? 'user' :
            (es.readyState !== 2 ? 'network' : 'permanent');
        that.es_close = es.onmessage = es.onerror = null;
        // EventSource reconnects automatically.
        es.close();
        es = null;
        // Safari and chrome < 15 crash if we close window before
        // waiting for ES cleanup. See:
        //   https://code.google.com/p/chromium/issues/detail?id=89155
        utils.delay(200, function() {
                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));
                    });
    };
};

EventSourceReceiver.prototype = new REventTarget();

EventSourceReceiver.prototype.abort = function() {
    var that = this;
    if (that.es_close) {
        that.es_close({}, true);
    }
};
//         [*] End of lib/trans-receiver-eventsource.js


//         [*] Including lib/trans-receiver-htmlfile.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var _is_ie_htmlfile_capable;
var isIeHtmlfileCapable = function() {
    if (_is_ie_htmlfile_capable === undefined) {
        if ('ActiveXObject' in _window) {
            try {
                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');
            } catch (x) {}
        } else {
            _is_ie_htmlfile_capable = false;
        }
    }
    return _is_ie_htmlfile_capable;
};


var HtmlfileReceiver = function(url) {
    var that = this;
    utils.polluteGlobalNamespace();

    that.id = 'a' + utils.random_string(6, 26);
    url += ((url.indexOf('?') === -1) ? '?' : '&') +
        'c=' + escape(WPrefix + '.' + that.id);

    var constructor = isIeHtmlfileCapable() ?
        utils.createHtmlfile : utils.createIframe;

    var iframeObj;
    _window[WPrefix][that.id] = {
        start: function () {
            iframeObj.loaded();
        },
        message: function (data) {
            that.dispatchEvent(new SimpleEvent('message', {'data': data}));
        },
        stop: function () {
            that.iframe_close({}, 'network');
        }
    };
    that.iframe_close = function(e, abort_reason) {
        iframeObj.cleanup();
        that.iframe_close = iframeObj = null;
        delete _window[WPrefix][that.id];
        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));
    };
    iframeObj = constructor(url, function(e) {
                                that.iframe_close({}, 'permanent');
                            });
};

HtmlfileReceiver.prototype = new REventTarget();

HtmlfileReceiver.prototype.abort = function() {
    var that = this;
    if (that.iframe_close) {
        that.iframe_close({}, 'user');
    }
};
//         [*] End of lib/trans-receiver-htmlfile.js


//         [*] Including lib/trans-receiver-xhr.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var XhrReceiver = function(url, AjaxObject) {
    var that = this;
    var buf_pos = 0;

    that.xo = new AjaxObject('POST', url, null);
    that.xo.onchunk = function(status, text) {
        if (status !== 200) return;
        while (1) {
            var buf = text.slice(buf_pos);
            var p = buf.indexOf('\n');
            if (p === -1) break;
            buf_pos += p+1;
            var msg = buf.slice(0, p);
            that.dispatchEvent(new SimpleEvent('message', {data: msg}));
        }
    };
    that.xo.onfinish = function(status, text) {
        that.xo.onchunk(status, text);
        that.xo = null;
        var reason = status === 200 ? 'network' : 'permanent';
        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));
    }
};

XhrReceiver.prototype = new REventTarget();

XhrReceiver.prototype.abort = function() {
    var that = this;
    if (that.xo) {
        that.xo.close();
        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));
        that.xo = null;
    }
};
//         [*] End of lib/trans-receiver-xhr.js


//         [*] Including lib/test-hooks.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// For testing
SockJS.getUtils = function(){
    return utils;
};

SockJS.getIframeTransport = function(){
    return IframeTransport;
};
//         [*] End of lib/test-hooks.js

                  return SockJS;
          })();
if ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);

module.exports = SockJS;
//     [*] End of lib/index.js

// [*] End of lib/all.js

},{}],19:[function(require,module,exports){
ace.define("ace/mode/doc_comment_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/text_highlight_rules"], function(acequire, exports, module) {
"use strict";

var oop = acequire("../lib/oop");
var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;

var DocCommentHighlightRules = function() {
    this.$rules = {
        "start" : [ {
            token : "comment.doc.tag",
            regex : "@[\\w\\d_]+" // TODO: fix email addresses
        },
        DocCommentHighlightRules.getTagRule(),
        {
            defaultToken : "comment.doc",
            caseInsensitive: true
        }]
    };
};

oop.inherits(DocCommentHighlightRules, TextHighlightRules);

DocCommentHighlightRules.getTagRule = function(start) {
    return {
        token : "comment.doc.tag.storage.type",
        regex : "\\b(?:TODO|FIXME|XXX|HACK)\\b"
    };
}

DocCommentHighlightRules.getStartRule = function(start) {
    return {
        token : "comment.doc", // doc comment
        regex : "\\/\\*(?=\\*)",
        next  : start
    };
};

DocCommentHighlightRules.getEndRule = function (start) {
    return {
        token : "comment.doc", // closing comment
        regex : "\\*\\/",
        next  : start
    };
};


exports.DocCommentHighlightRules = DocCommentHighlightRules;

});

ace.define("ace/mode/javascript_highlight_rules",["require","exports","module","ace/lib/oop","ace/mode/doc_comment_highlight_rules","ace/mode/text_highlight_rules"], function(acequire, exports, module) {
"use strict";

var oop = acequire("../lib/oop");
var DocCommentHighlightRules = acequire("./doc_comment_highlight_rules").DocCommentHighlightRules;
var TextHighlightRules = acequire("./text_highlight_rules").TextHighlightRules;

var JavaScriptHighlightRules = function(options) {
    var keywordMapper = this.createKeywordMapper({
        "variable.language":
            "Array|Boolean|Date|Function|Iterator|Number|Object|RegExp|String|Proxy|"  + // Constructors
            "Namespace|QName|XML|XMLList|"                                             + // E4X
            "ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|"   +
            "Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray|"                    +
            "Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|"   + // Errors
            "SyntaxError|TypeError|URIError|"                                          +
            "decodeURI|decodeURIComponent|encodeURI|encodeURIComponent|eval|isFinite|" + // Non-constructor functions
            "isNaN|parseFloat|parseInt|"                                               +
            "JSON|Math|"                                                               + // Other
            "this|arguments|prototype|window|document"                                 , // Pseudo
        "keyword":
            "const|yield|import|get|set|" +
            "break|case|catch|continue|default|delete|do|else|finally|for|function|" +
            "if|in|instanceof|new|return|switch|throw|try|typeof|let|var|while|with|debugger|" +
            "__parent__|__count__|escape|unescape|with|__proto__|" +
            "class|enum|extends|super|export|implements|private|public|interface|package|protected|static",
        "storage.type":
            "const|let|var|function",
        "constant.language":
            "null|Infinity|NaN|undefined",
        "support.function":
            "alert",
        "constant.language.boolean": "true|false"
    }, "identifier");
    var kwBeforeRe = "case|do|else|finally|in|instanceof|return|throw|try|typeof|yield|void";
    var identifierRe = "[a-zA-Z\\$_\u00a1-\uffff][a-zA-Z\\d\\$_\u00a1-\uffff]*\\b";

    var escapedRe = "\\\\(?:x[0-9a-fA-F]{2}|" + // hex
        "u[0-9a-fA-F]{4}|" + // unicode
        "[0-2][0-7]{0,2}|" + // oct
        "3[0-6][0-7]?|" + // oct
        "37[0-7]?|" + // oct
        "[4-7][0-7]?|" + //oct
        ".)";

    this.$rules = {
        "no_regex" : [
            {
                token : "comment",
                regex : "\\/\\/",
                next : "line_comment"
            },
            DocCommentHighlightRules.getStartRule("doc-start"),
            {
                token : "comment", // multi line comment
                regex : /\/\*/,
                next : "comment"
            }, {
                token : "string",
                regex : "'(?=.)",
                next  : "qstring"
            }, {
                token : "string",
                regex : '"(?=.)',
                next  : "qqstring"
            }, {
                token : "constant.numeric", // hex
                regex : /0[xX][0-9a-fA-F]+\b/
            }, {
                token : "constant.numeric", // float
                regex : /[+-]?\d+(?:(?:\.\d*)?(?:[eE][+-]?\d+)?)?\b/
            }, {
                token : [
                    "storage.type", "punctuation.operator", "support.function",
                    "punctuation.operator", "entity.name.function", "text","keyword.operator"
                ],
                regex : "(" + identifierRe + ")(\\.)(prototype)(\\.)(" + identifierRe +")(\\s*)(=)",
                next: "function_arguments"
            }, {
                token : [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "entity.name.function", "text", "keyword.operator", "text", "storage.type",
                    "text", "paren.lparen"
                ],
                regex : "(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "storage.type", "punctuation.operator", "entity.name.function", "text",
                    "keyword.operator", "text",
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\.)(" + identifierRe +")(\\s*)(=)(\\s*)(function)(\\s+)(\\w+)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "storage.type", "text", "entity.name.function", "text", "paren.lparen"
                ],
                regex : "(function)(\\s+)(" + identifierRe + ")(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "entity.name.function", "text", "punctuation.operator",
                    "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(" + identifierRe + ")(\\s*)(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : [
                    "text", "text", "storage.type", "text", "paren.lparen"
                ],
                regex : "(:)(\\s*)(function)(\\s*)(\\()",
                next: "function_arguments"
            }, {
                token : "keyword",
                regex : "(?:" + kwBeforeRe + ")\\b",
                next : "start"
            }, {
                token : ["punctuation.operator", "support.function"],
                regex : /(\.)(s(?:h(?:ift|ow(?:Mod(?:elessDialog|alDialog)|Help))|croll(?:X|By(?:Pages|Lines)?|Y|To)?|t(?:op|rike)|i(?:n|zeToContent|debar|gnText)|ort|u(?:p|b(?:str(?:ing)?)?)|pli(?:ce|t)|e(?:nd|t(?:Re(?:sizable|questHeader)|M(?:i(?:nutes|lliseconds)|onth)|Seconds|Ho(?:tKeys|urs)|Year|Cursor|Time(?:out)?|Interval|ZOptions|Date|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Date|FullYear)|FullYear|Active)|arch)|qrt|lice|avePreferences|mall)|h(?:ome|andleEvent)|navigate|c(?:har(?:CodeAt|At)|o(?:s|n(?:cat|textual|firm)|mpile)|eil|lear(?:Timeout|Interval)?|a(?:ptureEvents|ll)|reate(?:StyleSheet|Popup|EventObject))|t(?:o(?:GMTString|S(?:tring|ource)|U(?:TCString|pperCase)|Lo(?:caleString|werCase))|est|a(?:n|int(?:Enabled)?))|i(?:s(?:NaN|Finite)|ndexOf|talics)|d(?:isableExternalCapture|ump|etachEvent)|u(?:n(?:shift|taint|escape|watch)|pdateCommands)|j(?:oin|avaEnabled)|p(?:o(?:p|w)|ush|lugins.refresh|a(?:ddings|rse(?:Int|Float)?)|r(?:int|ompt|eference))|e(?:scape|nableExternalCapture|val|lementFromPoint|x(?:p|ec(?:Script|Command)?))|valueOf|UTC|queryCommand(?:State|Indeterm|Enabled|Value)|f(?:i(?:nd|le(?:ModifiedDate|Size|CreatedDate|UpdatedDate)|xed)|o(?:nt(?:size|color)|rward)|loor|romCharCode)|watch|l(?:ink|o(?:ad|g)|astIndexOf)|a(?:sin|nchor|cos|t(?:tachEvent|ob|an(?:2)?)|pply|lert|b(?:s|ort))|r(?:ou(?:nd|teEvents)|e(?:size(?:By|To)|calc|turnValue|place|verse|l(?:oad|ease(?:Capture|Events)))|andom)|g(?:o|et(?:ResponseHeader|M(?:i(?:nutes|lliseconds)|onth)|Se(?:conds|lection)|Hours|Year|Time(?:zoneOffset)?|Da(?:y|te)|UTC(?:M(?:i(?:nutes|lliseconds)|onth)|Seconds|Hours|Da(?:y|te)|FullYear)|FullYear|A(?:ttention|llResponseHeaders)))|m(?:in|ove(?:B(?:y|elow)|To(?:Absolute)?|Above)|ergeAttributes|a(?:tch|rgins|x))|b(?:toa|ig|o(?:ld|rderWidths)|link|ack))\b(?=\()/
            }, {
                token : ["punctuation.operator", "support.function.dom"],
                regex : /(\.)(s(?:ub(?:stringData|mit)|plitText|e(?:t(?:NamedItem|Attribute(?:Node)?)|lect))|has(?:ChildNodes|Feature)|namedItem|c(?:l(?:ick|o(?:se|neNode))|reate(?:C(?:omment|DATASection|aption)|T(?:Head|extNode|Foot)|DocumentFragment|ProcessingInstruction|E(?:ntityReference|lement)|Attribute))|tabIndex|i(?:nsert(?:Row|Before|Cell|Data)|tem)|open|delete(?:Row|C(?:ell|aption)|T(?:Head|Foot)|Data)|focus|write(?:ln)?|a(?:dd|ppend(?:Child|Data))|re(?:set|place(?:Child|Data)|move(?:NamedItem|Child|Attribute(?:Node)?)?)|get(?:NamedItem|Element(?:sBy(?:Name|TagName)|ById)|Attribute(?:Node)?)|blur)\b(?=\()/
            }, {
                token : ["punctuation.operator", "support.constant"],
                regex : /(\.)(s(?:ystemLanguage|cr(?:ipts|ollbars|een(?:X|Y|Top|Left))|t(?:yle(?:Sheets)?|atus(?:Text|bar)?)|ibling(?:Below|Above)|ource|uffixes|e(?:curity(?:Policy)?|l(?:ection|f)))|h(?:istory|ost(?:name)?|as(?:h|Focus))|y|X(?:MLDocument|SLDocument)|n(?:ext|ame(?:space(?:s|URI)|Prop))|M(?:IN_VALUE|AX_VALUE)|c(?:haracterSet|o(?:n(?:structor|trollers)|okieEnabled|lorDepth|mp(?:onents|lete))|urrent|puClass|l(?:i(?:p(?:boardData)?|entInformation)|osed|asses)|alle(?:e|r)|rypto)|t(?:o(?:olbar|p)|ext(?:Transform|Indent|Decoration|Align)|ags)|SQRT(?:1_2|2)|i(?:n(?:ner(?:Height|Width)|put)|ds|gnoreCase)|zIndex|o(?:scpu|n(?:readystatechange|Line)|uter(?:Height|Width)|p(?:sProfile|ener)|ffscreenBuffering)|NEGATIVE_INFINITY|d(?:i(?:splay|alog(?:Height|Top|Width|Left|Arguments)|rectories)|e(?:scription|fault(?:Status|Ch(?:ecked|arset)|View)))|u(?:ser(?:Profile|Language|Agent)|n(?:iqueID|defined)|pdateInterval)|_content|p(?:ixelDepth|ort|ersonalbar|kcs11|l(?:ugins|atform)|a(?:thname|dding(?:Right|Bottom|Top|Left)|rent(?:Window|Layer)?|ge(?:X(?:Offset)?|Y(?:Offset)?))|r(?:o(?:to(?:col|type)|duct(?:Sub)?|mpter)|e(?:vious|fix)))|e(?:n(?:coding|abledPlugin)|x(?:ternal|pando)|mbeds)|v(?:isibility|endor(?:Sub)?|Linkcolor)|URLUnencoded|P(?:I|OSITIVE_INFINITY)|f(?:ilename|o(?:nt(?:Size|Family|Weight)|rmName)|rame(?:s|Element)|gColor)|E|whiteSpace|l(?:i(?:stStyleType|n(?:eHeight|kColor))|o(?:ca(?:tion(?:bar)?|lName)|wsrc)|e(?:ngth|ft(?:Context)?)|a(?:st(?:M(?:odified|atch)|Index|Paren)|yer(?:s|X)|nguage))|a(?:pp(?:MinorVersion|Name|Co(?:deName|re)|Version)|vail(?:Height|Top|Width|Left)|ll|r(?:ity|guments)|Linkcolor|bove)|r(?:ight(?:Context)?|e(?:sponse(?:XML|Text)|adyState))|global|x|m(?:imeTypes|ultiline|enubar|argin(?:Right|Bottom|Top|Left))|L(?:N(?:10|2)|OG(?:10E|2E))|b(?:o(?:ttom|rder(?:Width|RightWidth|BottomWidth|Style|Color|TopWidth|LeftWidth))|ufferDepth|elow|ackground(?:Color|Image)))\b/
            }, {
                token : ["support.constant"],
                regex : /that\b/
            }, {
                token : ["storage.type", "punctuation.operator", "support.function.firebug"],
                regex : /(console)(\.)(warn|info|log|error|time|trace|timeEnd|assert)\b/
            }, {
                token : keywordMapper,
                regex : identifierRe
            }, {
                token : "keyword.operator",
                regex : /--|\+\+|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\|\||\?\:|[!$%&*+\-~\/^]=?/,
                next  : "start"
            }, {
                token : "punctuation.operator",
                regex : /[?:,;.]/,
                next  : "start"
            }, {
                token : "paren.lparen",
                regex : /[\[({]/,
                next  : "start"
            }, {
                token : "paren.rparen",
                regex : /[\])}]/
            }, {
                token: "comment",
                regex: /^#!.*$/
            }
        ],
        "start": [
            DocCommentHighlightRules.getStartRule("doc-start"),
            {
                token : "comment", // multi line comment
                regex : "\\/\\*",
                next : "comment_regex_allowed"
            }, {
                token : "comment",
                regex : "\\/\\/",
                next : "line_comment_regex_allowed"
            }, {
                token: "string.regexp",
                regex: "\\/",
                next: "regex"
            }, {
                token : "text",
                regex : "\\s+|^$",
                next : "start"
            }, {
                token: "empty",
                regex: "",
                next: "no_regex"
            }
        ],
        "regex": [
            {
                token: "regexp.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
            }, {
                token: "string.regexp",
                regex: "/[sxngimy]*",
                next: "no_regex"
            }, {
                token : "invalid",
                regex: /\{\d+\b,?\d*\}[+*]|[+*$^?][+*]|[$^][?]|\?{3,}/
            }, {
                token : "constant.language.escape",
                regex: /\(\?[:=!]|\)|\{\d+\b,?\d*\}|[+*]\?|[()$^+*?.]/
            }, {
                token : "constant.language.delimiter",
                regex: /\|/
            }, {
                token: "constant.language.escape",
                regex: /\[\^?/,
                next: "regex_character_class"
            }, {
                token: "empty",
                regex: "$",
                next: "no_regex"
            }, {
                defaultToken: "string.regexp"
            }
        ],
        "regex_character_class": [
            {
                token: "regexp.charclass.keyword.operator",
                regex: "\\\\(?:u[\\da-fA-F]{4}|x[\\da-fA-F]{2}|.)"
            }, {
                token: "constant.language.escape",
                regex: "]",
                next: "regex"
            }, {
                token: "constant.language.escape",
                regex: "-"
            }, {
                token: "empty",
                regex: "$",
                next: "no_regex"
            }, {
                defaultToken: "string.regexp.charachterclass"
            }
        ],
        "function_arguments": [
            {
                token: "variable.parameter",
                regex: identifierRe
            }, {
                token: "punctuation.operator",
                regex: "[, ]+"
            }, {
                token: "punctuation.operator",
                regex: "$"
            }, {
                token: "empty",
                regex: "",
                next: "no_regex"
            }
        ],
        "comment_regex_allowed" : [
            DocCommentHighlightRules.getTagRule(),
            {token : "comment", regex : "\\*\\/", next : "start"},
            {defaultToken : "comment", caseInsensitive: true}
        ],
        "comment" : [
            DocCommentHighlightRules.getTagRule(),
            {token : "comment", regex : "\\*\\/", next : "no_regex"},
            {defaultToken : "comment", caseInsensitive: true}
        ],
        "line_comment_regex_allowed" : [
            DocCommentHighlightRules.getTagRule(),
            {token : "comment", regex : "$|^", next : "start"},
            {defaultToken : "comment", caseInsensitive: true}
        ],
        "line_comment" : [
            DocCommentHighlightRules.getTagRule(),
            {token : "comment", regex : "$|^", next : "no_regex"},
            {defaultToken : "comment", caseInsensitive: true}
        ],
        "qqstring" : [
            {
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "string",
                regex : "\\\\$",
                next  : "qqstring"
            }, {
                token : "string",
                regex : '"|$',
                next  : "no_regex"
            }, {
                defaultToken: "string"
            }
        ],
        "qstring" : [
            {
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "string",
                regex : "\\\\$",
                next  : "qstring"
            }, {
                token : "string",
                regex : "'|$",
                next  : "no_regex"
            }, {
                defaultToken: "string"
            }
        ]
    };
    
    
    if (!options || !options.noES6) {
        this.$rules.no_regex.unshift({
            regex: "[{}]", onMatch: function(val, state, stack) {
                this.next = val == "{" ? this.nextState : "";
                if (val == "{" && stack.length) {
                    stack.unshift("start", state);
                    return "paren";
                }
                if (val == "}" && stack.length) {
                    stack.shift();
                    this.next = stack.shift();
                    if (this.next.indexOf("string") != -1)
                        return "paren.quasi.end";
                }
                return val == "{" ? "paren.lparen" : "paren.rparen";
            },
            nextState: "start"
        }, {
            token : "string.quasi.start",
            regex : /`/,
            push  : [{
                token : "constant.language.escape",
                regex : escapedRe
            }, {
                token : "paren.quasi.start",
                regex : /\${/,
                push  : "start"
            }, {
                token : "string.quasi.end",
                regex : /`/,
                next  : "pop"
            }, {
                defaultToken: "string.quasi"
            }]
        });
    }
    
    this.embedRules(DocCommentHighlightRules, "doc-",
        [ DocCommentHighlightRules.getEndRule("no_regex") ]);
    
    this.normalizeRules();
};

oop.inherits(JavaScriptHighlightRules, TextHighlightRules);

exports.JavaScriptHighlightRules = JavaScriptHighlightRules;
});

ace.define("ace/mode/matching_brace_outdent",["require","exports","module","ace/range"], function(acequire, exports, module) {
"use strict";

var Range = acequire("../range").Range;

var MatchingBraceOutdent = function() {};

(function() {

    this.checkOutdent = function(line, input) {
        if (! /^\s+$/.test(line))
            return false;

        return /^\s*\}/.test(input);
    };

    this.autoOutdent = function(doc, row) {
        var line = doc.getLine(row);
        var match = line.match(/^(\s*\})/);

        if (!match) return 0;

        var column = match[1].length;
        var openBracePos = doc.findMatchingBracket({row: row, column: column});

        if (!openBracePos || openBracePos.row == row) return 0;

        var indent = this.$getIndent(doc.getLine(openBracePos.row));
        doc.replace(new Range(row, 0, row, column-1), indent);
    };

    this.$getIndent = function(line) {
        return line.match(/^\s*/)[0];
    };

}).call(MatchingBraceOutdent.prototype);

exports.MatchingBraceOutdent = MatchingBraceOutdent;
});

ace.define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"], function(acequire, exports, module) {
"use strict";

var oop = acequire("../../lib/oop");
var Behaviour = acequire("../behaviour").Behaviour;
var TokenIterator = acequire("../../token_iterator").TokenIterator;
var lang = acequire("../../lib/lang");

var SAFE_INSERT_IN_TOKENS =
    ["text", "paren.rparen", "punctuation.operator"];
var SAFE_INSERT_BEFORE_TOKENS =
    ["text", "paren.rparen", "punctuation.operator", "comment"];

var context;
var contextCache = {};
var initContext = function(editor) {
    var id = -1;
    if (editor.multiSelect) {
        id = editor.selection.index;
        if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = {rangeCount: editor.multiSelect.rangeCount};
    }
    if (contextCache[id])
        return context = contextCache[id];
    context = contextCache[id] = {
        autoInsertedBrackets: 0,
        autoInsertedRow: -1,
        autoInsertedLineEnd: "",
        maybeInsertedBrackets: 0,
        maybeInsertedRow: -1,
        maybeInsertedLineStart: "",
        maybeInsertedLineEnd: ""
    };
};

var CstyleBehaviour = function() {
    this.add("braces", "insertion", function(state, action, editor, session, text) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (text == '{') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
                return {
                    text: '{' + selected + '}',
                    selection: false
                };
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode) {
                    CstyleBehaviour.recordAutoInsert(editor, session, "}");
                    return {
                        text: '{}',
                        selection: [1, 1]
                    };
                } else {
                    CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                    return {
                        text: '{',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == '}') {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == '}') {
                var matching = session.$findOpeningBracket('}', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        } else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
                closing = lang.stringRepeat("}", context.maybeInsertedBrackets);
                CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === '}') {
                var openBracePos = session.findMatchingBracket({row: cursor.row, column: cursor.column+1}, '}');
                if (!openBracePos)
                     return null;
                var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing) {
                var next_indent = this.$getIndent(line);
            } else {
                CstyleBehaviour.clearMaybeInsertedClosing();
                return;
            }
            var indent = next_indent + session.getTabString();

            return {
                text: '\n' + indent + '\n' + next_indent + closing,
                selection: [1, indent.length, 1, indent.length]
            };
        } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
        }
    });

    this.add("braces", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '{') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == '}') {
                range.end.column++;
                return range;
            } else {
                context.maybeInsertedBrackets--;
            }
        }
    });

    this.add("parens", "insertion", function(state, action, editor, session, text) {
        if (text == '(') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return {
                    text: '(' + selected + ')',
                    selection: false
                };
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, ")");
                return {
                    text: '()',
                    selection: [1, 1]
                };
            }
        } else if (text == ')') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ')') {
                var matching = session.$findOpeningBracket(')', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("parens", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '(') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ')') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("brackets", "insertion", function(state, action, editor, session, text) {
        if (text == '[') {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
                return {
                    text: '[' + selected + ']',
                    selection: false
                };
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
                CstyleBehaviour.recordAutoInsert(editor, session, "]");
                return {
                    text: '[]',
                    selection: [1, 1]
                };
            }
        } else if (text == ']') {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ']') {
                var matching = session.$findOpeningBracket(']', {column: cursor.column + 1, row: cursor.row});
                if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                    CstyleBehaviour.popAutoInsertedClosing();
                    return {
                        text: '',
                        selection: [1, 1]
                    };
                }
            }
        }
    });

    this.add("brackets", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && selected == '[') {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ']') {
                range.end.column++;
                return range;
            }
        }
    });

    this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
        if (text == '"' || text == "'") {
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && selected !== "'" && selected != '"' && editor.getWrapBehavioursEnabled()) {
                return {
                    text: quote + selected + quote,
                    selection: false
                };
            } else {
                var cursor = editor.getCursorPosition();
                var line = session.doc.getLine(cursor.row);
                var leftChar = line.substring(cursor.column-1, cursor.column);
                if (leftChar == '\\') {
                    return null;
                }
                var tokens = session.getTokens(selection.start.row);
                var col = 0, token;
                var quotepos = -1; // Track whether we're inside an open quote.

                for (var x = 0; x < tokens.length; x++) {
                    token = tokens[x];
                    if (token.type == "string") {
                      quotepos = -1;
                    } else if (quotepos < 0) {
                      quotepos = token.value.indexOf(quote);
                    }
                    if ((token.value.length + col) > selection.start.column) {
                        break;
                    }
                    col += tokens[x].value.length;
                }
                if (!token || (quotepos < 0 && token.type !== "comment" && (token.type !== "string" || ((selection.start.column !== token.value.length+col-1) && token.value.lastIndexOf(quote) === token.value.length-1)))) {
                    if (!CstyleBehaviour.isSaneInsertion(editor, session))
                        return;
                    return {
                        text: quote + quote,
                        selection: [1,1]
                    };
                } else if (token && token.type === "string") {
                    var rightChar = line.substring(cursor.column, cursor.column + 1);
                    if (rightChar == quote) {
                        return {
                            text: '',
                            selection: [1, 1]
                        };
                    }
                }
            }
        }
    });

    this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
        var selected = session.doc.getTextRange(range);
        if (!range.isMultiLine() && (selected == '"' || selected == "'")) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
                range.end.column++;
                return range;
            }
        }
    });

};

    
CstyleBehaviour.isSaneInsertion = function(editor, session) {
    var cursor = editor.getCursorPosition();
    var iterator = new TokenIterator(session, cursor.row, cursor.column);
    if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
        var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
        if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
    }
    iterator.stepForward();
    return iterator.getCurrentTokenRow() !== cursor.row ||
        this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
};

CstyleBehaviour.$matchTokenType = function(token, types) {
    return types.indexOf(token.type || token) > -1;
};

CstyleBehaviour.recordAutoInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isAutoInsertedClosing(cursor, line, context.autoInsertedLineEnd[0]))
        context.autoInsertedBrackets = 0;
    context.autoInsertedRow = cursor.row;
    context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
    context.autoInsertedBrackets++;
};

CstyleBehaviour.recordMaybeInsert = function(editor, session, bracket) {
    var cursor = editor.getCursorPosition();
    var line = session.doc.getLine(cursor.row);
    if (!this.isMaybeInsertedClosing(cursor, line))
        context.maybeInsertedBrackets = 0;
    context.maybeInsertedRow = cursor.row;
    context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
    context.maybeInsertedLineEnd = line.substr(cursor.column);
    context.maybeInsertedBrackets++;
};

CstyleBehaviour.isAutoInsertedClosing = function(cursor, line, bracket) {
    return context.autoInsertedBrackets > 0 &&
        cursor.row === context.autoInsertedRow &&
        bracket === context.autoInsertedLineEnd[0] &&
        line.substr(cursor.column) === context.autoInsertedLineEnd;
};

CstyleBehaviour.isMaybeInsertedClosing = function(cursor, line) {
    return context.maybeInsertedBrackets > 0 &&
        cursor.row === context.maybeInsertedRow &&
        line.substr(cursor.column) === context.maybeInsertedLineEnd &&
        line.substr(0, cursor.column) == context.maybeInsertedLineStart;
};

CstyleBehaviour.popAutoInsertedClosing = function() {
    context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
    context.autoInsertedBrackets--;
};

CstyleBehaviour.clearMaybeInsertedClosing = function() {
    if (context) {
        context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = -1;
    }
};



oop.inherits(CstyleBehaviour, Behaviour);

exports.CstyleBehaviour = CstyleBehaviour;
});

ace.define("ace/mode/folding/cstyle",["require","exports","module","ace/lib/oop","ace/range","ace/mode/folding/fold_mode"], function(acequire, exports, module) {
"use strict";

var oop = acequire("../../lib/oop");
var Range = acequire("../../range").Range;
var BaseFoldMode = acequire("./fold_mode").FoldMode;

var FoldMode = exports.FoldMode = function(commentRegex) {
    if (commentRegex) {
        this.foldingStartMarker = new RegExp(
            this.foldingStartMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.start)
        );
        this.foldingStopMarker = new RegExp(
            this.foldingStopMarker.source.replace(/\|[^|]*?$/, "|" + commentRegex.end)
        );
    }
};
oop.inherits(FoldMode, BaseFoldMode);

(function() {

    this.foldingStartMarker = /(\{|\[)[^\}\]]*$|^\s*(\/\*)/;
    this.foldingStopMarker = /^[^\[\{]*(\}|\])|^[\s\*]*(\*\/)/;

    this.getFoldWidgetRange = function(session, foldStyle, row, forceMultiline) {
        var line = session.getLine(row);
        var match = line.match(this.foldingStartMarker);
        if (match) {
            var i = match.index;

            if (match[1])
                return this.openingBracketBlock(session, match[1], row, i);
                
            var range = session.getCommentFoldRange(row, i + match[0].length, 1);
            
            if (range && !range.isMultiLine()) {
                if (forceMultiline) {
                    range = this.getSectionRange(session, row);
                } else if (foldStyle != "all")
                    range = null;
            }
            
            return range;
        }

        if (foldStyle === "markbegin")
            return;

        var match = line.match(this.foldingStopMarker);
        if (match) {
            var i = match.index + match[0].length;

            if (match[1])
                return this.closingBracketBlock(session, match[1], row, i);

            return session.getCommentFoldRange(row, i, -1);
        }
    };
    
    this.getSectionRange = function(session, row) {
        var line = session.getLine(row);
        var startIndent = line.search(/\S/);
        var startRow = row;
        var startColumn = line.length;
        row = row + 1;
        var endRow = row;
        var maxRow = session.getLength();
        while (++row < maxRow) {
            line = session.getLine(row);
            var indent = line.search(/\S/);
            if (indent === -1)
                continue;
            if  (startIndent > indent)
                break;
            var subRange = this.getFoldWidgetRange(session, "all", row);
            
            if (subRange) {
                if (subRange.start.row <= startRow) {
                    break;
                } else if (subRange.isMultiLine()) {
                    row = subRange.end.row;
                } else if (startIndent == indent) {
                    break;
                }
            }
            endRow = row;
        }
        
        return new Range(startRow, startColumn, endRow, session.getLine(endRow).length);
    };

}).call(FoldMode.prototype);

});

ace.define("ace/mode/javascript",["require","exports","module","ace/lib/oop","ace/mode/text","ace/mode/javascript_highlight_rules","ace/mode/matching_brace_outdent","ace/range","ace/worker/worker_client","ace/mode/behaviour/cstyle","ace/mode/folding/cstyle"], function(acequire, exports, module) {
"use strict";

var oop = acequire("../lib/oop");
var TextMode = acequire("./text").Mode;
var JavaScriptHighlightRules = acequire("./javascript_highlight_rules").JavaScriptHighlightRules;
var MatchingBraceOutdent = acequire("./matching_brace_outdent").MatchingBraceOutdent;
var Range = acequire("../range").Range;
var WorkerClient = acequire("../worker/worker_client").WorkerClient;
var CstyleBehaviour = acequire("./behaviour/cstyle").CstyleBehaviour;
var CStyleFoldMode = acequire("./folding/cstyle").FoldMode;

var Mode = function() {
    this.HighlightRules = JavaScriptHighlightRules;
    
    this.$outdent = new MatchingBraceOutdent();
    this.$behaviour = new CstyleBehaviour();
    this.foldingRules = new CStyleFoldMode();
};
oop.inherits(Mode, TextMode);

(function() {

    this.lineCommentStart = "//";
    this.blockComment = {start: "/*", end: "*/"};

    this.getNextLineIndent = function(state, line, tab) {
        var indent = this.$getIndent(line);

        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);
        var tokens = tokenizedLine.tokens;
        var endState = tokenizedLine.state;

        if (tokens.length && tokens[tokens.length-1].type == "comment") {
            return indent;
        }

        if (state == "start" || state == "no_regex") {
            var match = line.match(/^.*(?:\bcase\b.*\:|[\{\(\[])\s*$/);
            if (match) {
                indent += tab;
            }
        } else if (state == "doc-start") {
            if (endState == "start" || endState == "no_regex") {
                return "";
            }
            var match = line.match(/^\s*(\/?)\*/);
            if (match) {
                if (match[1]) {
                    indent += " ";
                }
                indent += "* ";
            }
        }

        return indent;
    };

    this.checkOutdent = function(state, line, input) {
        return this.$outdent.checkOutdent(line, input);
    };

    this.autoOutdent = function(state, doc, row) {
        this.$outdent.autoOutdent(doc, row);
    };

    this.createWorker = function(session) {
        var worker = new WorkerClient(["ace"], require("../worker/javascript"), "JavaScriptWorker");
        worker.attachToDocument(session.getDocument());

        worker.on("jslint", function(results) {
            session.setAnnotations(results.data);
        });

        worker.on("terminate", function() {
            session.clearAnnotations();
        });

        return worker;
    };

    this.$id = "ace/mode/javascript";
}).call(Mode.prototype);

exports.Mode = Mode;
});

},{"../worker/javascript":20}],20:[function(require,module,exports){
module.exports.id = 'ace/mode/javascript_worker';
module.exports.src = "\"no use strict\";(function(window){if(void 0===window.window||!window.document){window.console=function(){var msgs=Array.prototype.slice.call(arguments,0);postMessage({type:\"log\",data:msgs})},window.console.error=window.console.warn=window.console.log=window.console.trace=window.console,window.window=window,window.ace=window,window.onerror=function(message,file,line,col,err){postMessage({type:\"error\",data:{message:message,file:file,line:line,col:col,stack:err.stack}})},window.normalizeModule=function(parentId,moduleName){if(-1!==moduleName.indexOf(\"!\")){var chunks=moduleName.split(\"!\");return window.normalizeModule(parentId,chunks[0])+\"!\"+window.normalizeModule(parentId,chunks[1])}if(\".\"==moduleName.charAt(0)){var base=parentId.split(\"/\").slice(0,-1).join(\"/\");for(moduleName=(base?base+\"/\":\"\")+moduleName;-1!==moduleName.indexOf(\".\")&&previous!=moduleName;){var previous=moduleName;moduleName=moduleName.replace(/^\\.\\//,\"\").replace(/\\/\\.\\//,\"/\").replace(/[^\\/]+\\/\\.\\.\\//,\"\")}}return moduleName},window.acequire=function(parentId,id){if(id||(id=parentId,parentId=null),!id.charAt)throw Error(\"worker.js acequire() accepts only (parentId, id) as arguments\");id=window.normalizeModule(parentId,id);var module=window.acequire.modules[id];if(module)return module.initialized||(module.initialized=!0,module.exports=module.factory().exports),module.exports;var chunks=id.split(\"/\");if(!window.acequire.tlns)return console.log(\"unable to load \"+id);chunks[0]=window.acequire.tlns[chunks[0]]||chunks[0];var path=chunks.join(\"/\")+\".js\";return window.acequire.id=id,importScripts(path),window.acequire(parentId,id)},window.acequire.modules={},window.acequire.tlns={},window.define=function(id,deps,factory){if(2==arguments.length?(factory=deps,\"string\"!=typeof id&&(deps=id,id=window.acequire.id)):1==arguments.length&&(factory=id,deps=[],id=window.acequire.id),\"function\"!=typeof factory)return window.acequire.modules[id]={exports:factory,initialized:!0},void 0;deps.length||(deps=[\"require\",\"exports\",\"module\"]);var req=function(childId){return window.acequire(id,childId)};window.acequire.modules[id]={exports:{},factory:function(){var module=this,returnExports=factory.apply(this,deps.map(function(dep){switch(dep){case\"require\":return req;case\"exports\":return module.exports;case\"module\":return module;default:return req(dep)}}));return returnExports&&(module.exports=returnExports),module}}},window.define.amd={},window.initBaseUrls=function initBaseUrls(topLevelNamespaces){acequire.tlns=topLevelNamespaces},window.initSender=function initSender(){var EventEmitter=window.acequire(\"ace/lib/event_emitter\").EventEmitter,oop=window.acequire(\"ace/lib/oop\"),Sender=function(){};return function(){oop.implement(this,EventEmitter),this.callback=function(data,callbackId){postMessage({type:\"call\",id:callbackId,data:data})},this.emit=function(name,data){postMessage({type:\"event\",name:name,data:data})}}.call(Sender.prototype),new Sender};var main=window.main=null,sender=window.sender=null;window.onmessage=function(e){var msg=e.data;if(msg.command){if(!main[msg.command])throw Error(\"Unknown command:\"+msg.command);main[msg.command].apply(main,msg.args)}else if(msg.init){initBaseUrls(msg.tlns),acequire(\"ace/lib/es5-shim\"),sender=window.sender=initSender();var clazz=acequire(msg.module)[msg.classname];main=window.main=new clazz(sender)}else msg.event&&sender&&sender._signal(msg.event,msg.data)}}})(this),ace.define(\"ace/lib/oop\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.inherits=function(ctor,superCtor){ctor.super_=superCtor,ctor.prototype=Object.create(superCtor.prototype,{constructor:{value:ctor,enumerable:!1,writable:!0,configurable:!0}})},exports.mixin=function(obj,mixin){for(var key in mixin)obj[key]=mixin[key];return obj},exports.implement=function(proto,mixin){exports.mixin(proto,mixin)}}),ace.define(\"ace/lib/event_emitter\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var EventEmitter={},stopPropagation=function(){this.propagationStopped=!0},preventDefault=function(){this.defaultPrevented=!0};EventEmitter._emit=EventEmitter._dispatchEvent=function(eventName,e){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var listeners=this._eventRegistry[eventName]||[],defaultHandler=this._defaultHandlers[eventName];if(listeners.length||defaultHandler){\"object\"==typeof e&&e||(e={}),e.type||(e.type=eventName),e.stopPropagation||(e.stopPropagation=stopPropagation),e.preventDefault||(e.preventDefault=preventDefault),listeners=listeners.slice();for(var i=0;listeners.length>i&&(listeners[i](e,this),!e.propagationStopped);i++);return defaultHandler&&!e.defaultPrevented?defaultHandler(e,this):void 0}},EventEmitter._signal=function(eventName,e){var listeners=(this._eventRegistry||{})[eventName];if(listeners){listeners=listeners.slice();for(var i=0;listeners.length>i;i++)listeners[i](e,this)}},EventEmitter.once=function(eventName,callback){var _self=this;callback&&this.addEventListener(eventName,function newCallback(){_self.removeEventListener(eventName,newCallback),callback.apply(null,arguments)})},EventEmitter.setDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers||(handlers=this._defaultHandlers={_disabled_:{}}),handlers[eventName]){var old=handlers[eventName],disabled=handlers._disabled_[eventName];disabled||(handlers._disabled_[eventName]=disabled=[]),disabled.push(old);var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}handlers[eventName]=callback},EventEmitter.removeDefaultHandler=function(eventName,callback){var handlers=this._defaultHandlers;if(handlers){var disabled=handlers._disabled_[eventName];if(handlers[eventName]==callback)handlers[eventName],disabled&&this.setDefaultHandler(eventName,disabled.pop());else if(disabled){var i=disabled.indexOf(callback);-1!=i&&disabled.splice(i,1)}}},EventEmitter.on=EventEmitter.addEventListener=function(eventName,callback,capturing){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];return listeners||(listeners=this._eventRegistry[eventName]=[]),-1==listeners.indexOf(callback)&&listeners[capturing?\"unshift\":\"push\"](callback),callback},EventEmitter.off=EventEmitter.removeListener=EventEmitter.removeEventListener=function(eventName,callback){this._eventRegistry=this._eventRegistry||{};var listeners=this._eventRegistry[eventName];if(listeners){var index=listeners.indexOf(callback);-1!==index&&listeners.splice(index,1)}},EventEmitter.removeAllListeners=function(eventName){this._eventRegistry&&(this._eventRegistry[eventName]=[])},exports.EventEmitter=EventEmitter}),ace.define(\"ace/range\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";var comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},Range=function(startRow,startColumn,endRow,endColumn){this.start={row:startRow,column:startColumn},this.end={row:endRow,column:endColumn}};(function(){this.isEqual=function(range){return this.start.row===range.start.row&&this.end.row===range.end.row&&this.start.column===range.start.column&&this.end.column===range.end.column},this.toString=function(){return\"Range: [\"+this.start.row+\"/\"+this.start.column+\"] -> [\"+this.end.row+\"/\"+this.end.column+\"]\"},this.contains=function(row,column){return 0==this.compare(row,column)},this.compareRange=function(range){var cmp,end=range.end,start=range.start;return cmp=this.compare(end.row,end.column),1==cmp?(cmp=this.compare(start.row,start.column),1==cmp?2:0==cmp?1:0):-1==cmp?-2:(cmp=this.compare(start.row,start.column),-1==cmp?-1:1==cmp?42:0)},this.comparePoint=function(p){return this.compare(p.row,p.column)},this.containsRange=function(range){return 0==this.comparePoint(range.start)&&0==this.comparePoint(range.end)},this.intersects=function(range){var cmp=this.compareRange(range);return-1==cmp||0==cmp||1==cmp},this.isEnd=function(row,column){return this.end.row==row&&this.end.column==column},this.isStart=function(row,column){return this.start.row==row&&this.start.column==column},this.setStart=function(row,column){\"object\"==typeof row?(this.start.column=row.column,this.start.row=row.row):(this.start.row=row,this.start.column=column)},this.setEnd=function(row,column){\"object\"==typeof row?(this.end.column=row.column,this.end.row=row.row):(this.end.row=row,this.end.column=column)},this.inside=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)||this.isStart(row,column)?!1:!0:!1},this.insideStart=function(row,column){return 0==this.compare(row,column)?this.isEnd(row,column)?!1:!0:!1},this.insideEnd=function(row,column){return 0==this.compare(row,column)?this.isStart(row,column)?!1:!0:!1},this.compare=function(row,column){return this.isMultiLine()||row!==this.start.row?this.start.row>row?-1:row>this.end.row?1:this.start.row===row?column>=this.start.column?0:-1:this.end.row===row?this.end.column>=column?0:1:0:this.start.column>column?-1:column>this.end.column?1:0},this.compareStart=function(row,column){return this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.compareEnd=function(row,column){return this.end.row==row&&this.end.column==column?1:this.compare(row,column)},this.compareInside=function(row,column){return this.end.row==row&&this.end.column==column?1:this.start.row==row&&this.start.column==column?-1:this.compare(row,column)},this.clipRows=function(firstRow,lastRow){if(this.end.row>lastRow)var end={row:lastRow+1,column:0};else if(firstRow>this.end.row)var end={row:firstRow,column:0};if(this.start.row>lastRow)var start={row:lastRow+1,column:0};else if(firstRow>this.start.row)var start={row:firstRow,column:0};return Range.fromPoints(start||this.start,end||this.end)},this.extend=function(row,column){var cmp=this.compare(row,column);if(0==cmp)return this;if(-1==cmp)var start={row:row,column:column};else var end={row:row,column:column};return Range.fromPoints(start||this.start,end||this.end)},this.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},this.isMultiLine=function(){return this.start.row!==this.end.row},this.clone=function(){return Range.fromPoints(this.start,this.end)},this.collapseRows=function(){return 0==this.end.column?new Range(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new Range(this.start.row,0,this.end.row,0)},this.toScreenRange=function(session){var screenPosStart=session.documentToScreenPosition(this.start),screenPosEnd=session.documentToScreenPosition(this.end);return new Range(screenPosStart.row,screenPosStart.column,screenPosEnd.row,screenPosEnd.column)},this.moveBy=function(row,column){this.start.row+=row,this.start.column+=column,this.end.row+=row,this.end.column+=column}}).call(Range.prototype),Range.fromPoints=function(start,end){return new Range(start.row,start.column,end.row,end.column)},Range.comparePoints=comparePoints,Range.comparePoints=function(p1,p2){return p1.row-p2.row||p1.column-p2.column},exports.Range=Range}),ace.define(\"ace/anchor\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Anchor=exports.Anchor=function(doc,row,column){this.$onChange=this.onChange.bind(this),this.attach(doc),column===void 0?this.setPosition(row.row,row.column):this.setPosition(row,column)};(function(){oop.implement(this,EventEmitter),this.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},this.getDocument=function(){return this.document},this.$insertRight=!1,this.onChange=function(e){var delta=e.data,range=delta.range;if(!(range.start.row==range.end.row&&range.start.row!=this.row||range.start.row>this.row||range.start.row==this.row&&range.start.column>this.column)){var row=this.row,column=this.column,start=range.start,end=range.end;\"insertText\"===delta.action?start.row===row&&column>=start.column?start.column===column&&this.$insertRight||(start.row===end.row?column+=end.column-start.column:(column-=start.column,row+=end.row-start.row)):start.row!==end.row&&row>start.row&&(row+=end.row-start.row):\"insertLines\"===delta.action?start.row===row&&0===column&&this.$insertRight||row>=start.row&&(row+=end.row-start.row):\"removeText\"===delta.action?start.row===row&&column>start.column?column=end.column>=column?start.column:Math.max(0,column-(end.column-start.column)):start.row!==end.row&&row>start.row?(end.row===row&&(column=Math.max(0,column-end.column)+start.column),row-=end.row-start.row):end.row===row&&(row-=end.row-start.row,column=Math.max(0,column-end.column)+start.column):\"removeLines\"==delta.action&&row>=start.row&&(row>=end.row?row-=end.row-start.row:(row=start.row,column=0)),this.setPosition(row,column,!0)}},this.setPosition=function(row,column,noClip){var pos;if(pos=noClip?{row:row,column:column}:this.$clipPositionToDocument(row,column),this.row!=pos.row||this.column!=pos.column){var old={row:this.row,column:this.column};this.row=pos.row,this.column=pos.column,this._signal(\"change\",{old:old,value:pos})}},this.detach=function(){this.document.removeEventListener(\"change\",this.$onChange)},this.attach=function(doc){this.document=doc||this.document,this.document.on(\"change\",this.$onChange)},this.$clipPositionToDocument=function(row,column){var pos={};return row>=this.document.getLength()?(pos.row=Math.max(0,this.document.getLength()-1),pos.column=this.document.getLine(pos.row).length):0>row?(pos.row=0,pos.column=0):(pos.row=row,pos.column=Math.min(this.document.getLine(pos.row).length,Math.max(0,column))),0>column&&(pos.column=0),pos}}).call(Anchor.prototype)}),ace.define(\"ace/document\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\",\"ace/range\",\"ace/anchor\"],function(acequire,exports){\"use strict\";var oop=acequire(\"./lib/oop\"),EventEmitter=acequire(\"./lib/event_emitter\").EventEmitter,Range=acequire(\"./range\").Range,Anchor=acequire(\"./anchor\").Anchor,Document=function(text){this.$lines=[],0===text.length?this.$lines=[\"\"]:Array.isArray(text)?this._insertLines(0,text):this.insert({row:0,column:0},text)};(function(){oop.implement(this,EventEmitter),this.setValue=function(text){var len=this.getLength();this.remove(new Range(0,0,len,this.getLine(len-1).length)),this.insert({row:0,column:0},text)},this.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},this.createAnchor=function(row,column){return new Anchor(this,row,column)},this.$split=0===\"aaa\".split(/a/).length?function(text){return text.replace(/\\r\\n|\\r/g,\"\\n\").split(\"\\n\")}:function(text){return text.split(/\\r\\n|\\r|\\n/)},this.$detectNewLine=function(text){var match=text.match(/^.*?(\\r\\n|\\r|\\n)/m);this.$autoNewLine=match?match[1]:\"\\n\",this._signal(\"changeNewLineMode\")},this.getNewLineCharacter=function(){switch(this.$newLineMode){case\"windows\":return\"\\r\\n\";case\"unix\":return\"\\n\";default:return this.$autoNewLine||\"\\n\"}},this.$autoNewLine=\"\",this.$newLineMode=\"auto\",this.setNewLineMode=function(newLineMode){this.$newLineMode!==newLineMode&&(this.$newLineMode=newLineMode,this._signal(\"changeNewLineMode\"))},this.getNewLineMode=function(){return this.$newLineMode},this.isNewLine=function(text){return\"\\r\\n\"==text||\"\\r\"==text||\"\\n\"==text},this.getLine=function(row){return this.$lines[row]||\"\"},this.getLines=function(firstRow,lastRow){return this.$lines.slice(firstRow,lastRow+1)},this.getAllLines=function(){return this.getLines(0,this.getLength())},this.getLength=function(){return this.$lines.length},this.getTextRange=function(range){if(range.start.row==range.end.row)return this.getLine(range.start.row).substring(range.start.column,range.end.column);var lines=this.getLines(range.start.row,range.end.row);lines[0]=(lines[0]||\"\").substring(range.start.column);var l=lines.length-1;return range.end.row-range.start.row==l&&(lines[l]=lines[l].substring(0,range.end.column)),lines.join(this.getNewLineCharacter())},this.$clipPosition=function(position){var length=this.getLength();return position.row>=length?(position.row=Math.max(0,length-1),position.column=this.getLine(length-1).length):0>position.row&&(position.row=0),position},this.insert=function(position,text){if(!text||0===text.length)return position;position=this.$clipPosition(position),1>=this.getLength()&&this.$detectNewLine(text);var lines=this.$split(text),firstLine=lines.splice(0,1)[0],lastLine=0==lines.length?null:lines.splice(lines.length-1,1)[0];return position=this.insertInLine(position,firstLine),null!==lastLine&&(position=this.insertNewLine(position),position=this._insertLines(position.row,lines),position=this.insertInLine(position,lastLine||\"\")),position},this.insertLines=function(row,lines){return row>=this.getLength()?this.insert({row:row,column:0},\"\\n\"+lines.join(\"\\n\")):this._insertLines(Math.max(row,0),lines)},this._insertLines=function(row,lines){if(0==lines.length)return{row:row,column:0};for(;lines.length>61440;){var end=this._insertLines(row,lines.slice(0,61440));lines=lines.slice(61440),row=end.row}var args=[row,0];args.push.apply(args,lines),this.$lines.splice.apply(this.$lines,args);var range=new Range(row,0,row+lines.length,0),delta={action:\"insertLines\",range:range,lines:lines};return this._signal(\"change\",{data:delta}),range.end},this.insertNewLine=function(position){position=this.$clipPosition(position);var line=this.$lines[position.row]||\"\";this.$lines[position.row]=line.substring(0,position.column),this.$lines.splice(position.row+1,0,line.substring(position.column,line.length));var end={row:position.row+1,column:0},delta={action:\"insertText\",range:Range.fromPoints(position,end),text:this.getNewLineCharacter()};return this._signal(\"change\",{data:delta}),end},this.insertInLine=function(position,text){if(0==text.length)return position;var line=this.$lines[position.row]||\"\";this.$lines[position.row]=line.substring(0,position.column)+text+line.substring(position.column);var end={row:position.row,column:position.column+text.length},delta={action:\"insertText\",range:Range.fromPoints(position,end),text:text};return this._signal(\"change\",{data:delta}),end},this.remove=function(range){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),range.start=this.$clipPosition(range.start),range.end=this.$clipPosition(range.end),range.isEmpty())return range.start;var firstRow=range.start.row,lastRow=range.end.row;if(range.isMultiLine()){var firstFullRow=0==range.start.column?firstRow:firstRow+1,lastFullRow=lastRow-1;range.end.column>0&&this.removeInLine(lastRow,0,range.end.column),lastFullRow>=firstFullRow&&this._removeLines(firstFullRow,lastFullRow),firstFullRow!=firstRow&&(this.removeInLine(firstRow,range.start.column,this.getLine(firstRow).length),this.removeNewLine(range.start.row))}else this.removeInLine(firstRow,range.start.column,range.end.column);return range.start},this.removeInLine=function(row,startColumn,endColumn){if(startColumn!=endColumn){var range=new Range(row,startColumn,row,endColumn),line=this.getLine(row),removed=line.substring(startColumn,endColumn),newLine=line.substring(0,startColumn)+line.substring(endColumn,line.length);this.$lines.splice(row,1,newLine);var delta={action:\"removeText\",range:range,text:removed};return this._signal(\"change\",{data:delta}),range.start}},this.removeLines=function(firstRow,lastRow){return 0>firstRow||lastRow>=this.getLength()?this.remove(new Range(firstRow,0,lastRow+1,0)):this._removeLines(firstRow,lastRow)},this._removeLines=function(firstRow,lastRow){var range=new Range(firstRow,0,lastRow+1,0),removed=this.$lines.splice(firstRow,lastRow-firstRow+1),delta={action:\"removeLines\",range:range,nl:this.getNewLineCharacter(),lines:removed};return this._signal(\"change\",{data:delta}),removed},this.removeNewLine=function(row){var firstLine=this.getLine(row),secondLine=this.getLine(row+1),range=new Range(row,firstLine.length,row+1,0),line=firstLine+secondLine;this.$lines.splice(row,2,line);var delta={action:\"removeText\",range:range,text:this.getNewLineCharacter()};this._signal(\"change\",{data:delta})},this.replace=function(range,text){if(range instanceof Range||(range=Range.fromPoints(range.start,range.end)),0==text.length&&range.isEmpty())return range.start;if(text==this.getTextRange(range))return range.end;if(this.remove(range),text)var end=this.insert(range.start,text);else end=range.start;return end},this.applyDeltas=function(deltas){for(var i=0;deltas.length>i;i++){var delta=deltas[i],range=Range.fromPoints(delta.range.start,delta.range.end);\"insertLines\"==delta.action?this.insertLines(range.start.row,delta.lines):\"insertText\"==delta.action?this.insert(range.start,delta.text):\"removeLines\"==delta.action?this._removeLines(range.start.row,range.end.row-1):\"removeText\"==delta.action&&this.remove(range)}},this.revertDeltas=function(deltas){for(var i=deltas.length-1;i>=0;i--){var delta=deltas[i],range=Range.fromPoints(delta.range.start,delta.range.end);\"insertLines\"==delta.action?this._removeLines(range.start.row,range.end.row-1):\"insertText\"==delta.action?this.remove(range):\"removeLines\"==delta.action?this._insertLines(range.start.row,delta.lines):\"removeText\"==delta.action&&this.insert(range.start,delta.text)}},this.indexToPosition=function(index,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,i=startRow||0,l=lines.length;l>i;i++)if(index-=lines[i].length+newlineLength,0>index)return{row:i,column:index+lines[i].length+newlineLength};return{row:l-1,column:lines[l-1].length}},this.positionToIndex=function(pos,startRow){for(var lines=this.$lines||this.getAllLines(),newlineLength=this.getNewLineCharacter().length,index=0,row=Math.min(pos.row,lines.length),i=startRow||0;row>i;++i)index+=lines[i].length+newlineLength;return index+pos.column}}).call(Document.prototype),exports.Document=Document}),ace.define(\"ace/lib/lang\",[\"require\",\"exports\",\"module\"],function(acequire,exports){\"use strict\";exports.last=function(a){return a[a.length-1]},exports.stringReverse=function(string){return string.split(\"\").reverse().join(\"\")},exports.stringRepeat=function(string,count){for(var result=\"\";count>0;)1&count&&(result+=string),(count>>=1)&&(string+=string);return result};var trimBeginRegexp=/^\\s\\s*/,trimEndRegexp=/\\s\\s*$/;exports.stringTrimLeft=function(string){return string.replace(trimBeginRegexp,\"\")},exports.stringTrimRight=function(string){return string.replace(trimEndRegexp,\"\")},exports.copyObject=function(obj){var copy={};for(var key in obj)copy[key]=obj[key];return copy},exports.copyArray=function(array){for(var copy=[],i=0,l=array.length;l>i;i++)copy[i]=array[i]&&\"object\"==typeof array[i]?this.copyObject(array[i]):array[i];return copy},exports.deepCopy=function(obj){if(\"object\"!=typeof obj||!obj)return obj;var cons=obj.constructor;if(cons===RegExp)return obj;var copy=cons();for(var key in obj)copy[key]=\"object\"==typeof obj[key]?exports.deepCopy(obj[key]):obj[key];return copy},exports.arrayToMap=function(arr){for(var map={},i=0;arr.length>i;i++)map[arr[i]]=1;return map},exports.createMap=function(props){var map=Object.create(null);for(var i in props)map[i]=props[i];return map},exports.arrayRemove=function(array,value){for(var i=0;array.length>=i;i++)value===array[i]&&array.splice(i,1)},exports.escapeRegExp=function(str){return str.replace(/([.*+?^${}()|[\\]\\/\\\\])/g,\"\\\\$1\")},exports.escapeHTML=function(str){return str.replace(/&/g,\"&#38;\").replace(/\"/g,\"&#34;\").replace(/'/g,\"&#39;\").replace(/</g,\"&#60;\")},exports.getMatchOffsets=function(string,regExp){var matches=[];return string.replace(regExp,function(str){matches.push({offset:arguments[arguments.length-2],length:str.length})}),matches},exports.deferredCall=function(fcn){var timer=null,callback=function(){timer=null,fcn()},deferred=function(timeout){return deferred.cancel(),timer=setTimeout(callback,timeout||0),deferred};return deferred.schedule=deferred,deferred.call=function(){return this.cancel(),fcn(),deferred},deferred.cancel=function(){return clearTimeout(timer),timer=null,deferred},deferred.isPending=function(){return timer},deferred},exports.delayedCall=function(fcn,defaultTimeout){var timer=null,callback=function(){timer=null,fcn()},_self=function(timeout){null==timer&&(timer=setTimeout(callback,timeout||defaultTimeout))};return _self.delay=function(timeout){timer&&clearTimeout(timer),timer=setTimeout(callback,timeout||defaultTimeout)},_self.schedule=_self,_self.call=function(){this.cancel(),fcn()},_self.cancel=function(){timer&&clearTimeout(timer),timer=null},_self.isPending=function(){return timer},_self}}),ace.define(\"ace/worker/mirror\",[\"require\",\"exports\",\"module\",\"ace/document\",\"ace/lib/lang\"],function(acequire,exports){\"use strict\";var Document=acequire(\"../document\").Document,lang=acequire(\"../lib/lang\"),Mirror=exports.Mirror=function(sender){this.sender=sender;var doc=this.doc=new Document(\"\"),deferredUpdate=this.deferredUpdate=lang.delayedCall(this.onUpdate.bind(this)),_self=this;sender.on(\"change\",function(e){return doc.applyDeltas(e.data),_self.$timeout?deferredUpdate.schedule(_self.$timeout):(_self.onUpdate(),void 0)})};(function(){this.$timeout=500,this.setTimeout=function(timeout){this.$timeout=timeout},this.setValue=function(value){this.doc.setValue(value),this.deferredUpdate.schedule(this.$timeout)},this.getValue=function(callbackId){this.sender.callback(this.doc.getValue(),callbackId)},this.onUpdate=function(){},this.isPending=function(){return this.deferredUpdate.isPending()}}).call(Mirror.prototype)}),ace.define(\"ace/mode/javascript/jshint\",[\"require\",\"exports\",\"module\"],function(acequire,exports,module){module.exports=function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=\"function\"==typeof acequire&&acequire;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw Error(\"Cannot find module '\"+o+\"'\")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}for(var i=\"function\"==typeof acequire&&acequire,o=0;r.length>o;o++)s(r[o]);return s}({1:[function(_dereq_,module){for(var identifierStartTable=[],i=0;128>i;i++)identifierStartTable[i]=36===i||i>=65&&90>=i||95===i||i>=97&&122>=i;for(var identifierPartTable=[],i=0;128>i;i++)identifierPartTable[i]=identifierStartTable[i]||i>=48&&57>=i;module.exports={asciiIdentifierStartTable:identifierStartTable,asciiIdentifierPartTable:identifierPartTable}},{}],2:[function(_dereq_,module,exports){(function(){var root=this,previousUnderscore=root._,breaker={},ArrayProto=Array.prototype,ObjProto=Object.prototype,FuncProto=Function.prototype,push=ArrayProto.push,slice=ArrayProto.slice,concat=ArrayProto.concat,toString=ObjProto.toString,hasOwnProperty=ObjProto.hasOwnProperty,nativeForEach=ArrayProto.forEach,nativeMap=ArrayProto.map,nativeReduce=ArrayProto.reduce,nativeReduceRight=ArrayProto.reduceRight,nativeFilter=ArrayProto.filter,nativeEvery=ArrayProto.every,nativeSome=ArrayProto.some,nativeIndexOf=ArrayProto.indexOf,nativeLastIndexOf=ArrayProto.lastIndexOf,nativeIsArray=Array.isArray,nativeKeys=Object.keys,nativeBind=FuncProto.bind,_=function(obj){return obj instanceof _?obj:this instanceof _?(this._wrapped=obj,void 0):new _(obj)};exports!==void 0?(module!==void 0&&module.exports&&(exports=module.exports=_),exports._=_):root._=_,_.VERSION=\"1.6.0\";var each=_.each=_.forEach=function(obj,iterator,context){if(null==obj)return obj;if(nativeForEach&&obj.forEach===nativeForEach)obj.forEach(iterator,context);else if(obj.length===+obj.length){for(var i=0,length=obj.length;length>i;i++)if(iterator.call(context,obj[i],i,obj)===breaker)return}else for(var keys=_.keys(obj),i=0,length=keys.length;length>i;i++)if(iterator.call(context,obj[keys[i]],keys[i],obj)===breaker)return;return obj};_.map=_.collect=function(obj,iterator,context){var results=[];return null==obj?results:nativeMap&&obj.map===nativeMap?obj.map(iterator,context):(each(obj,function(value,index,list){results.push(iterator.call(context,value,index,list))}),results)};var reduceError=\"Reduce of empty array with no initial value\";_.reduce=_.foldl=_.inject=function(obj,iterator,memo,context){var initial=arguments.length>2;if(null==obj&&(obj=[]),nativeReduce&&obj.reduce===nativeReduce)return context&&(iterator=_.bind(iterator,context)),initial?obj.reduce(iterator,memo):obj.reduce(iterator);if(each(obj,function(value,index,list){initial?memo=iterator.call(context,memo,value,index,list):(memo=value,initial=!0)}),!initial)throw new TypeError(reduceError);return memo},_.reduceRight=_.foldr=function(obj,iterator,memo,context){var initial=arguments.length>2;if(null==obj&&(obj=[]),nativeReduceRight&&obj.reduceRight===nativeReduceRight)return context&&(iterator=_.bind(iterator,context)),initial?obj.reduceRight(iterator,memo):obj.reduceRight(iterator);var length=obj.length;if(length!==+length){var keys=_.keys(obj);length=keys.length}if(each(obj,function(value,index,list){index=keys?keys[--length]:--length,initial?memo=iterator.call(context,memo,obj[index],index,list):(memo=obj[index],initial=!0)}),!initial)throw new TypeError(reduceError);return memo},_.find=_.detect=function(obj,predicate,context){var result;return any(obj,function(value,index,list){return predicate.call(context,value,index,list)?(result=value,!0):void 0}),result},_.filter=_.select=function(obj,predicate,context){var results=[];return null==obj?results:nativeFilter&&obj.filter===nativeFilter?obj.filter(predicate,context):(each(obj,function(value,index,list){predicate.call(context,value,index,list)&&results.push(value)}),results)},_.reject=function(obj,predicate,context){return _.filter(obj,function(value,index,list){return!predicate.call(context,value,index,list)},context)},_.every=_.all=function(obj,predicate,context){predicate||(predicate=_.identity);var result=!0;return null==obj?result:nativeEvery&&obj.every===nativeEvery?obj.every(predicate,context):(each(obj,function(value,index,list){return(result=result&&predicate.call(context,value,index,list))?void 0:breaker}),!!result)};var any=_.some=_.any=function(obj,predicate,context){predicate||(predicate=_.identity);var result=!1;return null==obj?result:nativeSome&&obj.some===nativeSome?obj.some(predicate,context):(each(obj,function(value,index,list){return result||(result=predicate.call(context,value,index,list))?breaker:void 0}),!!result)};_.contains=_.include=function(obj,target){return null==obj?!1:nativeIndexOf&&obj.indexOf===nativeIndexOf?-1!=obj.indexOf(target):any(obj,function(value){return value===target})},_.invoke=function(obj,method){var args=slice.call(arguments,2),isFunc=_.isFunction(method);return _.map(obj,function(value){return(isFunc?method:value[method]).apply(value,args)})},_.pluck=function(obj,key){return _.map(obj,_.property(key))},_.where=function(obj,attrs){return _.filter(obj,_.matches(attrs))},_.findWhere=function(obj,attrs){return _.find(obj,_.matches(attrs))},_.max=function(obj,iterator,context){if(!iterator&&_.isArray(obj)&&obj[0]===+obj[0]&&65535>obj.length)return Math.max.apply(Math,obj);var result=-1/0,lastComputed=-1/0;return each(obj,function(value,index,list){var computed=iterator?iterator.call(context,value,index,list):value;computed>lastComputed&&(result=value,lastComputed=computed)}),result},_.min=function(obj,iterator,context){if(!iterator&&_.isArray(obj)&&obj[0]===+obj[0]&&65535>obj.length)return Math.min.apply(Math,obj);var result=1/0,lastComputed=1/0;return each(obj,function(value,index,list){var computed=iterator?iterator.call(context,value,index,list):value;lastComputed>computed&&(result=value,lastComputed=computed)}),result},_.shuffle=function(obj){var rand,index=0,shuffled=[];return each(obj,function(value){rand=_.random(index++),shuffled[index-1]=shuffled[rand],shuffled[rand]=value}),shuffled},_.sample=function(obj,n,guard){return null==n||guard?(obj.length!==+obj.length&&(obj=_.values(obj)),obj[_.random(obj.length-1)]):_.shuffle(obj).slice(0,Math.max(0,n))};var lookupIterator=function(value){return null==value?_.identity:_.isFunction(value)?value:_.property(value)};_.sortBy=function(obj,iterator,context){return iterator=lookupIterator(iterator),_.pluck(_.map(obj,function(value,index,list){return{value:value,index:index,criteria:iterator.call(context,value,index,list)}\n}).sort(function(left,right){var a=left.criteria,b=right.criteria;if(a!==b){if(a>b||void 0===a)return 1;if(b>a||void 0===b)return-1}return left.index-right.index}),\"value\")};var group=function(behavior){return function(obj,iterator,context){var result={};return iterator=lookupIterator(iterator),each(obj,function(value,index){var key=iterator.call(context,value,index,obj);behavior(result,key,value)}),result}};_.groupBy=group(function(result,key,value){_.has(result,key)?result[key].push(value):result[key]=[value]}),_.indexBy=group(function(result,key,value){result[key]=value}),_.countBy=group(function(result,key){_.has(result,key)?result[key]++:result[key]=1}),_.sortedIndex=function(array,obj,iterator,context){iterator=lookupIterator(iterator);for(var value=iterator.call(context,obj),low=0,high=array.length;high>low;){var mid=low+high>>>1;value>iterator.call(context,array[mid])?low=mid+1:high=mid}return low},_.toArray=function(obj){return obj?_.isArray(obj)?slice.call(obj):obj.length===+obj.length?_.map(obj,_.identity):_.values(obj):[]},_.size=function(obj){return null==obj?0:obj.length===+obj.length?obj.length:_.keys(obj).length},_.first=_.head=_.take=function(array,n,guard){return null==array?void 0:null==n||guard?array[0]:0>n?[]:slice.call(array,0,n)},_.initial=function(array,n,guard){return slice.call(array,0,array.length-(null==n||guard?1:n))},_.last=function(array,n,guard){return null==array?void 0:null==n||guard?array[array.length-1]:slice.call(array,Math.max(array.length-n,0))},_.rest=_.tail=_.drop=function(array,n,guard){return slice.call(array,null==n||guard?1:n)},_.compact=function(array){return _.filter(array,_.identity)};var flatten=function(input,shallow,output){return shallow&&_.every(input,_.isArray)?concat.apply(output,input):(each(input,function(value){_.isArray(value)||_.isArguments(value)?shallow?push.apply(output,value):flatten(value,shallow,output):output.push(value)}),output)};_.flatten=function(array,shallow){return flatten(array,shallow,[])},_.without=function(array){return _.difference(array,slice.call(arguments,1))},_.partition=function(array,predicate){var pass=[],fail=[];return each(array,function(elem){(predicate(elem)?pass:fail).push(elem)}),[pass,fail]},_.uniq=_.unique=function(array,isSorted,iterator,context){_.isFunction(isSorted)&&(context=iterator,iterator=isSorted,isSorted=!1);var initial=iterator?_.map(array,iterator,context):array,results=[],seen=[];return each(initial,function(value,index){(isSorted?index&&seen[seen.length-1]===value:_.contains(seen,value))||(seen.push(value),results.push(array[index]))}),results},_.union=function(){return _.uniq(_.flatten(arguments,!0))},_.intersection=function(array){var rest=slice.call(arguments,1);return _.filter(_.uniq(array),function(item){return _.every(rest,function(other){return _.contains(other,item)})})},_.difference=function(array){var rest=concat.apply(ArrayProto,slice.call(arguments,1));return _.filter(array,function(value){return!_.contains(rest,value)})},_.zip=function(){for(var length=_.max(_.pluck(arguments,\"length\").concat(0)),results=Array(length),i=0;length>i;i++)results[i]=_.pluck(arguments,\"\"+i);return results},_.object=function(list,values){if(null==list)return{};for(var result={},i=0,length=list.length;length>i;i++)values?result[list[i]]=values[i]:result[list[i][0]]=list[i][1];return result},_.indexOf=function(array,item,isSorted){if(null==array)return-1;var i=0,length=array.length;if(isSorted){if(\"number\"!=typeof isSorted)return i=_.sortedIndex(array,item),array[i]===item?i:-1;i=0>isSorted?Math.max(0,length+isSorted):isSorted}if(nativeIndexOf&&array.indexOf===nativeIndexOf)return array.indexOf(item,isSorted);for(;length>i;i++)if(array[i]===item)return i;return-1},_.lastIndexOf=function(array,item,from){if(null==array)return-1;var hasIndex=null!=from;if(nativeLastIndexOf&&array.lastIndexOf===nativeLastIndexOf)return hasIndex?array.lastIndexOf(item,from):array.lastIndexOf(item);for(var i=hasIndex?from:array.length;i--;)if(array[i]===item)return i;return-1},_.range=function(start,stop,step){1>=arguments.length&&(stop=start||0,start=0),step=arguments[2]||1;for(var length=Math.max(Math.ceil((stop-start)/step),0),idx=0,range=Array(length);length>idx;)range[idx++]=start,start+=step;return range};var ctor=function(){};_.bind=function(func,context){var args,bound;if(nativeBind&&func.bind===nativeBind)return nativeBind.apply(func,slice.call(arguments,1));if(!_.isFunction(func))throw new TypeError;return args=slice.call(arguments,2),bound=function(){if(!(this instanceof bound))return func.apply(context,args.concat(slice.call(arguments)));ctor.prototype=func.prototype;var self=new ctor;ctor.prototype=null;var result=func.apply(self,args.concat(slice.call(arguments)));return Object(result)===result?result:self}},_.partial=function(func){var boundArgs=slice.call(arguments,1);return function(){for(var position=0,args=boundArgs.slice(),i=0,length=args.length;length>i;i++)args[i]===_&&(args[i]=arguments[position++]);for(;arguments.length>position;)args.push(arguments[position++]);return func.apply(this,args)}},_.bindAll=function(obj){var funcs=slice.call(arguments,1);if(0===funcs.length)throw Error(\"bindAll must be passed function names\");return each(funcs,function(f){obj[f]=_.bind(obj[f],obj)}),obj},_.memoize=function(func,hasher){var memo={};return hasher||(hasher=_.identity),function(){var key=hasher.apply(this,arguments);return _.has(memo,key)?memo[key]:memo[key]=func.apply(this,arguments)}},_.delay=function(func,wait){var args=slice.call(arguments,2);return setTimeout(function(){return func.apply(null,args)},wait)},_.defer=function(func){return _.delay.apply(_,[func,1].concat(slice.call(arguments,1)))},_.throttle=function(func,wait,options){var context,args,result,timeout=null,previous=0;options||(options={});var later=function(){previous=options.leading===!1?0:_.now(),timeout=null,result=func.apply(context,args),context=args=null};return function(){var now=_.now();previous||options.leading!==!1||(previous=now);var remaining=wait-(now-previous);return context=this,args=arguments,0>=remaining?(clearTimeout(timeout),timeout=null,previous=now,result=func.apply(context,args),context=args=null):timeout||options.trailing===!1||(timeout=setTimeout(later,remaining)),result}},_.debounce=function(func,wait,immediate){var timeout,args,context,timestamp,result,later=function(){var last=_.now()-timestamp;wait>last?timeout=setTimeout(later,wait-last):(timeout=null,immediate||(result=func.apply(context,args),context=args=null))};return function(){context=this,args=arguments,timestamp=_.now();var callNow=immediate&&!timeout;return timeout||(timeout=setTimeout(later,wait)),callNow&&(result=func.apply(context,args),context=args=null),result}},_.once=function(func){var memo,ran=!1;return function(){return ran?memo:(ran=!0,memo=func.apply(this,arguments),func=null,memo)}},_.wrap=function(func,wrapper){return _.partial(wrapper,func)},_.compose=function(){var funcs=arguments;return function(){for(var args=arguments,i=funcs.length-1;i>=0;i--)args=[funcs[i].apply(this,args)];return args[0]}},_.after=function(times,func){return function(){return 1>--times?func.apply(this,arguments):void 0}},_.keys=function(obj){if(!_.isObject(obj))return[];if(nativeKeys)return nativeKeys(obj);var keys=[];for(var key in obj)_.has(obj,key)&&keys.push(key);return keys},_.values=function(obj){for(var keys=_.keys(obj),length=keys.length,values=Array(length),i=0;length>i;i++)values[i]=obj[keys[i]];return values},_.pairs=function(obj){for(var keys=_.keys(obj),length=keys.length,pairs=Array(length),i=0;length>i;i++)pairs[i]=[keys[i],obj[keys[i]]];return pairs},_.invert=function(obj){for(var result={},keys=_.keys(obj),i=0,length=keys.length;length>i;i++)result[obj[keys[i]]]=keys[i];return result},_.functions=_.methods=function(obj){var names=[];for(var key in obj)_.isFunction(obj[key])&&names.push(key);return names.sort()},_.extend=function(obj){return each(slice.call(arguments,1),function(source){if(source)for(var prop in source)obj[prop]=source[prop]}),obj},_.pick=function(obj){var copy={},keys=concat.apply(ArrayProto,slice.call(arguments,1));return each(keys,function(key){key in obj&&(copy[key]=obj[key])}),copy},_.omit=function(obj){var copy={},keys=concat.apply(ArrayProto,slice.call(arguments,1));for(var key in obj)_.contains(keys,key)||(copy[key]=obj[key]);return copy},_.defaults=function(obj){return each(slice.call(arguments,1),function(source){if(source)for(var prop in source)void 0===obj[prop]&&(obj[prop]=source[prop])}),obj},_.clone=function(obj){return _.isObject(obj)?_.isArray(obj)?obj.slice():_.extend({},obj):obj},_.tap=function(obj,interceptor){return interceptor(obj),obj};var eq=function(a,b,aStack,bStack){if(a===b)return 0!==a||1/a==1/b;if(null==a||null==b)return a===b;a instanceof _&&(a=a._wrapped),b instanceof _&&(b=b._wrapped);var className=toString.call(a);if(className!=toString.call(b))return!1;switch(className){case\"[object String]\":return a==b+\"\";case\"[object Number]\":return a!=+a?b!=+b:0==a?1/a==1/b:a==+b;case\"[object Date]\":case\"[object Boolean]\":return+a==+b;case\"[object RegExp]\":return a.source==b.source&&a.global==b.global&&a.multiline==b.multiline&&a.ignoreCase==b.ignoreCase}if(\"object\"!=typeof a||\"object\"!=typeof b)return!1;for(var length=aStack.length;length--;)if(aStack[length]==a)return bStack[length]==b;var aCtor=a.constructor,bCtor=b.constructor;if(aCtor!==bCtor&&!(_.isFunction(aCtor)&&aCtor instanceof aCtor&&_.isFunction(bCtor)&&bCtor instanceof bCtor)&&\"constructor\"in a&&\"constructor\"in b)return!1;aStack.push(a),bStack.push(b);var size=0,result=!0;if(\"[object Array]\"==className){if(size=a.length,result=size==b.length)for(;size--&&(result=eq(a[size],b[size],aStack,bStack)););}else{for(var key in a)if(_.has(a,key)&&(size++,!(result=_.has(b,key)&&eq(a[key],b[key],aStack,bStack))))break;if(result){for(key in b)if(_.has(b,key)&&!size--)break;result=!size}}return aStack.pop(),bStack.pop(),result};_.isEqual=function(a,b){return eq(a,b,[],[])},_.isEmpty=function(obj){if(null==obj)return!0;if(_.isArray(obj)||_.isString(obj))return 0===obj.length;for(var key in obj)if(_.has(obj,key))return!1;return!0},_.isElement=function(obj){return!(!obj||1!==obj.nodeType)},_.isArray=nativeIsArray||function(obj){return\"[object Array]\"==toString.call(obj)},_.isObject=function(obj){return obj===Object(obj)},each([\"Arguments\",\"Function\",\"String\",\"Number\",\"Date\",\"RegExp\"],function(name){_[\"is\"+name]=function(obj){return toString.call(obj)==\"[object \"+name+\"]\"}}),_.isArguments(arguments)||(_.isArguments=function(obj){return!(!obj||!_.has(obj,\"callee\"))}),_.isFunction=function(obj){return\"function\"==typeof obj},_.isFinite=function(obj){return isFinite(obj)&&!isNaN(parseFloat(obj))},_.isNaN=function(obj){return _.isNumber(obj)&&obj!=+obj},_.isBoolean=function(obj){return obj===!0||obj===!1||\"[object Boolean]\"==toString.call(obj)},_.isNull=function(obj){return null===obj},_.isUndefined=function(obj){return void 0===obj},_.has=function(obj,key){return hasOwnProperty.call(obj,key)},_.noConflict=function(){return root._=previousUnderscore,this},_.identity=function(value){return value},_.constant=function(value){return function(){return value}},_.property=function(key){return function(obj){return obj[key]}},_.matches=function(attrs){return function(obj){if(obj===attrs)return!0;for(var key in attrs)if(attrs[key]!==obj[key])return!1;return!0}},_.times=function(n,iterator,context){for(var accum=Array(Math.max(0,n)),i=0;n>i;i++)accum[i]=iterator.call(context,i);return accum},_.random=function(min,max){return null==max&&(max=min,min=0),min+Math.floor(Math.random()*(max-min+1))},_.now=Date.now||function(){return(new Date).getTime()};var entityMap={escape:{\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&#x27;\"}};entityMap.unescape=_.invert(entityMap.escape);var entityRegexes={escape:RegExp(\"[\"+_.keys(entityMap.escape).join(\"\")+\"]\",\"g\"),unescape:RegExp(\"(\"+_.keys(entityMap.unescape).join(\"|\")+\")\",\"g\")};_.each([\"escape\",\"unescape\"],function(method){_[method]=function(string){return null==string?\"\":(\"\"+string).replace(entityRegexes[method],function(match){return entityMap[method][match]})}}),_.result=function(object,property){if(null==object)return void 0;var value=object[property];return _.isFunction(value)?value.call(object):value},_.mixin=function(obj){each(_.functions(obj),function(name){var func=_[name]=obj[name];_.prototype[name]=function(){var args=[this._wrapped];return push.apply(args,arguments),result.call(this,func.apply(_,args))}})};var idCounter=0;_.uniqueId=function(prefix){var id=++idCounter+\"\";return prefix?prefix+id:id},_.templateSettings={evaluate:/<%([\\s\\S]+?)%>/g,interpolate:/<%=([\\s\\S]+?)%>/g,escape:/<%-([\\s\\S]+?)%>/g};var noMatch=/(.)^/,escapes={\"'\":\"'\",\"\\\\\":\"\\\\\",\"\\r\":\"r\",\"\\n\":\"n\",\"\t\":\"t\",\"\\u2028\":\"u2028\",\"\\u2029\":\"u2029\"},escaper=/\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;_.template=function(text,data,settings){var render;settings=_.defaults({},settings,_.templateSettings);var matcher=RegExp([(settings.escape||noMatch).source,(settings.interpolate||noMatch).source,(settings.evaluate||noMatch).source].join(\"|\")+\"|$\",\"g\"),index=0,source=\"__p+='\";text.replace(matcher,function(match,escape,interpolate,evaluate,offset){return source+=text.slice(index,offset).replace(escaper,function(match){return\"\\\\\"+escapes[match]}),escape&&(source+=\"'+\\n((__t=(\"+escape+\"))==null?'':_.escape(__t))+\\n'\"),interpolate&&(source+=\"'+\\n((__t=(\"+interpolate+\"))==null?'':__t)+\\n'\"),evaluate&&(source+=\"';\\n\"+evaluate+\"\\n__p+='\"),index=offset+match.length,match}),source+=\"';\\n\",settings.variable||(source=\"with(obj||{}){\\n\"+source+\"}\\n\"),source=\"var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\\n\"+source+\"return __p;\\n\";try{render=Function(settings.variable||\"obj\",\"_\",source)}catch(e){throw e.source=source,e}if(data)return render(data,_);var template=function(data){return render.call(this,data,_)};return template.source=\"function(\"+(settings.variable||\"obj\")+\"){\\n\"+source+\"}\",template},_.chain=function(obj){return _(obj).chain()};var result=function(obj){return this._chain?_(obj).chain():obj};_.mixin(_),each([\"pop\",\"push\",\"reverse\",\"shift\",\"sort\",\"splice\",\"unshift\"],function(name){var method=ArrayProto[name];_.prototype[name]=function(){var obj=this._wrapped;return method.apply(obj,arguments),\"shift\"!=name&&\"splice\"!=name||0!==obj.length||delete obj[0],result.call(this,obj)}}),each([\"concat\",\"join\",\"slice\"],function(name){var method=ArrayProto[name];_.prototype[name]=function(){return result.call(this,method.apply(this._wrapped,arguments))}}),_.extend(_.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}}),\"function\"==typeof define&&define.amd&&ace.define(\"underscore\",[],function(){return _})}).call(this)},{}],3:[function(_dereq_,module,exports){var _=_dereq_(\"underscore\"),events=_dereq_(\"events\"),vars=_dereq_(\"./vars.js\"),messages=_dereq_(\"./messages.js\"),Lexer=_dereq_(\"./lex.js\").Lexer,reg=_dereq_(\"./reg.js\"),state=_dereq_(\"./state.js\").state,style=_dereq_(\"./style.js\"),JSHINT=function(){\"use strict\";function checkOption(name,t){return name=name.trim(),/^[+-]W\\d{3}$/g.test(name)?!0:void 0!==valOptions[name]||void 0!==boolOptions[name]||\"jslint\"===t.type||removedOptions[name]?!0:(error(\"E001\",t,name),!1)}function isString(obj){return\"[object String]\"===Object.prototype.toString.call(obj)}function isIdentifier(tkn,value){return tkn?tkn.identifier&&tkn.value===value?!0:!1:!1}function isReserved(token){if(!token.reserved)return!1;var meta=token.meta;if(meta&&meta.isFutureReservedWord&&state.option.inES5()){if(!meta.es5)return!1;if(meta.strictOnly&&!state.option.strict&&!state.directive[\"use strict\"])return!1;if(token.isProperty)return!1}return!0}function supplant(str,data){return str.replace(/\\{([^{}]*)\\}/g,function(a,b){var r=data[b];return\"string\"==typeof r||\"number\"==typeof r?r:a})}function combine(dest,src){Object.keys(src).forEach(function(name){_.has(JSHINT.blacklist,name)||(dest[name]=src[name])})}function assume(){state.option.esnext&&combine(predefined,vars.newEcmaIdentifiers),state.option.couch&&combine(predefined,vars.couch),state.option.qunit&&combine(predefined,vars.qunit),state.option.rhino&&combine(predefined,vars.rhino),state.option.shelljs&&(combine(predefined,vars.shelljs),combine(predefined,vars.node)),state.option.typed&&combine(predefined,vars.typed),state.option.phantom&&combine(predefined,vars.phantom),state.option.prototypejs&&combine(predefined,vars.prototypejs),state.option.node&&(combine(predefined,vars.node),combine(predefined,vars.typed)),state.option.devel&&combine(predefined,vars.devel),state.option.dojo&&combine(predefined,vars.dojo),state.option.browser&&(combine(predefined,vars.browser),combine(predefined,vars.typed)),state.option.nonstandard&&combine(predefined,vars.nonstandard),state.option.jasmine&&combine(predefined,vars.jasmine),state.option.jquery&&combine(predefined,vars.jquery),state.option.mootools&&combine(predefined,vars.mootools),state.option.worker&&combine(predefined,vars.worker),state.option.wsh&&combine(predefined,vars.wsh),state.option.globalstrict&&state.option.strict!==!1&&(state.option.strict=!0),state.option.yui&&combine(predefined,vars.yui),state.option.mocha&&combine(predefined,vars.mocha),state.option.inMoz=function(){return state.option.moz},state.option.inESNext=function(){return state.option.moz||state.option.esnext},state.option.inES5=function(){return!state.option.es3},state.option.inES3=function(strict){return strict?!state.option.moz&&!state.option.esnext&&state.option.es3:state.option.es3}}function quit(code,line,chr){var percentage=Math.floor(100*(line/state.lines.length)),message=messages.errors[code].desc;throw{name:\"JSHintError\",line:line,character:chr,message:message+\" (\"+percentage+\"% scanned).\",raw:message,code:code}}function isundef(scope,code,token,a){return JSHINT.undefs.push([scope,code,token,a])}function removeIgnoredMessages(){var ignored=state.ignoredLines;_.isEmpty(ignored)||(JSHINT.errors=_.reject(JSHINT.errors,function(err){return ignored[err.line]}))}function warning(code,t,a,b,c,d){var ch,l,w,msg;if(/^W\\d{3}$/.test(code)){if(state.ignored[code])return;msg=messages.warnings[code]}else/E\\d{3}/.test(code)?msg=messages.errors[code]:/I\\d{3}/.test(code)&&(msg=messages.info[code]);return t=t||state.tokens.next,\"(end)\"===t.id&&(t=state.tokens.curr),l=t.line||0,ch=t.from||0,w={id:\"(error)\",raw:msg.desc,code:msg.code,evidence:state.lines[l-1]||\"\",line:l,character:ch,scope:JSHINT.scope,a:a,b:b,c:c,d:d},w.reason=supplant(msg.desc,w),JSHINT.errors.push(w),removeIgnoredMessages(),JSHINT.errors.length>=state.option.maxerr&&quit(\"E043\",l,ch),w}function warningAt(m,l,ch,a,b,c,d){return warning(m,{line:l,from:ch},a,b,c,d)}function error(m,t,a,b,c,d){warning(m,t,a,b,c,d)}function errorAt(m,l,ch,a,b,c,d){return error(m,{line:l,from:ch},a,b,c,d)}function addInternalSrc(elem,src){var i;return i={id:\"(internal)\",elem:elem,value:src},JSHINT.internals.push(i),i}function addlabel(name,opts){opts=opts||{};var type=opts.type,token=opts.token,islet=opts.islet;\"exception\"===type&&_.has(funct[\"(context)\"],name)&&(funct[name]===!0||state.option.node||warning(\"W002\",state.tokens.next,name)),_.has(funct,name)&&!funct[\"(global)\"]&&(funct[name]===!0?state.option.latedef&&(state.option.latedef===!0&&_.contains([funct[name],type],\"unction\")||!_.contains([funct[name],type],\"unction\"))&&warning(\"W003\",state.tokens.next,name):((!state.option.shadow||_.contains([\"inner\",\"outer\"],state.option.shadow))&&\"exception\"!==type||funct[\"(blockscope)\"].getlabel(name))&&warning(\"W004\",state.tokens.next,name)),funct[\"(context)\"]&&_.has(funct[\"(context)\"],name)&&\"function\"!==type&&\"outer\"===state.option.shadow&&warning(\"W123\",state.tokens.next,name),islet?funct[\"(blockscope)\"].current.add(name,type,state.tokens.curr):(funct[\"(blockscope)\"].shadow(name),funct[name]=type,token&&(funct[\"(tokens)\"][name]=token),setprop(funct,name,{unused:opts.unused||!1}),funct[\"(global)\"]?(global[name]=funct,_.has(implied,name)&&(state.option.latedef&&(state.option.latedef===!0&&_.contains([funct[name],type],\"unction\")||!_.contains([funct[name],type],\"unction\"))&&warning(\"W003\",state.tokens.next,name),delete implied[name])):scope[name]=funct)}function doOption(){var nt=state.tokens.next,body=nt.body.match(/(-\\s+)?[^\\s,:]+(?:\\s*:\\s*(-\\s+)?[^\\s,]+)?/g)||[],predef={};if(\"globals\"===nt.type){body.forEach(function(g){g=g.split(\":\");var key=(g[0]||\"\").trim(),val=(g[1]||\"\").trim();\"-\"===key.charAt(0)?(key=key.slice(1),val=!1,JSHINT.blacklist[key]=key,delete predefined[key]):predef[key]=\"true\"===val}),combine(predefined,predef);for(var key in predef)_.has(predef,key)&&(declared[key]=nt)}\"exported\"===nt.type&&body.forEach(function(e){exported[e]=!0}),\"members\"===nt.type&&(membersOnly=membersOnly||{},body.forEach(function(m){var ch1=m.charAt(0),ch2=m.charAt(m.length-1);ch1!==ch2||'\"'!==ch1&&\"'\"!==ch1||(m=m.substr(1,m.length-2).replace('\\\\\"','\"')),membersOnly[m]=!1}));var numvals=[\"maxstatements\",\"maxparams\",\"maxdepth\",\"maxcomplexity\",\"maxerr\",\"maxlen\",\"indent\"];(\"jshint\"===nt.type||\"jslint\"===nt.type)&&(body.forEach(function(g){g=g.split(\":\");var key=(g[0]||\"\").trim(),val=(g[1]||\"\").trim();if(checkOption(key,nt))if(numvals.indexOf(key)>=0)if(\"false\"!==val){if(val=+val,\"number\"!=typeof val||!isFinite(val)||0>=val||Math.floor(val)!==val)return error(\"E032\",nt,g[1].trim()),void 0;state.option[key]=val}else state.option[key]=\"indent\"===key?4:!1;else{if(\"validthis\"===key)return funct[\"(global)\"]?void error(\"E009\"):\"true\"!==val&&\"false\"!==val?void error(\"E002\",nt):(state.option.validthis=\"true\"===val,void 0);if(\"quotmark\"!==key)if(\"shadow\"!==key)if(\"unused\"!==key)if(\"latedef\"!==key){if(\"ignore\"!==key){var match=/^([+-])(W\\d{3})$/g.exec(key);if(match)return state.ignored[match[2]]=\"-\"===match[1],void 0;var tn;return\"true\"===val||\"false\"===val?(\"jslint\"===nt.type?(tn=renamedOptions[key]||key,state.option[tn]=\"true\"===val,void 0!==invertedOptions[tn]&&(state.option[tn]=!state.option[tn])):state.option[key]=\"true\"===val,\"newcap\"===key&&(state.option[\"(explicitNewcap)\"]=!0),void 0):(error(\"E002\",nt),void 0)}switch(val){case\"start\":state.ignoreLinterErrors=!0;break;case\"end\":state.ignoreLinterErrors=!1;break;case\"line\":state.ignoredLines[nt.line]=!0,removeIgnoredMessages();break;default:error(\"E002\",nt)}}else switch(val){case\"true\":state.option.latedef=!0;break;case\"false\":state.option.latedef=!1;break;case\"nofunc\":state.option.latedef=\"nofunc\";break;default:error(\"E002\",nt)}else switch(val){case\"true\":state.option.unused=!0;break;case\"false\":state.option.unused=!1;break;case\"vars\":case\"strict\":state.option.unused=val;break;default:error(\"E002\",nt)}else switch(val){case\"true\":state.option.shadow=!0;break;case\"outer\":state.option.shadow=\"outer\";break;case\"false\":case\"inner\":state.option.shadow=\"inner\";break;default:error(\"E002\",nt)}else switch(val){case\"true\":case\"false\":state.option.quotmark=\"true\"===val;break;case\"double\":case\"single\":state.option.quotmark=val;break;default:error(\"E002\",nt)}}}),assume())}function peek(p){for(var t,i=p||0,j=0;i>=j;)t=lookahead[j],t||(t=lookahead[j]=lex.token()),j+=1;return t}function advance(id,t){switch(state.tokens.curr.id){case\"(number)\":\".\"===state.tokens.next.id&&warning(\"W005\",state.tokens.curr);break;case\"-\":(\"-\"===state.tokens.next.id||\"--\"===state.tokens.next.id)&&warning(\"W006\");break;case\"+\":(\"+\"===state.tokens.next.id||\"++\"===state.tokens.next.id)&&warning(\"W007\")}for((\"(string)\"===state.tokens.curr.type||state.tokens.curr.identifier)&&(anonname=state.tokens.curr.value),id&&state.tokens.next.id!==id&&(t?\"(end)\"===state.tokens.next.id?error(\"E019\",t,t.id):error(\"E020\",state.tokens.next,id,t.id,t.line,state.tokens.next.value):(\"(identifier)\"!==state.tokens.next.type||state.tokens.next.value!==id)&&warning(\"W116\",state.tokens.next,id,state.tokens.next.value)),state.tokens.prev=state.tokens.curr,state.tokens.curr=state.tokens.next;;){if(state.tokens.next=lookahead.shift()||lex.token(),state.tokens.next||quit(\"E041\",state.tokens.curr.line),\"(end)\"===state.tokens.next.id||\"(error)\"===state.tokens.next.id)return;if(state.tokens.next.check&&state.tokens.next.check(),state.tokens.next.isSpecial)doOption();else if(\"(endline)\"!==state.tokens.next.id)break}}function isInfix(token){return token.infix||!token.identifier&&!!token.led}function isEndOfExpr(){var curr=state.tokens.curr,next=state.tokens.next;return\";\"===next.id||\"}\"===next.id||\":\"===next.id?!0:isInfix(next)===isInfix(curr)||\"yield\"===curr.id&&state.option.inMoz(!0)?curr.line!==next.line:!1}function expression(rbp,initial){var left,isArray=!1,isObject=!1,isLetExpr=!1;initial||\"let\"!==state.tokens.next.value||\"(\"!==peek(0).value||(state.option.inMoz(!0)||warning(\"W118\",state.tokens.next,\"let expressions\"),isLetExpr=!0,funct[\"(blockscope)\"].stack(),advance(\"let\"),advance(\"(\"),state.syntax.let.fud.call(state.syntax.let.fud,!1),advance(\")\")),\"(end)\"===state.tokens.next.id&&error(\"E006\",state.tokens.curr);var isDangerous=state.option.asi&&state.tokens.prev.line<state.tokens.curr.line&&_.contains([\"]\",\")\"],state.tokens.prev.id)&&_.contains([\"[\",\"(\"],state.tokens.curr.id);if(isDangerous&&warning(\"W014\",state.tokens.curr,state.tokens.curr.id),advance(),initial&&(anonname=\"anonymous\",funct[\"(verb)\"]=state.tokens.curr.value),initial===!0&&state.tokens.curr.fud)left=state.tokens.curr.fud();else for(state.tokens.curr.nud?left=state.tokens.curr.nud():error(\"E030\",state.tokens.curr,state.tokens.curr.id);state.tokens.next.lbp>rbp&&!isEndOfExpr();)isArray=\"Array\"===state.tokens.curr.value,isObject=\"Object\"===state.tokens.curr.value,left&&(left.value||left.first&&left.first.value)&&(\"new\"!==left.value||left.first&&left.first.value&&\".\"===left.first.value)&&(isArray=!1,left.value!==state.tokens.curr.value&&(isObject=!1)),advance(),isArray&&\"(\"===state.tokens.curr.id&&\")\"===state.tokens.next.id&&warning(\"W009\",state.tokens.curr),isObject&&\"(\"===state.tokens.curr.id&&\")\"===state.tokens.next.id&&warning(\"W010\",state.tokens.curr),left&&state.tokens.curr.led?left=state.tokens.curr.led(left):error(\"E033\",state.tokens.curr,state.tokens.curr.id);return isLetExpr&&funct[\"(blockscope)\"].unstack(),left}function nobreaknonadjacent(left,right){left=left||state.tokens.curr,right=right||state.tokens.next,state.option.laxbreak||left.line===right.line||warning(\"W014\",right,right.value)}function nolinebreak(t){t=t||state.tokens.curr,t.line!==state.tokens.next.line&&warning(\"E022\",t,t.value)}function nobreakcomma(left,right){left.line!==right.line&&(state.option.laxcomma||(comma.first&&(warning(\"I001\"),comma.first=!1),warning(\"W014\",left,right.value)))}function comma(opts){if(opts=opts||{},opts.peek?nobreakcomma(state.tokens.prev,state.tokens.curr):(nobreakcomma(state.tokens.curr,state.tokens.next),advance(\",\")),state.tokens.next.identifier&&(!opts.property||!state.option.inES5()))switch(state.tokens.next.value){case\"break\":case\"case\":case\"catch\":case\"continue\":case\"default\":case\"do\":case\"else\":case\"finally\":case\"for\":case\"if\":case\"in\":case\"instanceof\":case\"return\":case\"switch\":case\"throw\":case\"try\":case\"var\":case\"let\":case\"while\":case\"with\":return error(\"E024\",state.tokens.next,state.tokens.next.value),!1}if(\"(punctuator)\"===state.tokens.next.type)switch(state.tokens.next.value){case\"}\":case\"]\":case\",\":if(opts.allowTrailing)return!0;case\")\":return error(\"E024\",state.tokens.next,state.tokens.next.value),!1}return!0}function symbol(s,p){var x=state.syntax[s];return x&&\"object\"==typeof x||(state.syntax[s]=x={id:s,lbp:p,value:s}),x}function delim(s){return symbol(s,0)}function stmt(s,f){var x=delim(s);return x.identifier=x.reserved=!0,x.fud=f,x}function blockstmt(s,f){var x=stmt(s,f);return x.block=!0,x}function reserveName(x){var c=x.id.charAt(0);return(c>=\"a\"&&\"z\">=c||c>=\"A\"&&\"Z\">=c)&&(x.identifier=x.reserved=!0),x}function prefix(s,f){var x=symbol(s,150);return reserveName(x),x.nud=\"function\"==typeof f?f:function(){return this.right=expression(150),this.arity=\"unary\",(\"++\"===this.id||\"--\"===this.id)&&(state.option.plusplus?warning(\"W016\",this,this.id):!this.right||this.right.identifier&&!isReserved(this.right)||\".\"===this.right.id||\"[\"===this.right.id||warning(\"W017\",this)),this},x}function type(s,f){var x=delim(s);return x.type=s,x.nud=f,x}function reserve(name,func){var x=type(name,func);return x.identifier=!0,x.reserved=!0,x}function FutureReservedWord(name,meta){var x=type(name,meta&&meta.nud||function(){return this});return meta=meta||{},meta.isFutureReservedWord=!0,x.value=name,x.identifier=!0,x.reserved=!0,x.meta=meta,x}function reservevar(s,v){return reserve(s,function(){return\"function\"==typeof v&&v(this),this})}function infix(s,f,p,w){var x=symbol(s,p);return reserveName(x),x.infix=!0,x.led=function(left){return w||nobreaknonadjacent(state.tokens.prev,state.tokens.curr),\"in\"===s&&\"!\"===left.id&&warning(\"W018\",left,\"!\"),\"function\"==typeof f?f(left,this):(this.left=left,this.right=expression(p),this)},x}function application(s){var x=symbol(s,42);return x.led=function(left){return state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"arrow function syntax (=>)\"),nobreaknonadjacent(state.tokens.prev,state.tokens.curr),this.left=left,this.right=doFunction(void 0,void 0,!1,left),this},x}function relation(s,f){var x=symbol(s,100);return x.led=function(left){nobreaknonadjacent(state.tokens.prev,state.tokens.curr);var right=expression(100);return isIdentifier(left,\"NaN\")||isIdentifier(right,\"NaN\")?warning(\"W019\",this):f&&f.apply(this,[left,right]),left&&right||quit(\"E041\",state.tokens.curr.line),\"!\"===left.id&&warning(\"W018\",left,\"!\"),\"!\"===right.id&&warning(\"W018\",right,\"!\"),this.left=left,this.right=right,this},x}function isPoorRelation(node){return node&&(\"(number)\"===node.type&&0===+node.value||\"(string)\"===node.type&&\"\"===node.value||\"null\"===node.type&&!state.option.eqnull||\"true\"===node.type||\"false\"===node.type||\"undefined\"===node.type)}function isTypoTypeof(left,right){if(state.option.notypeof)return!1;if(!left||!right)return!1;var values=[\"undefined\",\"object\",\"boolean\",\"number\",\"string\",\"function\",\"xml\",\"object\",\"unknown\"];return\"(identifier)\"===right.type&&\"typeof\"===right.value&&\"(string)\"===left.type?!_.contains(values,left.value):!1}function findNativePrototype(left){function walkPrototype(obj){return\"object\"==typeof obj?\"prototype\"===obj.right?obj:walkPrototype(obj.left):void 0}function walkNative(obj){for(;!obj.identifier&&\"object\"==typeof obj.left;)obj=obj.left;return obj.identifier&&natives.indexOf(obj.value)>=0?obj.value:void 0}var natives=[\"Array\",\"ArrayBuffer\",\"Boolean\",\"Collator\",\"DataView\",\"Date\",\"DateTimeFormat\",\"Error\",\"EvalError\",\"Float32Array\",\"Float64Array\",\"Function\",\"Infinity\",\"Intl\",\"Int16Array\",\"Int32Array\",\"Int8Array\",\"Iterator\",\"Number\",\"NumberFormat\",\"Object\",\"RangeError\",\"ReferenceError\",\"RegExp\",\"StopIteration\",\"String\",\"SyntaxError\",\"TypeError\",\"Uint16Array\",\"Uint32Array\",\"Uint8Array\",\"Uint8ClampedArray\",\"URIError\"],prototype=walkPrototype(left);return prototype?walkNative(prototype):void 0}function assignop(s,f,p){var x=infix(s,\"function\"==typeof f?f:function(left,that){if(that.left=left,left){if(state.option.freeze){var nativeObject=findNativePrototype(left);nativeObject&&warning(\"W121\",left,nativeObject)}if(predefined[left.value]===!1&&scope[left.value][\"(global)\"]===!0?warning(\"W020\",left):left[\"function\"]&&warning(\"W021\",left,left.value),\"const\"===funct[left.value]&&error(\"E013\",left,left.value),\".\"===left.id)return left.left?\"arguments\"!==left.left.value||state.directive[\"use strict\"]||warning(\"E031\",that):warning(\"E031\",that),that.right=expression(10),that;if(\"[\"===left.id)return state.tokens.curr.left.first?state.tokens.curr.left.first.forEach(function(t){t&&\"const\"===funct[t.value]&&error(\"E013\",t,t.value)}):left.left?\"arguments\"!==left.left.value||state.directive[\"use strict\"]||warning(\"E031\",that):warning(\"E031\",that),that.right=expression(10),that;if(left.identifier&&!isReserved(left))return\"exception\"===funct[left.value]&&warning(\"W022\",left),that.right=expression(10),that;left===state.syntax[\"function\"]&&warning(\"W023\",state.tokens.curr)\n}error(\"E031\",that)},p);return x.exps=!0,x.assign=!0,x}function bitwise(s,f,p){var x=symbol(s,p);return reserveName(x),x.led=\"function\"==typeof f?f:function(left){return state.option.bitwise&&warning(\"W016\",this,this.id),this.left=left,this.right=expression(p),this},x}function bitwiseassignop(s){return assignop(s,function(left,that){return state.option.bitwise&&warning(\"W016\",that,that.id),left?\".\"===left.id||\"[\"===left.id||left.identifier&&!isReserved(left)?(expression(10),that):(left===state.syntax[\"function\"]&&warning(\"W023\",state.tokens.curr),that):(error(\"E031\",that),void 0)},20)}function suffix(s){var x=symbol(s,150);return x.led=function(left){return state.option.plusplus?warning(\"W016\",this,this.id):left.identifier&&!isReserved(left)||\".\"===left.id||\"[\"===left.id||warning(\"W017\",this),this.left=left,this},x}function optionalidentifier(fnparam,prop){if(state.tokens.next.identifier){advance();var curr=state.tokens.curr,val=state.tokens.curr.value;return isReserved(curr)?prop&&state.option.inES5()?val:fnparam&&\"undefined\"===val?val:(warning(\"W024\",state.tokens.curr,state.tokens.curr.id),val):val}}function identifier(fnparam,prop){var i=optionalidentifier(fnparam,prop);return i?i:(\"function\"===state.tokens.curr.id&&\"(\"===state.tokens.next.id?warning(\"W025\"):error(\"E030\",state.tokens.next,state.tokens.next.value),void 0)}function reachable(s){var t,i=0;if(\";\"===state.tokens.next.id&&!noreach)for(;;){do t=peek(i),i+=1;while(\"(end)\"!=t.id&&\"(comment)\"===t.id);if(t.reach)return;if(\"(endline)\"!==t.id){if(\"function\"===t.id){state.option.latedef===!0&&warning(\"W026\",t);break}warning(\"W027\",t,t.value,s);break}}}function parseFinalSemicolon(){\";\"!==state.tokens.next.id?state.option.asi||state.option.lastsemic&&\"}\"===state.tokens.next.id&&state.tokens.next.line===state.tokens.curr.line||warningAt(\"W033\",state.tokens.curr.line,state.tokens.curr.character):advance(\";\")}function statement(){var values,r,i=indent,s=scope,t=state.tokens.next;if(\";\"===t.id)return advance(\";\"),void 0;var res=isReserved(t);if(res&&t.meta&&t.meta.isFutureReservedWord&&\":\"===peek().id&&(warning(\"W024\",t,t.id),res=!1),\"module\"===t.value&&\"(identifier)\"===t.type&&\"(identifier)\"===peek().type){state.option.inESNext()||warning(\"W119\",state.tokens.curr,\"module\"),advance(\"module\");var name=identifier();return addlabel(name,{type:\"unused\",token:state.tokens.curr}),advance(\"from\"),advance(\"(string)\"),parseFinalSemicolon(),void 0}if(_.has([\"[\",\"{\"],t.value)&&lookupBlockType().isDestAssign)return state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"destructuring expression\"),values=destructuringExpression(),values.forEach(function(tok){isundef(funct,\"W117\",tok.token,tok.id)}),advance(\"=\"),destructuringExpressionMatch(values,expression(10,!0)),advance(\";\"),void 0;if(t.identifier&&!res&&\":\"===peek().id&&(advance(),advance(\":\"),scope=Object.create(s),addlabel(t.value,{type:\"label\"}),state.tokens.next.labelled||\"{\"===state.tokens.next.value||warning(\"W028\",state.tokens.next,t.value,state.tokens.next.value),state.tokens.next.label=t.value,t=state.tokens.next),\"{\"===t.id){var iscase=\"case\"===funct[\"(verb)\"]&&\":\"===state.tokens.curr.value;return block(!0,!0,!1,!1,iscase),void 0}return r=expression(0,!0),!r||r.identifier&&\"function\"===r.value||\"(punctuator)\"===r.type||!state.directive[\"use strict\"]&&state.option.globalstrict&&state.option.strict&&warning(\"E007\"),t.block||(state.option.expr||r&&r.exps?state.option.nonew&&r&&r.left&&\"(\"===r.id&&\"new\"===r.left.id&&warning(\"W031\",t):warning(\"W030\",state.tokens.curr),parseFinalSemicolon()),indent=i,scope=s,r}function statements(startLine){for(var p,a=[];!state.tokens.next.reach&&\"(end)\"!==state.tokens.next.id;)\";\"===state.tokens.next.id?(p=peek(),(!p||\"(\"!==p.id&&\"[\"!==p.id)&&warning(\"W032\"),advance(\";\")):a.push(statement(startLine===state.tokens.next.line));return a}function directives(){for(var i,p,pn;\"(string)\"===state.tokens.next.id;){if(p=peek(0),\"(endline)\"===p.id){i=1;do pn=peek(i),i+=1;while(\"(endline)\"===pn.id);if(\";\"!==pn.id){if(\"(string)\"!==pn.id&&\"(number)\"!==pn.id&&\"(regexp)\"!==pn.id&&pn.identifier!==!0&&\"}\"!==pn.id)break;warning(\"W033\",state.tokens.next)}else p=pn}else if(\"}\"===p.id)warning(\"W033\",p);else if(\";\"!==p.id)break;advance(),state.directive[state.tokens.curr.value]&&warning(\"W034\",state.tokens.curr,state.tokens.curr.value),\"use strict\"===state.tokens.curr.value&&(state.option[\"(explicitNewcap)\"]||(state.option.newcap=!0),state.option.undef=!0),state.directive[state.tokens.curr.value]=!0,\";\"===p.id&&advance(\";\")}}function block(ordinary,stmt,isfunc,isfatarrow,iscase){var a,m,t,line,d,b=inblock,old_indent=indent,s=scope;inblock=ordinary,ordinary&&state.option.funcscope||(scope=Object.create(scope)),t=state.tokens.next;var metrics=funct[\"(metrics)\"];if(metrics.nestedBlockDepth+=1,metrics.verifyMaxNestedBlockDepthPerFunction(),\"{\"===state.tokens.next.id){if(advance(\"{\"),funct[\"(blockscope)\"].stack(),line=state.tokens.curr.line,\"}\"!==state.tokens.next.id){for(indent+=state.option.indent;!ordinary&&state.tokens.next.from>indent;)indent+=state.option.indent;if(isfunc){m={};for(d in state.directive)_.has(state.directive,d)&&(m[d]=state.directive[d]);directives(),state.option.strict&&funct[\"(context)\"][\"(global)\"]&&(m[\"use strict\"]||state.directive[\"use strict\"]||warning(\"E007\"))}a=statements(line),metrics.statementCount+=a.length,isfunc&&(state.directive=m),indent-=state.option.indent}advance(\"}\",t),funct[\"(blockscope)\"].unstack(),indent=old_indent}else if(ordinary)funct[\"(nolet)\"]=!0,(!stmt||state.option.curly)&&warning(\"W116\",state.tokens.next,\"{\",state.tokens.next.value),noreach=!0,indent+=state.option.indent,a=[statement()],indent-=state.option.indent,noreach=!1,delete funct[\"(nolet)\"];else if(isfunc){if(m={},!stmt||isfatarrow||state.option.inMoz(!0)||error(\"W118\",state.tokens.curr,\"function closure expressions\"),!stmt)for(d in state.directive)_.has(state.directive,d)&&(m[d]=state.directive[d]);expression(10),state.option.strict&&funct[\"(context)\"][\"(global)\"]&&(m[\"use strict\"]||state.directive[\"use strict\"]||warning(\"E007\"))}else error(\"E021\",state.tokens.next,\"{\",state.tokens.next.value);switch(funct[\"(verb)\"]){case\"break\":case\"continue\":case\"return\":case\"throw\":if(iscase)break;default:funct[\"(verb)\"]=null}return ordinary&&state.option.funcscope||(scope=s),inblock=b,!ordinary||!state.option.noempty||a&&0!==a.length||warning(\"W035\"),metrics.nestedBlockDepth-=1,a}function countMember(m){membersOnly&&\"boolean\"!=typeof membersOnly[m]&&warning(\"W036\",state.tokens.curr,m),\"number\"==typeof member[m]?member[m]+=1:member[m]=1}function note_implied(tkn){var name=tkn.value,desc=Object.getOwnPropertyDescriptor(implied,name);desc?desc.value.push(tkn.line):implied[name]=[tkn.line]}function comprehensiveArrayExpression(){var res={};res.exps=!0,funct[\"(comparray)\"].stack();var reversed=!1;return\"for\"!==state.tokens.next.value&&(reversed=!0,state.option.inMoz(!0)||warning(\"W116\",state.tokens.next,\"for\",state.tokens.next.value),funct[\"(comparray)\"].setState(\"use\"),res.right=expression(10)),advance(\"for\"),\"each\"===state.tokens.next.value&&(advance(\"each\"),state.option.inMoz(!0)||warning(\"W118\",state.tokens.curr,\"for each\")),advance(\"(\"),funct[\"(comparray)\"].setState(\"define\"),res.left=expression(130),_.contains([\"in\",\"of\"],state.tokens.next.value)?advance():error(\"E045\",state.tokens.curr),funct[\"(comparray)\"].setState(\"generate\"),expression(10),advance(\")\"),\"if\"===state.tokens.next.value&&(advance(\"if\"),advance(\"(\"),funct[\"(comparray)\"].setState(\"filter\"),res.filter=expression(10),advance(\")\")),reversed||(funct[\"(comparray)\"].setState(\"use\"),res.right=expression(10)),advance(\"]\"),funct[\"(comparray)\"].unstack(),res}function property_name(){var id=optionalidentifier(!1,!0);return id||(\"(string)\"===state.tokens.next.id?(id=state.tokens.next.value,advance()):\"(number)\"===state.tokens.next.id&&(id=\"\"+state.tokens.next.value,advance())),\"hasOwnProperty\"===id&&warning(\"W001\"),id}function functionparams(parsed){var curr,next,ident,t,params=[],tokens=[],pastDefault=!1;if(parsed){if(Array.isArray(parsed)){for(var i in parsed)curr=parsed[i],\"...\"!==curr.value?\",\"!==curr.value&&(params.push(curr.value),addlabel(curr.value,{type:\"unused\",token:curr})):state.option.inESNext()||warning(\"W104\",curr,\"spread/rest operator\");return params}if(parsed.identifier===!0)return addlabel(parsed.value,{type:\"unused\",token:parsed}),[parsed]}if(next=state.tokens.next,advance(\"(\"),\")\"===state.tokens.next.id)return advance(\")\"),void 0;for(;;){if(_.contains([\"{\",\"[\"],state.tokens.next.id)){tokens=destructuringExpression();for(t in tokens)t=tokens[t],t.id&&(params.push(t.id),addlabel(t.id,{type:\"unused\",token:t.token}))}else\"...\"===state.tokens.next.value?(state.option.inESNext()||warning(\"W104\",state.tokens.next,\"spread/rest operator\"),advance(\"...\"),ident=identifier(!0),params.push(ident),addlabel(ident,{type:\"unused\",token:state.tokens.curr})):(ident=identifier(!0),params.push(ident),addlabel(ident,{type:\"unused\",token:state.tokens.curr}));if(pastDefault&&\"=\"!==state.tokens.next.id&&error(\"E051\",state.tokens.current),\"=\"===state.tokens.next.id&&(state.option.inESNext()||warning(\"W119\",state.tokens.next,\"default parameters\"),advance(\"=\"),pastDefault=!0,expression(10)),\",\"!==state.tokens.next.id)return advance(\")\",next),params;comma()}}function setprop(funct,name,values){funct[\"(properties)\"][name]||(funct[\"(properties)\"][name]={unused:!1}),_.extend(funct[\"(properties)\"][name],values)}function getprop(funct,name,prop){return funct[\"(properties)\"][name]?funct[\"(properties)\"][name][prop]||null:null}function functor(name,token,scope,overwrites){var funct={\"(name)\":name,\"(breakage)\":0,\"(loopage)\":0,\"(scope)\":scope,\"(tokens)\":{},\"(properties)\":{},\"(catch)\":!1,\"(global)\":!1,\"(line)\":null,\"(character)\":null,\"(metrics)\":null,\"(statement)\":null,\"(context)\":null,\"(blockscope)\":null,\"(comparray)\":null,\"(generator)\":null,\"(params)\":null};return token&&_.extend(funct,{\"(line)\":token.line,\"(character)\":token.character,\"(metrics)\":createMetrics(token)}),_.extend(funct,overwrites),funct[\"(context)\"]&&(funct[\"(blockscope)\"]=funct[\"(context)\"][\"(blockscope)\"],funct[\"(comparray)\"]=funct[\"(context)\"][\"(comparray)\"]),funct}function doFunction(name,statement,generator,fatarrowparams){var f,oldOption=state.option,oldIgnored=state.ignored,oldScope=scope;return state.option=Object.create(state.option),state.ignored=Object.create(state.ignored),scope=Object.create(scope),funct=functor(name||'\"'+anonname+'\"',state.tokens.next,scope,{\"(statement)\":statement,\"(context)\":funct,\"(generator)\":generator?!0:null}),f=funct,state.tokens.curr.funct=funct,functions.push(funct),name&&addlabel(name,{type:\"function\"}),funct[\"(params)\"]=functionparams(fatarrowparams),funct[\"(metrics)\"].verifyMaxParametersPerFunction(funct[\"(params)\"]),JSHINT.undefs=_.filter(JSHINT.undefs,function(item){return!_.contains(_.union(fatarrowparams),item[2])}),block(!1,!0,!0,fatarrowparams?!0:!1),!state.option.noyield&&generator&&\"yielded\"!==funct[\"(generator)\"]&&warning(\"W124\",state.tokens.curr),funct[\"(metrics)\"].verifyMaxStatementsPerFunction(),funct[\"(metrics)\"].verifyMaxComplexityPerFunction(),funct[\"(unusedOption)\"]=state.option.unused,scope=oldScope,state.option=oldOption,state.ignored=oldIgnored,funct[\"(last)\"]=state.tokens.curr.line,funct[\"(lastcharacter)\"]=state.tokens.curr.character,_.map(Object.keys(funct),function(key){\"(\"!==key[0]&&funct[\"(blockscope)\"].unshadow(key)}),funct=funct[\"(context)\"],f}function createMetrics(functionStartToken){return{statementCount:0,nestedBlockDepth:-1,ComplexityCount:1,verifyMaxStatementsPerFunction:function(){state.option.maxstatements&&this.statementCount>state.option.maxstatements&&warning(\"W071\",functionStartToken,this.statementCount)},verifyMaxParametersPerFunction:function(params){params=params||[],state.option.maxparams&&params.length>state.option.maxparams&&warning(\"W072\",functionStartToken,params.length)},verifyMaxNestedBlockDepthPerFunction:function(){state.option.maxdepth&&this.nestedBlockDepth>0&&this.nestedBlockDepth===state.option.maxdepth+1&&warning(\"W073\",null,this.nestedBlockDepth)},verifyMaxComplexityPerFunction:function(){var max=state.option.maxcomplexity,cc=this.ComplexityCount;max&&cc>max&&warning(\"W074\",functionStartToken,cc)}}}function increaseComplexityCount(){funct[\"(metrics)\"].ComplexityCount+=1}function checkCondAssignment(expr){var id,paren;switch(expr&&(id=expr.id,paren=expr.paren,\",\"===id&&(expr=expr.exprs[expr.exprs.length-1])&&(id=expr.id,paren=paren||expr.paren)),id){case\"=\":case\"+=\":case\"-=\":case\"*=\":case\"%=\":case\"&=\":case\"|=\":case\"^=\":case\"/=\":paren||state.option.boss||warning(\"W084\")}}function destructuringExpression(){var id,ids,identifiers=[];state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"destructuring expression\");var nextInnerDE=function(){var ident;if(_.contains([\"[\",\"{\"],state.tokens.next.value)){ids=destructuringExpression();for(var id in ids)id=ids[id],identifiers.push({id:id.id,token:id.token})}else\",\"===state.tokens.next.value?identifiers.push({id:null,token:state.tokens.curr}):\"(\"===state.tokens.next.value?(advance(\"(\"),nextInnerDE(),advance(\")\")):(ident=identifier(),ident&&identifiers.push({id:ident,token:state.tokens.curr}))};if(\"[\"===state.tokens.next.value){for(advance(\"[\"),nextInnerDE();\"]\"!==state.tokens.next.value;)advance(\",\"),nextInnerDE();advance(\"]\")}else if(\"{\"===state.tokens.next.value){for(advance(\"{\"),id=identifier(),\":\"===state.tokens.next.value?(advance(\":\"),nextInnerDE()):identifiers.push({id:id,token:state.tokens.curr});\"}\"!==state.tokens.next.value;)advance(\",\"),id=identifier(),\":\"===state.tokens.next.value?(advance(\":\"),nextInnerDE()):identifiers.push({id:id,token:state.tokens.curr});advance(\"}\")}return identifiers}function destructuringExpressionMatch(tokens,value){var first=value.first;first&&_.zip(tokens,Array.isArray(first)?first:[first]).forEach(function(val){var token=val[0],value=val[1];token&&value?token.first=value:token&&token.first&&!value&&warning(\"W080\",token.first,token.first.value)})}function classdef(stmt){return state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"class\"),stmt?(this.name=identifier(),addlabel(this.name,{type:\"unused\",token:state.tokens.curr})):state.tokens.next.identifier&&\"extends\"!==state.tokens.next.value&&(this.name=identifier()),classtail(this),this}function classtail(c){var strictness=state.directive[\"use strict\"];\"extends\"===state.tokens.next.value&&(advance(\"extends\"),c.heritage=expression(10)),state.directive[\"use strict\"]=!0,advance(\"{\"),c.body=state.syntax[\"{\"].nud(!0),state.directive[\"use strict\"]=strictness}function destructuringAssignOrJsonValue(){var block=lookupBlockType();block.notJson?(!state.option.inESNext()&&block.isDestAssign&&warning(\"W104\",state.tokens.curr,\"destructuring assignment\"),statements()):(state.option.laxbreak=!0,state.jsonMode=!0,jsonValue())}function jsonValue(){function jsonObject(){var o={},t=state.tokens.next;if(advance(\"{\"),\"}\"!==state.tokens.next.id)for(;;){if(\"(end)\"===state.tokens.next.id)error(\"E026\",state.tokens.next,t.line);else{if(\"}\"===state.tokens.next.id){warning(\"W094\",state.tokens.curr);break}\",\"===state.tokens.next.id?error(\"E028\",state.tokens.next):\"(string)\"!==state.tokens.next.id&&warning(\"W095\",state.tokens.next,state.tokens.next.value)}if(o[state.tokens.next.value]===!0?warning(\"W075\",state.tokens.next,state.tokens.next.value):\"__proto__\"===state.tokens.next.value&&!state.option.proto||\"__iterator__\"===state.tokens.next.value&&!state.option.iterator?warning(\"W096\",state.tokens.next,state.tokens.next.value):o[state.tokens.next.value]=!0,advance(),advance(\":\"),jsonValue(),\",\"!==state.tokens.next.id)break;advance(\",\")}advance(\"}\")}function jsonArray(){var t=state.tokens.next;if(advance(\"[\"),\"]\"!==state.tokens.next.id)for(;;){if(\"(end)\"===state.tokens.next.id)error(\"E027\",state.tokens.next,t.line);else{if(\"]\"===state.tokens.next.id){warning(\"W094\",state.tokens.curr);break}\",\"===state.tokens.next.id&&error(\"E028\",state.tokens.next)}if(jsonValue(),\",\"!==state.tokens.next.id)break;advance(\",\")}advance(\"]\")}switch(state.tokens.next.id){case\"{\":jsonObject();break;case\"[\":jsonArray();break;case\"true\":case\"false\":case\"null\":case\"(number)\":case\"(string)\":advance();break;case\"-\":advance(\"-\"),advance(\"(number)\");break;default:error(\"E003\",state.tokens.next)}}var anonname,api,declared,exported,funct,functions,global,implied,inblock,indent,lookahead,lex,member,membersOnly,noreach,predefined,scope,stack,unuseds,urls,bang={\"<\":!0,\"<=\":!0,\"==\":!0,\"===\":!0,\"!==\":!0,\"!=\":!0,\">\":!0,\">=\":!0,\"+\":!0,\"-\":!0,\"*\":!0,\"/\":!0,\"%\":!0},boolOptions={asi:!0,bitwise:!0,boss:!0,browser:!0,camelcase:!0,couch:!0,curly:!0,debug:!0,devel:!0,dojo:!0,eqeqeq:!0,eqnull:!0,notypeof:!0,es3:!0,es5:!0,esnext:!0,moz:!0,evil:!0,expr:!0,forin:!0,funcscope:!0,globalstrict:!0,immed:!0,iterator:!0,jasmine:!0,jquery:!0,lastsemic:!0,laxbreak:!0,laxcomma:!0,loopfunc:!0,mootools:!0,multistr:!0,freeze:!0,newcap:!0,noarg:!0,node:!0,noempty:!0,nonbsp:!0,nonew:!0,nonstandard:!0,phantom:!0,plusplus:!0,proto:!0,prototypejs:!0,qunit:!0,rhino:!0,shelljs:!0,typed:!0,undef:!0,scripturl:!0,strict:!0,sub:!0,supernew:!0,validthis:!0,withstmt:!0,worker:!0,wsh:!0,yui:!0,mocha:!0,noyield:!0,onecase:!0,regexp:!0,regexdash:!0},valOptions={maxlen:!1,indent:!1,maxerr:!1,predef:!1,globals:!1,quotmark:!1,scope:!1,maxstatements:!1,maxdepth:!1,maxparams:!1,maxcomplexity:!1,shadow:!1,unused:!0,latedef:!1,ignore:!1},invertedOptions={bitwise:!0,forin:!0,newcap:!0,plusplus:!0,regexp:!0,undef:!0,eqeqeq:!0,strict:!0},renamedOptions={eqeq:\"eqeqeq\",windows:\"wsh\",sloppy:\"strict\"},removedOptions={nomen:!0,onevar:!0,passfail:!0,white:!0,gcl:!0,smarttabs:!0,trailing:!0},functionicity=[\"closure\",\"exception\",\"global\",\"label\",\"outer\",\"unused\",\"var\"],extraModules=[],emitter=new events.EventEmitter;type(\"(number)\",function(){return this}),type(\"(string)\",function(){return this}),type(\"(template)\",function(){return this}),state.syntax[\"(identifier)\"]={type:\"(identifier)\",lbp:0,identifier:!0,nud:function(){var f,block,v=this.value,s=scope[v];if(\"function\"==typeof s?s=void 0:funct[\"(blockscope)\"].current.has(v)||\"boolean\"!=typeof s||(f=funct,funct=functions[0],addlabel(v,{type:\"var\"}),s=funct,funct=f),block=funct[\"(blockscope)\"].getlabel(v),funct===s||block)switch(block?block[v][\"(type)\"]:funct[v]){case\"unused\":block?block[v][\"(type)\"]=\"var\":funct[v]=\"var\";break;case\"unction\":block?block[v][\"(type)\"]=\"function\":funct[v]=\"function\",this[\"function\"]=!0;break;case\"const\":setprop(funct,v,{unused:!1});break;case\"function\":this[\"function\"]=!0;break;case\"label\":warning(\"W037\",state.tokens.curr,v)}else if(funct[\"(global)\"])\"boolean\"!=typeof predefined[v]&&(\"typeof\"!==anonname&&\"delete\"!==anonname||state.tokens.next&&(\".\"===state.tokens.next.value||\"[\"===state.tokens.next.value))&&(funct[\"(comparray)\"].check(v)||isundef(funct,\"W117\",state.tokens.curr,v)),note_implied(state.tokens.curr);else switch(funct[v]){case\"closure\":case\"function\":case\"var\":case\"unused\":warning(\"W038\",state.tokens.curr,v);break;case\"label\":warning(\"W037\",state.tokens.curr,v);break;case\"outer\":case\"global\":break;default:if(s===!0)funct[v]=!0;else if(null===s)warning(\"W039\",state.tokens.curr,v),note_implied(state.tokens.curr);else if(\"object\"!=typeof s)(\"typeof\"!==anonname&&\"delete\"!==anonname||state.tokens.next&&(\".\"===state.tokens.next.value||\"[\"===state.tokens.next.value))&&isundef(funct,\"W117\",state.tokens.curr,v),funct[v]=!0,note_implied(state.tokens.curr);else switch(s[v]){case\"function\":case\"unction\":this[\"function\"]=!0,s[v]=\"closure\",funct[v]=s[\"(global)\"]?\"global\":\"outer\";break;case\"var\":case\"unused\":s[v]=\"closure\",funct[v]=s[\"(global)\"]?\"global\":\"outer\";break;case\"const\":setprop(s,v,{unused:!1});break;case\"closure\":funct[v]=s[\"(global)\"]?\"global\":\"outer\";break;case\"label\":warning(\"W037\",state.tokens.curr,v)}}return this},led:function(){error(\"E033\",state.tokens.next,state.tokens.next.value)}},type(\"(regexp)\",function(){return this}),delim(\"(endline)\"),delim(\"(begin)\"),delim(\"(end)\").reach=!0,delim(\"(error)\").reach=!0,delim(\"}\").reach=!0,delim(\")\"),delim(\"]\"),delim('\"').reach=!0,delim(\"'\").reach=!0,delim(\";\"),delim(\":\").reach=!0,delim(\"#\"),reserve(\"else\"),reserve(\"case\").reach=!0,reserve(\"catch\"),reserve(\"default\").reach=!0,reserve(\"finally\"),reservevar(\"arguments\",function(x){state.directive[\"use strict\"]&&funct[\"(global)\"]&&warning(\"E008\",x)}),reservevar(\"eval\"),reservevar(\"false\"),reservevar(\"Infinity\"),reservevar(\"null\"),reservevar(\"this\",function(x){state.directive[\"use strict\"]&&!state.option.validthis&&(funct[\"(statement)\"]&&funct[\"(name)\"].charAt(0)>\"Z\"||funct[\"(global)\"])&&warning(\"W040\",x)}),reservevar(\"true\"),reservevar(\"undefined\"),assignop(\"=\",\"assign\",20),assignop(\"+=\",\"assignadd\",20),assignop(\"-=\",\"assignsub\",20),assignop(\"*=\",\"assignmult\",20),assignop(\"/=\",\"assigndiv\",20).nud=function(){error(\"E014\")},assignop(\"%=\",\"assignmod\",20),bitwiseassignop(\"&=\",\"assignbitand\",20),bitwiseassignop(\"|=\",\"assignbitor\",20),bitwiseassignop(\"^=\",\"assignbitxor\",20),bitwiseassignop(\"<<=\",\"assignshiftleft\",20),bitwiseassignop(\">>=\",\"assignshiftright\",20),bitwiseassignop(\">>>=\",\"assignshiftrightunsigned\",20),infix(\",\",function(left,that){var expr;if(that.exprs=[left],!comma({peek:!0}))return that;for(;;){if(!(expr=expression(10)))break;if(that.exprs.push(expr),\",\"!==state.tokens.next.value||!comma())break}return that},10,!0),infix(\"?\",function(left,that){return increaseComplexityCount(),that.left=left,that.right=expression(10),advance(\":\"),that[\"else\"]=expression(10),that},30);var orPrecendence=40;infix(\"||\",function(left,that){return increaseComplexityCount(),that.left=left,that.right=expression(orPrecendence),that},orPrecendence),infix(\"&&\",\"and\",50),bitwise(\"|\",\"bitor\",70),bitwise(\"^\",\"bitxor\",80),bitwise(\"&\",\"bitand\",90),relation(\"==\",function(left,right){var eqnull=state.option.eqnull&&(\"null\"===left.value||\"null\"===right.value);switch(!0){case!eqnull&&state.option.eqeqeq:this.from=this.character,warning(\"W116\",this,\"===\",\"==\");break;case isPoorRelation(left):warning(\"W041\",this,\"===\",left.value);break;case isPoorRelation(right):warning(\"W041\",this,\"===\",right.value);break;case isTypoTypeof(right,left):warning(\"W122\",this,right.value);break;case isTypoTypeof(left,right):warning(\"W122\",this,left.value)}return this}),relation(\"===\",function(left,right){return isTypoTypeof(right,left)?warning(\"W122\",this,right.value):isTypoTypeof(left,right)&&warning(\"W122\",this,left.value),this}),relation(\"!=\",function(left,right){var eqnull=state.option.eqnull&&(\"null\"===left.value||\"null\"===right.value);return!eqnull&&state.option.eqeqeq?(this.from=this.character,warning(\"W116\",this,\"!==\",\"!=\")):isPoorRelation(left)?warning(\"W041\",this,\"!==\",left.value):isPoorRelation(right)?warning(\"W041\",this,\"!==\",right.value):isTypoTypeof(right,left)?warning(\"W122\",this,right.value):isTypoTypeof(left,right)&&warning(\"W122\",this,left.value),this}),relation(\"!==\",function(left,right){return isTypoTypeof(right,left)?warning(\"W122\",this,right.value):isTypoTypeof(left,right)&&warning(\"W122\",this,left.value),this}),relation(\"<\"),relation(\">\"),relation(\"<=\"),relation(\">=\"),bitwise(\"<<\",\"shiftleft\",120),bitwise(\">>\",\"shiftright\",120),bitwise(\">>>\",\"shiftrightunsigned\",120),infix(\"in\",\"in\",120),infix(\"instanceof\",\"instanceof\",120),infix(\"+\",function(left,that){var right=expression(130);return left&&right&&\"(string)\"===left.id&&\"(string)\"===right.id?(left.value+=right.value,left.character=right.character,!state.option.scripturl&&reg.javascriptURL.test(left.value)&&warning(\"W050\",left),left):(that.left=left,that.right=right,that)},130),prefix(\"+\",\"num\"),prefix(\"+++\",function(){return warning(\"W007\"),this.right=expression(150),this.arity=\"unary\",this}),infix(\"+++\",function(left){return warning(\"W007\"),this.left=left,this.right=expression(130),this},130),infix(\"-\",\"sub\",130),prefix(\"-\",\"neg\"),prefix(\"---\",function(){return warning(\"W006\"),this.right=expression(150),this.arity=\"unary\",this}),infix(\"---\",function(left){return warning(\"W006\"),this.left=left,this.right=expression(130),this},130),infix(\"*\",\"mult\",140),infix(\"/\",\"div\",140),infix(\"%\",\"mod\",140),suffix(\"++\",\"postinc\"),prefix(\"++\",\"preinc\"),state.syntax[\"++\"].exps=!0,suffix(\"--\",\"postdec\"),prefix(\"--\",\"predec\"),state.syntax[\"--\"].exps=!0,prefix(\"delete\",function(){var p=expression(10);return(!p||\".\"!==p.id&&\"[\"!==p.id)&&warning(\"W051\"),this.first=p,this}).exps=!0,prefix(\"~\",function(){return state.option.bitwise&&warning(\"W052\",this,\"~\"),expression(150),this}),prefix(\"...\",function(){return state.option.inESNext()||warning(\"W104\",this,\"spread/rest operator\"),state.tokens.next.identifier||error(\"E030\",state.tokens.next,state.tokens.next.value),expression(150),this}),prefix(\"!\",function(){return this.right=expression(150),this.arity=\"unary\",this.right||quit(\"E041\",this.line||0),bang[this.right.id]===!0&&warning(\"W018\",this,\"!\"),this}),prefix(\"typeof\",\"typeof\"),prefix(\"new\",function(){var i,c=expression(155);if(c&&\"function\"!==c.id)if(c.identifier)switch(c[\"new\"]=!0,c.value){case\"Number\":case\"String\":case\"Boolean\":case\"Math\":case\"JSON\":warning(\"W053\",state.tokens.prev,c.value);break;case\"Function\":state.option.evil||warning(\"W054\");break;case\"Date\":case\"RegExp\":case\"this\":break;default:\"function\"!==c.id&&(i=c.value.substr(0,1),state.option.newcap&&(\"A\">i||i>\"Z\")&&!_.has(global,c.value)&&warning(\"W055\",state.tokens.curr))}else\".\"!==c.id&&\"[\"!==c.id&&\"(\"!==c.id&&warning(\"W056\",state.tokens.curr);else state.option.supernew||warning(\"W057\",this);return\"(\"===state.tokens.next.id||state.option.supernew||warning(\"W058\",state.tokens.curr,state.tokens.curr.value),this.first=c,this}),state.syntax[\"new\"].exps=!0,prefix(\"void\").exps=!0,infix(\".\",function(left,that){var m=identifier(!1,!0);return\"string\"==typeof m&&countMember(m),that.left=left,that.right=m,m&&\"hasOwnProperty\"===m&&\"=\"===state.tokens.next.value&&warning(\"W001\"),!left||\"arguments\"!==left.value||\"callee\"!==m&&\"caller\"!==m?state.option.evil||!left||\"document\"!==left.value||\"write\"!==m&&\"writeln\"!==m||warning(\"W060\",left):state.option.noarg?warning(\"W059\",left,m):state.directive[\"use strict\"]&&error(\"E008\"),state.option.evil||\"eval\"!==m&&\"execScript\"!==m||warning(\"W061\"),that},160,!0),infix(\"(\",function(left,that){state.option.immed&&left&&!left.immed&&\"function\"===left.id&&warning(\"W062\");var n=0,p=[];if(left&&\"(identifier)\"===left.type&&left.value.match(/^[A-Z]([A-Z0-9_$]*[a-z][A-Za-z0-9_$]*)?$/)&&-1===\"Number String Boolean Date Object Error\".indexOf(left.value)&&(\"Math\"===left.value?warning(\"W063\",left):state.option.newcap&&warning(\"W064\",left)),\")\"!==state.tokens.next.id)for(;p[p.length]=expression(10),n+=1,\",\"===state.tokens.next.id;)comma();return advance(\")\"),\"object\"==typeof left&&(state.option.inES3()&&\"parseInt\"===left.value&&1===n&&warning(\"W065\",state.tokens.curr),state.option.evil||(\"eval\"===left.value||\"Function\"===left.value||\"execScript\"===left.value?(warning(\"W061\",left),p[0]&&\"(string)\"===[0].id&&addInternalSrc(left,p[0].value)):!p[0]||\"(string)\"!==p[0].id||\"setTimeout\"!==left.value&&\"setInterval\"!==left.value?!p[0]||\"(string)\"!==p[0].id||\".\"!==left.value||\"window\"!==left.left.value||\"setTimeout\"!==left.right&&\"setInterval\"!==left.right||(warning(\"W066\",left),addInternalSrc(left,p[0].value)):(warning(\"W066\",left),addInternalSrc(left,p[0].value))),left.identifier||\".\"===left.id||\"[\"===left.id||\"(\"===left.id||\"&&\"===left.id||\"||\"===left.id||\"?\"===left.id||warning(\"W067\",left)),that.left=left,that},155,!0).exps=!0,prefix(\"(\",function(){var bracket,pn,pn1,ret,brackets=[],i=0,parens=1;do pn=peek(i),\"(\"===pn.value?parens+=1:\")\"===pn.value&&(parens-=1),i+=1,pn1=peek(i);while((0!==parens||\")\"!==pn.value)&&\"=>\"!==pn1.value&&\";\"!==pn1.value&&\"(end)\"!==pn1.type);\"function\"===state.tokens.next.id&&(state.tokens.next.immed=!0);var exprs=[];if(\")\"!==state.tokens.next.id)for(;;){if(\"=>\"===pn1.value&&_.contains([\"{\",\"[\"],state.tokens.next.value)){bracket=state.tokens.next,bracket.left=destructuringExpression(),brackets.push(bracket);for(var t in bracket.left)exprs.push(bracket.left[t].token)}else exprs.push(expression(10));if(\",\"!==state.tokens.next.id)break;comma()}return advance(\")\",this),state.option.immed&&exprs[0]&&\"function\"===exprs[0].id&&\"(\"!==state.tokens.next.id&&(\".\"!==state.tokens.next.id||\"call\"!==peek().value&&\"apply\"!==peek().value)&&warning(\"W068\",this),\"=>\"===state.tokens.next.value?exprs:exprs.length?(exprs.length>1?(ret=Object.create(state.syntax[\",\"]),ret.exprs=exprs):ret=exprs[0],ret&&(ret.paren=!0),ret):void 0}),application(\"=>\"),infix(\"[\",function(left,that){var s,e=expression(10);return e&&\"(string)\"===e.type&&(state.option.evil||\"eval\"!==e.value&&\"execScript\"!==e.value||warning(\"W061\",that),countMember(e.value),!state.option.sub&&reg.identifier.test(e.value)&&(s=state.syntax[e.value],s&&isReserved(s)||warning(\"W069\",state.tokens.prev,e.value))),advance(\"]\",that),e&&\"hasOwnProperty\"===e.value&&\"=\"===state.tokens.next.value&&warning(\"W001\"),that.left=left,that.right=e,that},160,!0),prefix(\"[\",function(){var blocktype=lookupBlockType(!0);if(blocktype.isCompArray)return state.option.inESNext()||warning(\"W119\",state.tokens.curr,\"array comprehension\"),comprehensiveArrayExpression();blocktype.isDestAssign&&!state.option.inESNext()&&warning(\"W104\",state.tokens.curr,\"destructuring assignment\");var b=state.tokens.curr.line!==state.tokens.next.line;for(this.first=[],b&&(indent+=state.option.indent,state.tokens.next.from===indent+state.option.indent&&(indent+=state.option.indent));\"(end)\"!==state.tokens.next.id;){for(;\",\"===state.tokens.next.id;)state.option.inES5()||warning(\"W070\"),advance(\",\");if(\"]\"===state.tokens.next.id)break;if(this.first.push(expression(10)),\",\"!==state.tokens.next.id)break;if(comma({allowTrailing:!0}),\"]\"===state.tokens.next.id&&!state.option.inES5(!0)){warning(\"W070\",state.tokens.curr);break}}return b&&(indent-=state.option.indent),advance(\"]\",this),this},160),function(x){x.nud=function(isclassdef){function saveProperty(name,tkn){props[name]&&_.has(props,name)?warning(\"W075\",state.tokens.next,i):props[name]={},props[name].basic=!0,props[name].basictkn=tkn}function saveSetter(name,tkn){props[name]&&_.has(props,name)?(props[name].basic||props[name].setter)&&warning(\"W075\",state.tokens.next,i):props[name]={},props[name].setter=!0,props[name].setterToken=tkn}function saveGetter(name){props[name]&&_.has(props,name)?(props[name].basic||props[name].getter)&&warning(\"W075\",state.tokens.next,i):props[name]={},props[name].getter=!0,props[name].getterToken=state.tokens.curr}var b,f,i,p,t,g,props={},tag=\"\";for(b=state.tokens.curr.line!==state.tokens.next.line,b&&(indent+=state.option.indent,state.tokens.next.from===indent+state.option.indent&&(indent+=state.option.indent));\"}\"!==state.tokens.next.id;){if(isclassdef&&\"static\"===state.tokens.next.value&&(advance(\"static\"),tag=\"static \"),\"get\"===state.tokens.next.value&&\":\"!==peek().id)advance(\"get\"),state.option.inES5(!isclassdef)||error(\"E034\"),i=property_name(),i||state.option.inESNext()||error(\"E035\"),isclassdef&&\"constructor\"===i&&error(\"E049\",state.tokens.next,\"class getter method\",i),i&&saveGetter(tag+i),t=state.tokens.next,f=doFunction(),p=f[\"(params)\"],i&&p&&warning(\"W076\",t,p[0],i);else if(\"set\"===state.tokens.next.value&&\":\"!==peek().id)advance(\"set\"),state.option.inES5(!isclassdef)||error(\"E034\"),i=property_name(),i||state.option.inESNext()||error(\"E035\"),isclassdef&&\"constructor\"===i&&error(\"E049\",state.tokens.next,\"class setter method\",i),i&&saveSetter(tag+i,state.tokens.next),t=state.tokens.next,f=doFunction(),p=f[\"(params)\"],!i||p&&1===p.length||warning(\"W077\",t,i);else{if(g=!1,\"*\"===state.tokens.next.value&&\"(punctuator)\"===state.tokens.next.type&&(state.option.inESNext()||warning(\"W104\",state.tokens.next,\"generator functions\"),advance(\"*\"),g=!0),i=property_name(),saveProperty(tag+i,state.tokens.next),\"string\"!=typeof i)break;\"(\"===state.tokens.next.value?(state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"concise methods\"),doFunction(i,void 0,g)):isclassdef||(advance(\":\"),expression(10))}if(isclassdef&&\"prototype\"===i&&error(\"E049\",state.tokens.next,\"class method\",i),countMember(i),isclassdef)tag=\"\";\nelse{if(\",\"!==state.tokens.next.id)break;comma({allowTrailing:!0,property:!0}),\",\"===state.tokens.next.id?warning(\"W070\",state.tokens.curr):\"}\"!==state.tokens.next.id||state.option.inES5(!0)||warning(\"W070\",state.tokens.curr)}}if(b&&(indent-=state.option.indent),advance(\"}\",this),state.option.inES5())for(var name in props)_.has(props,name)&&props[name].setter&&!props[name].getter&&warning(\"W078\",props[name].setterToken);return this},x.fud=function(){error(\"E036\",state.tokens.curr)}}(delim(\"{\"));var conststatement=stmt(\"const\",function(prefix){var tokens,value,lone;for(state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"const\"),this.first=[];;){var names=[];_.contains([\"{\",\"[\"],state.tokens.next.value)?(tokens=destructuringExpression(),lone=!1):(tokens=[{id:identifier(),token:state.tokens.curr}],lone=!0);for(var t in tokens)tokens.hasOwnProperty(t)&&(t=tokens[t],\"const\"===funct[t.id]&&warning(\"E011\",null,t.id),funct[\"(global)\"]&&predefined[t.id]===!1&&warning(\"W079\",t.token,t.id),t.id&&(addlabel(t.id,{token:t.token,type:\"const\",unused:!0}),names.push(t.token)));if(prefix)break;if(this.first=this.first.concat(names),\"=\"!==state.tokens.next.id&&warning(\"E012\",state.tokens.curr,state.tokens.curr.value),\"=\"===state.tokens.next.id&&(advance(\"=\"),\"undefined\"===state.tokens.next.id&&warning(\"W080\",state.tokens.prev,state.tokens.prev.value),\"=\"===peek(0).id&&state.tokens.next.identifier&&warning(\"W120\",state.tokens.next,state.tokens.next.value),value=expression(10),lone?tokens[0].first=value:destructuringExpressionMatch(names,value)),\",\"!==state.tokens.next.id)break;comma()}return this});conststatement.exps=!0;var varstatement=stmt(\"var\",function(prefix){var tokens,lone,value;for(this.first=[];;){var names=[];_.contains([\"{\",\"[\"],state.tokens.next.value)?(tokens=destructuringExpression(),lone=!1):(tokens=[{id:identifier(),token:state.tokens.curr}],lone=!0);for(var t in tokens)tokens.hasOwnProperty(t)&&(t=tokens[t],state.option.inESNext()&&\"const\"===funct[t.id]&&warning(\"E011\",null,t.id),funct[\"(global)\"]&&predefined[t.id]===!1&&warning(\"W079\",t.token,t.id),t.id&&(addlabel(t.id,{type:\"unused\",token:t.token}),names.push(t.token)));if(prefix)break;if(this.first=this.first.concat(names),\"=\"===state.tokens.next.id&&(advance(\"=\"),\"undefined\"===state.tokens.next.id&&warning(\"W080\",state.tokens.prev,state.tokens.prev.value),\"=\"===peek(0).id&&state.tokens.next.identifier&&warning(\"W120\",state.tokens.next,state.tokens.next.value),value=expression(10),lone?tokens[0].first=value:destructuringExpressionMatch(names,value)),\",\"!==state.tokens.next.id)break;comma()}return this});varstatement.exps=!0;var letstatement=stmt(\"let\",function(prefix){var tokens,lone,value,letblock;for(state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"let\"),\"(\"===state.tokens.next.value?(state.option.inMoz(!0)||warning(\"W118\",state.tokens.next,\"let block\"),advance(\"(\"),funct[\"(blockscope)\"].stack(),letblock=!0):funct[\"(nolet)\"]&&error(\"E048\",state.tokens.curr),this.first=[];;){var names=[];_.contains([\"{\",\"[\"],state.tokens.next.value)?(tokens=destructuringExpression(),lone=!1):(tokens=[{id:identifier(),token:state.tokens.curr.value}],lone=!0);for(var t in tokens)tokens.hasOwnProperty(t)&&(t=tokens[t],state.option.inESNext()&&\"const\"===funct[t.id]&&warning(\"E011\",null,t.id),funct[\"(global)\"]&&predefined[t.id]===!1&&warning(\"W079\",t.token,t.id),t.id&&!funct[\"(nolet)\"]&&(addlabel(t.id,{type:\"unused\",token:t.token,islet:!0}),names.push(t.token)));if(prefix)break;if(this.first=this.first.concat(names),\"=\"===state.tokens.next.id&&(advance(\"=\"),\"undefined\"===state.tokens.next.id&&warning(\"W080\",state.tokens.prev,state.tokens.prev.value),\"=\"===peek(0).id&&state.tokens.next.identifier&&warning(\"W120\",state.tokens.next,state.tokens.next.value),value=expression(10),lone?tokens[0].first=value:destructuringExpressionMatch(names,value)),\",\"!==state.tokens.next.id)break;comma()}return letblock&&(advance(\")\"),block(!0,!0),this.block=!0,funct[\"(blockscope)\"].unstack()),this});letstatement.exps=!0,blockstmt(\"class\",function(){return classdef.call(this,!0)}),blockstmt(\"function\",function(){var generator=!1;\"*\"===state.tokens.next.value&&(advance(\"*\"),state.option.inESNext(!0)?generator=!0:warning(\"W119\",state.tokens.curr,\"function*\")),inblock&&warning(\"W082\",state.tokens.curr);var i=identifier();return\"const\"===funct[i]&&warning(\"E011\",null,i),addlabel(i,{type:\"unction\",token:state.tokens.curr}),doFunction(i,{statement:!0},generator),\"(\"===state.tokens.next.id&&state.tokens.next.line===state.tokens.curr.line&&error(\"E039\"),this}),prefix(\"function\",function(){var generator=!1;\"*\"===state.tokens.next.value&&(state.option.inESNext()||warning(\"W119\",state.tokens.curr,\"function*\"),advance(\"*\"),generator=!0);var i=optionalidentifier();return doFunction(i,void 0,generator),!state.option.loopfunc&&funct[\"(loopage)\"]&&warning(\"W083\"),this}),blockstmt(\"if\",function(){var t=state.tokens.next;return increaseComplexityCount(),state.condition=!0,advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),state.condition=!1,block(!0,!0),\"else\"===state.tokens.next.id&&(advance(\"else\"),\"if\"===state.tokens.next.id||\"switch\"===state.tokens.next.id?statement(!0):block(!0,!0)),this}),blockstmt(\"try\",function(){function doCatch(){var e,oldScope=scope;advance(\"catch\"),advance(\"(\"),scope=Object.create(oldScope),e=state.tokens.next.value,\"(identifier)\"!==state.tokens.next.type&&(e=null,warning(\"E030\",state.tokens.next,e)),advance(),funct=functor(\"(catch)\",state.tokens.next,scope,{\"(context)\":funct,\"(breakage)\":funct[\"(breakage)\"],\"(loopage)\":funct[\"(loopage)\"],\"(statement)\":!1,\"(catch)\":!0}),e&&addlabel(e,{type:\"exception\"}),\"if\"===state.tokens.next.value&&(state.option.inMoz(!0)||warning(\"W118\",state.tokens.curr,\"catch filter\"),advance(\"if\"),expression(0)),advance(\")\"),state.tokens.curr.funct=funct,functions.push(funct),block(!1),scope=oldScope,funct[\"(last)\"]=state.tokens.curr.line,funct[\"(lastcharacter)\"]=state.tokens.curr.character,funct=funct[\"(context)\"]}var b;for(block(!0);\"catch\"===state.tokens.next.id;)increaseComplexityCount(),b&&!state.option.inMoz(!0)&&warning(\"W118\",state.tokens.next,\"multiple catch blocks\"),doCatch(),b=!0;return\"finally\"===state.tokens.next.id?(advance(\"finally\"),block(!0),void 0):(b||error(\"E021\",state.tokens.next,\"catch\",state.tokens.next.value),this)}),blockstmt(\"while\",function(){var t=state.tokens.next;return funct[\"(breakage)\"]+=1,funct[\"(loopage)\"]+=1,increaseComplexityCount(),advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),block(!0,!0),funct[\"(breakage)\"]-=1,funct[\"(loopage)\"]-=1,this}).labelled=!0,blockstmt(\"with\",function(){var t=state.tokens.next;return state.directive[\"use strict\"]?error(\"E010\",state.tokens.curr):state.option.withstmt||warning(\"W085\",state.tokens.curr),advance(\"(\"),expression(0),advance(\")\",t),block(!0,!0),this}),blockstmt(\"switch\",function(){var t=state.tokens.next,g=!1,noindent=!1;for(funct[\"(breakage)\"]+=1,advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),t=state.tokens.next,advance(\"{\"),state.tokens.next.from===indent&&(noindent=!0),noindent||(indent+=state.option.indent),this.cases=[];;)switch(state.tokens.next.id){case\"case\":switch(funct[\"(verb)\"]){case\"yield\":case\"break\":case\"case\":case\"continue\":case\"return\":case\"switch\":case\"throw\":break;default:reg.fallsThrough.test(state.lines[state.tokens.next.line-2])||warning(\"W086\",state.tokens.curr,\"case\")}advance(\"case\"),this.cases.push(expression(0)),increaseComplexityCount(),g=!0,advance(\":\"),funct[\"(verb)\"]=\"case\";break;case\"default\":switch(funct[\"(verb)\"]){case\"yield\":case\"break\":case\"continue\":case\"return\":case\"throw\":break;default:this.cases.length&&(reg.fallsThrough.test(state.lines[state.tokens.next.line-2])||warning(\"W086\",state.tokens.curr,\"default\"))}advance(\"default\"),g=!0,advance(\":\");break;case\"}\":return noindent||(indent-=state.option.indent),advance(\"}\",t),funct[\"(breakage)\"]-=1,funct[\"(verb)\"]=void 0,void 0;case\"(end)\":return error(\"E023\",state.tokens.next,\"}\"),void 0;default:if(indent+=state.option.indent,g)switch(state.tokens.curr.id){case\",\":return error(\"E040\"),void 0;case\":\":g=!1,statements();break;default:return error(\"E025\",state.tokens.curr),void 0}else{if(\":\"!==state.tokens.curr.id)return error(\"E021\",state.tokens.next,\"case\",state.tokens.next.value),void 0;advance(\":\"),error(\"E024\",state.tokens.curr,\":\"),statements()}indent-=state.option.indent}}).labelled=!0,stmt(\"debugger\",function(){return state.option.debug||warning(\"W087\",this),this}).exps=!0,function(){var x=stmt(\"do\",function(){funct[\"(breakage)\"]+=1,funct[\"(loopage)\"]+=1,increaseComplexityCount(),this.first=block(!0,!0),advance(\"while\");var t=state.tokens.next;return advance(\"(\"),checkCondAssignment(expression(0)),advance(\")\",t),funct[\"(breakage)\"]-=1,funct[\"(loopage)\"]-=1,this});x.labelled=!0,x.exps=!0}(),blockstmt(\"for\",function(){var s,t=state.tokens.next,letscope=!1,foreachtok=null;\"each\"===t.value&&(foreachtok=t,advance(\"each\"),state.option.inMoz(!0)||warning(\"W118\",state.tokens.curr,\"for each\")),funct[\"(breakage)\"]+=1,funct[\"(loopage)\"]+=1,increaseComplexityCount(),advance(\"(\");var nextop,i=0,inof=[\"in\",\"of\"];do nextop=peek(i),++i;while(!_.contains(inof,nextop.value)&&\";\"!==nextop.value&&\"(end)\"!==nextop.type);if(_.contains(inof,nextop.value)){if(state.option.inESNext()||\"of\"!==nextop.value||error(\"W104\",nextop,\"for of\"),\"var\"===state.tokens.next.id)advance(\"var\"),state.syntax[\"var\"].fud.call(state.syntax[\"var\"].fud,!0);else if(\"let\"===state.tokens.next.id)advance(\"let\"),letscope=!0,funct[\"(blockscope)\"].stack(),state.syntax.let.fud.call(state.syntax.let.fud,!0);else if(state.tokens.next.identifier){switch(funct[state.tokens.next.value]){case\"unused\":funct[state.tokens.next.value]=\"var\";break;case\"var\":break;default:funct[\"(blockscope)\"].getlabel(state.tokens.next.value)||warning(\"W088\",state.tokens.next,state.tokens.next.value)}advance()}else error(\"E030\",state.tokens.next,state.tokens.next.type),advance();advance(nextop.value),expression(20),advance(\")\",t),s=block(!0,!0),state.option.forin&&s&&(s.length>1||\"object\"!=typeof s[0]||\"if\"!==s[0].value)&&warning(\"W089\",this),funct[\"(breakage)\"]-=1,funct[\"(loopage)\"]-=1}else{if(foreachtok&&error(\"E045\",foreachtok),\";\"!==state.tokens.next.id)if(\"var\"===state.tokens.next.id)advance(\"var\"),state.syntax[\"var\"].fud.call(state.syntax[\"var\"].fud);else if(\"let\"===state.tokens.next.id)advance(\"let\"),letscope=!0,funct[\"(blockscope)\"].stack(),state.syntax.let.fud.call(state.syntax.let.fud);else for(;expression(0,\"for\"),\",\"===state.tokens.next.id;)comma();if(nolinebreak(state.tokens.curr),advance(\";\"),\";\"!==state.tokens.next.id&&checkCondAssignment(expression(0)),nolinebreak(state.tokens.curr),advance(\";\"),\";\"===state.tokens.next.id&&error(\"E021\",state.tokens.next,\")\",\";\"),\")\"!==state.tokens.next.id)for(;expression(0,\"for\"),\",\"===state.tokens.next.id;)comma();advance(\")\",t),block(!0,!0),funct[\"(breakage)\"]-=1,funct[\"(loopage)\"]-=1}return letscope&&funct[\"(blockscope)\"].unstack(),this}).labelled=!0,stmt(\"break\",function(){var v=state.tokens.next.value;return 0===funct[\"(breakage)\"]&&warning(\"W052\",state.tokens.next,this.value),state.option.asi||nolinebreak(this),\";\"===state.tokens.next.id||state.tokens.next.reach||state.tokens.curr.line===state.tokens.next.line&&(\"label\"!==funct[v]?warning(\"W090\",state.tokens.next,v):scope[v]!==funct&&warning(\"W091\",state.tokens.next,v),this.first=state.tokens.next,advance()),reachable(\"break\"),this}).exps=!0,stmt(\"continue\",function(){var v=state.tokens.next.value;return 0===funct[\"(breakage)\"]&&warning(\"W052\",state.tokens.next,this.value),state.option.asi||nolinebreak(this),\";\"===state.tokens.next.id||state.tokens.next.reach?funct[\"(loopage)\"]||warning(\"W052\",state.tokens.next,this.value):state.tokens.curr.line===state.tokens.next.line&&(\"label\"!==funct[v]?warning(\"W090\",state.tokens.next,v):scope[v]!==funct&&warning(\"W091\",state.tokens.next,v),this.first=state.tokens.next,advance()),reachable(\"continue\"),this}).exps=!0,stmt(\"return\",function(){return this.line===state.tokens.next.line?\";\"===state.tokens.next.id||state.tokens.next.reach||(this.first=expression(0),!this.first||\"(punctuator)\"!==this.first.type||\"=\"!==this.first.value||this.first.paren||state.option.boss||warningAt(\"W093\",this.first.line,this.first.character)):\"(punctuator)\"===state.tokens.next.type&&[\"[\",\"{\",\"+\",\"-\"].indexOf(state.tokens.next.value)>-1&&nolinebreak(this),reachable(\"return\"),this}).exps=!0,function(x){x.exps=!0,x.lbp=25}(prefix(\"yield\",function(){var prev=state.tokens.prev;return state.option.inESNext(!0)&&!funct[\"(generator)\"]?\"(catch)\"===funct[\"(name)\"]&&funct[\"(context)\"][\"(generator)\"]||error(\"E046\",state.tokens.curr,\"yield\"):state.option.inESNext()||warning(\"W104\",state.tokens.curr,\"yield\"),funct[\"(generator)\"]=\"yielded\",this.line!==state.tokens.next.line&&state.option.inMoz(!0)?state.option.asi||nolinebreak(this):(\";\"!==state.tokens.next.id&&!state.tokens.next.reach&&state.tokens.next.nud&&(nobreaknonadjacent(state.tokens.curr,state.tokens.next),this.first=expression(10),\"(punctuator)\"!==this.first.type||\"=\"!==this.first.value||this.first.paren||state.option.boss||warningAt(\"W093\",this.first.line,this.first.character)),state.option.inMoz(!0)&&\")\"!==state.tokens.next.id&&(prev.lbp>30||!prev.assign&&!isEndOfExpr()||\"yield\"===prev.id)&&error(\"E050\",this)),this})),stmt(\"throw\",function(){return nolinebreak(this),this.first=expression(20),reachable(\"throw\"),this}).exps=!0,stmt(\"import\",function(){if(state.option.inESNext()||warning(\"W119\",state.tokens.curr,\"import\"),\"(string)\"===state.tokens.next.type)return advance(\"(string)\"),this;if(state.tokens.next.identifier)this.name=identifier(),addlabel(this.name,{type:\"unused\",token:state.tokens.curr});else for(advance(\"{\");;){if(\"}\"===state.tokens.next.value){advance(\"}\");break}var importName;if(\"default\"===state.tokens.next.type?(importName=\"default\",advance(\"default\")):importName=identifier(),\"as\"===state.tokens.next.value&&(advance(\"as\"),importName=identifier()),addlabel(importName,{type:\"unused\",token:state.tokens.curr}),\",\"!==state.tokens.next.value){if(\"}\"===state.tokens.next.value){advance(\"}\");break}error(\"E024\",state.tokens.next,state.tokens.next.value);break}advance(\",\")}return advance(\"from\"),advance(\"(string)\"),this}).exps=!0,stmt(\"export\",function(){if(state.option.inESNext()||warning(\"W119\",state.tokens.curr,\"export\"),\"default\"===state.tokens.next.type)return advance(\"default\"),(\"function\"===state.tokens.next.id||\"class\"===state.tokens.next.id)&&(this.block=!0),this.exportee=expression(10),this;if(\"{\"===state.tokens.next.value){for(advance(\"{\");;){if(exported[identifier()]=!0,\",\"!==state.tokens.next.value){if(\"}\"===state.tokens.next.value){advance(\"}\");break}error(\"E024\",state.tokens.next,state.tokens.next.value);break}advance(\",\")}return this}return\"var\"===state.tokens.next.id?(advance(\"var\"),exported[state.tokens.next.value]=!0,state.syntax[\"var\"].fud.call(state.syntax[\"var\"].fud)):\"let\"===state.tokens.next.id?(advance(\"let\"),exported[state.tokens.next.value]=!0,state.syntax.let.fud.call(state.syntax.let.fud)):\"const\"===state.tokens.next.id?(advance(\"const\"),exported[state.tokens.next.value]=!0,state.syntax[\"const\"].fud.call(state.syntax[\"const\"].fud)):\"function\"===state.tokens.next.id?(this.block=!0,advance(\"function\"),exported[state.tokens.next.value]=!0,state.syntax[\"function\"].fud()):\"class\"===state.tokens.next.id?(this.block=!0,advance(\"class\"),exported[state.tokens.next.value]=!0,state.syntax[\"class\"].fud()):error(\"E024\",state.tokens.next,state.tokens.next.value),this}).exps=!0,FutureReservedWord(\"abstract\"),FutureReservedWord(\"boolean\"),FutureReservedWord(\"byte\"),FutureReservedWord(\"char\"),FutureReservedWord(\"class\",{es5:!0,nud:classdef}),FutureReservedWord(\"double\"),FutureReservedWord(\"enum\",{es5:!0}),FutureReservedWord(\"export\",{es5:!0}),FutureReservedWord(\"extends\",{es5:!0}),FutureReservedWord(\"final\"),FutureReservedWord(\"float\"),FutureReservedWord(\"goto\"),FutureReservedWord(\"implements\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"import\",{es5:!0}),FutureReservedWord(\"int\"),FutureReservedWord(\"interface\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"long\"),FutureReservedWord(\"native\"),FutureReservedWord(\"package\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"private\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"protected\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"public\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"short\"),FutureReservedWord(\"static\",{es5:!0,strictOnly:!0}),FutureReservedWord(\"super\",{es5:!0}),FutureReservedWord(\"synchronized\"),FutureReservedWord(\"transient\"),FutureReservedWord(\"volatile\");var lookupBlockType=function(){var pn,pn1,i=-1,bracketStack=0,ret={};_.contains([\"[\",\"{\"],state.tokens.curr.value)&&(bracketStack+=1);do{if(pn=-1===i?state.tokens.next:peek(i),pn1=peek(i+1),i+=1,_.contains([\"[\",\"{\"],pn.value)?bracketStack+=1:_.contains([\"]\",\"}\"],pn.value)&&(bracketStack-=1),pn.identifier&&\"for\"===pn.value&&1===bracketStack){ret.isCompArray=!0,ret.notJson=!0;break}if(_.contains([\"}\",\"]\"],pn.value)&&\"=\"===pn1.value&&0===bracketStack){ret.isDestAssign=!0,ret.notJson=!0;break}\";\"===pn.value&&(ret.isBlock=!0,ret.notJson=!0)}while(bracketStack>0&&\"(end)\"!==pn.id&&15>i);return ret},arrayComprehension=function(){function declare(v){var l=_current.variables.filter(function(elt){return elt.value===v?(elt.undef=!1,v):void 0}).length;return 0!==l}function use(v){var l=_current.variables.filter(function(elt){return elt.value!==v||elt.undef?void 0:(elt.unused===!0&&(elt.unused=!1),v)}).length;return 0===l}var _current,CompArray=function(){this.mode=\"use\",this.variables=[]},_carrays=[];return{stack:function(){_current=new CompArray,_carrays.push(_current)},unstack:function(){_current.variables.filter(function(v){v.unused&&warning(\"W098\",v.token,v.value),v.undef&&isundef(v.funct,\"W117\",v.token,v.value)}),_carrays.splice(-1,1),_current=_carrays[_carrays.length-1]},setState:function(s){_.contains([\"use\",\"define\",\"generate\",\"filter\"],s)&&(_current.mode=s)},check:function(v){return _current?_current&&\"use\"===_current.mode?(use(v)&&_current.variables.push({funct:funct,token:state.tokens.curr,value:v,undef:!0,unused:!1}),!0):_current&&\"define\"===_current.mode?(declare(v)||_current.variables.push({funct:funct,token:state.tokens.curr,value:v,undef:!1,unused:!0}),!0):_current&&\"generate\"===_current.mode?(isundef(funct,\"W117\",state.tokens.curr,v),!0):_current&&\"filter\"===_current.mode?(use(v)&&isundef(funct,\"W117\",state.tokens.curr,v),!0):!1:void 0}}},blockScope=function(){function _checkBlockLabels(){for(var t in _current)if(\"unused\"===_current[t][\"(type)\"]&&state.option.unused){var tkn=_current[t][\"(token)\"],line=tkn.line,chr=tkn.character;warningAt(\"W098\",line,chr,t)}}var _current={},_variables=[_current];return{stack:function(){_current={},_variables.push(_current)},unstack:function(){_checkBlockLabels(),_variables.splice(_variables.length-1,1),_current=_.last(_variables)},getlabel:function(l){for(var i=_variables.length-1;i>=0;--i)if(_.has(_variables[i],l)&&!_variables[i][l][\"(shadowed)\"])return _variables[i]},shadow:function(name){for(var i=_variables.length-1;i>=0;i--)_.has(_variables[i],name)&&(_variables[i][name][\"(shadowed)\"]=!0)},unshadow:function(name){for(var i=_variables.length-1;i>=0;i--)_.has(_variables[i],name)&&(_variables[i][name][\"(shadowed)\"]=!1)},current:{has:function(t){return _.has(_current,t)},add:function(t,type,tok){_current[t]={\"(type)\":type,\"(token)\":tok,\"(shadowed)\":!1}}}}},itself=function(s,o,g){function each(obj,cb){obj&&(Array.isArray(obj)||\"object\"!=typeof obj||(obj=Object.keys(obj)),obj.forEach(cb))}var i,k,x,optionKeys,newOptionObj={},newIgnoredObj={};if(o=_.clone(o),state.reset(),o&&o.scope?JSHINT.scope=o.scope:(JSHINT.errors=[],JSHINT.undefs=[],JSHINT.internals=[],JSHINT.blacklist={},JSHINT.scope=\"(main)\"),predefined=Object.create(null),combine(predefined,vars.ecmaIdentifiers),combine(predefined,vars.reservedVars),combine(predefined,g||{}),declared=Object.create(null),exported=Object.create(null),o)for(each(o.predef||null,function(item){var slice,prop;\"-\"===item[0]?(slice=item.slice(1),JSHINT.blacklist[slice]=slice):(prop=Object.getOwnPropertyDescriptor(o.predef,item),predefined[item]=prop?prop.value:!1)}),each(o.exported||null,function(item){exported[item]=!0}),delete o.predef,delete o.exported,optionKeys=Object.keys(o),x=0;optionKeys.length>x;x++)/^-W\\d{3}$/g.test(optionKeys[x])?newIgnoredObj[optionKeys[x].slice(1)]=!0:(newOptionObj[optionKeys[x]]=o[optionKeys[x]],\"newcap\"===optionKeys[x]&&o[optionKeys[x]]===!1&&(newOptionObj[\"(explicitNewcap)\"]=!0));if(state.option=newOptionObj,state.ignored=newIgnoredObj,state.option.indent=state.option.indent||4,state.option.maxerr=state.option.maxerr||50,indent=1,global=Object.create(predefined),scope=global,funct=functor(\"(global)\",null,scope,{\"(global)\":!0,\"(blockscope)\":blockScope(),\"(comparray)\":arrayComprehension(),\"(metrics)\":createMetrics(state.tokens.next)}),functions=[funct],urls=[],stack=null,member={},membersOnly=null,implied={},inblock=!1,lookahead=[],unuseds=[],!isString(s)&&!Array.isArray(s))return errorAt(\"E004\",0),!1;api={get isJSON(){return state.jsonMode},getOption:function(name){return state.option[name]||null},getCache:function(name){return state.cache[name]},setCache:function(name,value){state.cache[name]=value},warn:function(code,data){warningAt.apply(null,[code,data.line,data.char].concat(data.data))},on:function(names,listener){names.split(\" \").forEach(function(name){emitter.on(name,listener)}.bind(this))}},emitter.removeAllListeners(),(extraModules||[]).forEach(function(func){func(api)}),state.tokens.prev=state.tokens.curr=state.tokens.next=state.syntax[\"(begin)\"],lex=new Lexer(s),lex.on(\"warning\",function(ev){warningAt.apply(null,[ev.code,ev.line,ev.character].concat(ev.data))}),lex.on(\"error\",function(ev){errorAt.apply(null,[ev.code,ev.line,ev.character].concat(ev.data))}),lex.on(\"fatal\",function(ev){quit(\"E041\",ev.line,ev.from)}),lex.on(\"Identifier\",function(ev){emitter.emit(\"Identifier\",ev)}),lex.on(\"String\",function(ev){emitter.emit(\"String\",ev)}),lex.on(\"Number\",function(ev){emitter.emit(\"Number\",ev)}),lex.start();for(var name in o)_.has(o,name)&&checkOption(name,state.tokens.curr);assume(),combine(predefined,g||{}),comma.first=!0;try{switch(advance(),state.tokens.next.id){case\"{\":case\"[\":destructuringAssignOrJsonValue();break;default:directives(),state.directive[\"use strict\"]&&(state.option.globalstrict||state.option.node||state.option.phantom||warning(\"W097\",state.tokens.prev)),statements()}advance(state.tokens.next&&\".\"!==state.tokens.next.value?\"(end)\":void 0),funct[\"(blockscope)\"].unstack();var markDefined=function(name,context){do{if(\"string\"==typeof context[name])return\"unused\"===context[name]?context[name]=\"var\":\"unction\"===context[name]&&(context[name]=\"closure\"),!0;context=context[\"(context)\"]}while(context);return!1},clearImplied=function(name,line){if(implied[name]){for(var newImplied=[],i=0;implied[name].length>i;i+=1)implied[name][i]!==line&&newImplied.push(implied[name][i]);0===newImplied.length?delete implied[name]:implied[name]=newImplied}},warnUnused=function(name,tkn,type,unused_opt){var line=tkn.line,chr=tkn.character;void 0===unused_opt&&(unused_opt=state.option.unused),unused_opt===!0&&(unused_opt=\"last-param\");var warnable_types={vars:[\"var\"],\"last-param\":[\"var\",\"param\"],strict:[\"var\",\"param\",\"last-param\"]};unused_opt&&warnable_types[unused_opt]&&-1!==warnable_types[unused_opt].indexOf(type)&&warningAt(\"W098\",line,chr,name),unuseds.push({name:name,line:line,character:chr})},checkUnused=function(func,key){var type=func[key],tkn=func[\"(tokens)\"][key];\"(\"!==key.charAt(0)&&(\"unused\"===type||\"unction\"===type||\"const\"===type)&&(func[\"(params)\"]&&-1!==func[\"(params)\"].indexOf(key)||func[\"(global)\"]&&_.has(exported,key)||(\"const\"!==type||getprop(func,key,\"unused\"))&&warnUnused(key,tkn,\"var\"))};for(i=0;JSHINT.undefs.length>i;i+=1)k=JSHINT.undefs[i].slice(0),markDefined(k[2].value,k[0])?clearImplied(k[2].value,k[2].line):state.option.undef&&warning.apply(warning,k.slice(1));functions.forEach(function(func){if(func[\"(unusedOption)\"]!==!1){for(var key in func)_.has(func,key)&&checkUnused(func,key);if(func[\"(params)\"])for(var type,unused_opt,params=func[\"(params)\"].slice(),param=params.pop();param;){if(type=func[param],unused_opt=func[\"(unusedOption)\"]||state.option.unused,unused_opt=unused_opt===!0?\"last-param\":unused_opt,\"undefined\"===param)return;if(\"unused\"===type||\"unction\"===type)warnUnused(param,func[\"(tokens)\"][param],\"param\",func[\"(unusedOption)\"]);else if(\"last-param\"===unused_opt)return;param=params.pop()}}});for(var key in declared)!_.has(declared,key)||_.has(global,key)||_.has(exported,key)||warnUnused(key,declared[key],\"var\")}catch(err){if(!err||\"JSHintError\"!==err.name)throw err;var nt=state.tokens.next||{};JSHINT.errors.push({scope:\"(main)\",raw:err.raw,code:err.code,reason:err.message,line:err.line||nt.line,character:err.character||nt.from},null)}if(\"(main)\"===JSHINT.scope)for(o=o||{},i=0;JSHINT.internals.length>i;i+=1)k=JSHINT.internals[i],o.scope=k.elem,itself(k.value,o,g);return 0===JSHINT.errors.length};return itself.addModule=function(func){extraModules.push(func)},itself.addModule(style.register),itself.data=function(){var fu,f,i,j,n,globals,data={functions:[],options:state.option},implieds=[],members=[];itself.errors.length&&(data.errors=itself.errors),state.jsonMode&&(data.json=!0);for(n in implied)_.has(implied,n)&&implieds.push({name:n,line:implied[n]});for(implieds.length>0&&(data.implieds=implieds),urls.length>0&&(data.urls=urls),globals=Object.keys(scope),globals.length>0&&(data.globals=globals),i=1;functions.length>i;i+=1){for(f=functions[i],fu={},j=0;functionicity.length>j;j+=1)fu[functionicity[j]]=[];for(j=0;functionicity.length>j;j+=1)0===fu[functionicity[j]].length&&delete fu[functionicity[j]];fu.name=f[\"(name)\"],fu.param=f[\"(params)\"],fu.line=f[\"(line)\"],fu.character=f[\"(character)\"],fu.last=f[\"(last)\"],fu.lastcharacter=f[\"(lastcharacter)\"],fu.metrics={complexity:f[\"(metrics)\"].ComplexityCount,parameters:(f[\"(params)\"]||[]).length,statements:f[\"(metrics)\"].statementCount},data.functions.push(fu)}unuseds.length>0&&(data.unused=unuseds),members=[];for(n in member)if(\"number\"==typeof member[n]){data.member=member;break}return data},itself.jshint=itself,itself}();\"object\"==typeof exports&&exports&&(exports.JSHINT=JSHINT)},{\"./lex.js\":4,\"./messages.js\":5,\"./reg.js\":6,\"./state.js\":7,\"./style.js\":8,\"./vars.js\":9,events:10,underscore:2}],4:[function(_dereq_,module,exports){\"use strict\";function asyncTrigger(){var _checks=[];return{push:function(fn){_checks.push(fn)},check:function(){for(var check=0;_checks.length>check;++check)_checks[check]();_checks.splice(0,_checks.length)}}}function Lexer(source){var lines=source;\"string\"==typeof lines&&(lines=lines.replace(/\\r\\n/g,\"\\n\").replace(/\\r/g,\"\\n\").split(\"\\n\")),lines[0]&&\"#!\"===lines[0].substr(0,2)&&(-1!==lines[0].indexOf(\"node\")&&(state.option.node=!0),lines[0]=\"\"),this.emitter=new events.EventEmitter,this.source=source,this.setLines(lines),this.prereg=!0,this.line=0,this.char=1,this.from=1,this.input=\"\",this.inComment=!1;for(var i=0;state.option.indent>i;i+=1)state.tab+=\" \"}var _=_dereq_(\"underscore\"),events=_dereq_(\"events\"),reg=_dereq_(\"./reg.js\"),state=_dereq_(\"./state.js\").state,unicodeData=_dereq_(\"../data/ascii-identifier-data.js\"),asciiIdentifierStartTable=unicodeData.asciiIdentifierStartTable,asciiIdentifierPartTable=unicodeData.asciiIdentifierPartTable,Token={Identifier:1,Punctuator:2,NumericLiteral:3,StringLiteral:4,Comment:5,Keyword:6,NullLiteral:7,BooleanLiteral:8,RegExp:9,TemplateLiteral:10};Lexer.prototype={_lines:[],getLines:function(){return this._lines=state.lines,this._lines},setLines:function(val){this._lines=val,state.lines=this._lines},peek:function(i){return this.input.charAt(i||0)},skip:function(i){i=i||1,this.char+=i,this.input=this.input.slice(i)},on:function(names,listener){names.split(\" \").forEach(function(name){this.emitter.on(name,listener)}.bind(this))},trigger:function(){this.emitter.emit.apply(this.emitter,Array.prototype.slice.call(arguments))},triggerAsync:function(type,args,checks,fn){checks.push(function(){fn()&&this.trigger(type,args)}.bind(this))},scanPunctuator:function(){var ch2,ch3,ch4,ch1=this.peek();switch(ch1){case\".\":if(/^[0-9]$/.test(this.peek(1)))return null;if(\".\"===this.peek(1)&&\".\"===this.peek(2))return{type:Token.Punctuator,value:\"...\"};case\"(\":case\")\":case\";\":case\",\":case\"{\":case\"}\":case\"[\":case\"]\":case\":\":case\"~\":case\"?\":return{type:Token.Punctuator,value:ch1};case\"#\":return{type:Token.Punctuator,value:ch1};case\"\":return null}return ch2=this.peek(1),ch3=this.peek(2),ch4=this.peek(3),\">\"===ch1&&\">\"===ch2&&\">\"===ch3&&\"=\"===ch4?{type:Token.Punctuator,value:\">>>=\"}:\"=\"===ch1&&\"=\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\"===\"}:\"!\"===ch1&&\"=\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\"!==\"}:\">\"===ch1&&\">\"===ch2&&\">\"===ch3?{type:Token.Punctuator,value:\">>>\"}:\"<\"===ch1&&\"<\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\"<<=\"}:\">\"===ch1&&\">\"===ch2&&\"=\"===ch3?{type:Token.Punctuator,value:\">>=\"}:\"=\"===ch1&&\">\"===ch2?{type:Token.Punctuator,value:ch1+ch2}:ch1===ch2&&\"+-<>&|\".indexOf(ch1)>=0?{type:Token.Punctuator,value:ch1+ch2}:\"<>=!+-*%&|^\".indexOf(ch1)>=0?\"=\"===ch2?{type:Token.Punctuator,value:ch1+ch2}:{type:Token.Punctuator,value:ch1}:\"/\"===ch1?\"=\"===ch2&&/\\/=(?!(\\S*\\/[gim]?))/.test(this.input)?{type:Token.Punctuator,value:\"/=\"}:{type:Token.Punctuator,value:\"/\"}:null},scanComments:function(){function commentToken(label,body,opt){var special=[\"jshint\",\"jslint\",\"members\",\"member\",\"globals\",\"global\",\"exported\"],isSpecial=!1,value=label+body,commentType=\"plain\";return opt=opt||{},opt.isMultiline&&(value+=\"*/\"),special.forEach(function(str){if(!isSpecial&&(\"//\"!==label||\"jshint\"===str)&&(body.substr(0,str.length)===str&&(isSpecial=!0,label+=str,body=body.substr(str.length)),isSpecial||\" \"!==body.charAt(0)||body.substr(1,str.length)!==str||(isSpecial=!0,label=label+\" \"+str,body=body.substr(str.length+1)),isSpecial))switch(str){case\"member\":commentType=\"members\";break;case\"global\":commentType=\"globals\";break;default:commentType=str}}),{type:Token.Comment,commentType:commentType,value:value,body:body,isSpecial:isSpecial,isMultiline:opt.isMultiline||!1,isMalformed:opt.isMalformed||!1}}var ch1=this.peek(),ch2=this.peek(1),rest=this.input.substr(2),startLine=this.line,startChar=this.char;if(\"*\"===ch1&&\"/\"===ch2)return this.trigger(\"error\",{code:\"E018\",line:startLine,character:startChar}),this.skip(2),null;if(\"/\"!==ch1||\"*\"!==ch2&&\"/\"!==ch2)return null;if(\"/\"===ch2)return this.skip(this.input.length),commentToken(\"//\",rest);var body=\"\";if(\"*\"===ch2){for(this.inComment=!0,this.skip(2);\"*\"!==this.peek()||\"/\"!==this.peek(1);)if(\"\"===this.peek()){if(body+=\"\\n\",!this.nextLine())return this.trigger(\"error\",{code:\"E017\",line:startLine,character:startChar}),this.inComment=!1,commentToken(\"/*\",body,{isMultiline:!0,isMalformed:!0})}else body+=this.peek(),this.skip();return this.skip(2),this.inComment=!1,commentToken(\"/*\",body,{isMultiline:!0})}},scanKeyword:function(){var result=/^[a-zA-Z_$][a-zA-Z0-9_$]*/.exec(this.input),keywords=[\"if\",\"in\",\"do\",\"var\",\"for\",\"new\",\"try\",\"let\",\"this\",\"else\",\"case\",\"void\",\"with\",\"enum\",\"while\",\"break\",\"catch\",\"throw\",\"const\",\"yield\",\"class\",\"super\",\"return\",\"typeof\",\"delete\",\"switch\",\"export\",\"import\",\"default\",\"finally\",\"extends\",\"function\",\"continue\",\"debugger\",\"instanceof\"];return result&&keywords.indexOf(result[0])>=0?{type:Token.Keyword,value:result[0]}:null},scanIdentifier:function(){function isNonAsciiIdentifierStart(code){return code>256}function isNonAsciiIdentifierPart(code){return code>256}function isHexDigit(str){return/^[0-9a-fA-F]$/.test(str)}var type,char,id=\"\",index=0,readUnicodeEscapeSequence=function(){if(index+=1,\"u\"!==this.peek(index))return null;var code,ch1=this.peek(index+1),ch2=this.peek(index+2),ch3=this.peek(index+3),ch4=this.peek(index+4);return isHexDigit(ch1)&&isHexDigit(ch2)&&isHexDigit(ch3)&&isHexDigit(ch4)?(code=parseInt(ch1+ch2+ch3+ch4,16),asciiIdentifierPartTable[code]||isNonAsciiIdentifierPart(code)?(index+=5,\"\\\\u\"+ch1+ch2+ch3+ch4):null):null\n}.bind(this),getIdentifierStart=function(){var chr=this.peek(index),code=chr.charCodeAt(0);return 92===code?readUnicodeEscapeSequence():128>code?asciiIdentifierStartTable[code]?(index+=1,chr):null:isNonAsciiIdentifierStart(code)?(index+=1,chr):null}.bind(this),getIdentifierPart=function(){var chr=this.peek(index),code=chr.charCodeAt(0);return 92===code?readUnicodeEscapeSequence():128>code?asciiIdentifierPartTable[code]?(index+=1,chr):null:isNonAsciiIdentifierPart(code)?(index+=1,chr):null}.bind(this);if(char=getIdentifierStart(),null===char)return null;for(id=char;char=getIdentifierPart(),null!==char;)id+=char;switch(id){case\"true\":case\"false\":type=Token.BooleanLiteral;break;case\"null\":type=Token.NullLiteral;break;default:type=Token.Identifier}return{type:type,value:id}},scanNumericLiteral:function(){function isDecimalDigit(str){return/^[0-9]$/.test(str)}function isOctalDigit(str){return/^[0-7]$/.test(str)}function isHexDigit(str){return/^[0-9a-fA-F]$/.test(str)}function isIdentifierStart(ch){return\"$\"===ch||\"_\"===ch||\"\\\\\"===ch||ch>=\"a\"&&\"z\">=ch||ch>=\"A\"&&\"Z\">=ch}var bad,index=0,value=\"\",length=this.input.length,char=this.peek(index);if(\".\"!==char&&!isDecimalDigit(char))return null;if(\".\"!==char){if(value=this.peek(index),index+=1,char=this.peek(index),\"0\"===value){if(\"x\"===char||\"X\"===char){for(index+=1,value+=char;length>index&&(char=this.peek(index),isHexDigit(char));)value+=char,index+=1;return 2>=value.length?{type:Token.NumericLiteral,value:value,isMalformed:!0}:length>index&&(char=this.peek(index),isIdentifierStart(char))?null:{type:Token.NumericLiteral,value:value,base:16,isMalformed:!1}}if(isOctalDigit(char)){for(index+=1,value+=char,bad=!1;length>index;){if(char=this.peek(index),isDecimalDigit(char))bad=!0;else if(!isOctalDigit(char))break;value+=char,index+=1}return length>index&&(char=this.peek(index),isIdentifierStart(char))?null:{type:Token.NumericLiteral,value:value,base:8,isMalformed:!1}}isDecimalDigit(char)&&(index+=1,value+=char)}for(;length>index&&(char=this.peek(index),isDecimalDigit(char));)value+=char,index+=1}if(\".\"===char)for(value+=char,index+=1;length>index&&(char=this.peek(index),isDecimalDigit(char));)value+=char,index+=1;if(\"e\"===char||\"E\"===char){if(value+=char,index+=1,char=this.peek(index),(\"+\"===char||\"-\"===char)&&(value+=this.peek(index),index+=1),char=this.peek(index),!isDecimalDigit(char))return null;for(value+=char,index+=1;length>index&&(char=this.peek(index),isDecimalDigit(char));)value+=char,index+=1}return length>index&&(char=this.peek(index),isIdentifierStart(char))?null:{type:Token.NumericLiteral,value:value,base:10,isMalformed:!isFinite(value)}},scanTemplateLiteral:function(){if(!state.option.esnext||\"`\"!==this.peek())return null;var startLine=this.line,startChar=this.char,jump=1,value=\"\";for(this.skip();\"`\"!==this.peek();){for(;\"\"===this.peek();){if(!this.nextLine())return this.trigger(\"error\",{code:\"E052\",line:startLine,character:startChar}),{type:Token.TemplateLiteral,value:value,isUnclosed:!0};value+=\"\\n\"}var char=this.peek();this.skip(jump),value+=char}return this.skip(),{type:Token.TemplateLiteral,value:value,isUnclosed:!1}},scanStringLiteral:function(checks){var quote=this.peek();if('\"'!==quote&&\"'\"!==quote)return null;this.triggerAsync(\"warning\",{code:\"W108\",line:this.line,character:this.char},checks,function(){return state.jsonMode&&'\"'!==quote});var value=\"\",startLine=this.line,startChar=this.char,allowNewLine=!1;this.skip();outer:for(;this.peek()!==quote;){for(;\"\"===this.peek();){if(allowNewLine?(allowNewLine=!1,this.triggerAsync(\"warning\",{code:\"W043\",line:this.line,character:this.char},checks,function(){return!state.option.multistr}),this.triggerAsync(\"warning\",{code:\"W042\",line:this.line,character:this.char},checks,function(){return state.jsonMode&&state.option.multistr})):this.trigger(\"warning\",{code:\"W112\",line:this.line,character:this.char}),!this.nextLine())return this.trigger(\"error\",{code:\"E029\",line:startLine,character:startChar}),{type:Token.StringLiteral,value:value,isUnclosed:!0,quote:quote};if(this.peek()==quote)break outer}allowNewLine=!1;var char=this.peek(),jump=1;if(\" \">char&&this.trigger(\"warning\",{code:\"W113\",line:this.line,character:this.char,data:[\"<non-printable>\"]}),\"\\\\\"===char)switch(this.skip(),char=this.peek()){case\"'\":this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"\\\\'\"]},checks,function(){return state.jsonMode});break;case\"b\":char=\"\\\\b\";break;case\"f\":char=\"\\\\f\";break;case\"n\":char=\"\\\\n\";break;case\"r\":char=\"\\\\r\";break;case\"t\":char=\"\\\\t\";break;case\"0\":char=\"\\\\0\";var n=parseInt(this.peek(1),10);this.triggerAsync(\"warning\",{code:\"W115\",line:this.line,character:this.char},checks,function(){return n>=0&&7>=n&&state.directive[\"use strict\"]});break;case\"u\":char=String.fromCharCode(parseInt(this.input.substr(1,4),16)),jump=5;break;case\"v\":this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"\\\\v\"]},checks,function(){return state.jsonMode}),char=\"\u000b\";break;case\"x\":var x=parseInt(this.input.substr(1,2),16);this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"\\\\x-\"]},checks,function(){return state.jsonMode}),char=String.fromCharCode(x),jump=3;break;case\"\\\\\":char=\"\\\\\\\\\";break;case'\"':char='\\\\\"';break;case\"/\":break;case\"\":allowNewLine=!0,char=\"\";break;case\"!\":if(\"<\"===value.slice(value.length-2))break;default:this.trigger(\"warning\",{code:\"W044\",line:this.line,character:this.char})}value+=char,this.skip(jump)}return this.skip(),{type:Token.StringLiteral,value:value,isUnclosed:!1,quote:quote}},scanRegExp:function(){var terminated,index=0,length=this.input.length,char=this.peek(),value=char,body=\"\",flags=[],malformed=!1,isCharSet=!1,scanUnexpectedChars=function(){\" \">char&&(malformed=!0,this.trigger(\"warning\",{code:\"W048\",line:this.line,character:this.char})),\"<\"===char&&(malformed=!0,this.trigger(\"warning\",{code:\"W049\",line:this.line,character:this.char,data:[char]}))}.bind(this);if(!this.prereg||\"/\"!==char)return null;for(index+=1,terminated=!1;length>index;)if(char=this.peek(index),value+=char,body+=char,isCharSet)\"]\"===char&&(\"\\\\\"!==this.peek(index-1)||\"\\\\\"===this.peek(index-2))&&(isCharSet=!1),\"\\\\\"===char&&(index+=1,char=this.peek(index),body+=char,value+=char,scanUnexpectedChars()),index+=1;else{if(\"\\\\\"===char){if(index+=1,char=this.peek(index),body+=char,value+=char,scanUnexpectedChars(),\"/\"===char){index+=1;continue}if(\"[\"===char){index+=1;continue}}if(\"[\"!==char){if(\"/\"===char){body=body.substr(0,body.length-1),terminated=!0,index+=1;break}index+=1}else isCharSet=!0,index+=1}if(!terminated)return this.trigger(\"error\",{code:\"E015\",line:this.line,character:this.from}),void this.trigger(\"fatal\",{line:this.line,from:this.from});for(;length>index&&(char=this.peek(index),/[gim]/.test(char));)flags.push(char),value+=char,index+=1;try{RegExp(body,flags.join(\"\"))}catch(err){malformed=!0,this.trigger(\"error\",{code:\"E016\",line:this.line,character:this.char,data:[err.message]})}return{type:Token.RegExp,value:value,flags:flags,isMalformed:malformed}},scanNonBreakingSpaces:function(){return state.option.nonbsp?this.input.search(/(\\u00A0)/):-1},scanUnsafeChars:function(){return this.input.search(reg.unsafeChars)},next:function(checks){this.from=this.char;var start;if(/\\s/.test(this.peek()))for(start=this.char;/\\s/.test(this.peek());)this.from+=1,this.skip();var match=this.scanComments()||this.scanStringLiteral(checks)||this.scanTemplateLiteral();return match?match:(match=this.scanRegExp()||this.scanPunctuator()||this.scanKeyword()||this.scanIdentifier()||this.scanNumericLiteral(),match?(this.skip(match.value.length),match):null)},nextLine:function(){var char;if(this.line>=this.getLines().length)return!1;this.input=this.getLines()[this.line],this.line+=1,this.char=1,this.from=1;var inputTrimmed=this.input.trim(),startsWith=function(){return _.some(arguments,function(prefix){return 0===inputTrimmed.indexOf(prefix)})},endsWith=function(){return _.some(arguments,function(suffix){return-1!==inputTrimmed.indexOf(suffix,inputTrimmed.length-suffix.length)})};if(state.ignoreLinterErrors===!0&&(startsWith(\"/*\",\"//\")||endsWith(\"*/\")||(this.input=\"\")),char=this.scanNonBreakingSpaces(),char>=0&&this.trigger(\"warning\",{code:\"W125\",line:this.line,character:char+1}),this.input=this.input.replace(/\\t/g,state.tab),char=this.scanUnsafeChars(),char>=0&&this.trigger(\"warning\",{code:\"W100\",line:this.line,character:char}),state.option.maxlen&&state.option.maxlen<this.input.length){var inComment=this.inComment||startsWith.call(inputTrimmed,\"//\")||startsWith.call(inputTrimmed,\"/*\"),shouldTriggerError=!inComment||!reg.maxlenException.test(inputTrimmed);shouldTriggerError&&this.trigger(\"warning\",{code:\"W101\",line:this.line,character:this.input.length})}return!0},start:function(){this.nextLine()},token:function(){function isReserved(token,isProperty){if(!token.reserved)return!1;var meta=token.meta;if(meta&&meta.isFutureReservedWord&&state.option.inES5()){if(!meta.es5)return!1;if(meta.strictOnly&&!state.option.strict&&!state.directive[\"use strict\"])return!1;if(isProperty)return!1}return!0}for(var token,checks=asyncTrigger(),create=function(type,value,isProperty){var obj;if(\"(endline)\"!==type&&\"(end)\"!==type&&(this.prereg=!1),\"(punctuator)\"===type){switch(value){case\".\":case\")\":case\"~\":case\"#\":case\"]\":this.prereg=!1;break;default:this.prereg=!0}obj=Object.create(state.syntax[value]||state.syntax[\"(error)\"])}return\"(identifier)\"===type&&((\"return\"===value||\"case\"===value||\"typeof\"===value)&&(this.prereg=!0),_.has(state.syntax,value)&&(obj=Object.create(state.syntax[value]||state.syntax[\"(error)\"]),isReserved(obj,isProperty&&\"(identifier)\"===type)||(obj=null))),obj||(obj=Object.create(state.syntax[type])),obj.identifier=\"(identifier)\"===type,obj.type=obj.type||type,obj.value=value,obj.line=this.line,obj.character=this.char,obj.from=this.from,isProperty&&obj.identifier&&(obj.isProperty=isProperty),obj.check=checks.check,obj}.bind(this);;){if(!this.input.length)return create(this.nextLine()?\"(endline)\":\"(end)\",\"\");if(token=this.next(checks))switch(token.type){case Token.StringLiteral:return this.triggerAsync(\"String\",{line:this.line,\"char\":this.char,from:this.from,value:token.value,quote:token.quote},checks,function(){return!0}),create(\"(string)\",token.value);case Token.TemplateLiteral:return this.trigger(\"Template\",{line:this.line,\"char\":this.char,from:this.from,value:token.value}),create(\"(template)\",token.value);case Token.Identifier:this.trigger(\"Identifier\",{line:this.line,\"char\":this.char,from:this.form,name:token.value,isProperty:\".\"===state.tokens.curr.id});case Token.Keyword:case Token.NullLiteral:case Token.BooleanLiteral:return create(\"(identifier)\",token.value,\".\"===state.tokens.curr.id);case Token.NumericLiteral:return token.isMalformed&&this.trigger(\"warning\",{code:\"W045\",line:this.line,character:this.char,data:[token.value]}),this.triggerAsync(\"warning\",{code:\"W114\",line:this.line,character:this.char,data:[\"0x-\"]},checks,function(){return 16===token.base&&state.jsonMode}),this.triggerAsync(\"warning\",{code:\"W115\",line:this.line,character:this.char},checks,function(){return state.directive[\"use strict\"]&&8===token.base}),this.trigger(\"Number\",{line:this.line,\"char\":this.char,from:this.from,value:token.value,base:token.base,isMalformed:token.malformed}),create(\"(number)\",token.value);case Token.RegExp:return create(\"(regexp)\",token.value);case Token.Comment:if(state.tokens.curr.comment=!0,token.isSpecial)return{id:\"(comment)\",value:token.value,body:token.body,type:token.commentType,isSpecial:token.isSpecial,line:this.line,character:this.char,from:this.from};break;case\"\":break;default:return create(\"(punctuator)\",token.value)}else this.input.length&&(this.trigger(\"error\",{code:\"E024\",line:this.line,character:this.char,data:[this.peek()]}),this.input=\"\")}}},exports.Lexer=Lexer},{\"../data/ascii-identifier-data.js\":1,\"./reg.js\":6,\"./state.js\":7,events:10,underscore:2}],5:[function(_dereq_,module,exports){\"use strict\";var _=_dereq_(\"underscore\"),errors={E001:\"Bad option: '{a}'.\",E002:\"Bad option value.\",E003:\"Expected a JSON value.\",E004:\"Input is neither a string nor an array of strings.\",E005:\"Input is empty.\",E006:\"Unexpected early end of program.\",E007:'Missing \"use strict\" statement.',E008:\"Strict violation.\",E009:\"Option 'validthis' can't be used in a global scope.\",E010:\"'with' is not allowed in strict mode.\",E011:\"const '{a}' has already been declared.\",E012:\"const '{a}' is initialized to 'undefined'.\",E013:\"Attempting to override '{a}' which is a constant.\",E014:\"A regular expression literal can be confused with '/='.\",E015:\"Unclosed regular expression.\",E016:\"Invalid regular expression.\",E017:\"Unclosed comment.\",E018:\"Unbegun comment.\",E019:\"Unmatched '{a}'.\",E020:\"Expected '{a}' to match '{b}' from line {c} and instead saw '{d}'.\",E021:\"Expected '{a}' and instead saw '{b}'.\",E022:\"Line breaking error '{a}'.\",E023:\"Missing '{a}'.\",E024:\"Unexpected '{a}'.\",E025:\"Missing ':' on a case clause.\",E026:\"Missing '}' to match '{' from line {a}.\",E027:\"Missing ']' to match '[' from line {a}.\",E028:\"Illegal comma.\",E029:\"Unclosed string.\",E030:\"Expected an identifier and instead saw '{a}'.\",E031:\"Bad assignment.\",E032:\"Expected a small integer or 'false' and instead saw '{a}'.\",E033:\"Expected an operator and instead saw '{a}'.\",E034:\"get/set are ES5 features.\",E035:\"Missing property name.\",E036:\"Expected to see a statement and instead saw a block.\",E037:null,E038:null,E039:\"Function declarations are not invocable. Wrap the whole function invocation in parens.\",E040:\"Each value should have its own case label.\",E041:\"Unrecoverable syntax error.\",E042:\"Stopping.\",E043:\"Too many errors.\",E044:null,E045:\"Invalid for each loop.\",E046:\"A yield statement shall be within a generator function (with syntax: `function*`)\",E047:null,E048:\"Let declaration not directly within block.\",E049:\"A {a} cannot be named '{b}'.\",E050:\"Mozilla acequires the yield expression to be parenthesized here.\",E051:\"Regular parameters cannot come after default parameters.\",E052:\"Unclosed template literal.\"},warnings={W001:\"'hasOwnProperty' is a really bad name.\",W002:\"Value of '{a}' may be overwritten in IE 8 and earlier.\",W003:\"'{a}' was used before it was defined.\",W004:\"'{a}' is already defined.\",W005:\"A dot following a number can be confused with a decimal point.\",W006:\"Confusing minuses.\",W007:\"Confusing plusses.\",W008:\"A leading decimal point can be confused with a dot: '{a}'.\",W009:\"The array literal notation [] is preferable.\",W010:\"The object literal notation {} is preferable.\",W011:null,W012:null,W013:null,W014:\"Bad line breaking before '{a}'.\",W015:null,W016:\"Unexpected use of '{a}'.\",W017:\"Bad operand.\",W018:\"Confusing use of '{a}'.\",W019:\"Use the isNaN function to compare with NaN.\",W020:\"Read only.\",W021:\"'{a}' is a function.\",W022:\"Do not assign to the exception parameter.\",W023:\"Expected an identifier in an assignment and instead saw a function invocation.\",W024:\"Expected an identifier and instead saw '{a}' (a reserved word).\",W025:\"Missing name in function declaration.\",W026:\"Inner functions should be listed at the top of the outer function.\",W027:\"Unreachable '{a}' after '{b}'.\",W028:\"Label '{a}' on {b} statement.\",W030:\"Expected an assignment or function call and instead saw an expression.\",W031:\"Do not use 'new' for side effects.\",W032:\"Unnecessary semicolon.\",W033:\"Missing semicolon.\",W034:'Unnecessary directive \"{a}\".',W035:\"Empty block.\",W036:\"Unexpected /*member '{a}'.\",W037:\"'{a}' is a statement label.\",W038:\"'{a}' used out of scope.\",W039:\"'{a}' is not allowed.\",W040:\"Possible strict violation.\",W041:\"Use '{a}' to compare with '{b}'.\",W042:\"Avoid EOL escaping.\",W043:\"Bad escaping of EOL. Use option multistr if needed.\",W044:\"Bad or unnecessary escaping.\",W045:\"Bad number '{a}'.\",W046:\"Don't use extra leading zeros '{a}'.\",W047:\"A trailing decimal point can be confused with a dot: '{a}'.\",W048:\"Unexpected control character in regular expression.\",W049:\"Unexpected escaped character '{a}' in regular expression.\",W050:\"JavaScript URL.\",W051:\"Variables should not be deleted.\",W052:\"Unexpected '{a}'.\",W053:\"Do not use {a} as a constructor.\",W054:\"The Function constructor is a form of eval.\",W055:\"A constructor name should start with an uppercase letter.\",W056:\"Bad constructor.\",W057:\"Weird construction. Is 'new' necessary?\",W058:\"Missing '()' invoking a constructor.\",W059:\"Avoid arguments.{a}.\",W060:\"document.write can be a form of eval.\",W061:\"eval can be harmful.\",W062:\"Wrap an immediate function invocation in parens to assist the reader in understanding that the expression is the result of a function, and not the function itself.\",W063:\"Math is not a function.\",W064:\"Missing 'new' prefix when invoking a constructor.\",W065:\"Missing radix parameter.\",W066:\"Implied eval. Consider passing a function instead of a string.\",W067:\"Bad invocation.\",W068:\"Wrapping non-IIFE function literals in parens is unnecessary.\",W069:\"['{a}'] is better written in dot notation.\",W070:\"Extra comma. (it breaks older versions of IE)\",W071:\"This function has too many statements. ({a})\",W072:\"This function has too many parameters. ({a})\",W073:\"Blocks are nested too deeply. ({a})\",W074:\"This function's cyclomatic complexity is too high. ({a})\",W075:\"Duplicate key '{a}'.\",W076:\"Unexpected parameter '{a}' in get {b} function.\",W077:\"Expected a single parameter in set {a} function.\",W078:\"Setter is defined without getter.\",W079:\"Redefinition of '{a}'.\",W080:\"It's not necessary to initialize '{a}' to 'undefined'.\",W081:null,W082:\"Function declarations should not be placed in blocks. Use a function expression or move the statement to the top of the outer function.\",W083:\"Don't make functions within a loop.\",W084:\"Assignment in conditional expression\",W085:\"Don't use 'with'.\",W086:\"Expected a 'break' statement before '{a}'.\",W087:\"Forgotten 'debugger' statement?\",W088:\"Creating global 'for' variable. Should be 'for (var {a} ...'.\",W089:\"The body of a for in should be wrapped in an if statement to filter unwanted properties from the prototype.\",W090:\"'{a}' is not a statement label.\",W091:\"'{a}' is out of scope.\",W093:\"Did you mean to return a conditional instead of an assignment?\",W094:\"Unexpected comma.\",W095:\"Expected a string and instead saw {a}.\",W096:\"The '{a}' key may produce unexpected results.\",W097:'Use the function form of \"use strict\".',W098:\"'{a}' is defined but never used.\",W099:null,W100:\"This character may get silently deleted by one or more browsers.\",W101:\"Line is too long.\",W102:null,W103:\"The '{a}' property is deprecated.\",W104:\"'{a}' is available in ES6 (use esnext option) or Mozilla JS extensions (use moz).\",W105:\"Unexpected {a} in '{b}'.\",W106:\"Identifier '{a}' is not in camel case.\",W107:\"Script URL.\",W108:\"Strings must use doublequote.\",W109:\"Strings must use singlequote.\",W110:\"Mixed double and single quotes.\",W112:\"Unclosed string.\",W113:\"Control character in string: {a}.\",W114:\"Avoid {a}.\",W115:\"Octal literals are not allowed in strict mode.\",W116:\"Expected '{a}' and instead saw '{b}'.\",W117:\"'{a}' is not defined.\",W118:\"'{a}' is only available in Mozilla JavaScript extensions (use moz option).\",W119:\"'{a}' is only available in ES6 (use esnext option).\",W120:\"You might be leaking a variable ({a}) here.\",W121:\"Extending prototype of native object: '{a}'.\",W122:\"Invalid typeof value '{a}'\",W123:\"'{a}' is already defined in outer scope.\",W124:\"A generator function shall contain a yield statement.\",W125:\"This line contains non-breaking spaces: http://jshint.com/doc/options/#nonbsp\"},info={I001:\"Comma warnings can be turned off with 'laxcomma'.\",I002:null,I003:\"ES5 option is now set per default\"};exports.errors={},exports.warnings={},exports.info={},_.each(errors,function(desc,code){exports.errors[code]={code:code,desc:desc}}),_.each(warnings,function(desc,code){exports.warnings[code]={code:code,desc:desc}}),_.each(info,function(desc,code){exports.info[code]={code:code,desc:desc}})},{underscore:2}],6:[function(_dereq_,module,exports){\"use string\";exports.unsafeString=/@cc|<\\/?|script|\\]\\s*\\]|<\\s*!|&lt/i,exports.unsafeChars=/[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,exports.needEsc=/[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/,exports.needEscGlobal=/[\\u0000-\\u001f&<\"\\/\\\\\\u007f-\\u009f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,exports.starSlash=/\\*\\//,exports.identifier=/^([a-zA-Z_$][a-zA-Z0-9_$]*)$/,exports.javascriptURL=/^(?:javascript|jscript|ecmascript|vbscript|livescript)\\s*:/i,exports.fallsThrough=/^\\s*\\/\\*\\s*falls?\\sthrough\\s*\\*\\/\\s*$/,exports.maxlenException=/^(?:(?:\\/\\/|\\/\\*|\\*) ?)?[^ ]+$/},{}],7:[function(_dereq_,module,exports){\"use strict\";var state={syntax:{},reset:function(){this.tokens={prev:null,next:null,curr:null},this.option={},this.ignored={},this.directive={},this.jsonMode=!1,this.jsonWarnings=[],this.lines=[],this.tab=\"\",this.cache={},this.ignoredLines={},this.ignoreLinterErrors=!1}};exports.state=state},{}],8:[function(_dereq_,module,exports){\"use strict\";exports.register=function(linter){linter.on(\"Identifier\",function(data){linter.getOption(\"proto\")||\"__proto__\"===data.name&&linter.warn(\"W103\",{line:data.line,\"char\":data.char,data:[data.name]})}),linter.on(\"Identifier\",function(data){linter.getOption(\"iterator\")||\"__iterator__\"===data.name&&linter.warn(\"W104\",{line:data.line,\"char\":data.char,data:[data.name]})}),linter.on(\"Identifier\",function(data){linter.getOption(\"camelcase\")&&data.name.replace(/^_+|_+$/g,\"\").indexOf(\"_\")>-1&&!data.name.match(/^[A-Z0-9_]*$/)&&linter.warn(\"W106\",{line:data.line,\"char\":data.from,data:[data.name]})}),linter.on(\"String\",function(data){var code,quotmark=linter.getOption(\"quotmark\");quotmark&&(\"single\"===quotmark&&\"'\"!==data.quote&&(code=\"W109\"),\"double\"===quotmark&&'\"'!==data.quote&&(code=\"W108\"),quotmark===!0&&(linter.getCache(\"quotmark\")||linter.setCache(\"quotmark\",data.quote),linter.getCache(\"quotmark\")!==data.quote&&(code=\"W110\")),code&&linter.warn(code,{line:data.line,\"char\":data.char}))}),linter.on(\"Number\",function(data){\".\"===data.value.charAt(0)&&linter.warn(\"W008\",{line:data.line,\"char\":data.char,data:[data.value]}),\".\"===data.value.substr(data.value.length-1)&&linter.warn(\"W047\",{line:data.line,\"char\":data.char,data:[data.value]}),/^00+/.test(data.value)&&linter.warn(\"W046\",{line:data.line,\"char\":data.char,data:[data.value]})}),linter.on(\"String\",function(data){var re=/^(?:javascript|jscript|ecmascript|vbscript|livescript)\\s*:/i;linter.getOption(\"scripturl\")||re.test(data.value)&&linter.warn(\"W107\",{line:data.line,\"char\":data.char})})}},{}],9:[function(_dereq_,module,exports){\"use strict\";exports.reservedVars={arguments:!1,NaN:!1},exports.ecmaIdentifiers={Array:!1,Boolean:!1,Date:!1,decodeURI:!1,decodeURIComponent:!1,encodeURI:!1,encodeURIComponent:!1,Error:!1,eval:!1,EvalError:!1,Function:!1,hasOwnProperty:!1,isFinite:!1,isNaN:!1,JSON:!1,Math:!1,Number:!1,Object:!1,parseInt:!1,parseFloat:!1,RangeError:!1,ReferenceError:!1,RegExp:!1,String:!1,SyntaxError:!1,TypeError:!1,URIError:!1},exports.newEcmaIdentifiers={Set:!1,Map:!1,WeakMap:!1,WeakSet:!1,Proxy:!1,Promise:!1},exports.browser={Audio:!1,Blob:!1,addEventListener:!1,applicationCache:!1,atob:!1,blur:!1,btoa:!1,CanvasGradient:!1,CanvasPattern:!1,CanvasRenderingContext2D:!1,clearInterval:!1,clearTimeout:!1,close:!1,closed:!1,CustomEvent:!1,DOMParser:!1,defaultStatus:!1,document:!1,Element:!1,ElementTimeControl:!1,event:!1,FileReader:!1,FormData:!1,focus:!1,frames:!1,getComputedStyle:!1,HTMLElement:!1,HTMLAnchorElement:!1,HTMLBaseElement:!1,HTMLBlockquoteElement:!1,HTMLBodyElement:!1,HTMLBRElement:!1,HTMLButtonElement:!1,HTMLCanvasElement:!1,HTMLDirectoryElement:!1,HTMLDivElement:!1,HTMLDListElement:!1,HTMLFieldSetElement:!1,HTMLFontElement:!1,HTMLFormElement:!1,HTMLFrameElement:!1,HTMLFrameSetElement:!1,HTMLHeadElement:!1,HTMLHeadingElement:!1,HTMLHRElement:!1,HTMLHtmlElement:!1,HTMLIFrameElement:!1,HTMLImageElement:!1,HTMLInputElement:!1,HTMLIsIndexElement:!1,HTMLLabelElement:!1,HTMLLayerElement:!1,HTMLLegendElement:!1,HTMLLIElement:!1,HTMLLinkElement:!1,HTMLMapElement:!1,HTMLMenuElement:!1,HTMLMetaElement:!1,HTMLModElement:!1,HTMLObjectElement:!1,HTMLOListElement:!1,HTMLOptGroupElement:!1,HTMLOptionElement:!1,HTMLParagraphElement:!1,HTMLParamElement:!1,HTMLPreElement:!1,HTMLQuoteElement:!1,HTMLScriptElement:!1,HTMLSelectElement:!1,HTMLStyleElement:!1,HTMLTableCaptionElement:!1,HTMLTableCellElement:!1,HTMLTableColElement:!1,HTMLTableElement:!1,HTMLTableRowElement:!1,HTMLTableSectionElement:!1,HTMLTextAreaElement:!1,HTMLTitleElement:!1,HTMLUListElement:!1,HTMLVideoElement:!1,history:!1,Image:!1,length:!1,localStorage:!1,location:!1,matchMedia:!1,MessageChannel:!1,MessageEvent:!1,MessagePort:!1,MouseEvent:!1,moveBy:!1,moveTo:!1,MutationObserver:!1,name:!1,Node:!1,NodeFilter:!1,NodeList:!1,navigator:!1,onbeforeunload:!0,onblur:!0,onerror:!0,onfocus:!0,onload:!0,onresize:!0,onunload:!0,open:!1,openDatabase:!1,opener:!1,Option:!1,parent:!1,print:!1,removeEventListener:!1,resizeBy:!1,resizeTo:!1,screen:!1,scroll:!1,scrollBy:!1,scrollTo:!1,sessionStorage:!1,setInterval:!1,setTimeout:!1,SharedWorker:!1,status:!1,SVGAElement:!1,SVGAltGlyphDefElement:!1,SVGAltGlyphElement:!1,SVGAltGlyphItemElement:!1,SVGAngle:!1,SVGAnimateColorElement:!1,SVGAnimateElement:!1,SVGAnimateMotionElement:!1,SVGAnimateTransformElement:!1,SVGAnimatedAngle:!1,SVGAnimatedBoolean:!1,SVGAnimatedEnumeration:!1,SVGAnimatedInteger:!1,SVGAnimatedLength:!1,SVGAnimatedLengthList:!1,SVGAnimatedNumber:!1,SVGAnimatedNumberList:!1,SVGAnimatedPathData:!1,SVGAnimatedPoints:!1,SVGAnimatedPreserveAspectRatio:!1,SVGAnimatedRect:!1,SVGAnimatedString:!1,SVGAnimatedTransformList:!1,SVGAnimationElement:!1,SVGCSSRule:!1,SVGCircleElement:!1,SVGClipPathElement:!1,SVGColor:!1,SVGColorProfileElement:!1,SVGColorProfileRule:!1,SVGComponentTransferFunctionElement:!1,SVGCursorElement:!1,SVGDefsElement:!1,SVGDescElement:!1,SVGDocument:!1,SVGElement:!1,SVGElementInstance:!1,SVGElementInstanceList:!1,SVGEllipseElement:!1,SVGExternalResourcesRequired:!1,SVGFEBlendElement:!1,SVGFEColorMatrixElement:!1,SVGFEComponentTransferElement:!1,SVGFECompositeElement:!1,SVGFEConvolveMatrixElement:!1,SVGFEDiffuseLightingElement:!1,SVGFEDisplacementMapElement:!1,SVGFEDistantLightElement:!1,SVGFEFloodElement:!1,SVGFEFuncAElement:!1,SVGFEFuncBElement:!1,SVGFEFuncGElement:!1,SVGFEFuncRElement:!1,SVGFEGaussianBlurElement:!1,SVGFEImageElement:!1,SVGFEMergeElement:!1,SVGFEMergeNodeElement:!1,SVGFEMorphologyElement:!1,SVGFEOffsetElement:!1,SVGFEPointLightElement:!1,SVGFESpecularLightingElement:!1,SVGFESpotLightElement:!1,SVGFETileElement:!1,SVGFETurbulenceElement:!1,SVGFilterElement:!1,SVGFilterPrimitiveStandardAttributes:!1,SVGFitToViewBox:!1,SVGFontElement:!1,SVGFontFaceElement:!1,SVGFontFaceFormatElement:!1,SVGFontFaceNameElement:!1,SVGFontFaceSrcElement:!1,SVGFontFaceUriElement:!1,SVGForeignObjectElement:!1,SVGGElement:!1,SVGGlyphElement:!1,SVGGlyphRefElement:!1,SVGGradientElement:!1,SVGHKernElement:!1,SVGICCColor:!1,SVGImageElement:!1,SVGLangSpace:!1,SVGLength:!1,SVGLengthList:!1,SVGLineElement:!1,SVGLinearGradientElement:!1,SVGLocatable:!1,SVGMPathElement:!1,SVGMarkerElement:!1,SVGMaskElement:!1,SVGMatrix:!1,SVGMetadataElement:!1,SVGMissingGlyphElement:!1,SVGNumber:!1,SVGNumberList:!1,SVGPaint:!1,SVGPathElement:!1,SVGPathSeg:!1,SVGPathSegArcAbs:!1,SVGPathSegArcRel:!1,SVGPathSegClosePath:!1,SVGPathSegCurvetoCubicAbs:!1,SVGPathSegCurvetoCubicRel:!1,SVGPathSegCurvetoCubicSmoothAbs:!1,SVGPathSegCurvetoCubicSmoothRel:!1,SVGPathSegCurvetoQuadraticAbs:!1,SVGPathSegCurvetoQuadraticRel:!1,SVGPathSegCurvetoQuadraticSmoothAbs:!1,SVGPathSegCurvetoQuadraticSmoothRel:!1,SVGPathSegLinetoAbs:!1,SVGPathSegLinetoHorizontalAbs:!1,SVGPathSegLinetoHorizontalRel:!1,SVGPathSegLinetoRel:!1,SVGPathSegLinetoVerticalAbs:!1,SVGPathSegLinetoVerticalRel:!1,SVGPathSegList:!1,SVGPathSegMovetoAbs:!1,SVGPathSegMovetoRel:!1,SVGPatternElement:!1,SVGPoint:!1,SVGPointList:!1,SVGPolygonElement:!1,SVGPolylineElement:!1,SVGPreserveAspectRatio:!1,SVGRadialGradientElement:!1,SVGRect:!1,SVGRectElement:!1,SVGRenderingIntent:!1,SVGSVGElement:!1,SVGScriptElement:!1,SVGSetElement:!1,SVGStopElement:!1,SVGStringList:!1,SVGStylable:!1,SVGStyleElement:!1,SVGSwitchElement:!1,SVGSymbolElement:!1,SVGTRefElement:!1,SVGTSpanElement:!1,SVGTests:!1,SVGTextContentElement:!1,SVGTextElement:!1,SVGTextPathElement:!1,SVGTextPositioningElement:!1,SVGTitleElement:!1,SVGTransform:!1,SVGTransformList:!1,SVGTransformable:!1,SVGURIReference:!1,SVGUnitTypes:!1,SVGUseElement:!1,SVGVKernElement:!1,SVGViewElement:!1,SVGViewSpec:!1,SVGZoomAndPan:!1,TimeEvent:!1,top:!1,URL:!1,WebSocket:!1,window:!1,Worker:!1,XMLHttpRequest:!1,XMLSerializer:!1,XPathEvaluator:!1,XPathException:!1,XPathExpression:!1,XPathNamespace:!1,XPathNSResolver:!1,XPathResult:!1},exports.devel={alert:!1,confirm:!1,console:!1,Debug:!1,opera:!1,prompt:!1},exports.worker={importScripts:!0,postMessage:!0,self:!0},exports.nonstandard={escape:!1,unescape:!1},exports.couch={require:!1,respond:!1,getRow:!1,emit:!1,send:!1,start:!1,sum:!1,log:!1,exports:!1,module:!1,provides:!1},exports.node={__filename:!1,__dirname:!1,GLOBAL:!1,global:!1,module:!1,acequire:!1,Buffer:!0,console:!0,exports:!0,process:!0,setTimeout:!0,clearTimeout:!0,setInterval:!0,clearInterval:!0,setImmediate:!0,clearImmediate:!0},exports.phantom={phantom:!0,acequire:!0,WebPage:!0,console:!0,exports:!0},exports.qunit={asyncTest:!1,deepEqual:!1,equal:!1,expect:!1,module:!1,notDeepEqual:!1,notEqual:!1,notPropEqual:!1,notStrictEqual:!1,ok:!1,propEqual:!1,QUnit:!1,raises:!1,start:!1,stop:!1,strictEqual:!1,test:!1,\"throws\":!1},exports.rhino={defineClass:!1,deserialize:!1,gc:!1,help:!1,importClass:!1,importPackage:!1,java:!1,load:!1,loadClass:!1,Packages:!1,print:!1,quit:!1,readFile:!1,readUrl:!1,runCommand:!1,seal:!1,serialize:!1,spawn:!1,sync:!1,toint32:!1,version:!1},exports.shelljs={target:!1,echo:!1,exit:!1,cd:!1,pwd:!1,ls:!1,find:!1,cp:!1,rm:!1,mv:!1,mkdir:!1,test:!1,cat:!1,sed:!1,grep:!1,which:!1,dirs:!1,pushd:!1,popd:!1,env:!1,exec:!1,chmod:!1,config:!1,error:!1,tempdir:!1},exports.typed={ArrayBuffer:!1,ArrayBufferView:!1,DataView:!1,Float32Array:!1,Float64Array:!1,Int16Array:!1,Int32Array:!1,Int8Array:!1,Uint16Array:!1,Uint32Array:!1,Uint8Array:!1,Uint8ClampedArray:!1},exports.wsh={ActiveXObject:!0,Enumerator:!0,GetObject:!0,ScriptEngine:!0,ScriptEngineBuildVersion:!0,ScriptEngineMajorVersion:!0,ScriptEngineMinorVersion:!0,VBArray:!0,WSH:!0,WScript:!0,XDomainRequest:!0},exports.dojo={dojo:!1,dijit:!1,dojox:!1,define:!1,require:!1},exports.jquery={$:!1,jQuery:!1},exports.mootools={$:!1,$$:!1,Asset:!1,Browser:!1,Chain:!1,Class:!1,Color:!1,Cookie:!1,Core:!1,Document:!1,DomReady:!1,DOMEvent:!1,DOMReady:!1,Drag:!1,Element:!1,Elements:!1,Event:!1,Events:!1,Fx:!1,Group:!1,Hash:!1,HtmlTable:!1,IFrame:!1,IframeShim:!1,InputValidator:!1,instanceOf:!1,Keyboard:!1,Locale:!1,Mask:!1,MooTools:!1,Native:!1,Options:!1,OverText:!1,Request:!1,Scroller:!1,Slick:!1,Slider:!1,Sortables:!1,Spinner:!1,Swiff:!1,Tips:!1,Type:!1,typeOf:!1,URI:!1,Window:!1},exports.prototypejs={$:!1,$$:!1,$A:!1,$F:!1,$H:!1,$R:!1,$break:!1,$continue:!1,$w:!1,Abstract:!1,Ajax:!1,Class:!1,Enumerable:!1,Element:!1,Event:!1,Field:!1,Form:!1,Hash:!1,Insertion:!1,ObjectRange:!1,PeriodicalExecuter:!1,Position:!1,Prototype:!1,Selector:!1,Template:!1,Toggle:!1,Try:!1,Autocompleter:!1,Builder:!1,Control:!1,Draggable:!1,Draggables:!1,Droppables:!1,Effect:!1,Sortable:!1,SortableObserver:!1,Sound:!1,Scriptaculous:!1},exports.yui={YUI:!1,Y:!1,YUI_config:!1},exports.mocha={describe:!1,it:!1,before:!1,after:!1,beforeEach:!1,afterEach:!1,suite:!1,test:!1,setup:!1,teardown:!1},exports.jasmine={jasmine:!1,describe:!1,it:!1,xit:!1,beforeEach:!1,afterEach:!1,setFixtures:!1,loadFixtures:!1,spyOn:!1,expect:!1,runs:!1,waitsFor:!1,waits:!1}},{}],10:[function(_dereq_,module){function EventEmitter(){this._events=this._events||{},this._maxListeners=this._maxListeners||void 0\n}function isFunction(arg){return\"function\"==typeof arg}function isNumber(arg){return\"number\"==typeof arg}function isObject(arg){return\"object\"==typeof arg&&null!==arg}function isUndefined(arg){return void 0===arg}module.exports=EventEmitter,EventEmitter.EventEmitter=EventEmitter,EventEmitter.prototype._events=void 0,EventEmitter.prototype._maxListeners=void 0,EventEmitter.defaultMaxListeners=10,EventEmitter.prototype.setMaxListeners=function(n){if(!isNumber(n)||0>n||isNaN(n))throw TypeError(\"n must be a positive number\");return this._maxListeners=n,this},EventEmitter.prototype.emit=function(type){var er,handler,len,args,i,listeners;if(this._events||(this._events={}),\"error\"===type&&(!this._events.error||isObject(this._events.error)&&!this._events.error.length))throw er=arguments[1],er instanceof Error?er:TypeError('Uncaught, unspecified \"error\" event.');if(handler=this._events[type],isUndefined(handler))return!1;if(isFunction(handler))switch(arguments.length){case 1:handler.call(this);break;case 2:handler.call(this,arguments[1]);break;case 3:handler.call(this,arguments[1],arguments[2]);break;default:for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];handler.apply(this,args)}else if(isObject(handler)){for(len=arguments.length,args=Array(len-1),i=1;len>i;i++)args[i-1]=arguments[i];for(listeners=handler.slice(),len=listeners.length,i=0;len>i;i++)listeners[i].apply(this,args)}return!0},EventEmitter.prototype.addListener=function(type,listener){var m;if(!isFunction(listener))throw TypeError(\"listener must be a function\");if(this._events||(this._events={}),this._events.newListener&&this.emit(\"newListener\",type,isFunction(listener.listener)?listener.listener:listener),this._events[type]?isObject(this._events[type])?this._events[type].push(listener):this._events[type]=[this._events[type],listener]:this._events[type]=listener,isObject(this._events[type])&&!this._events[type].warned){var m;m=isUndefined(this._maxListeners)?EventEmitter.defaultMaxListeners:this._maxListeners,m&&m>0&&this._events[type].length>m&&(this._events[type].warned=!0,console.error(\"(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.\",this._events[type].length),console.trace())}return this},EventEmitter.prototype.on=EventEmitter.prototype.addListener,EventEmitter.prototype.once=function(type,listener){function g(){this.removeListener(type,g),fired||(fired=!0,listener.apply(this,arguments))}if(!isFunction(listener))throw TypeError(\"listener must be a function\");var fired=!1;return g.listener=listener,this.on(type,g),this},EventEmitter.prototype.removeListener=function(type,listener){var list,position,length,i;if(!isFunction(listener))throw TypeError(\"listener must be a function\");if(!this._events||!this._events[type])return this;if(list=this._events[type],length=list.length,position=-1,list===listener||isFunction(list.listener)&&list.listener===listener)delete this._events[type],this._events.removeListener&&this.emit(\"removeListener\",type,listener);else if(isObject(list)){for(i=length;i-->0;)if(list[i]===listener||list[i].listener&&list[i].listener===listener){position=i;break}if(0>position)return this;1===list.length?(list.length=0,delete this._events[type]):list.splice(position,1),this._events.removeListener&&this.emit(\"removeListener\",type,listener)}return this},EventEmitter.prototype.removeAllListeners=function(type){var key,listeners;if(!this._events)return this;if(!this._events.removeListener)return 0===arguments.length?this._events={}:this._events[type]&&delete this._events[type],this;if(0===arguments.length){for(key in this._events)\"removeListener\"!==key&&this.removeAllListeners(key);return this.removeAllListeners(\"removeListener\"),this._events={},this}if(listeners=this._events[type],isFunction(listeners))this.removeListener(type,listeners);else for(;listeners.length;)this.removeListener(type,listeners[listeners.length-1]);return delete this._events[type],this},EventEmitter.prototype.listeners=function(type){var ret;return ret=this._events&&this._events[type]?isFunction(this._events[type])?[this._events[type]]:this._events[type].slice():[]},EventEmitter.listenerCount=function(emitter,type){var ret;return ret=emitter._events&&emitter._events[type]?isFunction(emitter._events[type])?1:emitter._events[type].length:0}},{}]},{},[3])(3)}),ace.define(\"ace/mode/javascript_worker\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/worker/mirror\",\"ace/mode/javascript/jshint\"],function(acequire,exports,module){\"use strict\";function startRegex(arr){return RegExp(\"^(\"+arr.join(\"|\")+\")\")}var oop=acequire(\"../lib/oop\"),Mirror=acequire(\"../worker/mirror\").Mirror,lint=acequire(\"./javascript/jshint\").JSHINT,disabledWarningsRe=startRegex([\"Bad for in variable '(.+)'.\",'Missing \"use strict\"']),errorsRe=startRegex([\"Unexpected\",\"Expected \",\"Confusing (plus|minus)\",\"\\\\{a\\\\} unterminated regular expression\",\"Unclosed \",\"Unmatched \",\"Unbegun comment\",\"Bad invocation\",\"Missing space after\",\"Missing operator at\"]),infoRe=startRegex([\"Expected an assignment\",\"Bad escapement of EOL\",\"Unexpected comma\",\"Unexpected space\",\"Missing radix parameter.\",\"A leading decimal point can\",\"\\\\['{a}'\\\\] is better written in dot notation.\",\"'{a}' used out of scope\"]),JavaScriptWorker=exports.JavaScriptWorker=function(sender){Mirror.call(this,sender),this.setTimeout(500),this.setOptions()};oop.inherits(JavaScriptWorker,Mirror),function(){this.setOptions=function(options){this.options=options||{esnext:!0,moz:!0,devel:!0,browser:!0,node:!0,laxcomma:!0,laxbreak:!0,lastsemic:!0,onevar:!1,passfail:!1,maxerr:100,expr:!0,multistr:!0,globalstrict:!0},this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.changeOptions=function(newOptions){oop.mixin(this.options,newOptions),this.doc.getValue()&&this.deferredUpdate.schedule(100)},this.isValidJS=function(str){try{eval(\"throw 0;\"+str)}catch(e){if(0===e)return!0}return!1},this.onUpdate=function(){var value=this.doc.getValue();if(value=value.replace(/^#!.*\\n/,\"\\n\"),!value)return this.sender.emit(\"jslint\",[]),void 0;var errors=[],maxErrorLevel=this.isValidJS(value)?\"warning\":\"error\";lint(value,this.options);for(var results=lint.errors,errorAdded=!1,i=0;results.length>i;i++){var error=results[i];if(error){var raw=error.raw,type=\"warning\";if(\"Missing semicolon.\"==raw){var str=error.evidence.substr(error.character);str=str.charAt(str.search(/\\S/)),\"error\"==maxErrorLevel&&str&&/[\\w\\d{(['\"]/.test(str)?(error.reason='Missing \";\" before statement',type=\"error\"):type=\"info\"}else{if(disabledWarningsRe.test(raw))continue;infoRe.test(raw)?type=\"info\":errorsRe.test(raw)?(errorAdded=!0,type=maxErrorLevel):\"'{a}' is not defined.\"==raw?type=\"warning\":\"'{a}' is defined but never used.\"==raw&&(type=\"info\")}errors.push({row:error.line-1,column:error.character-1,text:error.reason,type:type,raw:raw})}}this.sender.emit(\"jslint\",errors)}}.call(JavaScriptWorker.prototype)}),ace.define(\"ace/lib/es5-shim\",[\"require\",\"exports\",\"module\"],function(){function Empty(){}function doesDefinePropertyWork(object){try{return Object.defineProperty(object,\"sentinel\",{}),\"sentinel\"in object}catch(exception){}}function toInteger(n){return n=+n,n!==n?n=0:0!==n&&n!==1/0&&n!==-(1/0)&&(n=(n>0||-1)*Math.floor(Math.abs(n))),n}Function.prototype.bind||(Function.prototype.bind=function(that){var target=this;if(\"function\"!=typeof target)throw new TypeError(\"Function.prototype.bind called on incompatible \"+target);var args=slice.call(arguments,1),bound=function(){if(this instanceof bound){var result=target.apply(this,args.concat(slice.call(arguments)));return Object(result)===result?result:this}return target.apply(that,args.concat(slice.call(arguments)))};return target.prototype&&(Empty.prototype=target.prototype,bound.prototype=new Empty,Empty.prototype=null),bound});var defineGetter,defineSetter,lookupGetter,lookupSetter,supportsAccessors,call=Function.prototype.call,prototypeOfArray=Array.prototype,prototypeOfObject=Object.prototype,slice=prototypeOfArray.slice,_toString=call.bind(prototypeOfObject.toString),owns=call.bind(prototypeOfObject.hasOwnProperty);if((supportsAccessors=owns(prototypeOfObject,\"__defineGetter__\"))&&(defineGetter=call.bind(prototypeOfObject.__defineGetter__),defineSetter=call.bind(prototypeOfObject.__defineSetter__),lookupGetter=call.bind(prototypeOfObject.__lookupGetter__),lookupSetter=call.bind(prototypeOfObject.__lookupSetter__)),2!=[1,2].splice(0).length)if(function(){function makeArray(l){var a=Array(l+2);return a[0]=a[1]=0,a}var lengthBefore,array=[];return array.splice.apply(array,makeArray(20)),array.splice.apply(array,makeArray(26)),lengthBefore=array.length,array.splice(5,0,\"XXX\"),lengthBefore+1==array.length,lengthBefore+1==array.length?!0:void 0}()){var array_splice=Array.prototype.splice;Array.prototype.splice=function(start,deleteCount){return arguments.length?array_splice.apply(this,[void 0===start?0:start,void 0===deleteCount?this.length-start:deleteCount].concat(slice.call(arguments,2))):[]}}else Array.prototype.splice=function(pos,removeCount){var length=this.length;pos>0?pos>length&&(pos=length):void 0==pos?pos=0:0>pos&&(pos=Math.max(length+pos,0)),length>pos+removeCount||(removeCount=length-pos);var removed=this.slice(pos,pos+removeCount),insert=slice.call(arguments,2),add=insert.length;if(pos===length)add&&this.push.apply(this,insert);else{var remove=Math.min(removeCount,length-pos),tailOldPos=pos+remove,tailNewPos=tailOldPos+add-remove,tailCount=length-tailOldPos,lengthAfterRemove=length-remove;if(tailOldPos>tailNewPos)for(var i=0;tailCount>i;++i)this[tailNewPos+i]=this[tailOldPos+i];else if(tailNewPos>tailOldPos)for(i=tailCount;i--;)this[tailNewPos+i]=this[tailOldPos+i];if(add&&pos===lengthAfterRemove)this.length=lengthAfterRemove,this.push.apply(this,insert);else for(this.length=lengthAfterRemove+add,i=0;add>i;++i)this[pos+i]=insert[i]}return removed};Array.isArray||(Array.isArray=function(obj){return\"[object Array]\"==_toString(obj)});var boxedString=Object(\"a\"),splitString=\"a\"!=boxedString[0]||!(0 in boxedString);if(Array.prototype.forEach||(Array.prototype.forEach=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,thisp=arguments[1],i=-1,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError;for(;length>++i;)i in self&&fun.call(thisp,self[i],i,object)}),Array.prototype.map||(Array.prototype.map=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=Array(length),thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(result[i]=fun.call(thisp,self[i],i,object));return result}),Array.prototype.filter||(Array.prototype.filter=function(fun){var value,object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,result=[],thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)i in self&&(value=self[i],fun.call(thisp,value,i,object)&&result.push(value));return result}),Array.prototype.every||(Array.prototype.every=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&!fun.call(thisp,self[i],i,object))return!1;return!0}),Array.prototype.some||(Array.prototype.some=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0,thisp=arguments[1];if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");for(var i=0;length>i;i++)if(i in self&&fun.call(thisp,self[i],i,object))return!0;return!1}),Array.prototype.reduce||(Array.prototype.reduce=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduce of empty array with no initial value\");var result,i=0;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i++];break}if(++i>=length)throw new TypeError(\"reduce of empty array with no initial value\")}for(;length>i;i++)i in self&&(result=fun.call(void 0,result,self[i],i,object));return result}),Array.prototype.reduceRight||(Array.prototype.reduceRight=function(fun){var object=toObject(this),self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):object,length=self.length>>>0;if(\"[object Function]\"!=_toString(fun))throw new TypeError(fun+\" is not a function\");if(!length&&1==arguments.length)throw new TypeError(\"reduceRight of empty array with no initial value\");var result,i=length-1;if(arguments.length>=2)result=arguments[1];else for(;;){if(i in self){result=self[i--];break}if(0>--i)throw new TypeError(\"reduceRight of empty array with no initial value\")}do i in this&&(result=fun.call(void 0,result,self[i],i,object));while(i--);return result}),Array.prototype.indexOf&&-1==[0,1].indexOf(1,2)||(Array.prototype.indexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=0;for(arguments.length>1&&(i=toInteger(arguments[1])),i=i>=0?i:Math.max(0,length+i);length>i;i++)if(i in self&&self[i]===sought)return i;return-1}),Array.prototype.lastIndexOf&&-1==[0,1].lastIndexOf(0,-3)||(Array.prototype.lastIndexOf=function(sought){var self=splitString&&\"[object String]\"==_toString(this)?this.split(\"\"):toObject(this),length=self.length>>>0;if(!length)return-1;var i=length-1;for(arguments.length>1&&(i=Math.min(i,toInteger(arguments[1]))),i=i>=0?i:length-Math.abs(i);i>=0;i--)if(i in self&&sought===self[i])return i;return-1}),Object.getPrototypeOf||(Object.getPrototypeOf=function(object){return object.__proto__||(object.constructor?object.constructor.prototype:prototypeOfObject)}),!Object.getOwnPropertyDescriptor){var ERR_NON_OBJECT=\"Object.getOwnPropertyDescriptor called on a non-object: \";Object.getOwnPropertyDescriptor=function(object,property){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT+object);if(owns(object,property)){var descriptor,getter,setter;if(descriptor={enumerable:!0,configurable:!0},supportsAccessors){var prototype=object.__proto__;object.__proto__=prototypeOfObject;var getter=lookupGetter(object,property),setter=lookupSetter(object,property);if(object.__proto__=prototype,getter||setter)return getter&&(descriptor.get=getter),setter&&(descriptor.set=setter),descriptor}return descriptor.value=object[property],descriptor}}}if(Object.getOwnPropertyNames||(Object.getOwnPropertyNames=function(object){return Object.keys(object)}),!Object.create){var createEmpty;createEmpty=null===Object.prototype.__proto__?function(){return{__proto__:null}}:function(){var empty={};for(var i in empty)empty[i]=null;return empty.constructor=empty.hasOwnProperty=empty.propertyIsEnumerable=empty.isPrototypeOf=empty.toLocaleString=empty.toString=empty.valueOf=empty.__proto__=null,empty},Object.create=function(prototype,properties){var object;if(null===prototype)object=createEmpty();else{if(\"object\"!=typeof prototype)throw new TypeError(\"typeof prototype[\"+typeof prototype+\"] != 'object'\");var Type=function(){};Type.prototype=prototype,object=new Type,object.__proto__=prototype}return void 0!==properties&&Object.defineProperties(object,properties),object}}if(Object.defineProperty){var definePropertyWorksOnObject=doesDefinePropertyWork({}),definePropertyWorksOnDom=\"undefined\"==typeof document||doesDefinePropertyWork(document.createElement(\"div\"));if(!definePropertyWorksOnObject||!definePropertyWorksOnDom)var definePropertyFallback=Object.defineProperty}if(!Object.defineProperty||definePropertyFallback){var ERR_NON_OBJECT_DESCRIPTOR=\"Property description must be an object: \",ERR_NON_OBJECT_TARGET=\"Object.defineProperty called on non-object: \",ERR_ACCESSORS_NOT_SUPPORTED=\"getters & setters can not be defined on this javascript engine\";Object.defineProperty=function(object,property,descriptor){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(ERR_NON_OBJECT_TARGET+object);if(\"object\"!=typeof descriptor&&\"function\"!=typeof descriptor||null===descriptor)throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR+descriptor);if(definePropertyFallback)try{return definePropertyFallback.call(Object,object,property,descriptor)}catch(exception){}if(owns(descriptor,\"value\"))if(supportsAccessors&&(lookupGetter(object,property)||lookupSetter(object,property))){var prototype=object.__proto__;object.__proto__=prototypeOfObject,delete object[property],object[property]=descriptor.value,object.__proto__=prototype}else object[property]=descriptor.value;else{if(!supportsAccessors)throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);owns(descriptor,\"get\")&&defineGetter(object,property,descriptor.get),owns(descriptor,\"set\")&&defineSetter(object,property,descriptor.set)}return object}}Object.defineProperties||(Object.defineProperties=function(object,properties){for(var property in properties)owns(properties,property)&&Object.defineProperty(object,property,properties[property]);return object}),Object.seal||(Object.seal=function(object){return object}),Object.freeze||(Object.freeze=function(object){return object});try{Object.freeze(function(){})}catch(exception){Object.freeze=function(freezeObject){return function(object){return\"function\"==typeof object?object:freezeObject(object)}}(Object.freeze)}if(Object.preventExtensions||(Object.preventExtensions=function(object){return object}),Object.isSealed||(Object.isSealed=function(){return!1}),Object.isFrozen||(Object.isFrozen=function(){return!1}),Object.isExtensible||(Object.isExtensible=function(object){if(Object(object)===object)throw new TypeError;for(var name=\"\";owns(object,name);)name+=\"?\";object[name]=!0;var returnValue=owns(object,name);return delete object[name],returnValue}),!Object.keys){var hasDontEnumBug=!0,dontEnums=[\"toString\",\"toLocaleString\",\"valueOf\",\"hasOwnProperty\",\"isPrototypeOf\",\"propertyIsEnumerable\",\"constructor\"],dontEnumsLength=dontEnums.length;for(var key in{toString:null})hasDontEnumBug=!1;Object.keys=function(object){if(\"object\"!=typeof object&&\"function\"!=typeof object||null===object)throw new TypeError(\"Object.keys called on a non-object\");var keys=[];for(var name in object)owns(object,name)&&keys.push(name);if(hasDontEnumBug)for(var i=0,ii=dontEnumsLength;ii>i;i++){var dontEnum=dontEnums[i];owns(object,dontEnum)&&keys.push(dontEnum)}return keys}}Date.now||(Date.now=function(){return(new Date).getTime()});var ws=\"\t\\n\u000b\\f\\r \\u2028\\u2029\";if(!String.prototype.trim||ws.trim()){ws=\"[\"+ws+\"]\";var trimBeginRegexp=RegExp(\"^\"+ws+ws+\"*\"),trimEndRegexp=RegExp(ws+ws+\"*$\");String.prototype.trim=function(){return(this+\"\").replace(trimBeginRegexp,\"\").replace(trimEndRegexp,\"\")}}var toObject=function(o){if(null==o)throw new TypeError(\"can't convert \"+o+\" to object\");return Object(o)}});";
},{}],21:[function(require,module,exports){
// Browser Request
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// UMD HEADER START 
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
  }
}(this, function () {
// UMD HEADER END

var XHR = XMLHttpRequest
if (!XHR) throw new Error('missing XMLHttpRequest')
request.log = {
  'trace': noop, 'debug': noop, 'info': noop, 'warn': noop, 'error': noop
}

var DEFAULT_TIMEOUT = 3 * 60 * 1000 // 3 minutes

//
// request
//

function request(options, callback) {
  // The entry-point to the API: prep the options object and pass the real work to run_xhr.
  if(typeof callback !== 'function')
    throw new Error('Bad callback given: ' + callback)

  if(!options)
    throw new Error('No options given')

  var options_onResponse = options.onResponse; // Save this for later.

  if(typeof options === 'string')
    options = {'uri':options};
  else
    options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.

  options.onResponse = options_onResponse // And put it back.

  if (options.verbose) request.log = getLogger();

  if(options.url) {
    options.uri = options.url;
    delete options.url;
  }

  if(!options.uri && options.uri !== "")
    throw new Error("options.uri is a required argument");

  if(typeof options.uri != "string")
    throw new Error("options.uri must be a string");

  var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect']
  for (var i = 0; i < unsupported_options.length; i++)
    if(options[ unsupported_options[i] ])
      throw new Error("options." + unsupported_options[i] + " is not supported")

  options.callback = callback
  options.method = options.method || 'GET';
  options.headers = options.headers || {};
  options.body    = options.body || null
  options.timeout = options.timeout || request.DEFAULT_TIMEOUT

  if(options.headers.host)
    throw new Error("Options.headers.host is not supported");

  if(options.json) {
    options.headers.accept = options.headers.accept || 'application/json'
    if(options.method !== 'GET')
      options.headers['content-type'] = 'application/json'

    if(typeof options.json !== 'boolean')
      options.body = JSON.stringify(options.json)
    else if(typeof options.body !== 'string')
      options.body = JSON.stringify(options.body)
  }
  
  //BEGIN QS Hack
  var serialize = function(obj) {
    var str = [];
    for(var p in obj)
      if (obj.hasOwnProperty(p)) {
        str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
      }
    return str.join("&");
  }
  
  if(options.qs){
    var qs = (typeof options.qs == 'string')? options.qs : serialize(options.qs);
    if(options.uri.indexOf('?') !== -1){ //no get params
        options.uri = options.uri+'&'+qs;
    }else{ //existing get params
        options.uri = options.uri+'?'+qs;
    }
  }
  //END QS Hack
  
  //BEGIN FORM Hack
  var multipart = function(obj) {
    //todo: support file type (useful?)
    var result = {};
    result.boundry = '-------------------------------'+Math.floor(Math.random()*1000000000);
    var lines = [];
    for(var p in obj){
        if (obj.hasOwnProperty(p)) {
            lines.push(
                '--'+result.boundry+"\n"+
                'Content-Disposition: form-data; name="'+p+'"'+"\n"+
                "\n"+
                obj[p]+"\n"
            );
        }
    }
    lines.push( '--'+result.boundry+'--' );
    result.body = lines.join('');
    result.length = result.body.length;
    result.type = 'multipart/form-data; boundary='+result.boundry;
    return result;
  }
  
  if(options.form){
    if(typeof options.form == 'string') throw('form name unsupported');
    if(options.method === 'POST'){
        var encoding = (options.encoding || 'application/x-www-form-urlencoded').toLowerCase();
        options.headers['content-type'] = encoding;
        switch(encoding){
            case 'application/x-www-form-urlencoded':
                options.body = serialize(options.form).replace(/%20/g, "+");
                break;
            case 'multipart/form-data':
                var multi = multipart(options.form);
                //options.headers['content-length'] = multi.length;
                options.body = multi.body;
                options.headers['content-type'] = multi.type;
                break;
            default : throw new Error('unsupported encoding:'+encoding);
        }
    }
  }
  //END FORM Hack

  // If onResponse is boolean true, call back immediately when the response is known,
  // not when the full request is complete.
  options.onResponse = options.onResponse || noop
  if(options.onResponse === true) {
    options.onResponse = callback
    options.callback = noop
  }

  // XXX Browsers do not like this.
  //if(options.body)
  //  options.headers['content-length'] = options.body.length;

  // HTTP basic authentication
  if(!options.headers.authorization && options.auth)
    options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);

  return run_xhr(options)
}

var req_seq = 0
function run_xhr(options) {
  var xhr = new XHR
    , timed_out = false
    , is_cors = is_crossDomain(options.uri)
    , supports_cors = ('withCredentials' in xhr)

  req_seq += 1
  xhr.seq_id = req_seq
  xhr.id = req_seq + ': ' + options.method + ' ' + options.uri
  xhr._id = xhr.id // I know I will type "_id" from habit all the time.

  if(is_cors && !supports_cors) {
    var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri)
    cors_err.cors = 'unsupported'
    return options.callback(cors_err, xhr)
  }

  xhr.timeoutTimer = setTimeout(too_late, options.timeout)
  function too_late() {
    timed_out = true
    var er = new Error('ETIMEDOUT')
    er.code = 'ETIMEDOUT'
    er.duration = options.timeout

    request.log.error('Timeout', { 'id':xhr._id, 'milliseconds':options.timeout })
    return options.callback(er, xhr)
  }

  // Some states can be skipped over, so remember what is still incomplete.
  var did = {'response':false, 'loading':false, 'end':false}

  xhr.onreadystatechange = on_state_change
  xhr.open(options.method, options.uri, true) // asynchronous
  if(is_cors)
    xhr.withCredentials = !! options.withCredentials
  xhr.send(options.body)
  return xhr

  function on_state_change(event) {
    if(timed_out)
      return request.log.debug('Ignoring timed out state change', {'state':xhr.readyState, 'id':xhr.id})

    request.log.debug('State change', {'state':xhr.readyState, 'id':xhr.id, 'timed_out':timed_out})

    if(xhr.readyState === XHR.OPENED) {
      request.log.debug('Request started', {'id':xhr.id})
      for (var key in options.headers)
        xhr.setRequestHeader(key, options.headers[key])
    }

    else if(xhr.readyState === XHR.HEADERS_RECEIVED)
      on_response()

    else if(xhr.readyState === XHR.LOADING) {
      on_response()
      on_loading()
    }

    else if(xhr.readyState === XHR.DONE) {
      on_response()
      on_loading()
      on_end()
    }
  }

  function on_response() {
    if(did.response)
      return

    did.response = true
    request.log.debug('Got response', {'id':xhr.id, 'status':xhr.status})
    clearTimeout(xhr.timeoutTimer)
    xhr.statusCode = xhr.status // Node request compatibility

    // Detect failed CORS requests.
    if(is_cors && xhr.statusCode == 0) {
      var cors_err = new Error('CORS request rejected: ' + options.uri)
      cors_err.cors = 'rejected'

      // Do not process this request further.
      did.loading = true
      did.end = true

      return options.callback(cors_err, xhr)
    }

    options.onResponse(null, xhr)
  }

  function on_loading() {
    if(did.loading)
      return

    did.loading = true
    request.log.debug('Response body loading', {'id':xhr.id})
    // TODO: Maybe simulate "data" events by watching xhr.responseText
  }

  function on_end() {
    if(did.end)
      return

    did.end = true
    request.log.debug('Request done', {'id':xhr.id})

    xhr.body = xhr.responseText
    if(options.json) {
      try        { xhr.body = JSON.parse(xhr.responseText) }
      catch (er) { return options.callback(er, xhr)        }
    }

    options.callback(null, xhr, xhr.body)
  }

} // request

request.withCredentials = false;
request.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;

//
// defaults
//

request.defaults = function(options, requester) {
  var def = function (method) {
    var d = function (params, callback) {
      if(typeof params === 'string')
        params = {'uri': params};
      else {
        params = JSON.parse(JSON.stringify(params));
      }
      for (var i in options) {
        if (params[i] === undefined) params[i] = options[i]
      }
      return method(params, callback)
    }
    return d
  }
  var de = def(request)
  de.get = def(request.get)
  de.post = def(request.post)
  de.put = def(request.put)
  de.head = def(request.head)
  return de
}

//
// HTTP method shortcuts
//

var shortcuts = [ 'get', 'put', 'post', 'head' ];
shortcuts.forEach(function(shortcut) {
  var method = shortcut.toUpperCase();
  var func   = shortcut.toLowerCase();

  request[func] = function(opts) {
    if(typeof opts === 'string')
      opts = {'method':method, 'uri':opts};
    else {
      opts = JSON.parse(JSON.stringify(opts));
      opts.method = method;
    }

    var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));
    return request.apply(this, args);
  }
})

//
// CouchDB shortcut
//

request.couch = function(options, callback) {
  if(typeof options === 'string')
    options = {'uri':options}

  // Just use the request API to do JSON.
  options.json = true
  if(options.body)
    options.json = options.body
  delete options.body

  callback = callback || noop

  var xhr = request(options, couch_handler)
  return xhr

  function couch_handler(er, resp, body) {
    if(er)
      return callback(er, resp, body)

    if((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {
      // The body is a Couch JSON object indicating the error.
      er = new Error('CouchDB error: ' + (body.error.reason || body.error.error))
      for (var key in body)
        er[key] = body[key]
      return callback(er, resp, body);
    }

    return callback(er, resp, body);
  }
}

//
// Utility
//

function noop() {}

function getLogger() {
  var logger = {}
    , levels = ['trace', 'debug', 'info', 'warn', 'error']
    , level, i

  for(i = 0; i < levels.length; i++) {
    level = levels[i]

    logger[level] = noop
    if(typeof console !== 'undefined' && console && console[level])
      logger[level] = formatted(console, level)
  }

  return logger
}

function formatted(obj, method) {
  return formatted_logger

  function formatted_logger(str, context) {
    if(typeof context === 'object')
      str += ' ' + JSON.stringify(context)

    return obj[method].call(obj, str)
  }
}

// Return whether a URL is a cross-domain request.
function is_crossDomain(url) {
  var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/

  // jQuery #8138, IE may throw an exception when accessing
  // a field from window.location if document.domain has been set
  var ajaxLocation
  try { ajaxLocation = location.href }
  catch (e) {
    // Use the href attribute of an A element since IE will modify it given document.location
    ajaxLocation = document.createElement( "a" );
    ajaxLocation.href = "";
    ajaxLocation = ajaxLocation.href;
  }

  var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []
    , parts = rurl.exec(url.toLowerCase() )

  var result = !!(
    parts &&
    (  parts[1] != ajaxLocParts[1]
    || parts[2] != ajaxLocParts[2]
    || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))
    )
  )

  //console.debug('is_crossDomain('+url+') -> ' + result)
  return result
}

// MIT License from http://phpjs.org/functions/base64_encode:358
function b64_enc (data) {
    // Encodes string using MIME base64 algorithm
    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc="", tmp_arr = [];

    if (!data) {
        return data;
    }

    // assume utf8 data
    // data = this.utf8_encode(data+'');

    do { // pack three octets into four hexets
        o1 = data.charCodeAt(i++);
        o2 = data.charCodeAt(i++);
        o3 = data.charCodeAt(i++);

        bits = o1<<16 | o2<<8 | o3;

        h1 = bits>>18 & 0x3f;
        h2 = bits>>12 & 0x3f;
        h3 = bits>>6 & 0x3f;
        h4 = bits & 0x3f;

        // use hexets to index into b64, and append result to encoded string
        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
    } while (i < data.length);

    enc = tmp_arr.join('');

    switch (data.length % 3) {
        case 1:
            enc = enc.slice(0, -2) + '==';
        break;
        case 2:
            enc = enc.slice(0, -1) + '=';
        break;
    }

    return enc;
}
    return request;
//UMD FOOTER START
}));
//UMD FOOTER END

},{}],22:[function(require,module,exports){
'use strict';

/**
 * Module dependenices
 */

var typeOf = require('kind-of');
var forOwn = require('for-own');
var isPlainObject = require('is-plain-object');
var mixin = require('mixin-object');


/**
 * Recursively clone native types.
 */

function cloneDeep(val, instanceClone) {
  switch (typeOf(val)) {
  case 'object':
    return cloneObjectDeep(val, instanceClone);
  case 'array':
    return cloneArrayDeep(val, instanceClone);
  default:
    return clone(val);
  }
}

function cloneObjectDeep(obj, instanceClone) {
  if (isPlainObject(obj)) {
    var res = {};
    forOwn(obj, function (obj, key) {
      this[key] = cloneDeep(obj, instanceClone);
    }, res);
    return res;
  } else if (instanceClone) {
    return instanceClone(obj);
  } else {
    return obj;
  }
}

function cloneArrayDeep(arr, instanceClone) {
  var len = arr.length;
  var res = [];
  var i = -1;

  while (++i < len) {
    res[i] = cloneDeep(arr[i], instanceClone);
  }
  return res;
}

function clone(val) {
  switch (typeOf(val)) {
  case 'object':
    return cloneObject(val);
  case 'array':
    return cloneArray(val);
  case 'regexp':
    return cloneRegExp(val);
  case 'date':
    return cloneDate(val);
  default:
    return val;
  }
}

function cloneObject(obj) {
  if (isPlainObject(obj)) {
    return mixin({}, obj);
  } else {
    return obj;
  }
}

function cloneRegExp(re) {
  var flags = '';
  flags += re.multiline ? 'm' : '';
  flags += re.global ? 'g' : '';
  flags += re.ignorecase ? 'i' : '';
  return new RegExp(re.source, flags);
}

function cloneDate(date) {
  return new Date(+date);
}

function cloneArray(arr) {
  return arr.slice();
}

/**
 * Expose `cloneDeep`
 */

module.exports = cloneDeep;
},{"for-own":23,"is-plain-object":25,"kind-of":26,"mixin-object":27}],23:[function(require,module,exports){
/*!
 * for-own <https://github.com/jonschlinkert/for-own>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var forIn = require('for-in');
var hasOwn = Object.prototype.hasOwnProperty;

module.exports = function forOwn(o, fn, thisArg) {
  forIn(o, function (val, key) {
    if (hasOwn.call(o, key)) {
      return fn.call(thisArg, o[key], key, o);
    }
  });
};

},{"for-in":24}],24:[function(require,module,exports){
/*!
 * for-in <https://github.com/jonschlinkert/for-in>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

module.exports = function forIn(o, fn, thisArg) {
  for (var key in o) {
    if (fn.call(thisArg, o[key], key, o) === false) {
      break;
    }
  }
};
},{}],25:[function(require,module,exports){
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */

'use strict';

module.exports = function isPlainObject(o) {
  return !!o && typeof o === 'object' && o.constructor === Object;
};
},{}],26:[function(require,module,exports){
'use strict';

/**
 * Get the native `typeof` a value.
 *
 * @param  {*} `val`
 * @return {*} Native javascript type
 */

module.exports = function typeOf(val) {
  if (val === null) {
    return 'null';
  }

  if (val === undefined) {
    return 'undefined';
  }

  if (typeof val !== 'object') {
    return typeof val;
  }

  if (Array.isArray(val)) {
    return 'array';
  }

  return {}.toString.call(val)
    .slice(8, -1).toLowerCase();
};

},{}],27:[function(require,module,exports){
/*!
 * mixin-object <https://github.com/jonschlinkert/mixin-object>
 *
 * Copyright (c) 2014 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */

'use strict';

var forOwn = require('for-own');

module.exports = function mixIn(o) {
  var args = [].slice.call(arguments);
  var len = args.length;

  if (o == null) {
    return {};
  }

  if (len === 0) {
    return o;
  }

  function copy(value, key) {
    this[key] = value;
  }

  for (var i = 0; i < len; i++) {
    var obj = args[i];
    if (obj != null) {
      forOwn(obj, copy, o);
    }
  }
  return o;
};
},{"for-own":23}],28:[function(require,module,exports){
'use strict'

/**
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Computes the difference between two texts to create a patch.
 * Applies the patch onto another text, allowing for errors.
 * @author fraser@google.com (Neil Fraser)
 */

/**
 * Class containing the diff, match and patch methods.
 * @constructor
 */
function diff_match_patch() {

  // Defaults.
  // Redefine these in your program to override the defaults.

  // Number of seconds to map a diff before giving up (0 for infinity).
  this.Diff_Timeout = 1.0;
  // Cost of an empty edit operation in terms of edit characters.
  this.Diff_EditCost = 4;
  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).
  this.Match_Threshold = 0.5;
  // How far to search for a match (0 = exact location, 1000+ = broad match).
  // A match this many characters away from the expected location will add
  // 1.0 to the score (0.0 is a perfect match).
  this.Match_Distance = 1000;
  // When deleting a large block of text (over ~64 characters), how close do
  // the contents have to be to match the expected contents. (0.0 = perfection,
  // 1.0 = very loose).  Note that Match_Threshold controls how closely the
  // end points of a delete need to match.
  this.Patch_DeleteThreshold = 0.5;
  // Chunk size for context length.
  this.Patch_Margin = 4;

  // The number of bits in an int.
  this.Match_MaxBits = 32;
}


//  DIFF FUNCTIONS


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;

/** @typedef {{0: number, 1: string}} */
diff_match_patch.Diff;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean=} opt_checklines Optional speedup flag. If present and false,
 *     then don't run a line-level diff first to identify the changed areas.
 *     Defaults to true, which does a faster, slightly less optimal diff.
 * @param {number} opt_deadline Optional time when the diff should be complete
 *     by.  Used internally for recursive calls.  Users should set DiffTimeout
 *     instead.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 */
diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,
    opt_deadline) {
  // Set a deadline by which time the diff must be complete.
  if (typeof opt_deadline == 'undefined') {
    if (this.Diff_Timeout <= 0) {
      opt_deadline = Number.MAX_VALUE;
    } else {
      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;
    }
  }
  var deadline = opt_deadline;

  // Check for null inputs.
  if (text1 == null || text2 == null) {
    throw new Error('Null input. (diff_main)');
  }

  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  if (typeof opt_checklines == 'undefined') {
    opt_checklines = true;
  }
  var checklines = opt_checklines;

  // Trim off common prefix (speedup).
  var commonlength = this.diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = this.diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = this.diff_compute_(text1, text2, checklines, deadline);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  this.diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {boolean} checklines Speedup flag.  If false, then don't run a
 *     line-level diff first to identify the changed areas.
 *     If true, then run a faster, slightly less optimal diff.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,
    deadline) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = this.diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  if (checklines && text1.length > 100 && text2.length > 100) {
    return this.diff_lineMode_(text1, text2, deadline);
  }

  return this.diff_bisect_(text1, text2, deadline);
};


/**
 * Do a quick line-level diff on both strings, then rediff the parts for
 * greater accuracy.
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time when the diff should be complete by.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
  // Scan the text on a line-by-line basis first.
  var a = this.diff_linesToChars_(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  var linearray = a.lineArray;

  var diffs = this.diff_main(text1, text2, false, deadline);

  // Convert the diff back to original text.
  this.diff_charsToLines_(diffs, linearray);
  // Eliminate freak matches (e.g. blank lines)
  this.diff_cleanupSemantic(diffs);

  // Rediff any replacement blocks, this time character-by-character.
  // Add a dummy entry at the end.
  diffs.push([DIFF_EQUAL, '']);
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete >= 1 && count_insert >= 1) {
          // Delete the offending records and add the merged ones.
          diffs.splice(pointer - count_delete - count_insert,
                       count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          var a = this.diff_main(text_delete, text_insert, false, deadline);
          for (var j = a.length - 1; j >= 0; j--) {
            diffs.splice(pointer, 0, a[j]);
          }
          pointer = pointer + a.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
    pointer++;
  }
  diffs.pop();  // Remove the dummy entry at the end.

  return diffs;
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Bail out if deadline is reached.
    if ((new Date()).getTime() > deadline) {
      break;
    }

    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @param {number} deadline Time at which to bail if not yet complete.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @private
 */
diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,
    deadline) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = this.diff_main(text1a, text2a, false, deadline);
  var diffsb = this.diff_main(text1b, text2b, false, deadline);

  return diffs.concat(diffsb);
};


/**
 * Split two texts into an array of strings.  Reduce the texts to a string of
 * hashes where each Unicode character represents one line.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}
 *     An object containing the encoded text1, the encoded text2 and
 *     the array of unique strings.
 *     The zeroth element of the array of unique strings is intentionally blank.
 * @private
 */
diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
  var lineArray = [];  // e.g. lineArray[4] == 'Hello\n'
  var lineHash = {};   // e.g. lineHash['Hello\n'] == 4

  // '\x00' is a valid character, but various debuggers don't like it.
  // So we'll insert a junk entry to avoid generating a null character.
  lineArray[0] = '';

  /**
   * Split a text into an array of strings.  Reduce the texts to a string of
   * hashes where each Unicode character represents one line.
   * Modifies linearray and linehash through being a closure.
   * @param {string} text String to encode.
   * @return {string} Encoded string.
   * @private
   */
  function diff_linesToCharsMunge_(text) {
    var chars = '';
    // Walk the text, pulling out a substring for each line.
    // text.split('\n') would would temporarily double our memory footprint.
    // Modifying text would create many large strings to garbage collect.
    var lineStart = 0;
    var lineEnd = -1;
    // Keeping our own length variable is faster than looking it up.
    var lineArrayLength = lineArray.length;
    while (lineEnd < text.length - 1) {
      lineEnd = text.indexOf('\n', lineStart);
      if (lineEnd == -1) {
        lineEnd = text.length - 1;
      }
      var line = text.substring(lineStart, lineEnd + 1);
      lineStart = lineEnd + 1;

      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :
          (lineHash[line] !== undefined)) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
    }
    return chars;
  }

  var chars1 = diff_linesToCharsMunge_(text1);
  var chars2 = diff_linesToCharsMunge_(text2);
  return {chars1: chars1, chars2: chars2, lineArray: lineArray};
};


/**
 * Rehydrate the text in a diff from a string of line hashes to real lines of
 * text.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {!Array.<string>} lineArray Array of unique strings.
 * @private
 */
diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
  for (var x = 0; x < diffs.length; x++) {
    var chars = diffs[x][1];
    var text = [];
    for (var y = 0; y < chars.length; y++) {
      text[y] = lineArray[chars.charCodeAt(y)];
    }
    diffs[x][1] = text.join('');
  }
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine if the suffix of one string is the prefix of another.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of the first
 *     string and the start of the second string.
 * @private
 */
diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  // Eliminate the null case.
  if (text1_length == 0 || text2_length == 0) {
    return 0;
  }
  // Truncate the longer string.
  if (text1_length > text2_length) {
    text1 = text1.substring(text1_length - text2_length);
  } else if (text1_length < text2_length) {
    text2 = text2.substring(0, text1_length);
  }
  var text_length = Math.min(text1_length, text2_length);
  // Quick check for the worst case.
  if (text1 == text2) {
    return text_length;
  }

  // Start by looking for a single character match
  // and increase length until no match is found.
  // Performance analysis: http://neil.fraser.name/news/2010/11/04/
  var best = 0;
  var length = 1;
  while (true) {
    var pattern = text1.substring(text_length - length);
    var found = text2.indexOf(pattern);
    if (found == -1) {
      return best;
    }
    length += found;
    if (found == 0 || text1.substring(text_length - length) ==
        text2.substring(0, length)) {
      best = length;
      length++;
    }
  }
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 * @private
 */
diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
  if (this.Diff_Timeout <= 0) {
    // Don't risk returning a non-optimal diff if we have unlimited time.
    return null;
  }
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }
  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),
                                               shorttext.substring(j));
      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),
                                               shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reduce the number of edits by eliminating semantically trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Number of characters that changed prior to the equality.
  var length_insertions1 = 0;
  var length_deletions1 = 0;
  // Number of characters that changed after the equality.
  var length_insertions2 = 0;
  var length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastequality = diffs[pointer][1];
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_INSERT) {
        length_insertions2 += diffs[pointer][1].length;
      } else {
        length_deletions2 += diffs[pointer][1].length;
      }
      // Eliminate an equality that is smaller or equal to the edits on both
      // sides of it.
      if (lastequality && (lastequality.length <=
          Math.max(length_insertions1, length_deletions1)) &&
          (lastequality.length <= Math.max(length_insertions2,
                                           length_deletions2))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        // Throw away the equality we just deleted.
        equalitiesLength--;
        // Throw away the previous equality (it needs to be reevaluated).
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;  // Reset the counters.
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastequality = null;
        changes = true;
      }
    }
    pointer++;
  }

  // Normalize the diff.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
  this.diff_cleanupSemanticLossless(diffs);

  // Find any overlaps between deletions and insertions.
  // e.g: <del>abcxxx</del><ins>xxxdef</ins>
  //   -> <del>abc</del>xxx<ins>def</ins>
  // e.g: <del>xxxabc</del><ins>defxxx</ins>
  //   -> <ins>def</ins>xxx<del>abc</del>
  // Only extract an overlap if it is as big as the edit ahead or behind it.
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] == DIFF_DELETE &&
        diffs[pointer][0] == DIFF_INSERT) {
      var deletion = diffs[pointer - 1][1];
      var insertion = diffs[pointer][1];
      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 ||
            overlap_length1 >= insertion.length / 2) {
          // Overlap found.  Insert an equality and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);
          diffs[pointer - 1][1] =
              deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 ||
            overlap_length2 >= insertion.length / 2) {
          // Reverse overlap found.
          // Insert an equality and swap and trim the surrounding edits.
          diffs.splice(pointer, 0,
              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] =
              insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] =
              deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
};


/**
 * Look for single edits surrounded on both sides by equalities
 * which can be shifted sideways to align the edit to a word boundary.
 * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
  /**
   * Given two strings, compute a score representing whether the internal
   * boundary falls on logical boundaries.
   * Scores range from 6 (best) to 0 (worst).
   * Closure, but does not reference any external variables.
   * @param {string} one First string.
   * @param {string} two Second string.
   * @return {number} The score.
   * @private
   */
  function diff_cleanupSemanticScore_(one, two) {
    if (!one || !two) {
      // Edges are the best.
      return 6;
    }

    // Each port of this function behaves slightly differently due to
    // subtle differences in each language's definition of things like
    // 'whitespace'.  Since this function's purpose is largely cosmetic,
    // the choice has been made to use each language's native features
    // rather than force total conformity.
    var char1 = one.charAt(one.length - 1);
    var char2 = two.charAt(0);
    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
    var whitespace1 = nonAlphaNumeric1 &&
        char1.match(diff_match_patch.whitespaceRegex_);
    var whitespace2 = nonAlphaNumeric2 &&
        char2.match(diff_match_patch.whitespaceRegex_);
    var lineBreak1 = whitespace1 &&
        char1.match(diff_match_patch.linebreakRegex_);
    var lineBreak2 = whitespace2 &&
        char2.match(diff_match_patch.linebreakRegex_);
    var blankLine1 = lineBreak1 &&
        one.match(diff_match_patch.blanklineEndRegex_);
    var blankLine2 = lineBreak2 &&
        two.match(diff_match_patch.blanklineStartRegex_);

    if (blankLine1 || blankLine2) {
      // Five points for blank lines.
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      // Four points for line breaks.
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      // Three points for end of sentences.
      return 3;
    } else if (whitespace1 || whitespace2) {
      // Two points for whitespace.
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      // One point for non-alphanumeric.
      return 1;
    }
    return 0;
  }

  var pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      var equality1 = diffs[pointer - 1][1];
      var edit = diffs[pointer][1];
      var equality2 = diffs[pointer + 1][1];

      // First, shift the edit as far left as possible.
      var commonOffset = this.diff_commonSuffix(equality1, edit);
      if (commonOffset) {
        var commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }

      // Second, step character by character right, looking for the best fit.
      var bestEquality1 = equality1;
      var bestEdit = edit;
      var bestEquality2 = equality2;
      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +
          diff_cleanupSemanticScore_(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        var score = diff_cleanupSemanticScore_(equality1, edit) +
            diff_cleanupSemanticScore_(edit, equality2);
        // The >= encourages trailing rather than leading whitespace on edits.
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }

      if (diffs[pointer - 1][1] != bestEquality1) {
        // We have an improvement, save it back to the diff.
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
};

// Define some regex patterns for matching boundaries.
diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
diff_match_patch.whitespaceRegex_ = /\s/;
diff_match_patch.linebreakRegex_ = /[\r\n]/;
diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;

/**
 * Reduce the number of edits by eliminating operationally trivial equalities.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
  var changes = false;
  var equalities = [];  // Stack of indices where equalities are found.
  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.
  /** @type {?string} */
  var lastequality = null;
  // Always equal to diffs[equalities[equalitiesLength - 1]][1]
  var pointer = 0;  // Index of current position.
  // Is there an insertion operation before the last equality.
  var pre_ins = false;
  // Is there a deletion operation before the last equality.
  var pre_del = false;
  // Is there an insertion operation after the last equality.
  var post_ins = false;
  // Is there a deletion operation after the last equality.
  var post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.
      if (diffs[pointer][1].length < this.Diff_EditCost &&
          (post_ins || post_del)) {
        // Candidate found.
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastequality = diffs[pointer][1];
      } else {
        // Not a candidate, and can never become one.
        equalitiesLength = 0;
        lastequality = null;
      }
      post_ins = post_del = false;
    } else {  // An insertion or deletion.
      if (diffs[pointer][0] == DIFF_DELETE) {
        post_del = true;
      } else {
        post_ins = true;
      }
      /*
       * Five types to be split:
       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>
       * <ins>A</ins>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<ins>C</ins>
       * <ins>A</del>X<ins>C</ins><del>D</del>
       * <ins>A</ins><del>B</del>X<del>C</del>
       */
      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||
                           ((lastequality.length < this.Diff_EditCost / 2) &&
                            (pre_ins + pre_del + post_ins + post_del) == 3))) {
        // Duplicate record.
        diffs.splice(equalities[equalitiesLength - 1], 0,
                     [DIFF_DELETE, lastequality]);
        // Change second copy to insert.
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;  // Throw away the equality we just deleted;
        lastequality = null;
        if (pre_ins && pre_del) {
          // No changes made which could affect previous entry, keep going.
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;  // Throw away the previous equality.
          pointer = equalitiesLength > 0 ?
              equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }

  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 */
diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = this.diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = this.diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    this.diff_cleanupMerge(diffs);
  }
};


/**
 * loc is a location in text1, compute and return the equivalent location in
 * text2.
 * e.g. 'The cat' vs 'The big cat', 1->1, 5->8
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @param {number} loc Location within text1.
 * @return {number} Location within text2.
 */
diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
  var chars1 = 0;
  var chars2 = 0;
  var last_chars1 = 0;
  var last_chars2 = 0;
  var x;
  for (x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.
      chars1 += diffs[x][1].length;
    }
    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.
      chars2 += diffs[x][1].length;
    }
    if (chars1 > loc) {  // Overshot the location.
      break;
    }
    last_chars1 = chars1;
    last_chars2 = chars2;
  }
  // Was the location was deleted?
  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
    return last_chars2;
  }
  // Add the remaining character length.
  return last_chars2 + (loc - last_chars1);
};


/**
 * Convert a diff array into a pretty HTML report.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} HTML representation.
 */
diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
  var html = [];
  var pattern_amp = /&/g;
  var pattern_lt = /</g;
  var pattern_gt = />/g;
  var pattern_para = /\n/g;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];    // Operation (insert, delete, equal)
    var data = diffs[x][1];  // Text of change.
    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')
        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');
    switch (op) {
      case DIFF_INSERT:
        html[x] = '<ins style="background:#e6ffe6;">' + text + '</ins>';
        break;
      case DIFF_DELETE:
        html[x] = '<del style="background:#ffe6e6;">' + text + '</del>';
        break;
      case DIFF_EQUAL:
        html[x] = '<span>' + text + '</span>';
        break;
    }
  }
  return html.join('');
};


/**
 * Compute and return the source text (all equalities and deletions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Source text.
 */
diff_match_patch.prototype.diff_text1 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_INSERT) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute and return the destination text (all equalities and insertions).
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Destination text.
 */
diff_match_patch.prototype.diff_text2 = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    if (diffs[x][0] !== DIFF_DELETE) {
      text[x] = diffs[x][1];
    }
  }
  return text.join('');
};


/**
 * Compute the Levenshtein distance; the number of inserted, deleted or
 * substituted characters.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {number} Number of changes.
 */
diff_match_patch.prototype.diff_levenshtein = function(diffs) {
  var levenshtein = 0;
  var insertions = 0;
  var deletions = 0;
  for (var x = 0; x < diffs.length; x++) {
    var op = diffs[x][0];
    var data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        // A deletion and an insertion is one substitution.
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
};


/**
 * Crush the diff into an encoded string which describes the operations
 * required to transform text1 into text2.
 * E.g. =3\t-2\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.
 * Operations are tab-separated.  Inserted text is escaped using %xx notation.
 * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.
 * @return {string} Delta text.
 */
diff_match_patch.prototype.diff_toDelta = function(diffs) {
  var text = [];
  for (var x = 0; x < diffs.length; x++) {
    switch (diffs[x][0]) {
      case DIFF_INSERT:
        text[x] = '+' + encodeURI(diffs[x][1]);
        break;
      case DIFF_DELETE:
        text[x] = '-' + diffs[x][1].length;
        break;
      case DIFF_EQUAL:
        text[x] = '=' + diffs[x][1].length;
        break;
    }
  }
  return text.join('\t').replace(/%20/g, ' ');
};


/**
 * Given the original text1, and an encoded string which describes the
 * operations required to transform text1 into text2, compute the full diff.
 * @param {string} text1 Source string for the diff.
 * @param {string} delta Delta text.
 * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
  var diffs = [];
  var diffsLength = 0;  // Keeping our own length var is faster in JS.
  var pointer = 0;  // Cursor in text1
  var tokens = delta.split(/\t/g);
  for (var x = 0; x < tokens.length; x++) {
    // Each token begins with a one character parameter which specifies the
    // operation of this token (delete, insert, equality).
    var param = tokens[x].substring(1);
    switch (tokens[x].charAt(0)) {
      case '+':
        try {
          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];
        } catch (ex) {
          // Malformed URI sequence.
          throw new Error('Illegal escape in diff_fromDelta: ' + param);
        }
        break;
      case '-':
        // Fall through.
      case '=':
        var n = parseInt(param, 10);
        if (isNaN(n) || n < 0) {
          throw new Error('Invalid number in diff_fromDelta: ' + param);
        }
        var text = text1.substring(pointer, pointer += n);
        if (tokens[x].charAt(0) == '=') {
          diffs[diffsLength++] = [DIFF_EQUAL, text];
        } else {
          diffs[diffsLength++] = [DIFF_DELETE, text];
        }
        break;
      default:
        // Blank tokens are ok (from a trailing \t).
        // Anything else is an error.
        if (tokens[x]) {
          throw new Error('Invalid diff operation in diff_fromDelta: ' +
                          tokens[x]);
        }
    }
  }
  if (pointer != text1.length) {
    throw new Error('Delta length (' + pointer +
        ') does not equal source text length (' + text1.length + ').');
  }
  return diffs;
};


//  MATCH FUNCTIONS


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc'.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 */
diff_match_patch.prototype.match_main = function(text, pattern, loc) {
  // Check for null inputs.
  if (text == null || pattern == null || loc == null) {
    throw new Error('Null input. (match_main)');
  }

  loc = Math.max(0, Math.min(loc, text.length));
  if (text == pattern) {
    // Shortcut (potentially not guaranteed by the algorithm)
    return 0;
  } else if (!text.length) {
    // Nothing to match.
    return -1;
  } else if (text.substring(loc, loc + pattern.length) == pattern) {
    // Perfect match at the perfect spot!  (Includes case of null pattern)
    return loc;
  } else {
    // Do a fuzzy compare.
    return this.match_bitap_(text, pattern, loc);
  }
};


/**
 * Locate the best instance of 'pattern' in 'text' near 'loc' using the
 * Bitap algorithm.
 * @param {string} text The text to search.
 * @param {string} pattern The pattern to search for.
 * @param {number} loc The location to search around.
 * @return {number} Best match index or -1.
 * @private
 */
diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
  if (pattern.length > this.Match_MaxBits) {
    throw new Error('Pattern too long for this browser.');
  }

  // Initialise the alphabet.
  var s = this.match_alphabet_(pattern);

  var dmp = this;  // 'this' becomes 'window' in a closure.

  /**
   * Compute and return the score for a match with e errors and x location.
   * Accesses loc and pattern through being a closure.
   * @param {number} e Number of errors in match.
   * @param {number} x Location of match.
   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).
   * @private
   */
  function match_bitapScore_(e, x) {
    var accuracy = e / pattern.length;
    var proximity = Math.abs(loc - x);
    if (!dmp.Match_Distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + (proximity / dmp.Match_Distance);
  }

  // Highest score beyond which we give up.
  var score_threshold = this.Match_Threshold;
  // Is there a nearby exact match? (speedup)
  var best_loc = text.indexOf(pattern, loc);
  if (best_loc != -1) {
    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
    // What about in the other direction? (speedup)
    best_loc = text.lastIndexOf(pattern, loc + pattern.length);
    if (best_loc != -1) {
      score_threshold =
          Math.min(match_bitapScore_(0, best_loc), score_threshold);
    }
  }

  // Initialise the bit arrays.
  var matchmask = 1 << (pattern.length - 1);
  best_loc = -1;

  var bin_min, bin_mid;
  var bin_max = pattern.length + text.length;
  var last_rd;
  for (var d = 0; d < pattern.length; d++) {
    // Scan for the best match; each iteration allows for one more error.
    // Run a binary search to determine how far from 'loc' we can stray at this
    // error level.
    bin_min = 0;
    bin_mid = bin_max;
    while (bin_min < bin_mid) {
      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
        bin_min = bin_mid;
      } else {
        bin_max = bin_mid;
      }
      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
    }
    // Use the result from this iteration as the maximum for the next.
    bin_max = bin_mid;
    var start = Math.max(1, loc - bin_mid + 1);
    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;

    var rd = Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (var j = finish; j >= start; j--) {
      // The alphabet (s) is a sparse hash, so the following line generates
      // warnings.
      var charMatch = s[text.charAt(j - 1)];
      if (d === 0) {  // First pass: exact match.
        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
      } else {  // Subsequent passes: fuzzy match.
        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |
                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |
                last_rd[j + 1];
      }
      if (rd[j] & matchmask) {
        var score = match_bitapScore_(d, j - 1);
        // This match will almost certainly be better than any existing match.
        // But check anyway.
        if (score <= score_threshold) {
          // Told you so.
          score_threshold = score;
          best_loc = j - 1;
          if (best_loc > loc) {
            // When passing loc, don't exceed our current distance from loc.
            start = Math.max(1, 2 * loc - best_loc);
          } else {
            // Already passed loc, downhill from here on in.
            break;
          }
        }
      }
    }
    // No hope for a (better) match at greater error levels.
    if (match_bitapScore_(d + 1, loc) > score_threshold) {
      break;
    }
    last_rd = rd;
  }
  return best_loc;
};


/**
 * Initialise the alphabet for the Bitap algorithm.
 * @param {string} pattern The text to encode.
 * @return {!Object} Hash of character locations.
 * @private
 */
diff_match_patch.prototype.match_alphabet_ = function(pattern) {
  var s = {};
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] = 0;
  }
  for (var i = 0; i < pattern.length; i++) {
    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);
  }
  return s;
};


//  PATCH FUNCTIONS


/**
 * Increase the context until it is unique,
 * but don't let the pattern expand beyond Match_MaxBits.
 * @param {!diff_match_patch.patch_obj} patch The patch to grow.
 * @param {string} text Source text.
 * @private
 */
diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
  if (text.length == 0) {
    return;
  }
  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
  var padding = 0;

  // Look for the first and last matches of pattern in text.  If two different
  // matches are found, increase the pattern length.
  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&
         pattern.length < this.Match_MaxBits - this.Patch_Margin -
         this.Patch_Margin) {
    padding += this.Patch_Margin;
    pattern = text.substring(patch.start2 - padding,
                             patch.start2 + patch.length1 + padding);
  }
  // Add one chunk for good luck.
  padding += this.Patch_Margin;

  // Add the prefix.
  var prefix = text.substring(patch.start2 - padding, patch.start2);
  if (prefix) {
    patch.diffs.unshift([DIFF_EQUAL, prefix]);
  }
  // Add the suffix.
  var suffix = text.substring(patch.start2 + patch.length1,
                              patch.start2 + patch.length1 + padding);
  if (suffix) {
    patch.diffs.push([DIFF_EQUAL, suffix]);
  }

  // Roll back the start points.
  patch.start1 -= prefix.length;
  patch.start2 -= prefix.length;
  // Extend the lengths.
  patch.length1 += prefix.length + suffix.length;
  patch.length2 += prefix.length + suffix.length;
};


/**
 * Compute a list of patches to turn text1 into text2.
 * Use diffs if provided, otherwise compute it ourselves.
 * There are four ways to call this function, depending on what data is
 * available to the caller:
 * Method 1:
 * a = text1, b = text2
 * Method 2:
 * a = diffs
 * Method 3 (optimal):
 * a = text1, b = diffs
 * Method 4 (deprecated, use method 3):
 * a = text1, b = text2, c = diffs
 *
 * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or
 * Array of diff tuples for text1 to text2 (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or
 * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).
 * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples
 * for text1 to text2 (method 4) or undefined (methods 1,2,3).
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
  var text1, diffs;
  if (typeof a == 'string' && typeof opt_b == 'string' &&
      typeof opt_c == 'undefined') {
    // Method 1: text1, text2
    // Compute diffs from text1 and text2.
    text1 = /** @type {string} */(a);
    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);
    if (diffs.length > 2) {
      this.diff_cleanupSemantic(diffs);
      this.diff_cleanupEfficiency(diffs);
    }
  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&
      typeof opt_c == 'undefined') {
    // Method 2: diffs
    // Compute text1 from diffs.
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);
    text1 = this.diff_text1(diffs);
  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&
      typeof opt_c == 'undefined') {
    // Method 3: text1, diffs
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);
  } else if (typeof a == 'string' && typeof opt_b == 'string' &&
      opt_c && typeof opt_c == 'object') {
    // Method 4: text1, text2, diffs
    // text2 is not used.
    text1 = /** @type {string} */(a);
    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);
  } else {
    throw new Error('Unknown call format to patch_make.');
  }

  if (diffs.length === 0) {
    return [];  // Get rid of the null case.
  }
  var patches = [];
  var patch = new diff_match_patch.patch_obj();
  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.
  var char_count1 = 0;  // Number of characters into the text1 string.
  var char_count2 = 0;  // Number of characters into the text2 string.
  // Start with text1 (prepatch_text) and apply the diffs until we arrive at
  // text2 (postpatch_text).  We recreate the patches one by one to determine
  // context info.
  var prepatch_text = text1;
  var postpatch_text = text1;
  for (var x = 0; x < diffs.length; x++) {
    var diff_type = diffs[x][0];
    var diff_text = diffs[x][1];

    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
      // A new patch starts here.
      patch.start1 = char_count1;
      patch.start2 = char_count2;
    }

    switch (diff_type) {
      case DIFF_INSERT:
        patch.diffs[patchDiffLength++] = diffs[x];
        patch.length2 += diff_text.length;
        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +
                         postpatch_text.substring(char_count2);
        break;
      case DIFF_DELETE:
        patch.length1 += diff_text.length;
        patch.diffs[patchDiffLength++] = diffs[x];
        postpatch_text = postpatch_text.substring(0, char_count2) +
                         postpatch_text.substring(char_count2 +
                             diff_text.length);
        break;
      case DIFF_EQUAL:
        if (diff_text.length <= 2 * this.Patch_Margin &&
            patchDiffLength && diffs.length != x + 1) {
          // Small equality inside a patch.
          patch.diffs[patchDiffLength++] = diffs[x];
          patch.length1 += diff_text.length;
          patch.length2 += diff_text.length;
        } else if (diff_text.length >= 2 * this.Patch_Margin) {
          // Time for a new patch.
          if (patchDiffLength) {
            this.patch_addContext_(patch, prepatch_text);
            patches.push(patch);
            patch = new diff_match_patch.patch_obj();
            patchDiffLength = 0;
            // Unlike Unidiff, our patch lists have a rolling context.
            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff
            // Update prepatch text & pos to reflect the application of the
            // just completed patch.
            prepatch_text = postpatch_text;
            char_count1 = char_count2;
          }
        }
        break;
    }

    // Update the current character count.
    if (diff_type !== DIFF_INSERT) {
      char_count1 += diff_text.length;
    }
    if (diff_type !== DIFF_DELETE) {
      char_count2 += diff_text.length;
    }
  }
  // Pick up the leftover patch if not empty.
  if (patchDiffLength) {
    this.patch_addContext_(patch, prepatch_text);
    patches.push(patch);
  }

  return patches;
};


/**
 * Given an array of patches, return another array that is identical.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 */
diff_match_patch.prototype.patch_deepCopy = function(patches) {
  // Making deep copies is hard in JavaScript.
  var patchesCopy = [];
  for (var x = 0; x < patches.length; x++) {
    var patch = patches[x];
    var patchCopy = new diff_match_patch.patch_obj();
    patchCopy.diffs = [];
    for (var y = 0; y < patch.diffs.length; y++) {
      patchCopy.diffs[y] = patch.diffs[y].slice();
    }
    patchCopy.start1 = patch.start1;
    patchCopy.start2 = patch.start2;
    patchCopy.length1 = patch.length1;
    patchCopy.length2 = patch.length2;
    patchesCopy[x] = patchCopy;
  }
  return patchesCopy;
};


/**
 * Merge a set of patches onto the text.  Return a patched text, as well
 * as a list of true/false values indicating which patches were applied.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @param {string} text Old text.
 * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the
 *      new text and an array of boolean values.
 */
diff_match_patch.prototype.patch_apply = function(patches, text) {
  if (patches.length == 0) {
    return [text, []];
  }

  // Deep copy the patches so that no changes are made to originals.
  patches = this.patch_deepCopy(patches);

  var nullPadding = this.patch_addPadding(patches);
  text = nullPadding + text + nullPadding;

  this.patch_splitMax(patches);
  // delta keeps track of the offset between the expected and actual location
  // of the previous patch.  If there are patches expected at positions 10 and
  // 20, but the first patch was found at 12, delta is 2 and the second patch
  // has an effective expected position of 22.
  var delta = 0;
  var results = [];
  for (var x = 0; x < patches.length; x++) {
    var expected_loc = patches[x].start2 + delta;
    var text1 = this.diff_text1(patches[x].diffs);
    var start_loc;
    var end_loc = -1;
    if (text1.length > this.Match_MaxBits) {
      // patch_splitMax will only provide an oversized pattern in the case of
      // a monster delete.
      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),
                                  expected_loc);
      if (start_loc != -1) {
        end_loc = this.match_main(text,
            text1.substring(text1.length - this.Match_MaxBits),
            expected_loc + text1.length - this.Match_MaxBits);
        if (end_loc == -1 || start_loc >= end_loc) {
          // Can't find valid trailing context.  Drop this patch.
          start_loc = -1;
        }
      }
    } else {
      start_loc = this.match_main(text, text1, expected_loc);
    }
    if (start_loc == -1) {
      // No match found.  :(
      results[x] = false;
      // Subtract the delta for this failed patch from subsequent patches.
      delta -= patches[x].length2 - patches[x].length1;
    } else {
      // Found a match.  :)
      results[x] = true;
      delta = start_loc - expected_loc;
      var text2;
      if (end_loc == -1) {
        text2 = text.substring(start_loc, start_loc + text1.length);
      } else {
        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
      }
      if (text1 == text2) {
        // Perfect match, just shove the replacement text in.
        text = text.substring(0, start_loc) +
               this.diff_text2(patches[x].diffs) +
               text.substring(start_loc + text1.length);
      } else {
        // Imperfect match.  Run a diff to get a framework of equivalent
        // indices.
        var diffs = this.diff_main(text1, text2, false);
        if (text1.length > this.Match_MaxBits &&
            this.diff_levenshtein(diffs) / text1.length >
            this.Patch_DeleteThreshold) {
          // The end points match, but the content is unacceptably bad.
          results[x] = false;
        } else {
          this.diff_cleanupSemanticLossless(diffs);
          var index1 = 0;
          var index2;
          for (var y = 0; y < patches[x].diffs.length; y++) {
            var mod = patches[x].diffs[y];
            if (mod[0] !== DIFF_EQUAL) {
              index2 = this.diff_xIndex(diffs, index1);
            }
            if (mod[0] === DIFF_INSERT) {  // Insertion
              text = text.substring(0, start_loc + index2) + mod[1] +
                     text.substring(start_loc + index2);
            } else if (mod[0] === DIFF_DELETE) {  // Deletion
              text = text.substring(0, start_loc + index2) +
                     text.substring(start_loc + this.diff_xIndex(diffs,
                         index1 + mod[1].length));
            }
            if (mod[0] !== DIFF_DELETE) {
              index1 += mod[1].length;
            }
          }
        }
      }
    }
  }
  // Strip the padding off.
  text = text.substring(nullPadding.length, text.length - nullPadding.length);
  return [text, results];
};


/**
 * Add some padding on text start and end so that edges can match something.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} The padding string added to each side.
 */
diff_match_patch.prototype.patch_addPadding = function(patches) {
  var paddingLength = this.Patch_Margin;
  var nullPadding = '';
  for (var x = 1; x <= paddingLength; x++) {
    nullPadding += String.fromCharCode(x);
  }

  // Bump all the patches forward.
  for (var x = 0; x < patches.length; x++) {
    patches[x].start1 += paddingLength;
    patches[x].start2 += paddingLength;
  }

  // Add some padding on start of first diff.
  var patch = patches[0];
  var diffs = patch.diffs;
  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.unshift([DIFF_EQUAL, nullPadding]);
    patch.start1 -= paddingLength;  // Should be 0.
    patch.start2 -= paddingLength;  // Should be 0.
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[0][1].length) {
    // Grow first equality.
    var extraLength = paddingLength - diffs[0][1].length;
    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
    patch.start1 -= extraLength;
    patch.start2 -= extraLength;
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  // Add some padding on end of last diff.
  patch = patches[patches.length - 1];
  diffs = patch.diffs;
  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
    // Add nullPadding equality.
    diffs.push([DIFF_EQUAL, nullPadding]);
    patch.length1 += paddingLength;
    patch.length2 += paddingLength;
  } else if (paddingLength > diffs[diffs.length - 1][1].length) {
    // Grow last equality.
    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
    patch.length1 += extraLength;
    patch.length2 += extraLength;
  }

  return nullPadding;
};


/**
 * Look through the patches and break up any which are longer than the maximum
 * limit of the match algorithm.
 * Intended to be called only from within patch_apply.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 */
diff_match_patch.prototype.patch_splitMax = function(patches) {
  var patch_size = this.Match_MaxBits;
  for (var x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patch_size) {
      continue;
    }
    var bigpatch = patches[x];
    // Remove the big old patch.
    patches.splice(x--, 1);
    var start1 = bigpatch.start1;
    var start2 = bigpatch.start2;
    var precontext = '';
    while (bigpatch.diffs.length !== 0) {
      // Create one of several smaller patches.
      var patch = new diff_match_patch.patch_obj();
      var empty = true;
      patch.start1 = start1 - precontext.length;
      patch.start2 = start2 - precontext.length;
      if (precontext !== '') {
        patch.length1 = patch.length2 = precontext.length;
        patch.diffs.push([DIFF_EQUAL, precontext]);
      }
      while (bigpatch.diffs.length !== 0 &&
             patch.length1 < patch_size - this.Patch_Margin) {
        var diff_type = bigpatch.diffs[0][0];
        var diff_text = bigpatch.diffs[0][1];
        if (diff_type === DIFF_INSERT) {
          // Insertions are harmless.
          patch.length2 += diff_text.length;
          start2 += diff_text.length;
          patch.diffs.push(bigpatch.diffs.shift());
          empty = false;
        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&
                   patch.diffs[0][0] == DIFF_EQUAL &&
                   diff_text.length > 2 * patch_size) {
          // This is a large deletion.  Let it pass in one chunk.
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          empty = false;
          patch.diffs.push([diff_type, diff_text]);
          bigpatch.diffs.shift();
        } else {
          // Deletion or equality.  Only take as much as we can stomach.
          diff_text = diff_text.substring(0,
              patch_size - patch.length1 - this.Patch_Margin);
          patch.length1 += diff_text.length;
          start1 += diff_text.length;
          if (diff_type === DIFF_EQUAL) {
            patch.length2 += diff_text.length;
            start2 += diff_text.length;
          } else {
            empty = false;
          }
          patch.diffs.push([diff_type, diff_text]);
          if (diff_text == bigpatch.diffs[0][1]) {
            bigpatch.diffs.shift();
          } else {
            bigpatch.diffs[0][1] =
                bigpatch.diffs[0][1].substring(diff_text.length);
          }
        }
      }
      // Compute the head context for the next patch.
      precontext = this.diff_text2(patch.diffs);
      precontext =
          precontext.substring(precontext.length - this.Patch_Margin);
      // Append the end context for this patch.
      var postcontext = this.diff_text1(bigpatch.diffs)
                            .substring(0, this.Patch_Margin);
      if (postcontext !== '') {
        patch.length1 += postcontext.length;
        patch.length2 += postcontext.length;
        if (patch.diffs.length !== 0 &&
            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
          patch.diffs[patch.diffs.length - 1][1] += postcontext;
        } else {
          patch.diffs.push([DIFF_EQUAL, postcontext]);
        }
      }
      if (!empty) {
        patches.splice(++x, 0, patch);
      }
    }
  }
};


/**
 * Take a list of patches and return a textual representation.
 * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.
 * @return {string} Text representation of patches.
 */
diff_match_patch.prototype.patch_toText = function(patches) {
  var text = [];
  for (var x = 0; x < patches.length; x++) {
    text[x] = patches[x];
  }
  return text.join('');
};


/**
 * Parse a textual representation of patches and return a list of Patch objects.
 * @param {string} textline Text representation of patches.
 * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.
 * @throws {!Error} If invalid input.
 */
diff_match_patch.prototype.patch_fromText = function(textline) {
  var patches = [];
  if (!textline) {
    return patches;
  }
  var text = textline.split('\n');
  var textPointer = 0;
  var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
  while (textPointer < text.length) {
    var m = text[textPointer].match(patchHeader);
    if (!m) {
      throw new Error('Invalid patch string: ' + text[textPointer]);
    }
    var patch = new diff_match_patch.patch_obj();
    patches.push(patch);
    patch.start1 = parseInt(m[1], 10);
    if (m[2] === '') {
      patch.start1--;
      patch.length1 = 1;
    } else if (m[2] == '0') {
      patch.length1 = 0;
    } else {
      patch.start1--;
      patch.length1 = parseInt(m[2], 10);
    }

    patch.start2 = parseInt(m[3], 10);
    if (m[4] === '') {
      patch.start2--;
      patch.length2 = 1;
    } else if (m[4] == '0') {
      patch.length2 = 0;
    } else {
      patch.start2--;
      patch.length2 = parseInt(m[4], 10);
    }
    textPointer++;

    while (textPointer < text.length) {
      var sign = text[textPointer].charAt(0);
      try {
        var line = decodeURI(text[textPointer].substring(1));
      } catch (ex) {
        // Malformed URI sequence.
        throw new Error('Illegal escape in patch_fromText: ' + line);
      }
      if (sign == '-') {
        // Deletion.
        patch.diffs.push([DIFF_DELETE, line]);
      } else if (sign == '+') {
        // Insertion.
        patch.diffs.push([DIFF_INSERT, line]);
      } else if (sign == ' ') {
        // Minor equality.
        patch.diffs.push([DIFF_EQUAL, line]);
      } else if (sign == '@') {
        // Start of next patch.
        break;
      } else if (sign === '') {
        // Blank line?  Whatever.
      } else {
        // WTF?
        throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
      }
      textPointer++;
    }
  }
  return patches;
};


/**
 * Class representing one patch operation.
 * @constructor
 */
diff_match_patch.patch_obj = function() {
  /** @type {!Array.<!diff_match_patch.Diff>} */
  this.diffs = [];
  /** @type {?number} */
  this.start1 = null;
  /** @type {?number} */
  this.start2 = null;
  /** @type {number} */
  this.length1 = 0;
  /** @type {number} */
  this.length2 = 0;
};


/**
 * Emmulate GNU diff's format.
 * Header: @@ -382,8 +481,9 @@
 * Indicies are printed as 1-based, not 0-based.
 * @return {string} The GNU diff string.
 */
diff_match_patch.patch_obj.prototype.toString = function() {
  var coords1, coords2;
  if (this.length1 === 0) {
    coords1 = this.start1 + ',0';
  } else if (this.length1 == 1) {
    coords1 = this.start1 + 1;
  } else {
    coords1 = (this.start1 + 1) + ',' + this.length1;
  }
  if (this.length2 === 0) {
    coords2 = this.start2 + ',0';
  } else if (this.length2 == 1) {
    coords2 = this.start2 + 1;
  } else {
    coords2 = (this.start2 + 1) + ',' + this.length2;
  }
  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\n'];
  var op;
  // Escape the body of the patch with %xx notation.
  for (var x = 0; x < this.diffs.length; x++) {
    switch (this.diffs[x][0]) {
      case DIFF_INSERT:
        op = '+';
        break;
      case DIFF_DELETE:
        op = '-';
        break;
      case DIFF_EQUAL:
        op = ' ';
        break;
    }
    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\n';
  }
  return text.join('').replace(/%20/g, ' ');
};


// The following export code was added by @ForbesLindesay
module.exports = diff_match_patch;
module.exports['diff_match_patch'] = diff_match_patch;
module.exports['DIFF_DELETE'] = DIFF_DELETE;
module.exports['DIFF_INSERT'] = DIFF_INSERT;
module.exports['DIFF_EQUAL'] = DIFF_EQUAL;

},{}],29:[function(require,module,exports){

/**
 * Expose `parse`.
 */

module.exports = parse;

/**
 * Tests for browser support.
 */

var div = document.createElement('div');
// Setup
div.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
// Make sure that link elements get serialized correctly by innerHTML
// This requires a wrapper element in IE
var innerHTMLBug = !div.getElementsByTagName('link').length;
div = undefined;

/**
 * Wrap map from jquery.
 */

var map = {
  legend: [1, '<fieldset>', '</fieldset>'],
  tr: [2, '<table><tbody>', '</tbody></table>'],
  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  // for script/link/style tags to work in IE6-8, you have to wrap
  // in a div with a non-whitespace character in front, ha!
  _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']
};

map.td =
map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

map.option =
map.optgroup = [1, '<select multiple="multiple">', '</select>'];

map.thead =
map.tbody =
map.colgroup =
map.caption =
map.tfoot = [1, '<table>', '</table>'];

map.polyline =
map.ellipse =
map.polygon =
map.circle =
map.text =
map.line =
map.path =
map.rect =
map.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">','</svg>'];

/**
 * Parse `html` and return a DOM Node instance, which could be a TextNode,
 * HTML DOM Node of some kind (<div> for example), or a DocumentFragment
 * instance, depending on the contents of the `html` string.
 *
 * @param {String} html - HTML string to "domify"
 * @param {Document} doc - The `document` instance to create the Node for
 * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance
 * @api private
 */

function parse(html, doc) {
  if ('string' != typeof html) throw new TypeError('String expected');

  // default to the global `document` object
  if (!doc) doc = document;

  // tag name
  var m = /<([\w:]+)/.exec(html);
  if (!m) return doc.createTextNode(html);

  html = html.replace(/^\s+|\s+$/g, ''); // Remove leading/trailing whitespace

  var tag = m[1];

  // body support
  if (tag == 'body') {
    var el = doc.createElement('html');
    el.innerHTML = html;
    return el.removeChild(el.lastChild);
  }

  // wrap map
  var wrap = map[tag] || map._default;
  var depth = wrap[0];
  var prefix = wrap[1];
  var suffix = wrap[2];
  var el = doc.createElement('div');
  el.innerHTML = prefix + html + suffix;
  while (depth--) el = el.lastChild;

  // one element
  if (el.firstChild == el.lastChild) {
    return el.removeChild(el.firstChild);
  }

  // several elements
  var fragment = doc.createDocumentFragment();
  while (el.firstChild) {
    fragment.appendChild(el.removeChild(el.firstChild));
  }

  return fragment;
}

},{}],30:[function(require,module,exports){
(function (global){
"use strict";

/**
 * filesize
 *
 * @author Jason Mulligan <jason.mulligan@avoidwork.com>
 * @copyright 2015 Jason Mulligan
 * @license BSD-3 <https://raw.github.com/avoidwork/filesize.js/master/LICENSE>
 * @link http://filesizejs.com
 * @module filesize
 * @version 3.1.2
 */
(function (global) {
	var bit = /b$/;
	var si = {
		bits: ["B", "kb", "Mb", "Gb", "Tb", "Pb", "Eb", "Zb", "Yb"],
		bytes: ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
	};

	/**
  * filesize
  *
  * @method filesize
  * @param  {Mixed}   arg        String, Int or Float to transform
  * @param  {Object}  descriptor [Optional] Flags
  * @return {String}             Readable file size String
  */
	var filesize = function (arg) {
		var descriptor = arguments[1] === undefined ? {} : arguments[1];

		var result = [];
		var skip = false;
		var val = 0;
		var e = undefined,
		    base = undefined,
		    bits = undefined,
		    ceil = undefined,
		    neg = undefined,
		    num = undefined,
		    output = undefined,
		    round = undefined,
		    unix = undefined,
		    spacer = undefined,
		    suffixes = undefined;

		if (isNaN(arg)) {
			throw new Error("Invalid arguments");
		}

		bits = descriptor.bits === true;
		unix = descriptor.unix === true;
		base = descriptor.base !== undefined ? descriptor.base : 2;
		round = descriptor.round !== undefined ? descriptor.round : unix ? 1 : 2;
		spacer = descriptor.spacer !== undefined ? descriptor.spacer : unix ? "" : " ";
		suffixes = descriptor.suffixes !== undefined ? descriptor.suffixes : {};
		output = descriptor.output !== undefined ? descriptor.output : "string";
		e = descriptor.exponent !== undefined ? descriptor.exponent : -1;
		num = Number(arg);
		neg = num < 0;
		ceil = base > 2 ? 1000 : 1024;

		// Flipping a negative number to determine the size
		if (neg) {
			num = -num;
		}

		// Zero is now a special case because bytes divide by 1
		if (num === 0) {
			result[0] = 0;

			if (unix) {
				result[1] = "";
			} else {
				result[1] = "B";
			}
		} else {
			// Determining the exponent
			if (e === -1 || isNaN(e)) {
				e = Math.floor(Math.log(num) / Math.log(ceil));
			}

			// Exceeding supported length, time to reduce & multiply
			if (e > 8) {
				val = val * (1000 * (e - 8));
				e = 8;
			}

			if (base === 2) {
				val = num / Math.pow(2, e * 10);
			} else {
				val = num / Math.pow(1000, e);
			}

			if (bits) {
				val = val * 8;

				if (val > ceil) {
					val = val / ceil;
					e++;
				}
			}

			result[0] = Number(val.toFixed(e > 0 ? round : 0));
			result[1] = si[bits ? "bits" : "bytes"][e];

			if (!skip && unix) {
				if (bits && bit.test(result[1])) {
					result[1] = result[1].toLowerCase();
				}

				result[1] = result[1].charAt(0);

				if (result[1] === "B") {
					result[0] = Math.floor(result[0]);
					result[1] = "";
				} else if (!bits && result[1] === "k") {
					result[1] = "K";
				}
			}
		}

		// Decorating a 'diff'
		if (neg) {
			result[0] = -result[0];
		}

		// Applying custom suffix
		result[1] = suffixes[result[1]] || result[1];

		// Returning Array, Object, or String (default)
		if (output === "array") {
			return result;
		}

		if (output === "exponent") {
			return e;
		}

		if (output === "object") {
			return { value: result[0], suffix: result[1] };
		}

		return result.join(spacer);
	};

	// CommonJS, AMD, script tag
	if (typeof exports !== "undefined") {
		module.exports = filesize;
	} else if (typeof define === "function") {
		define(function () {
			return filesize;
		});
	} else {
		global.filesize = filesize;
	}
})(typeof global !== "undefined" ? global : window);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],31:[function(require,module,exports){

var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};


},{}],32:[function(require,module,exports){
var READY = -1,
	COMPLETE = 0,
	FAILED = 1,
	Gatherer,
	checkTasks;

function Gatherer(){

	this.reset();
	return this;

}

function checkTasks(){

	var completed = this.tasksComplete + this.tasksFailed;
	var count = this.tasks.length;

	// post the percent complete..
	this.fn.update( Math.ceil(100 * (completed / count)));

	// and fire the complete callback when done, regardless of outcome
	if(completed >= count){

		this.isComplete = true;

		this.fn.complete( this.tasksFailed ? this.errors : null );
		
	}

	return;
};

Gatherer.prototype = {

	reset : function resetGathering(){

		var self = this;

		this.tasks = [];
		this.fn = {
			complete : function(){},
			update : function(){}
		}
		this.isComplete = false;
		this.tasksComplete = 0;
		this.tasksFailed = 0;
		this.errors = [];

		return;

	},

	task : function createTask( callback ){

		var self = this,
			task = { status : READY },
			done = function(){
				task.status = COMPLETE;
				self.tasksComplete++;
				checkTasks.call(self);	
			},
			error = function(err){
				task.status = FAILED;
				self.tasksFailed++;
				self.errors.push(err);
				checkTasks.call(self);
			};

		task.fn = function(){

			callback(done, error);

		}
		self.tasks.push(task);
		return self;

	},

	run : function runTasks( callback, timeout ){

		var self = this;

		if (timeout){

			setTimeout(function(){

				if (!self.isComplete){

					self.fn.complete('Error: Timed out');
					self.fn.complete = function(){};

				}


			}, timeout);

		}

		self.fn.complete = callback;

		// run the task callbacks...
		for (var i = 0, il = self.tasks.length; i < il; i++){
			self.tasks[i].fn();
		}

		return self;

	},

	update : function setUpdateCallback( callback ){
		this.fn.update = callback;
		return this;
	}

}

module.exports = Gatherer;
},{}],33:[function(require,module,exports){
/**
 * Module dependencies.
 */

var matches = require('matches-selector');
var delegate = require('delegate');
var classes = require('classes');
var traverse = require('traverse');
var indexof = require('indexof');
var domify = require('domify');
var events = require('event');
var value = require('value');
var query = require('query');
var type = require('type');
var trim = require('trim');
var css = require('css');

var eventRefs = {};
var expando = 0;

/**
 * Attributes supported.
 */

var attrs = [
  'id',
  'src',
  'rel',
  'cols',
  'rows',
  'type',
  'name',
  'href',
  'title',
  'style',
  'width',
  'height',
  'action',
  'method',
  'tabindex',
  'placeholder'
];

/**
 * Expose `dom()`.
 */

exports = module.exports = dom;

/**
 * Expose supported attrs.
 */

exports.attrs = attrs;

/**
 * Return a dom `List` for the given
 * `html`, selector, or element.
 *
 * @param {String|Element|List}
 * @return {List}
 * @api public
 */

function dom(selector, context) {
  // array
  if (Array.isArray(selector)) {
    return new List(selector);
  }

  // List
  if (selector instanceof List) {
    return selector;
  }

  // node
  if (selector.nodeName) {
    return new List([selector]);
  }

  if ('string' != typeof selector) {
    throw new TypeError('invalid selector');
  }

  // html
  var htmlselector = trim.left(selector);
  if ('<' == htmlselector.charAt(0)) {
    return new List([domify(htmlselector)], htmlselector);
  }

  // selector
  var ctx = context
    ? (context.els ? context.els[0] : context)
    : document;

  return new List(query.all(selector, ctx), selector);
}

/**
 * Expose `List` constructor.
 */

exports.List = List;

/**
 * Initialize a new `List` with the
 * given array-ish of `els` and `selector`
 * string.
 *
 * @param {Mixed} els
 * @param {String} selector
 * @api private
 */

function List(els, selector) {
  this.els = els || [];
  this.selector = selector;
}

/**
 * Enumerable iterator.
 */

List.prototype.__iterate__ = function(){
  var self = this;
  return {
    length: function(){ return self.els.length },
    get: function(i){ return new List([self.els[i]]) }
  }
};

/**
 * Remove elements from the DOM.
 *
 * @api public
 */

List.prototype.remove = function(){
  for (var i = 0; i < this.els.length; i++) {
    var el = this.els[i];
    el.style.display = "none"; // hide it, if nothing else.
    walkDOM(el, function( node ){
      var id;
      if(id = node.__expando){
        for(var j = 0; j < eventRefs[id].length; ++j){
          events.unbind(node, eventRefs[id][j].evt, eventRefs[id][j].fn);
          delete eventRefs[id][j];
        }
      }
      return true;
    });
    el.style.display = "";
    var parent = el.parentNode;
    if (parent) parent.removeChild(el);
  }
};

/**
 * Set attribute `name` to `val`, or get attr `name`.
 *
 * @param {String} name
 * @param {String} [val]
 * @return {String|List} self
 * @api public
 */

List.prototype.attr = function(name, val){

  // set via object
  if ("object" == typeof name){
    for (var attr in name) {
      this.attr(attr, name[attr]);
    }
    return this;
  }

  // get
  if (1 == arguments.length) {
    return this.els[0] && this.els[0].getAttribute(name);
  }

  // remove
  if (null == val) {
    return this.removeAttr(name);
  }

  // set
  return this.forEach(function(el){
    el.setAttribute(name, val);
  });
};

/**
 * Remove attribute `name`.
 *
 * @param {String} name
 * @return {List} self
 * @api public
 */

List.prototype.removeAttr = function(name){
  return this.forEach(function(el){
    el.removeAttribute(name);
  });
};

/**
 * Set property `name` to `val`, or get property `name`.
 *
 * @param {String} name
 * @param {String} [val]
 * @return {Object|List} self
 * @api public
 */

List.prototype.prop = function(name, val){
  if (1 == arguments.length) {
    return this.els[0] && this.els[0][name];
  }

  return this.forEach(function(el){
    el[name] = val;
  });
};

/**
 * Get the first element's value or set selected
 * element values to `val`.
 *
 * @param {Mixed} [val]
 * @return {Mixed}
 * @api public
 */

List.prototype.val =
List.prototype.value = function(val){
  if (0 == arguments.length) {
    return this.els[0]
      ? value(this.els[0])
      : undefined;
  }

  return this.forEach(function(el){
    value(el, val);
  });
};

/**
 * Return a cloned `List` with all elements cloned.
 *
 * @return {List}
 * @api public
 */

List.prototype.clone = function(){
  var arr = [];
  for (var i = 0, len = this.els.length; i < len; ++i) {
    arr.push(this.els[i].cloneNode(true));
  }
  return new List(arr);
};

/**
 * Prepend `val`.
 *
 * @param {String|Element|List} val
 * @return {List} new list
 * @api public
 */

List.prototype.prepend = function(val){
  var el = this.els[0];
  if (!el) return this;
  val = dom(val);
  for (var i = 0; i < val.els.length; ++i) {
    if (el.children.length) {
      el.insertBefore(val.els[i], el.firstChild);
    } else {
      el.appendChild(val.els[i]);
    }
  }
  return val;
};

/**
 * Append `val`.
 *
 * @param {String|Element|List} val
 * @return {List} new list
 * @api public
 */

List.prototype.append = function(val){
  var el = this.els[0];
  if (!el) return this;
  val = dom(val);
  for (var i = 0; i < val.els.length; ++i) {
    el.appendChild(val.els[i]);
  }
  return val;
};

/**
 * Append self's `el` to `val`
 *
 * @param {String|Element|List} val
 * @return {List} self
 * @api public
 */

List.prototype.appendTo = function(val){
  dom(val).append(this);
  return this;
};

/**
 * Insert self's `els` after `val`
 *
 * @param {String|Element|List} val
 * @return {List} self
 * @api public
 */

List.prototype.insertAfter = function(val){
  val = dom(val).els[0];
  if (!val || !val.parentNode) return this;
  this.forEach(function(el){
    val.parentNode.insertBefore(el, val.nextSibling);
  });
  return this;
};

/**
 * Return a `List` containing the element at `i`.
 *
 * @param {Number} i
 * @return {List}
 * @api public
 */

List.prototype.at = function(i){
  return new List([this.els[i]], this.selector);
};

/**
 * Return a `List` containing the first element.
 *
 * @param {Number} i
 * @return {List}
 * @api public
 */

List.prototype.first = function(){
  return new List([this.els[0]], this.selector);
};

/**
 * Return a `List` containing the last element.
 *
 * @param {Number} i
 * @return {List}
 * @api public
 */

List.prototype.last = function(){
  return new List([this.els[this.els.length - 1]], this.selector);
};

/**
 * Return an `Element` at `i`.
 *
 * @param {Number} i
 * @return {Element}
 * @api public
 */

List.prototype.get = function(i){
  return this.els[i || 0];
};

/**
 * Return list length.
 *
 * @return {Number}
 * @api public
 */

List.prototype.length = function(){
  return this.els.length;
};

/**
 * Return element text.
 *
 * @param {String} str
 * @return {String|List}
 * @api public
 */

List.prototype.text = function(str){
  // TODO: real impl
  if (1 == arguments.length) {
    this.forEach(function(el){
      el.textContent = str;
    });
    return this;
  }

  var str = '';
  for (var i = 0; i < this.els.length; ++i) {
    str += this.els[i].textContent;
  }
  return str;
};

/**
 * Return element html.
 *
 * @return {String} html
 * @api public
 */

List.prototype.html = function(html){
  if (1 == arguments.length) {
    return this.forEach(function(el){
      el.innerHTML = html;
    });
  }

  // TODO: real impl
  return this.els[0] && this.els[0].innerHTML;
};

/**
 * Bind to `event` and invoke `fn(e)`. When
 * a `selector` is given then events are delegated.
 *
 * @param {String} event
 * @param {String} [selector]
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {List}
 * @api public
 */

List.prototype.on = function(event, selector, fn, capture){
  var id, cur;
  if ('string' == typeof selector) {
    for (var i = 0; i < this.els.length; ++i) {
      fn._delegate = delegate.bind(this.els[i], selector, event, fn, capture);
    }
    return this;
  }

  capture = fn;
  fn = selector;

  for (var i = 0; i < this.els.length; ++i) {
    if (id = this.els[i].__expando){
    } else {
      id = ++expando;
      this.els[i].__expando = id;
    }
    if(!eventRefs[id]){
      eventRefs[id] = [];
    }
    cur = eventRefs[id].length;
    eventRefs[id][cur] = {
      evt : event,
      fn : fn
    };
    events.bind(this.els[i], eventRefs[id][cur].evt, eventRefs[id][cur].fn, capture);
  }

  return this;
};

/**
 * Unbind to `event` and invoke `fn(e)`. When
 * a `selector` is given then delegated event
 * handlers are unbound.
 *
 * @param {String} event
 * @param {String} [selector]
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {List}
 * @api public
 */

List.prototype.off = function(event, selector, fn, capture){
  var id, i;
  if ('string' == typeof selector) {
    for (i = 0; i < this.els.length; ++i) {
      // TODO: add selector support back
      delegate.unbind(this.els[i], event, fn._delegate, capture);
    }
    return this;
  }

  capture = fn;
  fn = selector;

  if (!selector){
    for (i = 0; i < this.els.length; ++i) {
      id = this.els[i].__expando;
      for(var j = 0; j < eventRefs[id].length; ++j){
        events.unbind(this.els[i], eventRefs[id][j].evt, eventRefs[id][j].fn);
      }
    }
  } else {
    for (i = 0; i < this.els.length; ++i) {
      events.unbind(this.els[i], event, fn, capture);
    }
  }
  
  return this;
};
/**
 * Iterate elements and invoke `fn(list, i)`.
 *
 * @param {Function} fn
 * @return {List} self
 * @api public
 */

List.prototype.each = function(fn){
  for (var i = 0; i < this.els.length; ++i) {
    fn(new List([this.els[i]], this.selector), i);
  }
  return this;
};

/**
 * Iterate elements and invoke `fn(el, i)`.
 *
 * @param {Function} fn
 * @return {List} self
 * @api public
 */

List.prototype.forEach = function(fn){
  for (var i = 0; i < this.els.length; ++i) {
    fn(this.els[i], i);
  }
  return this;
};

/**
 * Map elements invoking `fn(list, i)`.
 *
 * @param {Function} fn
 * @return {Array}
 * @api public
 */

List.prototype.map = function(fn){
  var arr = [];
  for (var i = 0; i < this.els.length; ++i) {
    arr.push(fn(new List([this.els[i]], this.selector), i));
  }
  return arr;
};

/**
 * Filter elements invoking `fn(list, i)`, returning
 * a new `List` of elements when a truthy value is returned.
 *
 * @param {Function} fn
 * @return {List}
 * @api public
 */

List.prototype.select =
List.prototype.filter = function(fn){
  var el;
  var list = new List([], this.selector);
  for (var i = 0; i < this.els.length; ++i) {
    el = this.els[i];
    if (fn(new List([el], this.selector), i)) list.els.push(el);
  }
  return list;
};

/**
 * Filter elements invoking `fn(list, i)`, returning
 * a new `List` of elements when a falsey value is returned.
 *
 * @param {Function} fn
 * @return {List}
 * @api public
 */

List.prototype.reject = function(fn){
  var el;
  var list = new List([], this.selector);
  for (var i = 0; i < this.els.length; ++i) {
    el = this.els[i];
    if (!fn(new List([el], this.selector), i)) list.els.push(el);
  }
  return list;
};

/**
 * Add the given class `name`.
 *
 * @param {String} name
 * @return {List} self
 * @api public
 */

List.prototype.addClass = function(name){
  var el;
  for (var i = 0; i < this.els.length; ++i) {
    el = this.els[i];
    el._classes = el._classes || classes(el);
    el._classes.add(name);
  }
  return this;
};

/**
 * Remove the given class `name`.
 *
 * @param {String|RegExp} name
 * @return {List} self
 * @api public
 */

List.prototype.removeClass = function(name){
  var el;

  if ('regexp' == type(name)) {
    for (var i = 0; i < this.els.length; ++i) {
      el = this.els[i];
      el._classes = el._classes || classes(el);
      var arr = el._classes.array();
      for (var j = 0; j < arr.length; j++) {
        if (name.test(arr[j])) {
          el._classes.remove(arr[j]);
        }
      }
    }
    return this;
  }

  for (var i = 0; i < this.els.length; ++i) {
    el = this.els[i];
    el._classes = el._classes || classes(el);
    el._classes.remove(name);
  }

  return this;
};

/**
 * Toggle the given class `name`,
 * optionally a `bool` may be given
 * to indicate that the class should
 * be added when truthy.
 *
 * @param {String} name
 * @param {Boolean} bool
 * @return {List} self
 * @api public
 */

List.prototype.toggleClass = function(name, bool){
  var el;
  var fn = 'toggle';

  // toggle with boolean
  if (2 == arguments.length) {
    fn = bool ? 'add' : 'remove';
  }

  for (var i = 0; i < this.els.length; ++i) {
    el = this.els[i];
    el._classes = el._classes || classes(el);
    el._classes[fn](name);
  }

  return this;
};

/**
 * Check if the given class `name` is present.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

List.prototype.hasClass = function(name){
  var el;
  for (var i = 0; i < this.els.length; ++i) {
    el = this.els[i];
    el._classes = el._classes || classes(el);
    if (el._classes.has(name)) return true;
  }
  return false;
};

/**
 * Set CSS `prop` to `val` or get `prop` value.
 * Also accepts an object (`prop`: `val`)
 *
 * @param {String} prop
 * @param {Mixed} val
 * @return {List|String}
 * @api public
 */

List.prototype.css = function(prop, val){
  if (2 == arguments.length) {
    var obj = {};
    obj[prop] = val;
    return this.setStyle(obj);
  }

  if ('object' == type(prop)) {
    return this.setStyle(prop);
  }

  return this.getStyle(prop);
};

/**
 * Set CSS `props`.
 *
 * @param {Object} props
 * @return {List} self
 * @api private
 */

List.prototype.setStyle = function(props){
  for (var i = 0; i < this.els.length; ++i) {
    css(this.els[i], props);
  }
  return this;
};

/**
 * Get CSS `prop` value.
 *
 * @param {String} prop
 * @return {String}
 * @api private
 */

List.prototype.getStyle = function(prop){
  var el = this.els[0];
  if (el) return el.style[prop];
};

/**
 * Find children matching the given `selector`.
 *
 * @param {String} selector
 * @return {List}
 * @api public
 */

List.prototype.find = function(selector){
  return dom(selector, this);
};

/**
 * Empty the dom list
 *
 * @return self
 * @api public
 */

List.prototype.empty = function(){
  var elem, el;

  for (var i = 0; i < this.els.length; ++i) {
    el = this.els[i];
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
  }

  return this;
}

/**
 * Check if the first element matches `selector`.
 *
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

List.prototype.is = function(selector){
  return matches(this.get(0), selector);
};

/**
 * Get parent(s) with optional `selector` and `limit`
 *
 * @param {String} selector
 * @param {Number} limit
 * @return {List}
 * @api public
 */

List.prototype.parent = function(selector, limit){
  return new List(traverse('parentNode',
    this.get(0),
    selector,
    limit
    || 1));
};

/**
 * Get next element(s) with optional `selector` and `limit`.
 *
 * @param {String} selector
 * @param {Number} limit
 * @retrun {List}
 * @api public
 */

List.prototype.next = function(selector, limit){
  return new List(traverse('nextSibling',
    this.get(0),
    selector,
    limit
    || 1));
};

/**
 * Get previous element(s) with optional `selector` and `limit`.
 *
 * @param {String} selector
 * @param {Number} limit
 * @return {List}
 * @api public
 */

List.prototype.prev =
List.prototype.previous = function(selector, limit){
  return new List(traverse('previousSibling',
    this.get(0),
    selector,
    limit
    || 1));
};

/**
 * Attribute accessors.
 */

attrs.forEach(function(name){
  List.prototype[name] = function(val){
    if (0 == arguments.length) return this.attr(name);
    return this.attr(name, val);
  };
});

/**
 * Walk Dom `node` and call `func`.
 *
 * @param {Object} domNode, {Function} callback
 * @return null
 * @api private
 */

function walkDOM(node, func){
  var go = func(node);
  if(go){
    node = node.firstChild;
    while (node){
      walkDOM(node, func);
      node = node.nextSibling;
    }
  }
};


},{"classes":34,"css":44,"delegate":35,"domify":38,"event":39,"indexof":40,"matches-selector":41,"query":42,"traverse":45,"trim":47,"type":43,"value":46}],34:[function(require,module,exports){
/**
 * Module dependencies.
 */

var index = require('indexof');

/**
 * Whitespace regexp.
 */

var re = /\s+/;

/**
 * toString reference.
 */

var toString = Object.prototype.toString;

/**
 * Wrap `el` in a `ClassList`.
 *
 * @param {Element} el
 * @return {ClassList}
 * @api public
 */

module.exports = function(el){
  return new ClassList(el);
};

/**
 * Initialize a new ClassList for `el`.
 *
 * @param {Element} el
 * @api private
 */

function ClassList(el) {
  if (!el) throw new Error('A DOM element reference is required');
  this.el = el;
  this.list = el.classList;
}

/**
 * Add class `name` if not already present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.add = function(name){
  // classList
  if (this.list) {
    this.list.add(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (!~i) arr.push(name);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove class `name` when present, or
 * pass a regular expression to remove
 * any which match.
 *
 * @param {String|RegExp} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.remove = function(name){
  if ('[object RegExp]' == toString.call(name)) {
    return this.removeMatching(name);
  }

  // classList
  if (this.list) {
    this.list.remove(name);
    return this;
  }

  // fallback
  var arr = this.array();
  var i = index(arr, name);
  if (~i) arr.splice(i, 1);
  this.el.className = arr.join(' ');
  return this;
};

/**
 * Remove all classes matching `re`.
 *
 * @param {RegExp} re
 * @return {ClassList}
 * @api private
 */

ClassList.prototype.removeMatching = function(re){
  var arr = this.array();
  for (var i = 0; i < arr.length; i++) {
    if (re.test(arr[i])) {
      this.remove(arr[i]);
    }
  }
  return this;
};

/**
 * Toggle class `name`, can force state via `force`.
 *
 * For browsers that support classList, but do not support `force` yet,
 * the mistake will be detected and corrected.
 *
 * @param {String} name
 * @param {Boolean} force
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.toggle = function(name, force){
  // classList
  if (this.list) {
    if ("undefined" !== typeof force) {
      if (force !== this.list.toggle(name, force)) {
        this.list.toggle(name); // toggle again to correct
      }
    } else {
      this.list.toggle(name);
    }
    return this;
  }

  // fallback
  if ("undefined" !== typeof force) {
    if (!force) {
      this.remove(name);
    } else {
      this.add(name);
    }
  } else {
    if (this.has(name)) {
      this.remove(name);
    } else {
      this.add(name);
    }
  }

  return this;
};

/**
 * Return an array of classes.
 *
 * @return {Array}
 * @api public
 */

ClassList.prototype.array = function(){
  var str = this.el.className.replace(/^\s+|\s+$/g, '');
  var arr = str.split(re);
  if ('' === arr[0]) arr.shift();
  return arr;
};

/**
 * Check if class `name` is present.
 *
 * @param {String} name
 * @return {ClassList}
 * @api public
 */

ClassList.prototype.has =
ClassList.prototype.contains = function(name){
  return this.list
    ? this.list.contains(name)
    : !! ~index(this.array(), name);
};

},{"indexof":40}],35:[function(require,module,exports){
/**
 * Module dependencies.
 */

var closest = require('closest')
  , event = require('event');

/**
 * Delegate event `type` to `selector`
 * and invoke `fn(e)`. A callback function
 * is returned which may be passed to `.unbind()`.
 *
 * @param {Element} el
 * @param {String} selector
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, selector, type, fn, capture){
  return event.bind(el, type, function(e){
    var target = e.target || e.srcElement;
    e.delegateTarget = closest(target, selector, true, el);
    if (e.delegateTarget) fn.call(el, e);
  }, capture);
};

/**
 * Unbind event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  event.unbind(el, type, fn, capture);
};

},{"closest":36,"event":39}],36:[function(require,module,exports){
var matches = require('matches-selector')

module.exports = function (element, selector, checkYoSelf, root) {
  element = checkYoSelf ? {parentNode: element} : element

  root = root || document

  // Make sure `element !== document` and `element != null`
  // otherwise we get an illegal invocation
  while ((element = element.parentNode) && element !== document) {
    if (matches(element, selector))
      return element
    // After `matches` on the edge case that
    // the selector matches the root
    // (when the root is not the document)
    if (element === root)
      return  
  }
}
},{"matches-selector":37}],37:[function(require,module,exports){
'use strict';

var proto = Element.prototype;
var vendor = proto.matches
  || proto.matchesSelector
  || proto.webkitMatchesSelector
  || proto.mozMatchesSelector
  || proto.msMatchesSelector
  || proto.oMatchesSelector;

module.exports = match;

/**
 * Match `el` to `selector`.
 *
 * @param {Element} el
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

function match(el, selector) {
  if (vendor) return vendor.call(el, selector);
  var nodes = el.parentNode.querySelectorAll(selector);
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i] == el) return true;
  }
  return false;
}
},{}],38:[function(require,module,exports){

/**
 * Expose `parse`.
 */

module.exports = parse;

/**
 * Wrap map from jquery.
 */

var map = {
  legend: [1, '<fieldset>', '</fieldset>'],
  tr: [2, '<table><tbody>', '</tbody></table>'],
  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  _default: [0, '', '']
};

map.td =
map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

map.option =
map.optgroup = [1, '<select multiple="multiple">', '</select>'];

map.thead =
map.tbody =
map.colgroup =
map.caption =
map.tfoot = [1, '<table>', '</table>'];

map.text =
map.circle =
map.ellipse =
map.line =
map.path =
map.polygon =
map.polyline =
map.rect = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">','</svg>'];

/**
 * Parse `html` and return the children.
 *
 * @param {String} html
 * @return {Array}
 * @api private
 */

function parse(html) {
  if ('string' != typeof html) throw new TypeError('String expected');
  
  // tag name
  var m = /<([\w:]+)/.exec(html);
  if (!m) return document.createTextNode(html);

  html = html.replace(/^\s+|\s+$/g, ''); // Remove leading/trailing whitespace

  var tag = m[1];

  // body support
  if (tag == 'body') {
    var el = document.createElement('html');
    el.innerHTML = html;
    return el.removeChild(el.lastChild);
  }

  // wrap map
  var wrap = map[tag] || map._default;
  var depth = wrap[0];
  var prefix = wrap[1];
  var suffix = wrap[2];
  var el = document.createElement('div');
  el.innerHTML = prefix + html + suffix;
  while (depth--) el = el.lastChild;

  // one element
  if (el.firstChild == el.lastChild) {
    return el.removeChild(el.firstChild);
  }

  // several elements
  var fragment = document.createDocumentFragment();
  while (el.firstChild) {
    fragment.appendChild(el.removeChild(el.firstChild));
  }

  return fragment;
}

},{}],39:[function(require,module,exports){
var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
    prefix = bind !== 'addEventListener' ? 'on' : '';

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, type, fn, capture){
  el[bind](prefix + type, fn, capture || false);
  return fn;
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  el[unbind](prefix + type, fn, capture || false);
  return fn;
};
},{}],40:[function(require,module,exports){
module.exports = function(arr, obj){
  if (arr.indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],41:[function(require,module,exports){
/**
 * Module dependencies.
 */

var query = require('query');

/**
 * Element prototype.
 */

var proto = Element.prototype;

/**
 * Vendor function.
 */

var vendor = proto.matches
  || proto.webkitMatchesSelector
  || proto.mozMatchesSelector
  || proto.msMatchesSelector
  || proto.oMatchesSelector;

/**
 * Expose `match()`.
 */

module.exports = match;

/**
 * Match `el` to `selector`.
 *
 * @param {Element} el
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

function match(el, selector) {
  if (vendor) return vendor.call(el, selector);
  var nodes = query.all(selector, el.parentNode);
  for (var i = 0; i < nodes.length; ++i) {
    if (nodes[i] == el) return true;
  }
  return false;
}

},{"query":42}],42:[function(require,module,exports){
function one(selector, el) {
  return el.querySelector(selector);
}

exports = module.exports = function(selector, el){
  el = el || document;
  return one(selector, el);
};

exports.all = function(selector, el){
  el = el || document;
  return el.querySelectorAll(selector);
};

exports.engine = function(obj){
  if (!obj.one) throw new Error('.one callback required');
  if (!obj.all) throw new Error('.all callback required');
  one = obj.one;
  exports.all = obj.all;
  return exports;
};

},{}],43:[function(require,module,exports){

/**
 * toString ref.
 */

var toString = Object.prototype.toString;

/**
 * Return the type of `val`.
 *
 * @param {Mixed} val
 * @return {String}
 * @api public
 */

module.exports = function(val){
  switch (toString.call(val)) {
    case '[object Function]': return 'function';
    case '[object Date]': return 'date';
    case '[object RegExp]': return 'regexp';
    case '[object Arguments]': return 'arguments';
    case '[object Array]': return 'array';
    case '[object String]': return 'string';
  }

  if (val === null) return 'null';
  if (val === undefined) return 'undefined';
  if (val && val.nodeType === 1) return 'element';
  if (val === Object(val)) return 'object';

  return typeof val;
};

},{}],44:[function(require,module,exports){

/**
 * Properties to ignore appending "px".
 */

var ignore = {
  columnCount: true,
  fillOpacity: true,
  fontWeight: true,
  lineHeight: true,
  opacity: true,
  orphans: true,
  widows: true,
  zIndex: true,
  zoom: true
};

/**
 * Set `el` css values.
 *
 * @param {Element} el
 * @param {Object} obj
 * @return {Element}
 * @api public
 */

module.exports = function(el, obj){
  for (var key in obj) {
    var val = obj[key];
    if ('number' == typeof val && !ignore[key]) val += 'px';
    el.style[key] = val;
  }
  return el;
};

},{}],45:[function(require,module,exports){

/**
 * dependencies
 */

var matches = require('matches-selector');

/**
 * Traverse with the given `el`, `selector` and `len`.
 *
 * @param {String} type
 * @param {Element} el
 * @param {String} selector
 * @param {Number} len
 * @return {Array}
 * @api public
 */

module.exports = function(type, el, selector, len){
  var el = el[type]
    , n = len || 1
    , ret = [];

  if (!el) return ret;

  do {
    if (n == ret.length) break;
    if (1 != el.nodeType) continue;
    if (matches(el, selector)) ret.push(el);
    if (!selector) ret.push(el);
  } while (el = el[type]);

  return ret;
}

},{"matches-selector":41}],46:[function(require,module,exports){
/**
 * Module dependencies.
 */

var typeOf = require('type');

/**
 * Set or get `el`'s' value.
 *
 * @param {Element} el
 * @param {Mixed} val
 * @return {Mixed}
 * @api public
 */

module.exports = function(el, val){
  if (2 == arguments.length) return set(el, val);
  return get(el);
};

/**
 * Get `el`'s value.
 */

function get(el) {
  switch (type(el)) {
    case 'checkbox':
    case 'radio':
      if (el.checked) {
        var attr = el.getAttribute('value');
        return null == attr ? true : attr;
      } else {
        return false;
      }
    case 'radiogroup':
      for (var i = 0, radio; radio = el[i]; i++) {
        if (radio.checked) return radio.value;
      }
      break;
    case 'select':
      var vals = [];
      for (var i = 0, option; option = el.options[i]; i++) {
        if (option.selected) vals.push(option.value);
      }
      return (vals.length===1 ? vals[0] : vals);
      break;
    default:
      return el.value;
  }
}

/**
 * Set `el`'s value.
 */


function set(el, val) {
  switch (type(el)) {
    case 'checkbox':
    case 'radio':
      el.checked = (val === true ? true : (val == el.getAttribute('value')));
      break;
    case 'radiogroup':
      for (var i = 0, radio; radio = el[i]; i++) {
        radio.checked = radio.value === val;
      }
      break;
    case 'select':
      var vals = ('array' == typeOf(val) ? val : [val]), found;
      for (var i = 0, option; option = el.options[i]; i++) {
        found = 0;
        for (var j = 0, v; v = vals[j]; j++){
          found |= v === option.value;
        }
        option.selected = (found === 1);
      }
      break;
    default:
      el.value = val;
  }
}

/**
 * Element type.
 */

function type(el) {
  var group = 'array' == typeOf(el) || 'object' == typeOf(el);
  if (group) el = el[0];
  var name = el.nodeName.toLowerCase();
  var type = el.getAttribute('type');

  if (group && type && 'radio' == type.toLowerCase()) return 'radiogroup';
  if ('input' == name && type && 'checkbox' == type.toLowerCase()) return 'checkbox';
  if ('input' == name && type && 'radio' == type.toLowerCase()) return 'radio';
  if ('select' == name) return 'select';
  return name;
}

},{"type":43}],47:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],48:[function(require,module,exports){

},{}],49:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff
var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding) {
  var self = this
  if (!(self instanceof Buffer)) return new Buffer(subject, encoding)

  var type = typeof subject
  var length

  if (type === 'number') {
    length = +subject
  } else if (type === 'string') {
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) {
    // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data)) subject = subject.data
    length = +subject.length
  } else {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (length > kMaxLength) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum size: 0x' +
      kMaxLength.toString(16) + ' bytes')
  }

  if (length < 0) length = 0
  else length >>>= 0 // coerce to uint32

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    self = Buffer._augment(new Uint8Array(length)) // eslint-disable-line consistent-this
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    self.length = length
    self._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    self._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++) {
        self[i] = subject.readUInt8(i)
      }
    } else {
      for (i = 0; i < length; i++) {
        self[i] = ((subject[i] % 256) + 256) % 256
      }
    }
  } else if (type === 'string') {
    self.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT) {
    for (i = 0; i < length; i++) {
      self[i] = 0
    }
  }

  if (length > 0 && length <= Buffer.poolSize) self.parent = rootParent

  return self
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, totalLength) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function byteLength (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function toString (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0

  if (length < 0 || offset < 0 || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) >>> 0 & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) >>> 0 & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(
      this, value, offset, byteLength,
      Math.pow(2, 8 * byteLength - 1) - 1,
      -Math.pow(2, 8 * byteLength - 1)
    )
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkInt(
      this, value, offset, byteLength,
      Math.pow(2, 8 * byteLength - 1) - 1,
      -Math.pow(2, 8 * byteLength - 1)
    )
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, target_start, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (target_start >= target.length) target_start = target.length
  if (!target_start) target_start = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (target_start < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - target_start < end - start) {
    end = target.length - target_start + start
  }

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":50,"ieee754":51,"is-array":52}],50:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],51:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],52:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],53:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],54:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":55}],55:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],56:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],57:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],58:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],59:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":57,"./encode":58}],60:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":56,"querystring":59}],61:[function(require,module,exports){
(function (global){
/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

;(function() {

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(this.smartypants(cap[0]));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */

InlineLexer.prototype.smartypants = function(text) {
  if (!this.options.smartypants) return text;
  return text
    // em-dashes
    .replace(/--/g, '\u2014')
    // opening singles
    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
    // closing singles & apostrophes
    .replace(/'/g, '\u2019')
    // opening doubles
    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
    // closing doubles
    .replace(/"/g, '\u201d')
    // ellipses
    .replace(/\.{3}/g, '\u2026');
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  return html.replace(/&([#\w]+);/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

if (typeof module !== 'undefined' && typeof exports === 'object') {
  module.exports = marked;
} else if (typeof define === 'function' && define.amd) {
  define(function() { return marked; });
} else {
  this.marked = marked;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],62:[function(require,module,exports){
//! moment.js
//! version : 2.10.2
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, function () { 'use strict';

    var hookCallback;

    function utils_hooks__hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false
        };
    }

    function isArray(input) {
        return Object.prototype.toString.call(input) === '[object Array]';
    }

    function isDate(input) {
        return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function create_utc__createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function valid__isValid(m) {
        if (m._isValid == null) {
            m._isValid = !isNaN(m._d.getTime()) &&
                m._pf.overflow < 0 &&
                !m._pf.empty &&
                !m._pf.invalidMonth &&
                !m._pf.nullInput &&
                !m._pf.invalidFormat &&
                !m._pf.userInvalidated;

            if (m._strict) {
                m._isValid = m._isValid &&
                    m._pf.charsLeftOver === 0 &&
                    m._pf.unusedTokens.length === 0 &&
                    m._pf.bigHour === undefined;
            }
        }
        return m._isValid;
    }

    function valid__createInvalid (flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
            extend(m._pf, flags);
        }
        else {
            m._pf.userInvalidated = true;
        }

        return m;
    }

    var momentProperties = utils_hooks__hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (typeof from._isAMomentObject !== 'undefined') {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (typeof from._i !== 'undefined') {
            to._i = from._i;
        }
        if (typeof from._f !== 'undefined') {
            to._f = from._f;
        }
        if (typeof from._l !== 'undefined') {
            to._l = from._l;
        }
        if (typeof from._strict !== 'undefined') {
            to._strict = from._strict;
        }
        if (typeof from._tzm !== 'undefined') {
            to._tzm = from._tzm;
        }
        if (typeof from._isUTC !== 'undefined') {
            to._isUTC = from._isUTC;
        }
        if (typeof from._offset !== 'undefined') {
            to._offset = from._offset;
        }
        if (typeof from._pf !== 'undefined') {
            to._pf = from._pf;
        }
        if (typeof from._locale !== 'undefined') {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i in momentProperties) {
                prop = momentProperties[i];
                val = from[prop];
                if (typeof val !== 'undefined') {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(+config._d);
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            utils_hooks__hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && hasOwnProp(obj, '_isAMomentObject'));
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            if (coercedNumber >= 0) {
                value = Math.floor(coercedNumber);
            } else {
                value = Math.ceil(coercedNumber);
            }
        }

        return value;
    }

    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function Locale() {
    }

    var locales = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return null;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && typeof module !== 'undefined' &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                require('./locale/' + name);
                // because defineLocale currently also sets the global locale, we
                // want to undo that for lazy loaded locales
                locale_locales__getSetGlobalLocale(oldLocale);
            } catch (e) { }
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function locale_locales__getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (typeof values === 'undefined') {
                data = locale_locales__getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, values) {
        if (values !== null) {
            values.abbr = name;
            if (!locales[name]) {
                locales[name] = new Locale();
            }
            locales[name].set(values);

            // backwards compat for now: also set the locale
            locale_locales__getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    // returns locale data
    function locale_locales__getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                get_set__set(this, unit, value);
                utils_hooks__hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get_set__get(this, unit);
            }
        };
    }

    function get_set__get (mom, unit) {
        return mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]();
    }

    function get_set__set (mom, unit, value) {
        return mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }

    // MOMENTS

    function getSet (units, value) {
        var unit;
        if (typeof units === 'object') {
            for (unit in units) {
                this.set(unit, units[unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (typeof this[units] === 'function') {
                return this[units](value);
            }
        }
        return this;
    }

    function zeroFill(number, targetLength, forceSign) {
        var output = '' + Math.abs(number),
            sign = number >= 0;

        while (output.length < targetLength) {
            output = '0' + output;
        }
        return (sign ? (forceSign ? '+' : '') : '-') + output;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '';
            for (i = 0; i < length; i++) {
                output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());

        if (!formatFunctions[format]) {
            formatFunctions[format] = makeFormatFunction(format);
        }

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = typeof regex === 'function' ? regex : function (isStrict) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (typeof callback === 'number') {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  matchWord);
    addRegexToken('MMMM', matchWord);

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            config._pf.invalidMonth = input;
        }
    });

    // LOCALES

    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m) {
        return this._months[m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m) {
        return this._monthsShort[m.month()];
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = create_utc__createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        // TODO: Move this out of here!
        if (typeof value === 'string') {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (typeof value !== 'number') {
                return mom;
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            utils_hooks__hooks.updateOffset(this, true);
            return this;
        } else {
            return get_set__get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && m._pf.overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (m._pf._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }

            m._pf.overflow = overflow;
        }

        return m;
    }

    function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && typeof console !== 'undefined' && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function () {
            if (firstTime) {
                warn(msg);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    utils_hooks__hooks.suppressDeprecationWarnings = false;

    var from_string__isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d{2}-\d{2}/],
        ['YYYY-MM-DD', /\d{4}-\d{2}-\d{2}/],
        ['GGGG-[W]WW-E', /\d{4}-W\d{2}-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d{2}/],
        ['YYYY-DDD', /\d{4}-\d{3}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /(T| )\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss', /(T| )\d\d:\d\d:\d\d/],
        ['HH:mm', /(T| )\d\d:\d\d/],
        ['HH', /(T| )\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = from_string__isoRegex.exec(string);

        if (match) {
            config._pf.iso = true;
            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(string)) {
                    // match[5] should be 'T' or undefined
                    config._f = isoDates[i][0] + (match[6] || ' ');
                    break;
                }
            }
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(string)) {
                    config._f += isoTimes[i][0];
                    break;
                }
            }
            if (string.match(matchOffset)) {
                config._f += 'Z';
            }
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    utils_hooks__hooks.createFromInputFallback = deprecate(
        'moment construction falls back to js Date. This is ' +
        'discouraged and will be removed in upcoming major ' +
        'release. Please refer to ' +
        'https://github.com/moment/moment/issues/1407 for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    function createDate (y, m, d, h, M, s, ms) {
        //can't just apply() to create a date:
        //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
        var date = new Date(y, m, d, h, M, s, ms);

        //the date constructor doesn't accept years < 1970
        if (y < 1970) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate (y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 1970) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYY', 'YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YY', function (input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    utils_hooks__hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', false);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // firstDayOfWeek       0 = sun, 6 = sat
    //                      the day of the week that starts the week
    //                      (usually sunday or monday)
    // firstDayOfWeekOfYear 0 = sun, 6 = sat
    //                      the first week is the week that contains the first
    //                      of this day of the week
    //                      (eg. ISO weeks use thursday (4))
    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var end = firstDayOfWeekOfYear - firstDayOfWeek,
            daysToDayOfWeek = firstDayOfWeekOfYear - mom.day(),
            adjustedMoment;


        if (daysToDayOfWeek > end) {
            daysToDayOfWeek -= 7;
        }

        if (daysToDayOfWeek < end - 7) {
            daysToDayOfWeek += 7;
        }

        adjustedMoment = local__createLocal(mom).add(daysToDayOfWeek, 'd');
        return {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        };
    }

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    //http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var d = createUTCDate(year, 0, 1).getUTCDay();
        var daysToAdd;
        var dayOfYear;

        d = d === 0 ? 7 : d;
        weekday = weekday != null ? weekday : firstDayOfWeek;
        daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (d < firstDayOfWeek ? 7 : 0);
        dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1;

        return {
            year      : dayOfYear > 0 ? year      : year - 1,
            dayOfYear : dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        };
    }

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        var now = new Date();
        if (config._useUTC) {
            return [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()];
        }
        return [now.getFullYear(), now.getMonth(), now.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse)) {
                config._pf._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
            week = defaults(w.w, 1);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < dow) {
                    ++week;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow);

        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }

    utils_hooks__hooks.ISO_8601 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === utils_hooks__hooks.ISO_8601) {
            configFromISO(config);
            return;
        }

        config._a = [];
        config._pf.empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    config._pf.unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    config._pf.empty = false;
                }
                else {
                    config._pf.unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                config._pf.unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        config._pf.charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            config._pf.unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._pf.bigHour === true && config._a[HOUR] <= 12) {
            config._pf.bigHour = undefined;
        }
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            config._pf.invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._pf = defaultParsingFlags();
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!valid__isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += tempConfig._pf.charsLeftOver;

            //or tokens
            currentScore += tempConfig._pf.unusedTokens.length * 10;

            tempConfig._pf.score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = [i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond];

        configFromArray(config);
    }

    function createFromConfig (config) {
        var input = config._i,
            format = config._f,
            res;

        config._locale = config._locale || locale_locales__getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return valid__createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        res = new Moment(checkOverflow(config));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
            config._d = new Date();
        } else if (isDate(input)) {
            config._d = new Date(+input);
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (typeof(input) === 'object') {
            configFromObject(config);
        } else if (typeof(input) === 'number') {
            // from milliseconds
            config._d = new Date(input);
        } else {
            utils_hooks__hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (typeof(locale) === 'boolean') {
            strict = locale;
            locale = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        c._pf = defaultParsingFlags();

        return createFromConfig(c);
    }

    function local__createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
         'moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548',
         function () {
             var other = local__createLocal.apply(null, arguments);
             return other < this ? this : other;
         }
     );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548',
        function () {
            var other = local__createLocal.apply(null, arguments);
            return other > this ? this : other;
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 36e5; // 1000 * 60 * 60
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = locale_locales__getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchOffset);
    addRegexToken('ZZ', matchOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(string) {
        var matches = ((string || '').match(matchOffset) || []);
        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? +input : +local__createLocal(input)) - (+res);
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(+res._d + diff);
            utils_hooks__hooks.updateOffset(res, false);
            return res;
        } else {
            return local__createLocal(input).local();
        }
        return model._isUTC ? local__createLocal(input).zone(model._offset || 0) : local__createLocal(input).local();
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    utils_hooks__hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(input);
            }
            if (Math.abs(input) < 16) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    utils_hooks__hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm) {
            this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
            this.utcOffset(offsetFromString(this._i));
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!input) {
            input = 0;
        }
        else {
            input = local__createLocal(input).utcOffset();
        }

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (this._a) {
            var other = this._isUTC ? create_utc__createUTC(this._a) : local__createLocal(this._a);
            return this.isValid() && compareArrays(this._a, other.toArray()) > 0;
        }

        return false;
    }

    function isLocal () {
        return !this._isUTC;
    }

    function isUtcOffset () {
        return this._isUTC;
    }

    function isUtc () {
        return this._isUTC && this._offset === 0;
    }

    var aspNetRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    var create__isoRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/;

    function create__createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (typeof input === 'number') {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])        * sign,
                h  : toInt(match[HOUR])        * sign,
                m  : toInt(match[MINUTE])      * sign,
                s  : toInt(match[SECOND])      * sign,
                ms : toInt(match[MILLISECOND]) * sign
            };
        } else if (!!(match = create__isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                d : parseIso(match[4], sign),
                h : parseIso(match[5], sign),
                m : parseIso(match[6], sign),
                s : parseIso(match[7], sign),
                w : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    create__createDuration.fn = Duration.prototype;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = create__createDuration(val, period);
            add_subtract__addSubtract(this, dur, direction);
            return this;
        };
    }

    function add_subtract__addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = duration._days,
            months = duration._months;
        updateOffset = updateOffset == null ? true : updateOffset;

        if (milliseconds) {
            mom._d.setTime(+mom._d + milliseconds * isAdding);
        }
        if (days) {
            get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
            setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
            utils_hooks__hooks.updateOffset(mom, days || months);
        }
    }

    var add_subtract__add      = createAdder(1, 'add');
    var add_subtract__subtract = createAdder(-1, 'subtract');

    function moment_calendar__calendar (time) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
        return this.format(this.localeData().calendar(format, this, local__createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this > +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return inputMs < +this.clone().startOf(units);
        }
    }

    function isBefore (input, units) {
        var inputMs;
        units = normalizeUnits(typeof units !== 'undefined' ? units : 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this < +input;
        } else {
            inputMs = isMoment(input) ? +input : +local__createLocal(input);
            return +this.clone().endOf(units) < inputMs;
        }
    }

    function isBetween (from, to, units) {
        return this.isAfter(from, units) && this.isBefore(to, units);
    }

    function isSame (input, units) {
        var inputMs;
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            input = isMoment(input) ? input : local__createLocal(input);
            return +this === +input;
        } else {
            inputMs = +local__createLocal(input);
            return +(this.clone().startOf(units)) <= inputMs && inputMs <= +(this.clone().endOf(units));
        }
    }

    function absFloor (number) {
        if (number < 0) {
            return Math.ceil(number);
        } else {
            return Math.floor(number);
        }
    }

    function diff (input, units, asFloat) {
        var that = cloneWithOffset(input, this),
            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4,
            delta, output;

        units = normalizeUnits(units);

        if (units === 'year' || units === 'month' || units === 'quarter') {
            output = monthDiff(this, that);
            if (units === 'quarter') {
                output = output / 3;
            } else if (units === 'year') {
                output = output / 12;
            }
        } else {
            delta = this - that;
            output = units === 'second' ? delta / 1e3 : // 1000
                units === 'minute' ? delta / 6e4 : // 1000 * 60
                units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
                units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
                units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
                delta;
        }
        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        return -(wholeMonthDiff + adjust);
    }

    utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function moment_format__toISOString () {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
            if ('function' === typeof Date.prototype.toISOString) {
                // native implementation is ~50x faster, use it when we can
                return this.toDate().toISOString();
            } else {
                return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
            }
        } else {
            return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    }

    function format (inputString) {
        var output = formatMoment(this, inputString || utils_hooks__hooks.defaultFormat);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        return create__createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    }

    function fromNow (withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
    }

    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = locale_locales__getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    function startOf (units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf (units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function to_type__valueOf () {
        return +this._d - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(+this / 1000);
    }

    function toDate () {
        return this._offset ? new Date(+this) : this._d;
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function moment_valid__isValid () {
        return valid__isValid(this);
    }

    function parsingFlags () {
        return extend({}, this._pf);
    }

    function invalidAt () {
        return this._pf.overflow;
    }

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
    });

    // HELPERS

    function weeksInYear(year, dow, doy) {
        return weekOfYear(local__createLocal([year, 11, 31 + dow - doy]), dow, doy).week;
    }

    // MOMENTS

    function getSetWeekYear (input) {
        var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getSetISOWeekYear (input) {
        var year = weekOfYear(this, 1, 4).year;
        return input == null ? year : this.add((input - year), 'y');
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    addFormatToken('Q', 0, 0, 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   matchWord);
    addRegexToken('ddd',  matchWord);
    addRegexToken('dddd', matchWord);

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config) {
        var weekday = config._locale.weekdaysParse(input);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            config._pf.invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input === 'string') {
            if (!isNaN(input)) {
                input = parseInt(input, 10);
            }
            else {
                input = locale.weekdaysParse(input);
                if (typeof input !== 'number') {
                    return null;
                }
            }
        }
        return input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m) {
        return this._weekdays[m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return this._weekdaysShort[m.day()];
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return this._weekdaysMin[m.day()];
    }

    function localeWeekdaysParse (weekdayName) {
        var i, mom, regex;

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            if (!this._weekdaysParse[i]) {
                mom = local__createLocal([2000, 1]).day(i);
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, function () {
        return this.hours() % 12 || 12;
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        config._pf.bigHour = true;
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    function millisecond__milliseconds (token) {
        addFormatToken(0, [token, 3], 0, 'millisecond');
    }

    millisecond__milliseconds('SSS');
    millisecond__milliseconds('SSSS');

    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);
    addRegexToken('SSSS', matchUnsigned);
    addParseToken(['S', 'SS', 'SSS', 'SSSS'], function (input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    });

    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var momentPrototype__proto = Moment.prototype;

    momentPrototype__proto.add          = add_subtract__add;
    momentPrototype__proto.calendar     = moment_calendar__calendar;
    momentPrototype__proto.clone        = clone;
    momentPrototype__proto.diff         = diff;
    momentPrototype__proto.endOf        = endOf;
    momentPrototype__proto.format       = format;
    momentPrototype__proto.from         = from;
    momentPrototype__proto.fromNow      = fromNow;
    momentPrototype__proto.get          = getSet;
    momentPrototype__proto.invalidAt    = invalidAt;
    momentPrototype__proto.isAfter      = isAfter;
    momentPrototype__proto.isBefore     = isBefore;
    momentPrototype__proto.isBetween    = isBetween;
    momentPrototype__proto.isSame       = isSame;
    momentPrototype__proto.isValid      = moment_valid__isValid;
    momentPrototype__proto.lang         = lang;
    momentPrototype__proto.locale       = locale;
    momentPrototype__proto.localeData   = localeData;
    momentPrototype__proto.max          = prototypeMax;
    momentPrototype__proto.min          = prototypeMin;
    momentPrototype__proto.parsingFlags = parsingFlags;
    momentPrototype__proto.set          = getSet;
    momentPrototype__proto.startOf      = startOf;
    momentPrototype__proto.subtract     = add_subtract__subtract;
    momentPrototype__proto.toArray      = toArray;
    momentPrototype__proto.toDate       = toDate;
    momentPrototype__proto.toISOString  = moment_format__toISOString;
    momentPrototype__proto.toJSON       = moment_format__toISOString;
    momentPrototype__proto.toString     = toString;
    momentPrototype__proto.unix         = unix;
    momentPrototype__proto.valueOf      = to_type__valueOf;

    // Year
    momentPrototype__proto.year       = getSetYear;
    momentPrototype__proto.isLeapYear = getIsLeapYear;

    // Week Year
    momentPrototype__proto.weekYear    = getSetWeekYear;
    momentPrototype__proto.isoWeekYear = getSetISOWeekYear;

    // Quarter
    momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;

    // Month
    momentPrototype__proto.month       = getSetMonth;
    momentPrototype__proto.daysInMonth = getDaysInMonth;

    // Week
    momentPrototype__proto.week           = momentPrototype__proto.weeks        = getSetWeek;
    momentPrototype__proto.isoWeek        = momentPrototype__proto.isoWeeks     = getSetISOWeek;
    momentPrototype__proto.weeksInYear    = getWeeksInYear;
    momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;

    // Day
    momentPrototype__proto.date       = getSetDayOfMonth;
    momentPrototype__proto.day        = momentPrototype__proto.days             = getSetDayOfWeek;
    momentPrototype__proto.weekday    = getSetLocaleDayOfWeek;
    momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
    momentPrototype__proto.dayOfYear  = getSetDayOfYear;

    // Hour
    momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;

    // Minute
    momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;

    // Second
    momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;

    // Millisecond
    momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;

    // Offset
    momentPrototype__proto.utcOffset            = getSetOffset;
    momentPrototype__proto.utc                  = setOffsetToUTC;
    momentPrototype__proto.local                = setOffsetToLocal;
    momentPrototype__proto.parseZone            = setOffsetToParsedOffset;
    momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
    momentPrototype__proto.isDST                = isDaylightSavingTime;
    momentPrototype__proto.isDSTShifted         = isDaylightSavingTimeShifted;
    momentPrototype__proto.isLocal              = isLocal;
    momentPrototype__proto.isUtcOffset          = isUtcOffset;
    momentPrototype__proto.isUtc                = isUtc;
    momentPrototype__proto.isUTC                = isUtc;

    // Timezone
    momentPrototype__proto.zoneAbbr = getZoneAbbr;
    momentPrototype__proto.zoneName = getZoneName;

    // Deprecations
    momentPrototype__proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    momentPrototype__proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    momentPrototype__proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);

    var momentPrototype = momentPrototype__proto;

    function moment__createUnix (input) {
        return local__createLocal(input * 1000);
    }

    function moment__createInZone () {
        return local__createLocal.apply(null, arguments).parseZone();
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function locale_calendar__calendar (key, mom, now) {
        var output = this._calendar[key];
        return typeof output === 'function' ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY LT',
        LLLL : 'dddd, MMMM D, YYYY LT'
    };

    function longDateFormat (key) {
        var output = this._longDateFormat[key];
        if (!output && this._longDateFormat[key.toUpperCase()]) {
            output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                return val.slice(1);
            });
            this._longDateFormat[key] = output;
        }
        return output;
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    function preParsePostFormat (string) {
        return string;
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relative__relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (typeof output === 'function') ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return typeof format === 'function' ? format(output) : format.replace(/%s/i, output);
    }

    function locale_set__set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (typeof prop === 'function') {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _ordinalParseLenient.
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + /\d{1,2}/.source);
    }

    var prototype__proto = Locale.prototype;

    prototype__proto._calendar       = defaultCalendar;
    prototype__proto.calendar        = locale_calendar__calendar;
    prototype__proto._longDateFormat = defaultLongDateFormat;
    prototype__proto.longDateFormat  = longDateFormat;
    prototype__proto._invalidDate    = defaultInvalidDate;
    prototype__proto.invalidDate     = invalidDate;
    prototype__proto._ordinal        = defaultOrdinal;
    prototype__proto.ordinal         = ordinal;
    prototype__proto._ordinalParse   = defaultOrdinalParse;
    prototype__proto.preparse        = preParsePostFormat;
    prototype__proto.postformat      = preParsePostFormat;
    prototype__proto._relativeTime   = defaultRelativeTime;
    prototype__proto.relativeTime    = relative__relativeTime;
    prototype__proto.pastFuture      = pastFuture;
    prototype__proto.set             = locale_set__set;

    // Month
    prototype__proto.months       =        localeMonths;
    prototype__proto._months      = defaultLocaleMonths;
    prototype__proto.monthsShort  =        localeMonthsShort;
    prototype__proto._monthsShort = defaultLocaleMonthsShort;
    prototype__proto.monthsParse  =        localeMonthsParse;

    // Week
    prototype__proto.week = localeWeek;
    prototype__proto._week = defaultLocaleWeek;
    prototype__proto.firstDayOfYear = localeFirstDayOfYear;
    prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;

    // Day of Week
    prototype__proto.weekdays       =        localeWeekdays;
    prototype__proto._weekdays      = defaultLocaleWeekdays;
    prototype__proto.weekdaysMin    =        localeWeekdaysMin;
    prototype__proto._weekdaysMin   = defaultLocaleWeekdaysMin;
    prototype__proto.weekdaysShort  =        localeWeekdaysShort;
    prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
    prototype__proto.weekdaysParse  =        localeWeekdaysParse;

    // Hours
    prototype__proto.isPM = localeIsPM;
    prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
    prototype__proto.meridiem = localeMeridiem;

    function lists__get (format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function list (format, index, field, count, setter) {
        if (typeof format === 'number') {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return lists__get(format, index, field, setter);
        }

        var i;
        var out = [];
        for (i = 0; i < count; i++) {
            out[i] = lists__get(format, i, field, setter);
        }
        return out;
    }

    function lists__listMonths (format, index) {
        return list(format, index, 'months', 12, 'month');
    }

    function lists__listMonthsShort (format, index) {
        return list(format, index, 'monthsShort', 12, 'month');
    }

    function lists__listWeekdays (format, index) {
        return list(format, index, 'weekdays', 7, 'day');
    }

    function lists__listWeekdaysShort (format, index) {
        return list(format, index, 'weekdaysShort', 7, 'day');
    }

    function lists__listWeekdaysMin (format, index) {
        return list(format, index, 'weekdaysMin', 7, 'day');
    }

    locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports
    utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
    utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);

    var mathAbs = Math.abs;

    function duration_abs__abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function duration_add_subtract__addSubtract (duration, input, value, direction) {
        var other = create__createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function duration_add_subtract__add (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function duration_add_subtract__subtract (input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years = 0;

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // Accurately convert days to years, assume start from year 0.
        years = absFloor(daysToYears(days));
        days -= absFloor(yearsToDays(years));

        // 30 days to a month
        // TODO (iskren): Use anchor date (like 1st Jan) to compute this.
        months += absFloor(days / 30);
        days   %= 30;

        // 12 months -> 1 year
        years  += absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToYears (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        return days * 400 / 146097;
    }

    function yearsToDays (years) {
        // years * 365 + absFloor(years / 4) -
        //     absFloor(years / 100) + absFloor(years / 400);
        return years * 146097 / 400;
    }

    function as (units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days   = this._days   + milliseconds / 864e5;
            months = this._months + daysToYears(days) * 12;
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(yearsToDays(this._months / 12));
            switch (units) {
                case 'week'   : return days / 7            + milliseconds / 6048e5;
                case 'day'    : return days                + milliseconds / 864e5;
                case 'hour'   : return days * 24           + milliseconds / 36e5;
                case 'minute' : return days * 24 * 60      + milliseconds / 6e4;
                case 'second' : return days * 24 * 60 * 60 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 24 * 60 * 60 * 1000) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function duration_as__valueOf () {
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asYears        = makeAs('y');

    function duration_get__get (units) {
        units = normalizeUnits(units);
        return this[units + 's']();
    }

    function makeGetter(name) {
        return function () {
            return this._data[name];
        };
    }

    var duration_get__milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        s: 45,  // seconds to minute
        m: 45,  // minutes to hour
        h: 22,  // hours to day
        d: 26,  // days to month
        M: 11   // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function duration_humanize__relativeTime (posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds < thresholds.s && ['s', seconds]  ||
                minutes === 1          && ['m']           ||
                minutes < thresholds.m && ['mm', minutes] ||
                hours   === 1          && ['h']           ||
                hours   < thresholds.h && ['hh', hours]   ||
                days    === 1          && ['d']           ||
                days    < thresholds.d && ['dd', days]    ||
                months  === 1          && ['M']           ||
                months  < thresholds.M && ['MM', months]  ||
                years   === 1          && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set a threshold for relative time strings
    function duration_humanize__getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
    }

    function humanize (withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var iso_string__abs = Math.abs;

    function iso_string__toISOString() {
        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = iso_string__abs(this.years());
        var M = iso_string__abs(this.months());
        var D = iso_string__abs(this.days());
        var h = iso_string__abs(this.hours());
        var m = iso_string__abs(this.minutes());
        var s = iso_string__abs(this.seconds() + this.milliseconds() / 1000);
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        return (total < 0 ? '-' : '') +
            'P' +
            (Y ? Y + 'Y' : '') +
            (M ? M + 'M' : '') +
            (D ? D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? h + 'H' : '') +
            (m ? m + 'M' : '') +
            (s ? s + 'S' : '');
    }

    var duration_prototype__proto = Duration.prototype;

    duration_prototype__proto.abs            = duration_abs__abs;
    duration_prototype__proto.add            = duration_add_subtract__add;
    duration_prototype__proto.subtract       = duration_add_subtract__subtract;
    duration_prototype__proto.as             = as;
    duration_prototype__proto.asMilliseconds = asMilliseconds;
    duration_prototype__proto.asSeconds      = asSeconds;
    duration_prototype__proto.asMinutes      = asMinutes;
    duration_prototype__proto.asHours        = asHours;
    duration_prototype__proto.asDays         = asDays;
    duration_prototype__proto.asWeeks        = asWeeks;
    duration_prototype__proto.asMonths       = asMonths;
    duration_prototype__proto.asYears        = asYears;
    duration_prototype__proto.valueOf        = duration_as__valueOf;
    duration_prototype__proto._bubble        = bubble;
    duration_prototype__proto.get            = duration_get__get;
    duration_prototype__proto.milliseconds   = duration_get__milliseconds;
    duration_prototype__proto.seconds        = seconds;
    duration_prototype__proto.minutes        = minutes;
    duration_prototype__proto.hours          = hours;
    duration_prototype__proto.days           = days;
    duration_prototype__proto.weeks          = weeks;
    duration_prototype__proto.months         = months;
    duration_prototype__proto.years          = years;
    duration_prototype__proto.humanize       = humanize;
    duration_prototype__proto.toISOString    = iso_string__toISOString;
    duration_prototype__proto.toString       = iso_string__toISOString;
    duration_prototype__proto.toJSON         = iso_string__toISOString;
    duration_prototype__proto.locale         = locale;
    duration_prototype__proto.localeData     = localeData;

    // Deprecations
    duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
    duration_prototype__proto.lang = lang;

    // Side effect imports

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    utils_hooks__hooks.version = '2.10.2';

    setHookCallback(local__createLocal);

    utils_hooks__hooks.fn                    = momentPrototype;
    utils_hooks__hooks.min                   = min;
    utils_hooks__hooks.max                   = max;
    utils_hooks__hooks.utc                   = create_utc__createUTC;
    utils_hooks__hooks.unix                  = moment__createUnix;
    utils_hooks__hooks.months                = lists__listMonths;
    utils_hooks__hooks.isDate                = isDate;
    utils_hooks__hooks.locale                = locale_locales__getSetGlobalLocale;
    utils_hooks__hooks.invalid               = valid__createInvalid;
    utils_hooks__hooks.duration              = create__createDuration;
    utils_hooks__hooks.isMoment              = isMoment;
    utils_hooks__hooks.weekdays              = lists__listWeekdays;
    utils_hooks__hooks.parseZone             = moment__createInZone;
    utils_hooks__hooks.localeData            = locale_locales__getLocale;
    utils_hooks__hooks.isDuration            = isDuration;
    utils_hooks__hooks.monthsShort           = lists__listMonthsShort;
    utils_hooks__hooks.weekdaysMin           = lists__listWeekdaysMin;
    utils_hooks__hooks.defineLocale          = defineLocale;
    utils_hooks__hooks.weekdaysShort         = lists__listWeekdaysShort;
    utils_hooks__hooks.normalizeUnits        = normalizeUnits;
    utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;

    var _moment = utils_hooks__hooks;

    return _moment;

}));
},{}],63:[function(require,module,exports){
var SvgPanZoom = require('./svg-pan-zoom.js');

module.exports = SvgPanZoom;

},{"./svg-pan-zoom.js":66}],64:[function(require,module,exports){
var SvgUtils = require('./svg-utilities');

module.exports = {
  enable: function(instance) {
    // Select (and create if necessary) defs
    var defs = instance.svg.querySelector('defs')
    if (!defs) {
      defs = document.createElementNS(SvgUtils.svgNS, 'defs')
      instance.svg.appendChild(defs)
    }

    // Create style element
    var style = document.createElementNS(SvgUtils.svgNS, 'style')
    style.setAttribute('type', 'text/css')
    style.textContent = '.svg-pan-zoom-control { cursor: pointer; fill: black; fill-opacity: 0.333; } .svg-pan-zoom-control:hover { fill-opacity: 0.8; } .svg-pan-zoom-control-background { fill: white; fill-opacity: 0.5; } .svg-pan-zoom-control-background { fill-opacity: 0.8; }'
    defs.appendChild(style)


    // Zoom Group
    var zoomGroup = document.createElementNS(SvgUtils.svgNS, 'g');
    zoomGroup.setAttribute('id', 'svg-pan-zoom-controls');
    zoomGroup.setAttribute('transform', 'translate(' + ( instance.width - 70 ) + ' ' + ( instance.height - 76 ) + ') scale(0.75)');
    zoomGroup.setAttribute('class', 'svg-pan-zoom-control');

    // Control elements
    zoomGroup.appendChild(this._createZoomIn(instance))
    zoomGroup.appendChild(this._createZoomReset(instance))
    zoomGroup.appendChild(this._createZoomOut(instance))

    // Finally append created element
    instance.svg.appendChild(zoomGroup)

    // Cache control instance
    instance.controlIcons = zoomGroup
  }

, _createZoomIn: function(instance) {
    var zoomIn = document.createElementNS(SvgUtils.svgNS, 'g');
    zoomIn.setAttribute('id', 'svg-pan-zoom-zoom-in');
    zoomIn.setAttribute('transform', 'translate(30.5 5) scale(0.015)');
    zoomIn.setAttribute('class', 'svg-pan-zoom-control');
    zoomIn.addEventListener('click', function() {instance.getPublicInstance().zoomIn()}, false)
    zoomIn.addEventListener('touchstart', function() {instance.getPublicInstance().zoomIn()}, false)

    var zoomInBackground = document.createElementNS(SvgUtils.svgNS, 'rect'); // TODO change these background space fillers to rounded rectangles so they look prettier
    zoomInBackground.setAttribute('x', '0');
    zoomInBackground.setAttribute('y', '0');
    zoomInBackground.setAttribute('width', '1500'); // larger than expected because the whole group is transformed to scale down
    zoomInBackground.setAttribute('height', '1400');
    zoomInBackground.setAttribute('class', 'svg-pan-zoom-control-background');
    zoomIn.appendChild(zoomInBackground);

    var zoomInShape = document.createElementNS(SvgUtils.svgNS, 'path');
    zoomInShape.setAttribute('d', 'M1280 576v128q0 26 -19 45t-45 19h-320v320q0 26 -19 45t-45 19h-128q-26 0 -45 -19t-19 -45v-320h-320q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h320v-320q0 -26 19 -45t45 -19h128q26 0 45 19t19 45v320h320q26 0 45 19t19 45zM1536 1120v-960 q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5t84.5 -203.5z');
    zoomInShape.setAttribute('class', 'svg-pan-zoom-control-element');
    zoomIn.appendChild(zoomInShape);

    return zoomIn
  }

, _createZoomReset: function(instance){
    // reset
    var resetPanZoomControl = document.createElementNS(SvgUtils.svgNS, 'g');
    resetPanZoomControl.setAttribute('id', 'svg-pan-zoom-reset-pan-zoom');
    resetPanZoomControl.setAttribute('transform', 'translate(5 35) scale(0.4)');
    resetPanZoomControl.setAttribute('class', 'svg-pan-zoom-control');
    resetPanZoomControl.addEventListener('click', function() {instance.getPublicInstance().reset()}, false);
    resetPanZoomControl.addEventListener('touchstart', function() {instance.getPublicInstance().reset()}, false);

    var resetPanZoomControlBackground = document.createElementNS(SvgUtils.svgNS, 'rect'); // TODO change these background space fillers to rounded rectangles so they look prettier
    resetPanZoomControlBackground.setAttribute('x', '2');
    resetPanZoomControlBackground.setAttribute('y', '2');
    resetPanZoomControlBackground.setAttribute('width', '182'); // larger than expected because the whole group is transformed to scale down
    resetPanZoomControlBackground.setAttribute('height', '58');
    resetPanZoomControlBackground.setAttribute('class', 'svg-pan-zoom-control-background');
    resetPanZoomControl.appendChild(resetPanZoomControlBackground);

    var resetPanZoomControlShape1 = document.createElementNS(SvgUtils.svgNS, 'path');
    resetPanZoomControlShape1.setAttribute('d', 'M33.051,20.632c-0.742-0.406-1.854-0.609-3.338-0.609h-7.969v9.281h7.769c1.543,0,2.701-0.188,3.473-0.562c1.365-0.656,2.048-1.953,2.048-3.891C35.032,22.757,34.372,21.351,33.051,20.632z');
    resetPanZoomControlShape1.setAttribute('class', 'svg-pan-zoom-control-element');
    resetPanZoomControl.appendChild(resetPanZoomControlShape1);

    var resetPanZoomControlShape2 = document.createElementNS(SvgUtils.svgNS, 'path');
    resetPanZoomControlShape2.setAttribute('d', 'M170.231,0.5H15.847C7.102,0.5,0.5,5.708,0.5,11.84v38.861C0.5,56.833,7.102,61.5,15.847,61.5h154.384c8.745,0,15.269-4.667,15.269-10.798V11.84C185.5,5.708,178.976,0.5,170.231,0.5z M42.837,48.569h-7.969c-0.219-0.766-0.375-1.383-0.469-1.852c-0.188-0.969-0.289-1.961-0.305-2.977l-0.047-3.211c-0.03-2.203-0.41-3.672-1.142-4.406c-0.732-0.734-2.103-1.102-4.113-1.102h-7.05v13.547h-7.055V14.022h16.524c2.361,0.047,4.178,0.344,5.45,0.891c1.272,0.547,2.351,1.352,3.234,2.414c0.731,0.875,1.31,1.844,1.737,2.906s0.64,2.273,0.64,3.633c0,1.641-0.414,3.254-1.242,4.84s-2.195,2.707-4.102,3.363c1.594,0.641,2.723,1.551,3.387,2.73s0.996,2.98,0.996,5.402v2.32c0,1.578,0.063,2.648,0.19,3.211c0.19,0.891,0.635,1.547,1.333,1.969V48.569z M75.579,48.569h-26.18V14.022h25.336v6.117H56.454v7.336h16.781v6H56.454v8.883h19.125V48.569z M104.497,46.331c-2.44,2.086-5.887,3.129-10.34,3.129c-4.548,0-8.125-1.027-10.731-3.082s-3.909-4.879-3.909-8.473h6.891c0.224,1.578,0.662,2.758,1.316,3.539c1.196,1.422,3.246,2.133,6.15,2.133c1.739,0,3.151-0.188,4.236-0.562c2.058-0.719,3.087-2.055,3.087-4.008c0-1.141-0.504-2.023-1.512-2.648c-1.008-0.609-2.607-1.148-4.796-1.617l-3.74-0.82c-3.676-0.812-6.201-1.695-7.576-2.648c-2.328-1.594-3.492-4.086-3.492-7.477c0-3.094,1.139-5.664,3.417-7.711s5.623-3.07,10.036-3.07c3.685,0,6.829,0.965,9.431,2.895c2.602,1.93,3.966,4.73,4.093,8.402h-6.938c-0.128-2.078-1.057-3.555-2.787-4.43c-1.154-0.578-2.587-0.867-4.301-0.867c-1.907,0-3.428,0.375-4.565,1.125c-1.138,0.75-1.706,1.797-1.706,3.141c0,1.234,0.561,2.156,1.682,2.766c0.721,0.406,2.25,0.883,4.589,1.43l6.063,1.43c2.657,0.625,4.648,1.461,5.975,2.508c2.059,1.625,3.089,3.977,3.089,7.055C108.157,41.624,106.937,44.245,104.497,46.331z M139.61,48.569h-26.18V14.022h25.336v6.117h-18.281v7.336h16.781v6h-16.781v8.883h19.125V48.569z M170.337,20.14h-10.336v28.43h-7.266V20.14h-10.383v-6.117h27.984V20.14z');
    resetPanZoomControlShape2.setAttribute('class', 'svg-pan-zoom-control-element');
    resetPanZoomControl.appendChild(resetPanZoomControlShape2);

    return resetPanZoomControl
  }

, _createZoomOut: function(instance){
    // zoom out
    var zoomOut = document.createElementNS(SvgUtils.svgNS, 'g');
    zoomOut.setAttribute('id', 'svg-pan-zoom-zoom-out');
    zoomOut.setAttribute('transform', 'translate(30.5 70) scale(0.015)');
    zoomOut.setAttribute('class', 'svg-pan-zoom-control');
    zoomOut.addEventListener('click', function() {instance.getPublicInstance().zoomOut()}, false);
    zoomOut.addEventListener('touchstart', function() {instance.getPublicInstance().zoomOut()}, false);

    var zoomOutBackground = document.createElementNS(SvgUtils.svgNS, 'rect'); // TODO change these background space fillers to rounded rectangles so they look prettier
    zoomOutBackground.setAttribute('x', '0');
    zoomOutBackground.setAttribute('y', '0');
    zoomOutBackground.setAttribute('width', '1500'); // larger than expected because the whole group is transformed to scale down
    zoomOutBackground.setAttribute('height', '1400');
    zoomOutBackground.setAttribute('class', 'svg-pan-zoom-control-background');
    zoomOut.appendChild(zoomOutBackground);

    var zoomOutShape = document.createElementNS(SvgUtils.svgNS, 'path');
    zoomOutShape.setAttribute('d', 'M1280 576v128q0 26 -19 45t-45 19h-896q-26 0 -45 -19t-19 -45v-128q0 -26 19 -45t45 -19h896q26 0 45 19t19 45zM1536 1120v-960q0 -119 -84.5 -203.5t-203.5 -84.5h-960q-119 0 -203.5 84.5t-84.5 203.5v960q0 119 84.5 203.5t203.5 84.5h960q119 0 203.5 -84.5 t84.5 -203.5z');
    zoomOutShape.setAttribute('class', 'svg-pan-zoom-control-element');
    zoomOut.appendChild(zoomOutShape);

    return zoomOut
  }

, disable: function(instance) {
    if (instance.controlIcons) {
      instance.controlIcons.parentNode.removeChild(instance.controlIcons)
      instance.controlIcons = null
    }
  }
}

},{"./svg-utilities":67}],65:[function(require,module,exports){
var SvgUtils = require('./svg-utilities')
  , Utils = require('./utilities')
  ;

var ShadowViewport = function(viewport, options){
  this.init(viewport, options)
}

/**
 * Initialization
 *
 * @param  {SVGElement} viewport
 * @param  {Object} options
 */
ShadowViewport.prototype.init = function(viewport, options) {
  // DOM Elements
  this.viewport = viewport
  this.options = options

  // State cache
  this.originalState = {zoom: 1, x: 0, y: 0}
  this.activeState = {zoom: 1, x: 0, y: 0}

  this.updateCTMCached = Utils.proxy(this.updateCTM, this)

  // Create a custom requestAnimationFrame taking in account refreshRate
  this.requestAnimationFrame = Utils.createRequestAnimationFrame(this.options.refreshRate)

  // ViewBox
  this.viewBox = {x: 0, y: 0, width: 0, height: 0}
  this.cacheViewBox()

  // Process CTM
  this.processCTM()
}

/**
 * Cache initial viewBox value
 * If no viewBox is defined, then use viewport size/position instead for viewBox values
 */
ShadowViewport.prototype.cacheViewBox = function() {
  var svgViewBox = this.options.svg.getAttribute('viewBox')

  if (svgViewBox) {
    var viewBoxValues = svgViewBox.split(' ').map(parseFloat)

    // Cache viewbox x and y offset
    this.viewBox.x = viewBoxValues[0]
    this.viewBox.y = viewBoxValues[1]
    this.viewBox.width = viewBoxValues[2]
    this.viewBox.height = viewBoxValues[3]

    var zoom = Math.min(this.options.width / this.viewBox.width, this.options.height / this.viewBox.height)

    // Update active state
    this.activeState.zoom = zoom
    this.activeState.x = (this.options.width - this.viewBox.width * zoom) / 2
    this.activeState.y = (this.options.height - this.viewBox.height * zoom) / 2

    // Force updating CTM
    this.updateCTMOnNextFrame()

    this.options.svg.removeAttribute('viewBox')
  } else {
    var bBox = this.viewport.getBBox();

    // Cache viewbox sizes
    this.viewBox.x = bBox.x;
    this.viewBox.y = bBox.y;
    this.viewBox.width = bBox.width
    this.viewBox.height = bBox.height
  }
}

/**
 * Recalculate viewport sizes and update viewBox cache
 */
ShadowViewport.prototype.recacheViewBox = function() {
  var boundingClientRect = this.viewport.getBoundingClientRect()
    , viewBoxWidth = boundingClientRect.width / this.getZoom()
    , viewBoxHeight = boundingClientRect.height / this.getZoom()

  // Cache viewbox
  this.viewBox.x = 0
  this.viewBox.y = 0
  this.viewBox.width = viewBoxWidth
  this.viewBox.height = viewBoxHeight
}

/**
 * Returns a viewbox object. Safe to alter
 *
 * @return {Object} viewbox object
 */
ShadowViewport.prototype.getViewBox = function() {
  return Utils.extend({}, this.viewBox)
}

/**
 * Get initial zoom and pan values. Save them into originalState
 * Parses viewBox attribute to alter initial sizes
 */
ShadowViewport.prototype.processCTM = function() {
  var newCTM = this.getCTM()

  if (this.options.fit) {
    var newScale = Math.min(this.options.width/(this.viewBox.width - this.viewBox.x), this.options.height/(this.viewBox.height - this.viewBox.y));

    newCTM.a = newScale; //x-scale
    newCTM.d = newScale; //y-scale
    newCTM.e = -this.viewBox.x * newScale; //x-transform
    newCTM.f = -this.viewBox.y * newScale; //y-transform
  }

  if (this.options.center) {
    var offsetX = (this.options.width - (this.viewBox.width + this.viewBox.x) * newCTM.a) * 0.5
      , offsetY = (this.options.height - (this.viewBox.height + this.viewBox.y) * newCTM.a) * 0.5

    newCTM.e = offsetX
    newCTM.f = offsetY
  }

  // Cache initial values. Based on activeState and fix+center opitons
  this.originalState.zoom = newCTM.a
  this.originalState.x = newCTM.e
  this.originalState.y = newCTM.f

  // Update viewport CTM and cache zoom and pan
  this.setCTM(newCTM);
}

/**
 * Return originalState object. Safe to alter
 *
 * @return {Object}
 */
ShadowViewport.prototype.getOriginalState = function() {
  return Utils.extend({}, this.originalState)
}

/**
 * Return actualState object. Safe to alter
 *
 * @return {Object}
 */
ShadowViewport.prototype.getState = function() {
  return Utils.extend({}, this.activeState)
}

/**
 * Get zoom scale
 *
 * @return {Float} zoom scale
 */
ShadowViewport.prototype.getZoom = function() {
  return this.activeState.zoom
}

/**
 * Get zoom scale for pubilc usage
 *
 * @return {Float} zoom scale
 */
ShadowViewport.prototype.getRelativeZoom = function() {
  return this.activeState.zoom / this.originalState.zoom
}

/**
 * Compute zoom scale for pubilc usage
 *
 * @return {Float} zoom scale
 */
ShadowViewport.prototype.computeRelativeZoom = function(scale) {
  return scale / this.originalState.zoom
}

/**
 * Get pan
 *
 * @return {Object}
 */
ShadowViewport.prototype.getPan = function() {
  return {x: this.activeState.x, y: this.activeState.y}
}

/**
 * Return cached viewport CTM value that can be safely modified
 *
 * @return {SVGMatrix}
 */
ShadowViewport.prototype.getCTM = function() {
  var safeCTM = this.options.svg.createSVGMatrix()

  // Copy values manually as in FF they are not itterable
  safeCTM.a = this.activeState.zoom
  safeCTM.b = 0
  safeCTM.c = 0
  safeCTM.d = this.activeState.zoom
  safeCTM.e = this.activeState.x
  safeCTM.f = this.activeState.y

  return safeCTM
}

/**
 * Set a new CTM
 *
 * @param {SVGMatrix} newCTM
 */
ShadowViewport.prototype.setCTM = function(newCTM) {
  var willZoom = this.isZoomDifferent(newCTM)
    , willPan = this.isPanDifferent(newCTM)

  if (willZoom || willPan) {
    // Before zoom
    if (willZoom) {
      // If returns false then cancel zooming
      if (this.options.beforeZoom(this.getRelativeZoom(), this.computeRelativeZoom(newCTM.a)) === false) {
        newCTM.a = newCTM.d = this.activeState.zoom
        willZoom = false
      }
    }

    // Before pan
    if (willPan) {
      var preventPan = this.options.beforePan(this.getPan(), {x: newCTM.e, y: newCTM.f})
          // If prevent pan is an object
        , preventPanX = false
        , preventPanY = false

      // If prevent pan is Boolean false
      if (preventPan === false) {
        // Set x and y same as before
        newCTM.e = this.getPan().x
        newCTM.f = this.getPan().y

        preventPanX = preventPanY = true
      } else if (Utils.isObject(preventPan)) {
        // Check for X axes attribute
        if (preventPan.x === false) {
          // Prevent panning on x axes
          newCTM.e = this.getPan().x
          preventPanX = true
        } else if (Utils.isNumber(preventPan.x)) {
          // Set a custom pan value
          newCTM.e = preventPan.x
        }

        // Check for Y axes attribute
        if (preventPan.y === false) {
          // Prevent panning on x axes
          newCTM.f = this.getPan().y
          preventPanY = true
        } else if (Utils.isNumber(preventPan.y)) {
          // Set a custom pan value
          newCTM.f = preventPan.y
        }
      }

      // Update willPan flag
      if (preventPanX && preventPanY) {
        willPan = false
      }
    }

    // Check again if should zoom or pan
    if (willZoom || willPan) {
      this.updateCache(newCTM)

      this.updateCTMOnNextFrame()

      // After callbacks
      if (willZoom) {this.options.onZoom(this.getRelativeZoom())}
      if (willPan) {this.options.onPan(this.getPan())}
    }
  }
}

ShadowViewport.prototype.isZoomDifferent = function(newCTM) {
  return this.activeState.zoom !== newCTM.a
}

ShadowViewport.prototype.isPanDifferent = function(newCTM) {
  return this.activeState.x !== newCTM.e || this.activeState.y !== newCTM.f
}


/**
 * Update cached CTM and active state
 *
 * @param {SVGMatrix} newCTM
 */
ShadowViewport.prototype.updateCache = function(newCTM) {
  this.activeState.zoom = newCTM.a
  this.activeState.x = newCTM.e
  this.activeState.y = newCTM.f
}

ShadowViewport.prototype.pendingUpdate = false

/**
 * Place a request to update CTM on next Frame
 */
ShadowViewport.prototype.updateCTMOnNextFrame = function() {
  if (!this.pendingUpdate) {
    // Lock
    this.pendingUpdate = true

    // Throttle next update
    this.requestAnimationFrame.call(window, this.updateCTMCached)
  }
}

/**
 * Update viewport CTM with cached CTM
 */
ShadowViewport.prototype.updateCTM = function() {
  // Updates SVG element
  SvgUtils.setCTM(this.viewport, this.getCTM(), this.defs)

  // Free the lock
  this.pendingUpdate = false
}

module.exports = function(viewport, options){
  return new ShadowViewport(viewport, options)
}

},{"./svg-utilities":67,"./utilities":69}],66:[function(require,module,exports){
var Wheel = require('./uniwheel')
, ControlIcons = require('./control-icons')
, Utils = require('./utilities')
, SvgUtils = require('./svg-utilities')
, ShadowViewport = require('./shadow-viewport')

var SvgPanZoom = function(svg, options) {
  this.init(svg, options)
}

var optionsDefaults = {
  viewportSelector: '.svg-pan-zoom_viewport' // Viewport selector. Can be querySelector string or SVGElement
, panEnabled: true // enable or disable panning (default enabled)
, controlIconsEnabled: false // insert icons to give user an option in addition to mouse events to control pan/zoom (default disabled)
, zoomEnabled: true // enable or disable zooming (default enabled)
, dblClickZoomEnabled: true // enable or disable zooming by double clicking (default enabled)
, mouseWheelZoomEnabled: true // enable or disable zooming by mouse wheel (default enabled)
, zoomScaleSensitivity: 0.2 // Zoom sensitivity
, minZoom: 0.5 // Minimum Zoom level
, maxZoom: 10 // Maximum Zoom level
, fit: true // enable or disable viewport fit in SVG (default true)
, center: true // enable or disable viewport centering in SVG (default true)
, refreshRate: 'auto' // Maximum number of frames per second (altering SVG's viewport)
, beforeZoom: null
, onZoom: null
, beforePan: null
, onPan: null
, customEventsHandler: null
}

SvgPanZoom.prototype.init = function(svg, options) {
  var that = this

  this.svg = svg
  this.defs = svg.querySelector('defs')

  // Add default attributes to SVG
  SvgUtils.setupSvgAttributes(this.svg)

  // Set options
  this.options = Utils.extend(Utils.extend({}, optionsDefaults), options)

  // Set default state
  this.state = 'none'

  // Get dimensions
  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(svg)
  this.width = boundingClientRectNormalized.width
  this.height = boundingClientRectNormalized.height

  // Init shadow viewport
  this.viewport = ShadowViewport(SvgUtils.getOrCreateViewport(this.svg, this.options.viewportSelector), {
    svg: this.svg
  , width: this.width
  , height: this.height
  , fit: this.options.fit
  , center: this.options.center
  , refreshRate: this.options.refreshRate
  // Put callbacks into functions as they can change through time
  , beforeZoom: function(oldScale, newScale) {
      if (that.viewport && that.options.beforeZoom) {return that.options.beforeZoom(oldScale, newScale)}
    }
  , onZoom: function(scale) {
      if (that.viewport && that.options.onZoom) {return that.options.onZoom(scale)}
    }
  , beforePan: function(oldPoint, newPoint) {
      if (that.viewport && that.options.beforePan) {return that.options.beforePan(oldPoint, newPoint)}
    }
  , onPan: function(point) {
      if (that.viewport && that.options.onPan) {return that.options.onPan(point)}
    }
  })

  // Wrap callbacks into public API context
  var publicInstance = this.getPublicInstance()
  publicInstance.setBeforeZoom(this.options.beforeZoom)
  publicInstance.setOnZoom(this.options.onZoom)
  publicInstance.setBeforePan(this.options.beforePan)
  publicInstance.setOnPan(this.options.onPan)

  if (this.options.controlIconsEnabled) {
    ControlIcons.enable(this)
  }

  // Init events handlers
  this.setupHandlers()
}

/**
 * Register event handlers
 */
SvgPanZoom.prototype.setupHandlers = function() {
  var that = this
    , prevEvt = null // use for touchstart event to detect double tap
    ;

  this.eventListeners = {
    // Mouse down group
    mousedown: function(evt) {
      return that.handleMouseDown(evt, null);
    }
  , touchstart: function(evt) {
      var result = that.handleMouseDown(evt, prevEvt);
      prevEvt = evt
      return result;
    }

    // Mouse up group
  , mouseup: function(evt) {
      return that.handleMouseUp(evt);
    }
  , touchend: function(evt) {
      return that.handleMouseUp(evt);
    }

    // Mouse move group
  , mousemove: function(evt) {
      return that.handleMouseMove(evt);
    }
  , touchmove: function(evt) {
      return that.handleMouseMove(evt);
    }

    // Mouse leave group
  , mouseleave: function(evt) {
      return that.handleMouseUp(evt);
    }
  , touchleave: function(evt) {
      return that.handleMouseUp(evt);
    }
  , touchcancel: function(evt) {
      return that.handleMouseUp(evt);
    }
  }

  // Init custom events handler if available
  if (this.options.customEventsHandler != null) { // jshint ignore:line
    this.options.customEventsHandler.init({
      svgElement: this.svg
    , instance: this.getPublicInstance()
    })

    // Custom event handler may halt builtin listeners
    var haltEventListeners = this.options.customEventsHandler.haltEventListeners
    if (haltEventListeners && haltEventListeners.length) {
      for (var i = haltEventListeners.length - 1; i >= 0; i--) {
        if (this.eventListeners.hasOwnProperty(haltEventListeners[i])) {
          delete this.eventListeners[haltEventListeners[i]]
        }
      }
    }
  }

  // Bind eventListeners
  for (var event in this.eventListeners) {
    this.svg.addEventListener(event, this.eventListeners[event], false)
  }

  // Zoom using mouse wheel
  if (this.options.mouseWheelZoomEnabled) {
    this.options.mouseWheelZoomEnabled = false // set to false as enable will set it back to true
    this.enableMouseWheelZoom()
  }
}

/**
 * Enable ability to zoom using mouse wheel
 */
SvgPanZoom.prototype.enableMouseWheelZoom = function() {
  if (!this.options.mouseWheelZoomEnabled) {
    var that = this

    // Mouse wheel listener
    this.wheelListener = function(evt) {
      return that.handleMouseWheel(evt);
    }

    // Bind wheelListener
    Wheel.on(this.svg, this.wheelListener, false)

    this.options.mouseWheelZoomEnabled = true
  }
}

/**
 * Disable ability to zoom using mouse wheel
 */
SvgPanZoom.prototype.disableMouseWheelZoom = function() {
  if (this.options.mouseWheelZoomEnabled) {
    Wheel.off(this.svg, this.wheelListener, false)
    this.options.mouseWheelZoomEnabled = false
  }
}

/**
 * Handle mouse wheel event
 *
 * @param  {Event} evt
 */
SvgPanZoom.prototype.handleMouseWheel = function(evt) {
  if (!this.options.zoomEnabled || this.state !== 'none') {
    return;
  }

  if (evt.preventDefault) {
    evt.preventDefault();
  } else {
    evt.returnValue = false;
  }

  var delta = 0

  if ('deltaMode' in evt && evt.deltaMode === 0) {
    // Make empirical adjustments for browsers that give deltaY in pixels (deltaMode=0)

    if (evt.wheelDelta) {
      // Normalizer for Chrome
      delta = evt.deltaY / Math.abs(evt.wheelDelta/3)
    } else {
      // Others. Possibly tablets? Use a value just in case
      delta = evt.deltaY / 120
    }
  } else if ('mozPressure' in evt) {
    // Normalizer for newer Firefox
    // NOTE: May need to change detection at some point if mozPressure disappears.
    delta = evt.deltaY / 3;
  } else {
    // Others should be reasonably normalized by the mousewheel code at the end of the file.
    delta = evt.deltaY;
  }

  var inversedScreenCTM = this.svg.getScreenCTM().inverse()
    , relativeMousePoint = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(inversedScreenCTM)
    , zoom = Math.pow(1 + this.options.zoomScaleSensitivity, (-1) * delta); // multiplying by neg. 1 so as to make zoom in/out behavior match Google maps behavior

  this.zoomAtPoint(zoom, relativeMousePoint)
}

/**
 * Zoom in at a SVG point
 *
 * @param  {SVGPoint} point
 * @param  {Float} zoomScale    Number representing how much to zoom
 * @param  {Boolean} zoomAbsolute Default false. If true, zoomScale is treated as an absolute value.
 *                                Otherwise, zoomScale is treated as a multiplied (e.g. 1.10 would zoom in 10%)
 */
SvgPanZoom.prototype.zoomAtPoint = function(zoomScale, point, zoomAbsolute) {
  var originalState = this.viewport.getOriginalState()

  if (!zoomAbsolute) {
    // Fit zoomScale in set bounds
    if (this.getZoom() * zoomScale < this.options.minZoom * originalState.zoom) {
      zoomScale = (this.options.minZoom * originalState.zoom) / this.getZoom()
    } else if (this.getZoom() * zoomScale > this.options.maxZoom * originalState.zoom) {
      zoomScale = (this.options.maxZoom * originalState.zoom) / this.getZoom()
    }
  } else {
    // Fit zoomScale in set bounds
    zoomScale = Math.max(this.options.minZoom * originalState.zoom, Math.min(this.options.maxZoom * originalState.zoom, zoomScale))
    // Find relative scale to achieve desired scale
    zoomScale = zoomScale/this.getZoom()
  }

  var oldCTM = this.viewport.getCTM()
    , relativePoint = point.matrixTransform(oldCTM.inverse())
    , modifier = this.svg.createSVGMatrix().translate(relativePoint.x, relativePoint.y).scale(zoomScale).translate(-relativePoint.x, -relativePoint.y)
    , newCTM = oldCTM.multiply(modifier)

  if (newCTM.a !== oldCTM.a) {
    this.viewport.setCTM(newCTM)
  }
}

/**
 * Zoom at center point
 *
 * @param  {Float} scale
 * @param  {Boolean} absolute Marks zoom scale as relative or absolute
 */
SvgPanZoom.prototype.zoom = function(scale, absolute) {
  this.zoomAtPoint(scale, SvgUtils.getSvgCenterPoint(this.svg, this.width, this.height), absolute)
}

/**
 * Zoom used by public instance
 *
 * @param  {Float} scale
 * @param  {Boolean} absolute Marks zoom scale as relative or absolute
 */
SvgPanZoom.prototype.publicZoom = function(scale, absolute) {
  if (absolute) {
    scale = this.computeFromRelativeZoom(scale)
  }

  this.zoom(scale, absolute)
}

/**
 * Zoom at point used by public instance
 *
 * @param  {Float} scale
 * @param  {SVGPoint|Object} point    An object that has x and y attributes
 * @param  {Boolean} absolute Marks zoom scale as relative or absolute
 */
SvgPanZoom.prototype.publicZoomAtPoint = function(scale, point, absolute) {
  if (absolute) {
    // Transform zoom into a relative value
    scale = this.computeFromRelativeZoom(scale)
  }

  // If not a SVGPoint but has x and y than create a SVGPoint
  if (Utils.getType(point) !== 'SVGPoint' && 'x' in point && 'y' in point) {
    point = SvgUtils.createSVGPoint(this.svg, point.x, point.y)
  } else {
    throw new Error('Given point is invalid')
    return
  }

  this.zoomAtPoint(scale, point, absolute)
}

/**
 * Get zoom scale
 *
 * @return {Float} zoom scale
 */
SvgPanZoom.prototype.getZoom = function() {
  return this.viewport.getZoom()
}

/**
 * Get zoom scale for public usage
 *
 * @return {Float} zoom scale
 */
SvgPanZoom.prototype.getRelativeZoom = function() {
  return this.viewport.getRelativeZoom()
}

/**
 * Compute actual zoom from public zoom
 *
 * @param  {Float} zoom
 * @return {Float} zoom scale
 */
SvgPanZoom.prototype.computeFromRelativeZoom = function(zoom) {
  return zoom * this.viewport.getOriginalState().zoom
}

/**
 * Set zoom to initial state
 */
SvgPanZoom.prototype.resetZoom = function() {
  var originalState = this.viewport.getOriginalState()

  this.zoom(originalState.zoom, true);
}

/**
 * Set pan to initial state
 */
SvgPanZoom.prototype.resetPan = function() {
  this.pan(this.viewport.getOriginalState());
}

/**
 * Set pan and zoom to initial state
 */
SvgPanZoom.prototype.reset = function() {
  this.resetZoom()
  this.resetPan()
}

/**
 * Handle double click event
 * See handleMouseDown() for alternate detection method
 *
 * @param {Event} evt
 */
SvgPanZoom.prototype.handleDblClick = function(evt) {
  if (evt.preventDefault) {
    evt.preventDefault()
  } else {
    evt.returnValue = false
  }

  // Check if target was a control button
  if (this.options.controlIconsEnabled) {
    var targetClass = evt.target.getAttribute('class') || ''
    if (targetClass.indexOf('svg-pan-zoom-control') > -1) {
      return false
    }
  }

  var zoomFactor

  if (evt.shiftKey) {
    zoomFactor = 1/((1 + this.options.zoomScaleSensitivity) * 2) // zoom out when shift key pressed
  } else {
    zoomFactor = (1 + this.options.zoomScaleSensitivity) * 2
  }

  var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.svg.getScreenCTM().inverse())
  this.zoomAtPoint(zoomFactor, point)
}

/**
 * Handle click event
 *
 * @param {Event} evt
 */
SvgPanZoom.prototype.handleMouseDown = function(evt, prevEvt) {
  if (evt.preventDefault) {
    evt.preventDefault()
  } else {
    evt.returnValue = false
  }

  Utils.mouseAndTouchNormalize(evt, this.svg)

  // Double click detection; more consistent than ondblclick
  if (this.options.dblClickZoomEnabled && Utils.isDblClick(evt, prevEvt)){
    this.handleDblClick(evt)
  } else {
    // Pan mode
    this.state = 'pan'
    this.firstEventCTM = this.viewport.getCTM()
    this.stateOrigin = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse())
  }
}

/**
 * Handle mouse move event
 *
 * @param  {Event} evt
 */
SvgPanZoom.prototype.handleMouseMove = function(evt) {
  if (evt.preventDefault) {
    evt.preventDefault()
  } else {
    evt.returnValue = false
  }

  if (this.state === 'pan' && this.options.panEnabled) {
    // Pan mode
    var point = SvgUtils.getEventPoint(evt, this.svg).matrixTransform(this.firstEventCTM.inverse())
      , viewportCTM = this.firstEventCTM.translate(point.x - this.stateOrigin.x, point.y - this.stateOrigin.y)

    this.viewport.setCTM(viewportCTM)
  }
}

/**
 * Handle mouse button release event
 *
 * @param {Event} evt
 */
SvgPanZoom.prototype.handleMouseUp = function(evt) {
  if (evt.preventDefault) {
    evt.preventDefault()
  } else {
    evt.returnValue = false
  }

  if (this.state === 'pan') {
    // Quit pan mode
    this.state = 'none'
  }
}

/**
 * Adjust viewport size (only) so it will fit in SVG
 * Does not center image
 */
SvgPanZoom.prototype.fit = function() {
  var viewBox = this.viewport.getViewBox()
    , newScale = Math.min(this.width/(viewBox.width - viewBox.x), this.height/(viewBox.height - viewBox.y))

  this.zoom(newScale, true)
}

/**
 * Adjust viewport pan (only) so it will be centered in SVG
 * Does not zoom/fit image
 */
SvgPanZoom.prototype.center = function() {
  var viewBox = this.viewport.getViewBox()
    , offsetX = (this.width - (viewBox.width + viewBox.x) * this.getZoom()) * 0.5
    , offsetY = (this.height - (viewBox.height + viewBox.y) * this.getZoom()) * 0.5

  this.getPublicInstance().pan({x: offsetX, y: offsetY})
}

/**
 * Update content cached BorderBox
 * Use when viewport contents change
 */
SvgPanZoom.prototype.updateBBox = function() {
  this.viewport.recacheViewBox()
}

/**
 * Pan to a rendered position
 *
 * @param  {Object} point {x: 0, y: 0}
 */
SvgPanZoom.prototype.pan = function(point) {
  var viewportCTM = this.viewport.getCTM()
  viewportCTM.e = point.x
  viewportCTM.f = point.y
  this.viewport.setCTM(viewportCTM)
}

/**
 * Relatively pan the graph by a specified rendered position vector
 *
 * @param  {Object} point {x: 0, y: 0}
 */
SvgPanZoom.prototype.panBy = function(point) {
  var viewportCTM = this.viewport.getCTM()
  viewportCTM.e += point.x
  viewportCTM.f += point.y
  this.viewport.setCTM(viewportCTM)
}

/**
 * Get pan vector
 *
 * @return {Object} {x: 0, y: 0}
 */
SvgPanZoom.prototype.getPan = function() {
  var state = this.viewport.getState()

  return {x: state.x, y: state.y}
}

/**
 * Recalculates cached svg dimensions and controls position
 */
SvgPanZoom.prototype.resize = function() {
  // Get dimensions
  var boundingClientRectNormalized = SvgUtils.getBoundingClientRectNormalized(this.svg)
  this.width = boundingClientRectNormalized.width
  this.height = boundingClientRectNormalized.height

  // Reposition control icons by re-enabling them
  if (this.options.controlIconsEnabled) {
    this.getPublicInstance().disableControlIcons()
    this.getPublicInstance().enableControlIcons()
  }
}

/**
 * Unbind mouse events, free callbacks and destroy public instance
 */
SvgPanZoom.prototype.destroy = function() {
  var that = this

  // Free callbacks
  this.beforeZoom = null
  this.onZoom = null
  this.beforePan = null
  this.onPan = null

  // Destroy custom event handlers
  if (this.options.customEventsHandler != null) { // jshint ignore:line
    this.options.customEventsHandler.destroy({
      svgElement: this.svg
    , instance: this.getPublicInstance()
    })
  }

  // Unbind eventListeners
  for (var event in this.eventListeners) {
    this.svg.removeEventListener(event, this.eventListeners[event], false)
  }

  // Unbind wheelListener
  this.disableMouseWheelZoom()

  // Remove control icons
  this.getPublicInstance().disableControlIcons()

  // Reset zoom and pan
  this.reset()

  // Remove instance from instancesStore
  instancesStore = instancesStore.filter(function(instance){
    return instance.svg !== that.svg
  })

  // Delete options and its contents
  delete this.options

  // Destroy public instance and rewrite getPublicInstance
  delete this.publicInstance
  delete this.pi
  this.getPublicInstance = function(){
    return null
  }
}

/**
 * Returns a public instance object
 *
 * @return {Object} Public instance object
 */
SvgPanZoom.prototype.getPublicInstance = function() {
  var that = this

  // Create cache
  if (!this.publicInstance) {
    this.publicInstance = this.pi = {
      // Pan
      enablePan: function() {that.options.panEnabled = true; return that.pi}
    , disablePan: function() {that.options.panEnabled = false; return that.pi}
    , isPanEnabled: function() {return !!that.options.panEnabled}
    , pan: function(point) {that.pan(point); return that.pi}
    , panBy: function(point) {that.panBy(point); return that.pi}
    , getPan: function() {return that.getPan()}
      // Pan event
    , setBeforePan: function(fn) {that.options.beforePan = fn === null ? null : Utils.proxy(fn, that.publicInstance); return that.pi}
    , setOnPan: function(fn) {that.options.onPan = fn === null ? null : Utils.proxy(fn, that.publicInstance); return that.pi}
      // Zoom and Control Icons
    , enableZoom: function() {that.options.zoomEnabled = true; return that.pi}
    , disableZoom: function() {that.options.zoomEnabled = false; return that.pi}
    , isZoomEnabled: function() {return !!that.options.zoomEnabled}
    , enableControlIcons: function() {
        if (!that.options.controlIconsEnabled) {
          that.options.controlIconsEnabled = true
          ControlIcons.enable(that)
        }
        return that.pi
      }
    , disableControlIcons: function() {
        if (that.options.controlIconsEnabled) {
          that.options.controlIconsEnabled = false;
          ControlIcons.disable(that)
        }
        return that.pi
      }
    , isControlIconsEnabled: function() {return !!that.options.controlIconsEnabled}
      // Double click zoom
    , enableDblClickZoom: function() {that.options.dblClickZoomEnabled = true; return that.pi}
    , disableDblClickZoom: function() {that.options.dblClickZoomEnabled = false; return that.pi}
    , isDblClickZoomEnabled: function() {return !!that.options.dblClickZoomEnabled}
      // Mouse wheel zoom
    , enableMouseWheelZoom: function() {that.enableMouseWheelZoom(); return that.pi}
    , disableMouseWheelZoom: function() {that.disableMouseWheelZoom(); return that.pi}
    , isMouseWheelZoomEnabled: function() {return !!that.options.mouseWheelZoomEnabled}
      // Zoom scale and bounds
    , setZoomScaleSensitivity: function(scale) {that.options.zoomScaleSensitivity = scale; return that.pi}
    , setMinZoom: function(zoom) {that.options.minZoom = zoom; return that.pi}
    , setMaxZoom: function(zoom) {that.options.maxZoom = zoom; return that.pi}
      // Zoom event
    , setBeforeZoom: function(fn) {that.options.beforeZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance); return that.pi}
    , setOnZoom: function(fn) {that.options.onZoom = fn === null ? null : Utils.proxy(fn, that.publicInstance); return that.pi}
      // Zooming
    , zoom: function(scale) {that.publicZoom(scale, true); return that.pi}
    , zoomBy: function(scale) {that.publicZoom(scale, false); return that.pi}
    , zoomAtPoint: function(scale, point) {that.publicZoomAtPoint(scale, point, true); return that.pi}
    , zoomAtPointBy: function(scale, point) {that.publicZoomAtPoint(scale, point, false); return that.pi}
    , zoomIn: function() {this.zoomBy(1 + that.options.zoomScaleSensitivity); return that.pi}
    , zoomOut: function() {this.zoomBy(1 / (1 + that.options.zoomScaleSensitivity)); return that.pi}
    , getZoom: function() {return that.getRelativeZoom()}
      // Reset
    , resetZoom: function() {that.resetZoom(); return that.pi}
    , resetPan: function() {that.resetPan(); return that.pi}
    , reset: function() {that.reset(); return that.pi}
      // Fit and Center
    , fit: function() {that.fit(); return that.pi}
    , center: function() {that.center(); return that.pi}
      // Size and Resize
    , updateBBox: function() {that.updateBBox(); return that.pi}
    , resize: function() {that.resize(); return that.pi}
    , getSizes: function() {
        return {
          width: that.width
        , height: that.height
        , realZoom: that.getZoom()
        , viewBox: that.viewport.getViewBox()
        }
      }
      // Destroy
    , destroy: function() {that.destroy(); return that.pi}
    }
  }

  return this.publicInstance
}

/**
 * Stores pairs of instances of SvgPanZoom and SVG
 * Each pair is represented by an object {svg: SVGSVGElement, instance: SvgPanZoom}
 *
 * @type {Array}
 */
var instancesStore = []

var svgPanZoom = function(elementOrSelector, options){
  var svg = Utils.getSvg(elementOrSelector)

  if (svg === null) {
    return null
  } else {
    // Look for existent instance
    for(var i = instancesStore.length - 1; i >= 0; i--) {
      if (instancesStore[i].svg === svg) {
        return instancesStore[i].instance.getPublicInstance()
      }
    }

    // If instance not found - create one
    instancesStore.push({
      svg: svg
    , instance: new SvgPanZoom(svg, options)
    })

    // Return just pushed instance
    return instancesStore[instancesStore.length - 1].instance.getPublicInstance()
  }
}

module.exports = svgPanZoom;

},{"./control-icons":64,"./shadow-viewport":65,"./svg-utilities":67,"./uniwheel":68,"./utilities":69}],67:[function(require,module,exports){
var Utils = require('./utilities')
  , _browser = 'unknown'
  ;

// http://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
if (/*@cc_on!@*/false || !!document.documentMode) { // internet explorer
  _browser = 'ie';
}

module.exports = {
  svgNS:  'http://www.w3.org/2000/svg'
, xmlNS:  'http://www.w3.org/XML/1998/namespace'
, xmlnsNS:  'http://www.w3.org/2000/xmlns/'
, xlinkNS:  'http://www.w3.org/1999/xlink'
, evNS:  'http://www.w3.org/2001/xml-events'

  /**
   * Get svg dimensions: width and height
   *
   * @param  {SVGSVGElement} svg
   * @return {Object}     {width: 0, height: 0}
   */
, getBoundingClientRectNormalized: function(svg) {
    if (svg.clientWidth && svg.clientHeight) {
      return {width: svg.clientWidth, height: svg.clientHeight}
    } else if (!!svg.getBoundingClientRect()) {
      return svg.getBoundingClientRect();
    } else {
      throw new Error('Cannot get BoundingClientRect for SVG.');
    }
  }

  /**
   * Gets g element with class of "viewport" or creates it if it doesn't exist
   *
   * @param  {SVGSVGElement} svg
   * @return {SVGElement}     g (group) element
   */
, getOrCreateViewport: function(svg, selector) {
    var viewport = null

    if (Utils.isElement(selector)) {
      viewport = selector
    } else {
      viewport = svg.querySelector(selector)
    }

    // Check if there is just one main group in SVG
    if (!viewport) {
      var childNodes = Array.prototype.slice.call(svg.childNodes || svg.children).filter(function(el){
        return el.nodeName !== 'defs' && el.nodeName !== '#text'
      })

      // Node name should be SVGGElement and should have no transform attribute
      // Groups with transform are not used as viewport because it involves parsing of all transform possibilities
      if (childNodes.length === 1 && childNodes[0].nodeName === 'g' && childNodes[0].getAttribute('transform') === null) {
        viewport = childNodes[0]
      }
    }

    // If no favorable group element exists then create one
    if (!viewport) {
      var viewportId = 'viewport-' + new Date().toISOString().replace(/\D/g, '');
      viewport = document.createElementNS(this.svgNS, 'g');
      viewport.setAttribute('id', viewportId);

      // Internet Explorer (all versions?) can't use childNodes, but other browsers prefer (require?) using childNodes
      var svgChildren = svg.childNodes || svg.children;
      if (!!svgChildren && svgChildren.length > 0) {
        for (var i = svgChildren.length; i > 0; i--) {
          // Move everything into viewport except defs
          if (svgChildren[svgChildren.length - i].nodeName !== 'defs') {
            viewport.appendChild(svgChildren[svgChildren.length - i]);
          }
        }
      }
      svg.appendChild(viewport);
    }

    // Parse class names
    var classNames = [];
    if (viewport.getAttribute('class')) {
      classNames = viewport.getAttribute('class').split(' ')
    }

    // Set class (if not set already)
    if (!~classNames.indexOf('svg-pan-zoom_viewport')) {
      classNames.push('svg-pan-zoom_viewport')
      viewport.setAttribute('class', classNames.join(' '))
    }

    return viewport
  }

  /**
   * Set SVG attributes
   *
   * @param  {SVGSVGElement} svg
   */
  , setupSvgAttributes: function(svg) {
    // Setting default attributes
    svg.setAttribute('xmlns', this.svgNS);
    svg.setAttributeNS(this.xmlnsNS, 'xmlns:xlink', this.xlinkNS);
    svg.setAttributeNS(this.xmlnsNS, 'xmlns:ev', this.evNS);

    // Needed for Internet Explorer, otherwise the viewport overflows
    if (svg.parentNode !== null) {
      var style = svg.getAttribute('style') || '';
      if (style.toLowerCase().indexOf('overflow') === -1) {
        svg.setAttribute('style', 'overflow: hidden; ' + style);
      }
    }
  }

/**
 * How long Internet Explorer takes to finish updating its display (ms).
 */
, internetExplorerRedisplayInterval: 300

/**
 * Forces the browser to redisplay all SVG elements that rely on an
 * element defined in a 'defs' section. It works globally, for every
 * available defs element on the page.
 * The throttling is intentionally global.
 *
 * This is only needed for IE. It is as a hack to make markers (and 'use' elements?)
 * visible after pan/zoom when there are multiple SVGs on the page.
 * See bug report: https://connect.microsoft.com/IE/feedback/details/781964/
 * also see svg-pan-zoom issue: https://github.com/ariutta/svg-pan-zoom/issues/62
 */
, refreshDefsGlobal: Utils.throttle(function() {
    var allDefs = document.querySelectorAll('defs');
    var allDefsCount = allDefs.length;
    for (var i = 0; i < allDefsCount; i++) {
      var thisDefs = allDefs[i];
      thisDefs.parentNode.insertBefore(thisDefs, thisDefs);
    }
  }, this.internetExplorerRedisplayInterval)

  /**
   * Sets the current transform matrix of an element
   *
   * @param {SVGElement} element
   * @param {SVGMatrix} matrix  CTM
   * @param {SVGElement} defs
   */
, setCTM: function(element, matrix, defs) {
    var that = this
      , s = 'matrix(' + matrix.a + ',' + matrix.b + ',' + matrix.c + ',' + matrix.d + ',' + matrix.e + ',' + matrix.f + ')';

    element.setAttributeNS(null, 'transform', s);

    // IE has a bug that makes markers disappear on zoom (when the matrix "a" and/or "d" elements change)
    // see http://stackoverflow.com/questions/17654578/svg-marker-does-not-work-in-ie9-10
    // and http://srndolha.wordpress.com/2013/11/25/svg-line-markers-may-disappear-in-internet-explorer-11/
    if (_browser === 'ie' && !!defs) {
      // this refresh is intended for redisplaying the SVG during zooming
      defs.parentNode.insertBefore(defs, defs);
      // this refresh is intended for redisplaying the other SVGs on a page when panning a given SVG
      // it is also needed for the given SVG itself, on zoomEnd, if the SVG contains any markers that
      // are located under any other element(s).
      window.setTimeout(function() {
        that.refreshDefsGlobal();
      }, that.internetExplorerRedisplayInterval);
    }
  }

  /**
   * Instantiate an SVGPoint object with given event coordinates
   *
   * @param {Event} evt
   * @param  {SVGSVGElement} svg
   * @return {SVGPoint}     point
   */
, getEventPoint: function(evt, svg) {
    var point = svg.createSVGPoint()

    Utils.mouseAndTouchNormalize(evt, svg)

    point.x = evt.clientX
    point.y = evt.clientY

    return point
  }

  /**
   * Get SVG center point
   *
   * @param  {SVGSVGElement} svg
   * @return {SVGPoint}
   */
, getSvgCenterPoint: function(svg, width, height) {
    return this.createSVGPoint(svg, width / 2, height / 2)
  }

  /**
   * Create a SVGPoint with given x and y
   *
   * @param  {SVGSVGElement} svg
   * @param  {Number} x
   * @param  {Number} y
   * @return {SVGPoint}
   */
, createSVGPoint: function(svg, x, y) {
    var point = svg.createSVGPoint()
    point.x = x
    point.y = y

    return point
  }
}

},{"./utilities":69}],68:[function(require,module,exports){
// uniwheel 0.1.2 (customized)
// A unified cross browser mouse wheel event handler
// https://github.com/teemualap/uniwheel

module.exports = (function(){

  //Full details: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel

  var prefix = "", _addEventListener, _removeEventListener, onwheel, support, fns = [];

  // detect event model
  if ( window.addEventListener ) {
    _addEventListener = "addEventListener";
    _removeEventListener = "removeEventListener";
  } else {
    _addEventListener = "attachEvent";
    _removeEventListener = "detachEvent";
    prefix = "on";
  }

  // detect available wheel event
  support = "onwheel" in document.createElement("div") ? "wheel" : // Modern browsers support "wheel"
            document.onmousewheel !== undefined ? "mousewheel" : // Webkit and IE support at least "mousewheel"
            "DOMMouseScroll"; // let's assume that remaining browsers are older Firefox


  function createCallback(element,callback,capture) {

    var fn = function(originalEvent) {

      !originalEvent && ( originalEvent = window.event );

      // create a normalized event object
      var event = {
        // keep a ref to the original event object
        originalEvent: originalEvent,
        target: originalEvent.target || originalEvent.srcElement,
        type: "wheel",
        deltaMode: originalEvent.type == "MozMousePixelScroll" ? 0 : 1,
        deltaX: 0,
        delatZ: 0,
        preventDefault: function() {
          originalEvent.preventDefault ?
            originalEvent.preventDefault() :
            originalEvent.returnValue = false;
        }
      };

      // calculate deltaY (and deltaX) according to the event
      if ( support == "mousewheel" ) {
        event.deltaY = - 1/40 * originalEvent.wheelDelta;
        // Webkit also support wheelDeltaX
        originalEvent.wheelDeltaX && ( event.deltaX = - 1/40 * originalEvent.wheelDeltaX );
      } else {
        event.deltaY = originalEvent.detail;
      }

      // it's time to fire the callback
      return callback( event );

    };

    fns.push({
      element: element,
      fn: fn,
      capture: capture
    });

    return fn;
  }

  function getCallback(element,capture) {
    for (var i = 0; i < fns.length; i++) {
      if (fns[i].element === element && fns[i].capture === capture) {
        return fns[i].fn;
      }
    }
    return function(){};
  }

  function removeCallback(element,capture) {
    for (var i = 0; i < fns.length; i++) {
      if (fns[i].element === element && fns[i].capture === capture) {
        return fns.splice(i,1);
      }
    }
  }

  function _addWheelListener( elem, eventName, callback, useCapture ) {

    var cb;

    if (support === "wheel") {
      cb = callback;
    } else {
      cb = createCallback(elem,callback,useCapture);
    }

    elem[ _addEventListener ]( prefix + eventName, cb, useCapture || false );

  }

  function _removeWheelListener( elem, eventName, callback, useCapture ) {

    if (support === "wheel") {
      cb = callback;
    } else {
      cb = getCallback(elem,useCapture);
    }

    elem[ _removeEventListener ]( prefix + eventName, cb, useCapture || false );

    removeCallback(elem,useCapture);

  }

  function addWheelListener( elem, callback, useCapture ) {
    _addWheelListener( elem, support, callback, useCapture );

    // handle MozMousePixelScroll in older Firefox
    if( support == "DOMMouseScroll" ) {
        _addWheelListener( elem, "MozMousePixelScroll", callback, useCapture);
    }
  }

  function removeWheelListener(elem,callback,useCapture){
    _removeWheelListener(elem,support,callback,useCapture);

    // handle MozMousePixelScroll in older Firefox
    if( support == "DOMMouseScroll" ) {
        _removeWheelListener(elem, "MozMousePixelScroll", callback, useCapture);
    }
  }

  return {
    on: addWheelListener,
    off: removeWheelListener
  };

})();

},{}],69:[function(require,module,exports){
module.exports = {
  /**
   * Extends an object
   *
   * @param  {Object} target object to extend
   * @param  {Object} source object to take properties from
   * @return {Object}        extended object
   */
  extend: function(target, source) {
    target = target || {};
    for (var prop in source) {
      // Go recursively
      if (this.isObject(source[prop])) {
        target[prop] = this.extend(target[prop], source[prop])
      } else {
        target[prop] = source[prop]
      }
    }
    return target;
  }

  /**
   * Checks if an object is a DOM element
   *
   * @param  {Object}  o HTML element or String
   * @return {Boolean}   returns true if object is a DOM element
   */
, isElement: function(o){
    return (
      o instanceof HTMLElement || o instanceof SVGElement || o instanceof SVGSVGElement || //DOM2
      (o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string')
    );
  }

  /**
   * Checks if an object is an Object
   *
   * @param  {Object}  o Object
   * @return {Boolean}   returns true if object is an Object
   */
, isObject: function(o){
    return Object.prototype.toString.call(o) === '[object Object]';
  }

  /**
   * Checks if variable is Number
   *
   * @param  {Integer|Float}  n
   * @return {Boolean}   returns true if variable is Number
   */
, isNumber: function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }

  /**
   * Search for an SVG element
   *
   * @param  {Object|String} elementOrSelector DOM Element or selector String
   * @return {Object|Null}                   SVG or null
   */
, getSvg: function(elementOrSelector) {
    var element
      , svg;

    if (!this.isElement(elementOrSelector)) {
      // If selector provided
      if (typeof elementOrSelector === 'string' || elementOrSelector instanceof String) {
        // Try to find the element
        element = document.querySelector(elementOrSelector)

        if (!element) {
          throw new Error('Provided selector did not find any elements. Selector: ' + elementOrSelector)
          return null
        }
      } else {
        throw new Error('Provided selector is not an HTML object nor String')
        return null
      }
    } else {
      element = elementOrSelector
    }

    if (element.tagName.toLowerCase() === 'svg') {
      svg = element;
    } else {
      if (element.tagName.toLowerCase() === 'object') {
        svg = element.contentDocument.documentElement;
      } else {
        if (element.tagName.toLowerCase() === 'embed') {
          svg = element.getSVGDocument().documentElement;
        } else {
          if (element.tagName.toLowerCase() === 'img') {
            throw new Error('Cannot script an SVG in an "img" element. Please use an "object" element or an in-line SVG.');
          } else {
            throw new Error('Cannot get SVG.');
          }
          return null
        }
      }
    }

    return svg
  }

  /**
   * Attach a given context to a function
   * @param  {Function} fn      Function
   * @param  {Object}   context Context
   * @return {Function}           Function with certain context
   */
, proxy: function(fn, context) {
    return function() {
      return fn.apply(context, arguments)
    }
  }

  /**
   * Returns object type
   * Uses toString that returns [object SVGPoint]
   * And than parses object type from string
   *
   * @param  {Object} o Any object
   * @return {String}   Object type
   */
, getType: function(o) {
    return Object.prototype.toString.apply(o).replace(/^\[object\s/, '').replace(/\]$/, '')
  }

  /**
   * If it is a touch event than add clientX and clientY to event object
   *
   * @param  {Event} evt
   * @param  {SVGSVGElement} svg
   */
, mouseAndTouchNormalize: function(evt, svg) {
    // If no cilentX and but touch objects are available
    if (evt.clientX === void 0 || evt.clientX === null) {
      // Fallback
      evt.clientX = 0
      evt.clientY = 0

      // If it is a touch event
      if (evt.changedTouches !== void 0 && evt.changedTouches.length) {
        // If touch event has changedTouches
        if (evt.changedTouches[0].clientX !== void 0) {
          evt.clientX = evt.changedTouches[0].clientX
          evt.clientY = evt.changedTouches[0].clientY
        }
        // If changedTouches has pageX attribute
        else if (evt.changedTouches[0].pageX !== void 0) {
          var rect = svg.getBoundingClientRect();

          evt.clientX = evt.changedTouches[0].pageX - rect.left
          evt.clientY = evt.changedTouches[0].pageY - rect.top
        }
      // If it is a custom event
      } else if (evt.originalEvent !== void 0) {
        if (evt.originalEvent.clientX !== void 0) {
          evt.clientX = evt.originalEvent.clientX
          evt.clientY = evt.originalEvent.clientY
        }
      }
    }
  }

  /**
   * Check if an event is a double click/tap
   * TODO: For touch gestures use a library (hammer.js) that takes in account other events
   * (touchmove and touchend). It should take in account tap duration and traveled distance
   *
   * @param  {Event}  evt
   * @param  {Event}  prevEvt Previous Event
   * @return {Boolean}
   */
, isDblClick: function(evt, prevEvt) {
    // Double click detected by browser
    if (evt.detail === 2) {
      return true;
    }
    // Try to compare events
    else if (prevEvt !== void 0 && prevEvt !== null) {
      var timeStampDiff = evt.timeStamp - prevEvt.timeStamp // should be lower than 250 ms
        , touchesDistance = Math.sqrt(Math.pow(evt.clientX - prevEvt.clientX, 2) + Math.pow(evt.clientY - prevEvt.clientY, 2))

      return timeStampDiff < 250 && touchesDistance < 10
    }

    // Nothing found
    return false;
  }

  /**
   * Returns current timestamp as an integer
   *
   * @return {Number}
   */
, now: Date.now || function() {
    return new Date().getTime();
  }

  // From underscore.
  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
// jscs:disable
// jshint ignore:start
, throttle: function(func, wait, options) {
    var that = this;
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : that.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = that.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  }
// jshint ignore:end
// jscs:enable

  /**
   * Create a requestAnimationFrame simulation
   *
   * @param  {Number|String} refreshRate
   * @return {Function}
   */
, createRequestAnimationFrame: function(refreshRate) {
    var timeout = null

    // Convert refreshRate to timeout
    if (refreshRate !== 'auto' && refreshRate < 60 && refreshRate > 1) {
      timeout = Math.floor(1000 / refreshRate)
    }

    if (timeout === null) {
      return window.requestAnimationFrame || requestTimeout(33)
    } else {
      return requestTimeout(timeout)
    }
  }
}

/**
 * Create a callback that will execute after a given timeout
 *
 * @param  {Function} timeout
 * @return {Function}
 */
function requestTimeout(timeout) {
  return function(callback) {
    window.setTimeout(callback, timeout)
  }
}

},{}],70:[function(require,module,exports){
module.exports = require('./lib/index.js');

},{"./lib/index.js":71}],71:[function(require,module,exports){
(function (Buffer,__dirname){
/**
 * term.js - an xterm emulator
 * Copyright (c) 2012-2013, Christopher Jeffrey (MIT License)
 * https://github.com/chjj/term.js
 */

function term(options) {
  return new term.Terminal(options);
}

term.middleware = function(options) {
  var url = require('url');

  options = options || {};
  options.path = options.path || '/term.js';

  return function(req, res, next) {
    if (url.parse(req.url).pathname !== options.path) {
      return next();
    }

    if (+new Date(req.headers['if-modified-since']) === term.last) {
      res.statusCode = 304;
      res.end();
      return;
    }

    res.writeHead(200, {
      'Content-Type': 'application/javascript; charset=utf-8',
      'Content-Length': Buffer.byteLength(term.script),
      'Last-Modified': term.last
    });

    res.end(term.script);
  };
};

term.path = __dirname + '/../src/term.js';

term.__defineGetter__('script', function() {
  if (term._script) return term._script;
  term.last = +new Date;
  return term._script = require('fs').readFileSync(term.path, 'utf8');
});

term.__defineGetter__('Terminal', function() {
  if (term._Terminal) return term._Terminal;
  return term._Terminal = require('../src/term');
});

/**
 * Expose
 */

module.exports = term;

}).call(this,require("buffer").Buffer,"/node_modules/term.js/lib")

},{"../src/term":72,"buffer":49,"fs":48,"url":60}],72:[function(require,module,exports){
(function (global){
/**
 * term.js - an xterm emulator
 * Copyright (c) 2012-2013, Christopher Jeffrey (MIT License)
 * https://github.com/chjj/term.js
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * Originally forked from (with the author's permission):
 *   Fabrice Bellard's javascript vt100 for jslinux:
 *   http://bellard.org/jslinux/
 *   Copyright (c) 2011 Fabrice Bellard
 *   The original design remains. The terminal itself
 *   has been extended to include xterm CSI codes, among
 *   other features.
 */

;(function() {

/**
 * Terminal Emulation References:
 *   http://vt100.net/
 *   http://invisible-island.net/xterm/ctlseqs/ctlseqs.txt
 *   http://invisible-island.net/xterm/ctlseqs/ctlseqs.html
 *   http://invisible-island.net/vttest/
 *   http://www.inwap.com/pdp10/ansicode.txt
 *   http://linux.die.net/man/4/console_codes
 *   http://linux.die.net/man/7/urxvt
 */

'use strict';

/**
 * Shared
 */

var window = this
  , document = this.document;

/**
 * EventEmitter
 */

function EventEmitter() {
  this._events = this._events || {};
}

EventEmitter.prototype.addListener = function(type, listener) {
  this._events[type] = this._events[type] || [];
  this._events[type].push(listener);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.removeListener = function(type, listener) {
  if (!this._events[type]) return;

  var obj = this._events[type]
    , i = obj.length;

  while (i--) {
    if (obj[i] === listener || obj[i].listener === listener) {
      obj.splice(i, 1);
      return;
    }
  }
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function(type) {
  if (this._events[type]) delete this._events[type];
};

EventEmitter.prototype.once = function(type, listener) {
  function on() {
    var args = Array.prototype.slice.call(arguments);
    this.removeListener(type, on);
    return listener.apply(this, args);
  }
  on.listener = listener;
  return this.on(type, on);
};

EventEmitter.prototype.emit = function(type) {
  if (!this._events[type]) return;

  var args = Array.prototype.slice.call(arguments, 1)
    , obj = this._events[type]
    , l = obj.length
    , i = 0;

  for (; i < l; i++) {
    obj[i].apply(this, args);
  }
};

EventEmitter.prototype.listeners = function(type) {
  return this._events[type] = this._events[type] || [];
};

/**
 * States
 */

var normal = 0
  , escaped = 1
  , csi = 2
  , osc = 3
  , charset = 4
  , dcs = 5
  , ignore = 6;

/**
 * Terminal
 */

function Terminal(options) {
  var self = this;

  if (!(this instanceof Terminal)) {
    return new Terminal(arguments[0], arguments[1], arguments[2]);
  }

  EventEmitter.call(this);

  if (typeof options === 'number') {
    options = {
      cols: arguments[0],
      rows: arguments[1],
      handler: arguments[2]
    };
  }

  options = options || {};

  each(keys(Terminal.defaults), function(key) {
    if (options[key] == null) {
      options[key] = Terminal.options[key];
      // Legacy:
      if (Terminal[key] !== Terminal.defaults[key]) {
        options[key] = Terminal[key];
      }
    }
    self[key] = options[key];
  });

  if (options.colors.length === 8) {
    options.colors = options.colors.concat(Terminal._colors.slice(8));
  } else if (options.colors.length === 16) {
    options.colors = options.colors.concat(Terminal._colors.slice(16));
  } else if (options.colors.length === 10) {
    options.colors = options.colors.slice(0, -2).concat(
      Terminal._colors.slice(8, -2), options.colors.slice(-2));
  } else if (options.colors.length === 18) {
    options.colors = options.colors.concat(
      Terminal._colors.slice(16, -2), options.colors.slice(-2));
  }
  this.colors = options.colors;

  this.options = options;

  // this.context = options.context || window;
  // this.document = options.document || document;
  this.parent = options.body || options.parent
    || (document ? document.getElementsByTagName('body')[0] : null);

  this.cols = options.cols || options.geometry[0];
  this.rows = options.rows || options.geometry[1];

  if (options.handler) {
    this.on('data', options.handler);
  }

  this.ybase = 0;
  this.ydisp = 0;
  this.x = 0;
  this.y = 0;
  this.cursorState = 0;
  this.cursorHidden = false;
  this.convertEol;
  this.state = 0;
  this.queue = '';
  this.scrollTop = 0;
  this.scrollBottom = this.rows - 1;

  // modes
  this.applicationKeypad = false;
  this.applicationCursor = false;
  this.originMode = false;
  this.insertMode = false;
  this.wraparoundMode = false;
  this.normal = null;

  // select modes
  this.prefixMode = false;
  this.selectMode = false;
  this.visualMode = false;
  this.searchMode = false;
  this.searchDown;
  this.entry = '';
  this.entryPrefix = 'Search: ';
  this._real;
  this._selected;
  this._textarea;

  // charset
  this.charset = null;
  this.gcharset = null;
  this.glevel = 0;
  this.charsets = [null];

  // mouse properties
  this.decLocator;
  this.x10Mouse;
  this.vt200Mouse;
  this.vt300Mouse;
  this.normalMouse;
  this.mouseEvents;
  this.sendFocus;
  this.utfMouse;
  this.sgrMouse;
  this.urxvtMouse;

  // misc
  this.element;
  this.children;
  this.refreshStart;
  this.refreshEnd;
  this.savedX;
  this.savedY;
  this.savedCols;

  // stream
  this.readable = true;
  this.writable = true;

  this.defAttr = (0 << 18) | (257 << 9) | (256 << 0);
  this.curAttr = this.defAttr;

  this.params = [];
  this.currentParam = 0;
  this.prefix = '';
  this.postfix = '';

  this.lines = [];
  var i = this.rows;
  while (i--) {
    this.lines.push(this.blankLine());
  }

  this.tabs;
  this.setupStops();
}

inherits(Terminal, EventEmitter);

// back_color_erase feature for xterm.
Terminal.prototype.eraseAttr = function() {
  // if (this.is('screen')) return this.defAttr;
  return (this.defAttr & ~0x1ff) | (this.curAttr & 0x1ff);
};

/**
 * Colors
 */

// Colors 0-15
Terminal.tangoColors = [
  // dark:
  '#2e3436',
  '#cc0000',
  '#4e9a06',
  '#c4a000',
  '#3465a4',
  '#75507b',
  '#06989a',
  '#d3d7cf',
  // bright:
  '#555753',
  '#ef2929',
  '#8ae234',
  '#fce94f',
  '#729fcf',
  '#ad7fa8',
  '#34e2e2',
  '#eeeeec'
];

Terminal.xtermColors = [
  // dark:
  '#000000', // black
  '#cd0000', // red3
  '#00cd00', // green3
  '#cdcd00', // yellow3
  '#0000ee', // blue2
  '#cd00cd', // magenta3
  '#00cdcd', // cyan3
  '#e5e5e5', // gray90
  // bright:
  '#7f7f7f', // gray50
  '#ff0000', // red
  '#00ff00', // green
  '#ffff00', // yellow
  '#5c5cff', // rgb:5c/5c/ff
  '#ff00ff', // magenta
  '#00ffff', // cyan
  '#ffffff'  // white
];

// Colors 0-15 + 16-255
// Much thanks to TooTallNate for writing this.
Terminal.colors = (function() {
  var colors = Terminal.tangoColors.slice()
    , r = [0x00, 0x5f, 0x87, 0xaf, 0xd7, 0xff]
    , i;

  // 16-231
  i = 0;
  for (; i < 216; i++) {
    out(r[(i / 36) % 6 | 0], r[(i / 6) % 6 | 0], r[i % 6]);
  }

  // 232-255 (grey)
  i = 0;
  for (; i < 24; i++) {
    r = 8 + i * 10;
    out(r, r, r);
  }

  function out(r, g, b) {
    colors.push('#' + hex(r) + hex(g) + hex(b));
  }

  function hex(c) {
    c = c.toString(16);
    return c.length < 2 ? '0' + c : c;
  }

  return colors;
})();

// Default BG/FG
Terminal.colors[256] = '#000000';
Terminal.colors[257] = '#f0f0f0';

Terminal._colors = Terminal.colors.slice();

Terminal.vcolors = (function() {
  var out = []
    , colors = Terminal.colors
    , i = 0
    , color;

  for (; i < 256; i++) {
    color = parseInt(colors[i].substring(1), 16);
    out.push([
      (color >> 16) & 0xff,
      (color >> 8) & 0xff,
      color & 0xff
    ]);
  }

  return out;
})();

/**
 * Options
 */

Terminal.defaults = {
  colors: Terminal.colors,
  convertEol: false,
  termName: 'xterm',
  geometry: [80, 24],
  cursorBlink: true,
  visualBell: false,
  popOnBell: false,
  scrollback: 1000,
  screenKeys: false,
  debug: false,
  useStyle: false
  // programFeatures: false,
  // focusKeys: false,
};

Terminal.options = {};

each(keys(Terminal.defaults), function(key) {
  Terminal[key] = Terminal.defaults[key];
  Terminal.options[key] = Terminal.defaults[key];
});

/**
 * Focused Terminal
 */

Terminal.focus = null;

Terminal.prototype.focus = function() {
  if (Terminal.focus === this) return;

  if (Terminal.focus) {
    Terminal.focus.blur();
  }

  if (this.sendFocus) this.send('\x1b[I');
  this.showCursor();

  // try {
  //   this.element.focus();
  // } catch (e) {
  //   ;
  // }

  // this.emit('focus');

  Terminal.focus = this;
};

Terminal.prototype.blur = function() {
  if (Terminal.focus !== this) return;

  this.cursorState = 0;
  this.refresh(this.y, this.y);
  if (this.sendFocus) this.send('\x1b[O');

  // try {
  //   this.element.blur();
  // } catch (e) {
  //   ;
  // }

  // this.emit('blur');

  Terminal.focus = null;
};

/**
 * Initialize global behavior
 */

Terminal.prototype.initGlobal = function() {
  var document = this.document;

  Terminal._boundDocs = Terminal._boundDocs || [];
  if (~indexOf(Terminal._boundDocs, document)) {
    return;
  }
  Terminal._boundDocs.push(document);

  Terminal.bindPaste(document);

  Terminal.bindKeys(document);

  Terminal.bindCopy(document);

  if (this.isIpad || this.isIphone) {
    Terminal.fixIpad(document);
  }

  if (this.useStyle) {
    Terminal.insertStyle(document, this.colors[256], this.colors[257]);
  }
};

/**
 * Bind to paste event
 */

Terminal.bindPaste = function(document) {
  // This seems to work well for ctrl-V and middle-click,
  // even without the contentEditable workaround.
  var window = document.defaultView;
  on(window, 'paste', function(ev) {
    var term = Terminal.focus;
    if (!term) return;
    if (ev.clipboardData) {
      term.send(ev.clipboardData.getData('text/plain'));
    } else if (term.context.clipboardData) {
      term.send(term.context.clipboardData.getData('Text'));
    }
    // Not necessary. Do it anyway for good measure.
    term.element.contentEditable = 'inherit';
    return cancel(ev);
  });
};

/**
 * Global Events for key handling
 */

Terminal.bindKeys = function(document) {
  // We should only need to check `target === body` below,
  // but we can check everything for good measure.
  on(document, 'keydown', function(ev) {
    if (!Terminal.focus) return;
    var target = ev.target || ev.srcElement;
    if (!target) return;
    if (target === Terminal.focus.element
        || target === Terminal.focus.context
        || target === Terminal.focus.document
        || target === Terminal.focus.body
        || target === Terminal._textarea
        || target === Terminal.focus.parent) {
      return Terminal.focus.keyDown(ev);
    }
  }, true);

  on(document, 'keypress', function(ev) {
    if (!Terminal.focus) return;
    var target = ev.target || ev.srcElement;
    if (!target) return;
    if (target === Terminal.focus.element
        || target === Terminal.focus.context
        || target === Terminal.focus.document
        || target === Terminal.focus.body
        || target === Terminal._textarea
        || target === Terminal.focus.parent) {
      return Terminal.focus.keyPress(ev);
    }
  }, true);

  // If we click somewhere other than a
  // terminal, unfocus the terminal.
  on(document, 'mousedown', function(ev) {
    if (!Terminal.focus) return;

    var el = ev.target || ev.srcElement;
    if (!el) return;

    do {
      if (el === Terminal.focus.element) return;
    } while (el = el.parentNode);

    Terminal.focus.blur();
  });
};

/**
 * Copy Selection w/ Ctrl-C (Select Mode)
 */

Terminal.bindCopy = function(document) {
  var window = document.defaultView;

  // if (!('onbeforecopy' in document)) {
  //   // Copies to *only* the clipboard.
  //   on(window, 'copy', function fn(ev) {
  //     var term = Terminal.focus;
  //     if (!term) return;
  //     if (!term._selected) return;
  //     var text = term.grabText(
  //       term._selected.x1, term._selected.x2,
  //       term._selected.y1, term._selected.y2);
  //     term.emit('copy', text);
  //     ev.clipboardData.setData('text/plain', text);
  //   });
  //   return;
  // }

  // Copies to primary selection *and* clipboard.
  // NOTE: This may work better on capture phase,
  // or using the `beforecopy` event.
  on(window, 'copy', function(ev) {
    var term = Terminal.focus;
    if (!term) return;
    if (!term._selected) return;
    var textarea = term.getCopyTextarea();
    var text = term.grabText(
      term._selected.x1, term._selected.x2,
      term._selected.y1, term._selected.y2);
    term.emit('copy', text);
    textarea.focus();
    textarea.textContent = text;
    textarea.value = text;
    textarea.setSelectionRange(0, text.length);
    setTimeout(function() {
      term.element.focus();
      term.focus();
    }, 1);
  });
};

/**
 * Fix iPad - no idea if this works
 */

Terminal.fixIpad = function(document) {
  var textarea = document.createElement('textarea');
  textarea.style.position = 'absolute';
  textarea.style.left = '-32000px';
  textarea.style.top = '-32000px';
  textarea.style.width = '0px';
  textarea.style.height = '0px';
  textarea.style.opacity = '0';
  textarea.style.backgroundColor = 'transparent';
  textarea.style.borderStyle = 'none';
  textarea.style.outlineStyle = 'none';
  textarea.autocapitalize = 'none';
  textarea.autocorrect = 'off';

  document.getElementsByTagName('body')[0].appendChild(textarea);

  Terminal._textarea = textarea;

  setTimeout(function() {
    textarea.focus();
  }, 1000);
};

/**
 * Insert a default style
 */

Terminal.insertStyle = function(document, bg, fg) {
  var style = document.getElementById('term-style');
  if (style) return;

  var head = document.getElementsByTagName('head')[0];
  if (!head) return;

  var style = document.createElement('style');
  style.id = 'term-style';

  // textContent doesn't work well with IE for <style> elements.
  style.innerHTML = ''
    + '.terminal {\n'
    + '  float: left;\n'
    + '  border: ' + bg + ' solid 5px;\n'
    + '  font-family: "DejaVu Sans Mono", "Liberation Mono", monospace;\n'
    + '  font-size: 11px;\n'
    + '  color: ' + fg + ';\n'
    + '  background: ' + bg + ';\n'
    + '}\n'
    + '\n'
    + '.terminal-cursor {\n'
    + '  color: ' + bg + ';\n'
    + '  background: ' + fg + ';\n'
    + '}\n';

  // var out = '';
  // each(Terminal.colors, function(color, i) {
  //   if (i === 256) {
  //     out += '\n.term-bg-color-default { background-color: ' + color + '; }';
  //   }
  //   if (i === 257) {
  //     out += '\n.term-fg-color-default { color: ' + color + '; }';
  //   }
  //   out += '\n.term-bg-color-' + i + ' { background-color: ' + color + '; }';
  //   out += '\n.term-fg-color-' + i + ' { color: ' + color + '; }';
  // });
  // style.innerHTML += out + '\n';

  head.insertBefore(style, head.firstChild);
};

/**
 * Open Terminal
 */

Terminal.prototype.open = function(parent) {
  var self = this
    , i = 0
    , div;

  this.parent = parent || this.parent;

  if (!this.parent) {
    throw new Error('Terminal requires a parent element.');
  }

  // Grab global elements.
  this.context = this.parent.ownerDocument.defaultView;
  this.document = this.parent.ownerDocument;
  this.body = this.document.getElementsByTagName('body')[0];

  // Parse user-agent strings.
  if (this.context.navigator && this.context.navigator.userAgent) {
    this.isMac = !!~this.context.navigator.userAgent.indexOf('Mac');
    this.isIpad = !!~this.context.navigator.userAgent.indexOf('iPad');
    this.isIphone = !!~this.context.navigator.userAgent.indexOf('iPhone');
    this.isMSIE = !!~this.context.navigator.userAgent.indexOf('MSIE');
  }

  // Create our main terminal element.
  this.element = this.document.createElement('div');
  this.element.className = 'terminal';
  this.element.style.outline = 'none';
  this.element.setAttribute('tabindex', 0);
  this.element.style.backgroundColor = this.colors[256];
  this.element.style.color = this.colors[257];

  // Create the lines for our terminal.
  this.children = [];
  for (; i < this.rows; i++) {
    div = this.document.createElement('div');
    this.element.appendChild(div);
    this.children.push(div);
  }
  this.parent.appendChild(this.element);

  // Draw the screen.
  this.refresh(0, this.rows - 1);

  // Initialize global actions that
  // need to be taken on the document.
  this.initGlobal();

  // Ensure there is a Terminal.focus.
  this.focus();

  // Start blinking the cursor.
  this.startBlink();

  // Bind to DOM events related
  // to focus and paste behavior.
  on(this.element, 'focus', function() {
    self.focus();
    if (self.isIpad || self.isIphone) {
      Terminal._textarea.focus();
    }
  });

  // This causes slightly funky behavior.
  // on(this.element, 'blur', function() {
  //   self.blur();
  // });

  on(this.element, 'mousedown', function() {
    self.focus();
  });

  // Clickable paste workaround, using contentEditable.
  // This probably shouldn't work,
  // ... but it does. Firefox's paste
  // event seems to only work for textareas?
  on(this.element, 'mousedown', function(ev) {
    var button = ev.button != null
      ? +ev.button
      : ev.which != null
        ? ev.which - 1
        : null;

    // Does IE9 do this?
    if (self.isMSIE) {
      button = button === 1 ? 0 : button === 4 ? 1 : button;
    }

    if (button !== 2) return;

    self.element.contentEditable = 'true';
    setTimeout(function() {
      self.element.contentEditable = 'inherit'; // 'false';
    }, 1);
  }, true);

  // Listen for mouse events and translate
  // them into terminal mouse protocols.
  this.bindMouse();

  // Figure out whether boldness affects
  // the character width of monospace fonts.
  if (Terminal.brokenBold == null) {
    Terminal.brokenBold = isBoldBroken(this.document);
  }

  // this.emit('open');

  // This can be useful for pasting,
  // as well as the iPad fix.
  setTimeout(function() {
    self.element.focus();
  }, 100);
};

// XTerm mouse events
// http://invisible-island.net/xterm/ctlseqs/ctlseqs.html#Mouse%20Tracking
// To better understand these
// the xterm code is very helpful:
// Relevant files:
//   button.c, charproc.c, misc.c
// Relevant functions in xterm/button.c:
//   BtnCode, EmitButtonCode, EditorButton, SendMousePosition
Terminal.prototype.bindMouse = function() {
  var el = this.element
    , self = this
    , pressed = 32;

  var wheelEvent = 'onmousewheel' in this.context
    ? 'mousewheel'
    : 'DOMMouseScroll';

  // mouseup, mousedown, mousewheel
  // left click: ^[[M 3<^[[M#3<
  // mousewheel up: ^[[M`3>
  function sendButton(ev) {
    var button
      , pos;

    // get the xterm-style button
    button = getButton(ev);

    // get mouse coordinates
    pos = getCoords(ev);
    if (!pos) return;

    sendEvent(button, pos);

    switch (ev.type) {
      case 'mousedown':
        pressed = button;
        break;
      case 'mouseup':
        // keep it at the left
        // button, just in case.
        pressed = 32;
        break;
      case wheelEvent:
        // nothing. don't
        // interfere with
        // `pressed`.
        break;
    }
  }

  // motion example of a left click:
  // ^[[M 3<^[[M@4<^[[M@5<^[[M@6<^[[M@7<^[[M#7<
  function sendMove(ev) {
    var button = pressed
      , pos;

    pos = getCoords(ev);
    if (!pos) return;

    // buttons marked as motions
    // are incremented by 32
    button += 32;

    sendEvent(button, pos);
  }

  // encode button and
  // position to characters
  function encode(data, ch) {
    if (!self.utfMouse) {
      if (ch === 255) return data.push(0);
      if (ch > 127) ch = 127;
      data.push(ch);
    } else {
      if (ch === 2047) return data.push(0);
      if (ch < 127) {
        data.push(ch);
      } else {
        if (ch > 2047) ch = 2047;
        data.push(0xC0 | (ch >> 6));
        data.push(0x80 | (ch & 0x3F));
      }
    }
  }

  // send a mouse event:
  // regular/utf8: ^[[M Cb Cx Cy
  // urxvt: ^[[ Cb ; Cx ; Cy M
  // sgr: ^[[ Cb ; Cx ; Cy M/m
  // vt300: ^[[ 24(1/3/5)~ [ Cx , Cy ] \r
  // locator: CSI P e ; P b ; P r ; P c ; P p & w
  function sendEvent(button, pos) {
    // self.emit('mouse', {
    //   x: pos.x - 32,
    //   y: pos.x - 32,
    //   button: button
    // });

    if (self.vt300Mouse) {
      // NOTE: Unstable.
      // http://www.vt100.net/docs/vt3xx-gp/chapter15.html
      button &= 3;
      pos.x -= 32;
      pos.y -= 32;
      var data = '\x1b[24';
      if (button === 0) data += '1';
      else if (button === 1) data += '3';
      else if (button === 2) data += '5';
      else if (button === 3) return;
      else data += '0';
      data += '~[' + pos.x + ',' + pos.y + ']\r';
      self.send(data);
      return;
    }

    if (self.decLocator) {
      // NOTE: Unstable.
      button &= 3;
      pos.x -= 32;
      pos.y -= 32;
      if (button === 0) button = 2;
      else if (button === 1) button = 4;
      else if (button === 2) button = 6;
      else if (button === 3) button = 3;
      self.send('\x1b['
        + button
        + ';'
        + (button === 3 ? 4 : 0)
        + ';'
        + pos.y
        + ';'
        + pos.x
        + ';'
        + (pos.page || 0)
        + '&w');
      return;
    }

    if (self.urxvtMouse) {
      pos.x -= 32;
      pos.y -= 32;
      pos.x++;
      pos.y++;
      self.send('\x1b[' + button + ';' + pos.x + ';' + pos.y + 'M');
      return;
    }

    if (self.sgrMouse) {
      pos.x -= 32;
      pos.y -= 32;
      self.send('\x1b[<'
        + ((button & 3) === 3 ? button & ~3 : button)
        + ';'
        + pos.x
        + ';'
        + pos.y
        + ((button & 3) === 3 ? 'm' : 'M'));
      return;
    }

    var data = [];

    encode(data, button);
    encode(data, pos.x);
    encode(data, pos.y);

    self.send('\x1b[M' + String.fromCharCode.apply(String, data));
  }

  function getButton(ev) {
    var button
      , shift
      , meta
      , ctrl
      , mod;

    // two low bits:
    // 0 = left
    // 1 = middle
    // 2 = right
    // 3 = release
    // wheel up/down:
    // 1, and 2 - with 64 added
    switch (ev.type) {
      case 'mousedown':
        button = ev.button != null
          ? +ev.button
          : ev.which != null
            ? ev.which - 1
            : null;

        if (self.isMSIE) {
          button = button === 1 ? 0 : button === 4 ? 1 : button;
        }
        break;
      case 'mouseup':
        button = 3;
        break;
      case 'DOMMouseScroll':
        button = ev.detail < 0
          ? 64
          : 65;
        break;
      case 'mousewheel':
        button = ev.wheelDeltaY > 0
          ? 64
          : 65;
        break;
    }

    // next three bits are the modifiers:
    // 4 = shift, 8 = meta, 16 = control
    shift = ev.shiftKey ? 4 : 0;
    meta = ev.metaKey ? 8 : 0;
    ctrl = ev.ctrlKey ? 16 : 0;
    mod = shift | meta | ctrl;

    // no mods
    if (self.vt200Mouse) {
      // ctrl only
      mod &= ctrl;
    } else if (!self.normalMouse) {
      mod = 0;
    }

    // increment to SP
    button = (32 + (mod << 2)) + button;

    return button;
  }

  // mouse coordinates measured in cols/rows
  function getCoords(ev) {
    var x, y, w, h, el;

    // ignore browsers without pageX for now
    if (ev.pageX == null) return;

    x = ev.pageX;
    y = ev.pageY;
    el = self.element;

    // should probably check offsetParent
    // but this is more portable
    while (el && el !== self.document.documentElement) {
      x -= el.offsetLeft;
      y -= el.offsetTop;
      el = 'offsetParent' in el
        ? el.offsetParent
        : el.parentNode;
    }

    // convert to cols/rows
    w = self.element.clientWidth;
    h = self.element.clientHeight;
    x = Math.round((x / w) * self.cols);
    y = Math.round((y / h) * self.rows);

    // be sure to avoid sending
    // bad positions to the program
    if (x < 0) x = 0;
    if (x > self.cols) x = self.cols;
    if (y < 0) y = 0;
    if (y > self.rows) y = self.rows;

    // xterm sends raw bytes and
    // starts at 32 (SP) for each.
    x += 32;
    y += 32;

    return {
      x: x,
      y: y,
      type: ev.type === wheelEvent
        ? 'mousewheel'
        : ev.type
    };
  }

  on(el, 'mousedown', function(ev) {
    if (!self.mouseEvents) return;

    // send the button
    sendButton(ev);

    // ensure focus
    self.focus();

    // fix for odd bug
    //if (self.vt200Mouse && !self.normalMouse) {
    if (self.vt200Mouse) {
      sendButton({ __proto__: ev, type: 'mouseup' });
      return cancel(ev);
    }

    // bind events
    if (self.normalMouse) on(self.document, 'mousemove', sendMove);

    // x10 compatibility mode can't send button releases
    if (!self.x10Mouse) {
      on(self.document, 'mouseup', function up(ev) {
        sendButton(ev);
        if (self.normalMouse) off(self.document, 'mousemove', sendMove);
        off(self.document, 'mouseup', up);
        return cancel(ev);
      });
    }

    return cancel(ev);
  });

  //if (self.normalMouse) {
  //  on(self.document, 'mousemove', sendMove);
  //}

  on(el, wheelEvent, function(ev) {
    if (!self.mouseEvents) return;
    if (self.x10Mouse
        || self.vt300Mouse
        || self.decLocator) return;
    sendButton(ev);
    return cancel(ev);
  });

  // allow mousewheel scrolling in
  // the shell for example
  on(el, wheelEvent, function(ev) {
    if (self.mouseEvents) return;
    if (self.applicationKeypad) return;
    if (ev.type === 'DOMMouseScroll') {
      self.scrollDisp(ev.detail < 0 ? -5 : 5);
    } else {
      self.scrollDisp(ev.wheelDeltaY > 0 ? -5 : 5);
    }
    return cancel(ev);
  });
};

/**
 * Destroy Terminal
 */

Terminal.prototype.destroy = function() {
  this.readable = false;
  this.writable = false;
  this._events = {};
  this.handler = function() {};
  this.write = function() {};
  if (this.element.parentNode) {
    this.element.parentNode.removeChild(this.element);
  }
  //this.emit('close');
};

/**
 * Rendering Engine
 */

// In the screen buffer, each character
// is stored as a an array with a character
// and a 32-bit integer.
// First value: a utf-16 character.
// Second value:
// Next 9 bits: background color (0-511).
// Next 9 bits: foreground color (0-511).
// Next 14 bits: a mask for misc. flags:
//   1=bold, 2=underline, 4=blink, 8=inverse, 16=invisible

Terminal.prototype.refresh = function(start, end) {
  var x
    , y
    , i
    , line
    , out
    , ch
    , width
    , data
    , attr
    , bg
    , fg
    , flags
    , row
    , parent;

  if (end - start >= this.rows / 2) {
    parent = this.element.parentNode;
    if (parent) parent.removeChild(this.element);
  }

  width = this.cols;
  y = start;

  if (end >= this.lines.length) {
    this.log('`end` is too large. Most likely a bad CSR.');
    end = this.lines.length - 1;
  }

  for (; y <= end; y++) {
    row = y + this.ydisp;

    line = this.lines[row];
    out = '';

    if (y === this.y
        && this.cursorState
        && (this.ydisp === this.ybase || this.selectMode)
        && !this.cursorHidden) {
      x = this.x;
    } else {
      x = -1;
    }

    attr = this.defAttr;
    i = 0;

    for (; i < width; i++) {
      data = line[i][0];
      ch = line[i][1];

      if (i === x) data = -1;

      if (data !== attr) {
        if (attr !== this.defAttr) {
          out += '</span>';
        }
        if (data !== this.defAttr) {
          if (data === -1) {
            out += '<span class="reverse-video terminal-cursor">';
          } else {
            out += '<span style="';

            bg = data & 0x1ff;
            fg = (data >> 9) & 0x1ff;
            flags = data >> 18;

            // bold
            if (flags & 1) {
              if (!Terminal.brokenBold) {
                out += 'font-weight:bold;';
              }
              // See: XTerm*boldColors
              if (fg < 8) fg += 8;
            }

            // underline
            if (flags & 2) {
              out += 'text-decoration:underline;';
            }

            // blink
            if (flags & 4) {
              if (flags & 2) {
                out = out.slice(0, -1);
                out += ' blink;';
              } else {
                out += 'text-decoration:blink;';
              }
            }

            // inverse
            if (flags & 8) {
              bg = (data >> 9) & 0x1ff;
              fg = data & 0x1ff;
              // Should inverse just be before the
              // above boldColors effect instead?
              if ((flags & 1) && fg < 8) fg += 8;
            }

            // invisible
            if (flags & 16) {
              out += 'visibility:hidden;';
            }

            // out += '" class="'
            //   + 'term-bg-color-' + bg
            //   + ' '
            //   + 'term-fg-color-' + fg
            //   + '">';

            if (bg !== 256) {
              out += 'background-color:'
                + this.colors[bg]
                + ';';
            }

            if (fg !== 257) {
              out += 'color:'
                + this.colors[fg]
                + ';';
            }

            out += '">';
          }
        }
      }

      switch (ch) {
        case '&':
          out += '&amp;';
          break;
        case '<':
          out += '&lt;';
          break;
        case '>':
          out += '&gt;';
          break;
        default:
          if (ch <= ' ') {
            out += '&nbsp;';
          } else {
            if (isWide(ch)) i++;
            out += ch;
          }
          break;
      }

      attr = data;
    }

    if (attr !== this.defAttr) {
      out += '</span>';
    }

    this.children[y].innerHTML = out;
  }

  if (parent) parent.appendChild(this.element);
};

Terminal.prototype._cursorBlink = function() {
  if (Terminal.focus !== this) return;
  this.cursorState ^= 1;
  this.refresh(this.y, this.y);
};

Terminal.prototype.showCursor = function() {
  if (!this.cursorState) {
    this.cursorState = 1;
    this.refresh(this.y, this.y);
  } else {
    // Temporarily disabled:
    // this.refreshBlink();
  }
};

Terminal.prototype.startBlink = function() {
  if (!this.cursorBlink) return;
  var self = this;
  this._blinker = function() {
    self._cursorBlink();
  };
  this._blink = setInterval(this._blinker, 500);
};

Terminal.prototype.refreshBlink = function() {
  if (!this.cursorBlink) return;
  clearInterval(this._blink);
  this._blink = setInterval(this._blinker, 500);
};

Terminal.prototype.scroll = function() {
  var row;

  if (++this.ybase === this.scrollback) {
    this.ybase = this.ybase / 2 | 0;
    this.lines = this.lines.slice(-(this.ybase + this.rows) + 1);
  }

  this.ydisp = this.ybase;

  // last line
  row = this.ybase + this.rows - 1;

  // subtract the bottom scroll region
  row -= this.rows - 1 - this.scrollBottom;

  if (row === this.lines.length) {
    // potential optimization:
    // pushing is faster than splicing
    // when they amount to the same
    // behavior.
    this.lines.push(this.blankLine());
  } else {
    // add our new line
    this.lines.splice(row, 0, this.blankLine());
  }

  if (this.scrollTop !== 0) {
    if (this.ybase !== 0) {
      this.ybase--;
      this.ydisp = this.ybase;
    }
    this.lines.splice(this.ybase + this.scrollTop, 1);
  }

  // this.maxRange();
  this.updateRange(this.scrollTop);
  this.updateRange(this.scrollBottom);
};

Terminal.prototype.scrollDisp = function(disp) {
  this.ydisp += disp;

  if (this.ydisp > this.ybase) {
    this.ydisp = this.ybase;
  } else if (this.ydisp < 0) {
    this.ydisp = 0;
  }

  this.refresh(0, this.rows - 1);
};

Terminal.prototype.write = function(data) {
  var l = data.length
    , i = 0
    , j
    , cs
    , ch;

  this.refreshStart = this.y;
  this.refreshEnd = this.y;

  if (this.ybase !== this.ydisp) {
    this.ydisp = this.ybase;
    this.maxRange();
  }

  // this.log(JSON.stringify(data.replace(/\x1b/g, '^[')));

  for (; i < l; i++) {
    ch = data[i];
    switch (this.state) {
      case normal:
        switch (ch) {
          // '\0'
          // case '\0':
          // case '\200':
          //   break;

          // '\a'
          case '\x07':
            this.bell();
            break;

          // '\n', '\v', '\f'
          case '\n':
          case '\x0b':
          case '\x0c':
            if (this.convertEol) {
              this.x = 0;
            }
            // TODO: Implement eat_newline_glitch.
            // if (this.realX >= this.cols) break;
            // this.realX = 0;
            this.y++;
            if (this.y > this.scrollBottom) {
              this.y--;
              this.scroll();
            }
            break;

          // '\r'
          case '\r':
            this.x = 0;
            break;

          // '\b'
          case '\x08':
            if (this.x > 0) {
              this.x--;
            }
            break;

          // '\t'
          case '\t':
            this.x = this.nextStop();
            break;

          // shift out
          case '\x0e':
            this.setgLevel(1);
            break;

          // shift in
          case '\x0f':
            this.setgLevel(0);
            break;

          // '\e'
          case '\x1b':
            this.state = escaped;
            break;

          default:
            // ' '
            if (ch >= ' ') {
              if (this.charset && this.charset[ch]) {
                ch = this.charset[ch];
              }

              if (this.x >= this.cols) {
                this.x = 0;
                this.y++;
                if (this.y > this.scrollBottom) {
                  this.y--;
                  this.scroll();
                }
              }

              this.lines[this.y + this.ybase][this.x] = [this.curAttr, ch];
              this.x++;
              this.updateRange(this.y);

              if (isWide(ch)) {
                j = this.y + this.ybase;
                if (this.cols < 2 || this.x >= this.cols) {
                  this.lines[j][this.x - 1] = [this.curAttr, ' '];
                  break;
                }
                this.lines[j][this.x] = [this.curAttr, ' '];
                this.x++;
              }
            }
            break;
        }
        break;
      case escaped:
        switch (ch) {
          // ESC [ Control Sequence Introducer ( CSI is 0x9b).
          case '[':
            this.params = [];
            this.currentParam = 0;
            this.state = csi;
            break;

          // ESC ] Operating System Command ( OSC is 0x9d).
          case ']':
            this.params = [];
            this.currentParam = 0;
            this.state = osc;
            break;

          // ESC P Device Control String ( DCS is 0x90).
          case 'P':
            this.params = [];
            this.currentParam = 0;
            this.state = dcs;
            break;

          // ESC _ Application Program Command ( APC is 0x9f).
          case '_':
            this.state = ignore;
            break;

          // ESC ^ Privacy Message ( PM is 0x9e).
          case '^':
            this.state = ignore;
            break;

          // ESC c Full Reset (RIS).
          case 'c':
            this.reset();
            break;

          // ESC E Next Line ( NEL is 0x85).
          // ESC D Index ( IND is 0x84).
          case 'E':
            this.x = 0;
            ;
          case 'D':
            this.index();
            break;

          // ESC M Reverse Index ( RI is 0x8d).
          case 'M':
            this.reverseIndex();
            break;

          // ESC % Select default/utf-8 character set.
          // @ = default, G = utf-8
          case '%':
            //this.charset = null;
            this.setgLevel(0);
            this.setgCharset(0, Terminal.charsets.US);
            this.state = normal;
            i++;
            break;

          // ESC (,),*,+,-,. Designate G0-G2 Character Set.
          case '(': // <-- this seems to get all the attention
          case ')':
          case '*':
          case '+':
          case '-':
          case '.':
            switch (ch) {
              case '(':
                this.gcharset = 0;
                break;
              case ')':
                this.gcharset = 1;
                break;
              case '*':
                this.gcharset = 2;
                break;
              case '+':
                this.gcharset = 3;
                break;
              case '-':
                this.gcharset = 1;
                break;
              case '.':
                this.gcharset = 2;
                break;
            }
            this.state = charset;
            break;

          // Designate G3 Character Set (VT300).
          // A = ISO Latin-1 Supplemental.
          // Not implemented.
          case '/':
            this.gcharset = 3;
            this.state = charset;
            i--;
            break;

          // ESC N
          // Single Shift Select of G2 Character Set
          // ( SS2 is 0x8e). This affects next character only.
          case 'N':
            break;
          // ESC O
          // Single Shift Select of G3 Character Set
          // ( SS3 is 0x8f). This affects next character only.
          case 'O':
            break;
          // ESC n
          // Invoke the G2 Character Set as GL (LS2).
          case 'n':
            this.setgLevel(2);
            break;
          // ESC o
          // Invoke the G3 Character Set as GL (LS3).
          case 'o':
            this.setgLevel(3);
            break;
          // ESC |
          // Invoke the G3 Character Set as GR (LS3R).
          case '|':
            this.setgLevel(3);
            break;
          // ESC }
          // Invoke the G2 Character Set as GR (LS2R).
          case '}':
            this.setgLevel(2);
            break;
          // ESC ~
          // Invoke the G1 Character Set as GR (LS1R).
          case '~':
            this.setgLevel(1);
            break;

          // ESC 7 Save Cursor (DECSC).
          case '7':
            this.saveCursor();
            this.state = normal;
            break;

          // ESC 8 Restore Cursor (DECRC).
          case '8':
            this.restoreCursor();
            this.state = normal;
            break;

          // ESC # 3 DEC line height/width
          case '#':
            this.state = normal;
            i++;
            break;

          // ESC H Tab Set (HTS is 0x88).
          case 'H':
            this.tabSet();
            break;

          // ESC = Application Keypad (DECPAM).
          case '=':
            this.log('Serial port requested application keypad.');
            this.applicationKeypad = true;
            this.state = normal;
            break;

          // ESC > Normal Keypad (DECPNM).
          case '>':
            this.log('Switching back to normal keypad.');
            this.applicationKeypad = false;
            this.state = normal;
            break;

          default:
            this.state = normal;
            this.error('Unknown ESC control: %s.', ch);
            break;
        }
        break;

      case charset:
        switch (ch) {
          case '0': // DEC Special Character and Line Drawing Set.
            cs = Terminal.charsets.SCLD;
            break;
          case 'A': // UK
            cs = Terminal.charsets.UK;
            break;
          case 'B': // United States (USASCII).
            cs = Terminal.charsets.US;
            break;
          case '4': // Dutch
            cs = Terminal.charsets.Dutch;
            break;
          case 'C': // Finnish
          case '5':
            cs = Terminal.charsets.Finnish;
            break;
          case 'R': // French
            cs = Terminal.charsets.French;
            break;
          case 'Q': // FrenchCanadian
            cs = Terminal.charsets.FrenchCanadian;
            break;
          case 'K': // German
            cs = Terminal.charsets.German;
            break;
          case 'Y': // Italian
            cs = Terminal.charsets.Italian;
            break;
          case 'E': // NorwegianDanish
          case '6':
            cs = Terminal.charsets.NorwegianDanish;
            break;
          case 'Z': // Spanish
            cs = Terminal.charsets.Spanish;
            break;
          case 'H': // Swedish
          case '7':
            cs = Terminal.charsets.Swedish;
            break;
          case '=': // Swiss
            cs = Terminal.charsets.Swiss;
            break;
          case '/': // ISOLatin (actually /A)
            cs = Terminal.charsets.ISOLatin;
            i++;
            break;
          default: // Default
            cs = Terminal.charsets.US;
            break;
        }
        this.setgCharset(this.gcharset, cs);
        this.gcharset = null;
        this.state = normal;
        break;

      case osc:
        // OSC Ps ; Pt ST
        // OSC Ps ; Pt BEL
        //   Set Text Parameters.
        if (ch === '\x1b' || ch === '\x07') {
          if (ch === '\x1b') i++;

          this.params.push(this.currentParam);

          switch (this.params[0]) {
            case 0:
            case 1:
            case 2:
              if (this.params[1]) {
                this.title = this.params[1];
                this.handleTitle(this.title);
              }
              break;
            case 3:
              // set X property
              break;
            case 4:
            case 5:
              // change dynamic colors
              break;
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
              // change dynamic ui colors
              break;
            case 46:
              // change log file
              break;
            case 50:
              // dynamic font
              break;
            case 51:
              // emacs shell
              break;
            case 52:
              // manipulate selection data
              break;
            case 104:
            case 105:
            case 110:
            case 111:
            case 112:
            case 113:
            case 114:
            case 115:
            case 116:
            case 117:
            case 118:
              // reset colors
              break;
          }

          this.params = [];
          this.currentParam = 0;
          this.state = normal;
        } else {
          if (!this.params.length) {
            if (ch >= '0' && ch <= '9') {
              this.currentParam =
                this.currentParam * 10 + ch.charCodeAt(0) - 48;
            } else if (ch === ';') {
              this.params.push(this.currentParam);
              this.currentParam = '';
            }
          } else {
            this.currentParam += ch;
          }
        }
        break;

      case csi:
        // '?', '>', '!'
        if (ch === '?' || ch === '>' || ch === '!') {
          this.prefix = ch;
          break;
        }

        // 0 - 9
        if (ch >= '0' && ch <= '9') {
          this.currentParam = this.currentParam * 10 + ch.charCodeAt(0) - 48;
          break;
        }

        // '$', '"', ' ', '\''
        if (ch === '$' || ch === '"' || ch === ' ' || ch === '\'') {
          this.postfix = ch;
          break;
        }

        this.params.push(this.currentParam);
        this.currentParam = 0;

        // ';'
        if (ch === ';') break;

        this.state = normal;

        switch (ch) {
          // CSI Ps A
          // Cursor Up Ps Times (default = 1) (CUU).
          case 'A':
            this.cursorUp(this.params);
            break;

          // CSI Ps B
          // Cursor Down Ps Times (default = 1) (CUD).
          case 'B':
            this.cursorDown(this.params);
            break;

          // CSI Ps C
          // Cursor Forward Ps Times (default = 1) (CUF).
          case 'C':
            this.cursorForward(this.params);
            break;

          // CSI Ps D
          // Cursor Backward Ps Times (default = 1) (CUB).
          case 'D':
            this.cursorBackward(this.params);
            break;

          // CSI Ps ; Ps H
          // Cursor Position [row;column] (default = [1,1]) (CUP).
          case 'H':
            this.cursorPos(this.params);
            break;

          // CSI Ps J  Erase in Display (ED).
          case 'J':
            this.eraseInDisplay(this.params);
            break;

          // CSI Ps K  Erase in Line (EL).
          case 'K':
            this.eraseInLine(this.params);
            break;

          // CSI Pm m  Character Attributes (SGR).
          case 'm':
            if (!this.prefix) {
              this.charAttributes(this.params);
            }
            break;

          // CSI Ps n  Device Status Report (DSR).
          case 'n':
            if (!this.prefix) {
              this.deviceStatus(this.params);
            }
            break;

          /**
           * Additions
           */

          // CSI Ps @
          // Insert Ps (Blank) Character(s) (default = 1) (ICH).
          case '@':
            this.insertChars(this.params);
            break;

          // CSI Ps E
          // Cursor Next Line Ps Times (default = 1) (CNL).
          case 'E':
            this.cursorNextLine(this.params);
            break;

          // CSI Ps F
          // Cursor Preceding Line Ps Times (default = 1) (CNL).
          case 'F':
            this.cursorPrecedingLine(this.params);
            break;

          // CSI Ps G
          // Cursor Character Absolute  [column] (default = [row,1]) (CHA).
          case 'G':
            this.cursorCharAbsolute(this.params);
            break;

          // CSI Ps L
          // Insert Ps Line(s) (default = 1) (IL).
          case 'L':
            this.insertLines(this.params);
            break;

          // CSI Ps M
          // Delete Ps Line(s) (default = 1) (DL).
          case 'M':
            this.deleteLines(this.params);
            break;

          // CSI Ps P
          // Delete Ps Character(s) (default = 1) (DCH).
          case 'P':
            this.deleteChars(this.params);
            break;

          // CSI Ps X
          // Erase Ps Character(s) (default = 1) (ECH).
          case 'X':
            this.eraseChars(this.params);
            break;

          // CSI Pm `  Character Position Absolute
          //   [column] (default = [row,1]) (HPA).
          case '`':
            this.charPosAbsolute(this.params);
            break;

          // 141 61 a * HPR -
          // Horizontal Position Relative
          case 'a':
            this.HPositionRelative(this.params);
            break;

          // CSI P s c
          // Send Device Attributes (Primary DA).
          // CSI > P s c
          // Send Device Attributes (Secondary DA)
          case 'c':
            this.sendDeviceAttributes(this.params);
            break;

          // CSI Pm d
          // Line Position Absolute  [row] (default = [1,column]) (VPA).
          case 'd':
            this.linePosAbsolute(this.params);
            break;

          // 145 65 e * VPR - Vertical Position Relative
          case 'e':
            this.VPositionRelative(this.params);
            break;

          // CSI Ps ; Ps f
          //   Horizontal and Vertical Position [row;column] (default =
          //   [1,1]) (HVP).
          case 'f':
            this.HVPosition(this.params);
            break;

          // CSI Pm h  Set Mode (SM).
          // CSI ? Pm h - mouse escape codes, cursor escape codes
          case 'h':
            this.setMode(this.params);
            break;

          // CSI Pm l  Reset Mode (RM).
          // CSI ? Pm l
          case 'l':
            this.resetMode(this.params);
            break;

          // CSI Ps ; Ps r
          //   Set Scrolling Region [top;bottom] (default = full size of win-
          //   dow) (DECSTBM).
          // CSI ? Pm r
          case 'r':
            this.setScrollRegion(this.params);
            break;

          // CSI s
          //   Save cursor (ANSI.SYS).
          case 's':
            this.saveCursor(this.params);
            break;

          // CSI u
          //   Restore cursor (ANSI.SYS).
          case 'u':
            this.restoreCursor(this.params);
            break;

          /**
           * Lesser Used
           */

          // CSI Ps I
          // Cursor Forward Tabulation Ps tab stops (default = 1) (CHT).
          case 'I':
            this.cursorForwardTab(this.params);
            break;

          // CSI Ps S  Scroll up Ps lines (default = 1) (SU).
          case 'S':
            this.scrollUp(this.params);
            break;

          // CSI Ps T  Scroll down Ps lines (default = 1) (SD).
          // CSI Ps ; Ps ; Ps ; Ps ; Ps T
          // CSI > Ps; Ps T
          case 'T':
            // if (this.prefix === '>') {
            //   this.resetTitleModes(this.params);
            //   break;
            // }
            // if (this.params.length > 2) {
            //   this.initMouseTracking(this.params);
            //   break;
            // }
            if (this.params.length < 2 && !this.prefix) {
              this.scrollDown(this.params);
            }
            break;

          // CSI Ps Z
          // Cursor Backward Tabulation Ps tab stops (default = 1) (CBT).
          case 'Z':
            this.cursorBackwardTab(this.params);
            break;

          // CSI Ps b  Repeat the preceding graphic character Ps times (REP).
          case 'b':
            this.repeatPrecedingCharacter(this.params);
            break;

          // CSI Ps g  Tab Clear (TBC).
          case 'g':
            this.tabClear(this.params);
            break;

          // CSI Pm i  Media Copy (MC).
          // CSI ? Pm i
          // case 'i':
          //   this.mediaCopy(this.params);
          //   break;

          // CSI Pm m  Character Attributes (SGR).
          // CSI > Ps; Ps m
          // case 'm': // duplicate
          //   if (this.prefix === '>') {
          //     this.setResources(this.params);
          //   } else {
          //     this.charAttributes(this.params);
          //   }
          //   break;

          // CSI Ps n  Device Status Report (DSR).
          // CSI > Ps n
          // case 'n': // duplicate
          //   if (this.prefix === '>') {
          //     this.disableModifiers(this.params);
          //   } else {
          //     this.deviceStatus(this.params);
          //   }
          //   break;

          // CSI > Ps p  Set pointer mode.
          // CSI ! p   Soft terminal reset (DECSTR).
          // CSI Ps$ p
          //   Request ANSI mode (DECRQM).
          // CSI ? Ps$ p
          //   Request DEC private mode (DECRQM).
          // CSI Ps ; Ps " p
          case 'p':
            switch (this.prefix) {
              // case '>':
              //   this.setPointerMode(this.params);
              //   break;
              case '!':
                this.softReset(this.params);
                break;
              // case '?':
              //   if (this.postfix === '$') {
              //     this.requestPrivateMode(this.params);
              //   }
              //   break;
              // default:
              //   if (this.postfix === '"') {
              //     this.setConformanceLevel(this.params);
              //   } else if (this.postfix === '$') {
              //     this.requestAnsiMode(this.params);
              //   }
              //   break;
            }
            break;

          // CSI Ps q  Load LEDs (DECLL).
          // CSI Ps SP q
          // CSI Ps " q
          // case 'q':
          //   if (this.postfix === ' ') {
          //     this.setCursorStyle(this.params);
          //     break;
          //   }
          //   if (this.postfix === '"') {
          //     this.setCharProtectionAttr(this.params);
          //     break;
          //   }
          //   this.loadLEDs(this.params);
          //   break;

          // CSI Ps ; Ps r
          //   Set Scrolling Region [top;bottom] (default = full size of win-
          //   dow) (DECSTBM).
          // CSI ? Pm r
          // CSI Pt; Pl; Pb; Pr; Ps$ r
          // case 'r': // duplicate
          //   if (this.prefix === '?') {
          //     this.restorePrivateValues(this.params);
          //   } else if (this.postfix === '$') {
          //     this.setAttrInRectangle(this.params);
          //   } else {
          //     this.setScrollRegion(this.params);
          //   }
          //   break;

          // CSI s     Save cursor (ANSI.SYS).
          // CSI ? Pm s
          // case 's': // duplicate
          //   if (this.prefix === '?') {
          //     this.savePrivateValues(this.params);
          //   } else {
          //     this.saveCursor(this.params);
          //   }
          //   break;

          // CSI Ps ; Ps ; Ps t
          // CSI Pt; Pl; Pb; Pr; Ps$ t
          // CSI > Ps; Ps t
          // CSI Ps SP t
          // case 't':
          //   if (this.postfix === '$') {
          //     this.reverseAttrInRectangle(this.params);
          //   } else if (this.postfix === ' ') {
          //     this.setWarningBellVolume(this.params);
          //   } else {
          //     if (this.prefix === '>') {
          //       this.setTitleModeFeature(this.params);
          //     } else {
          //       this.manipulateWindow(this.params);
          //     }
          //   }
          //   break;

          // CSI u     Restore cursor (ANSI.SYS).
          // CSI Ps SP u
          // case 'u': // duplicate
          //   if (this.postfix === ' ') {
          //     this.setMarginBellVolume(this.params);
          //   } else {
          //     this.restoreCursor(this.params);
          //   }
          //   break;

          // CSI Pt; Pl; Pb; Pr; Pp; Pt; Pl; Pp$ v
          // case 'v':
          //   if (this.postfix === '$') {
          //     this.copyRectagle(this.params);
          //   }
          //   break;

          // CSI Pt ; Pl ; Pb ; Pr ' w
          // case 'w':
          //   if (this.postfix === '\'') {
          //     this.enableFilterRectangle(this.params);
          //   }
          //   break;

          // CSI Ps x  Request Terminal Parameters (DECREQTPARM).
          // CSI Ps x  Select Attribute Change Extent (DECSACE).
          // CSI Pc; Pt; Pl; Pb; Pr$ x
          // case 'x':
          //   if (this.postfix === '$') {
          //     this.fillRectangle(this.params);
          //   } else {
          //     this.requestParameters(this.params);
          //     //this.__(this.params);
          //   }
          //   break;

          // CSI Ps ; Pu ' z
          // CSI Pt; Pl; Pb; Pr$ z
          // case 'z':
          //   if (this.postfix === '\'') {
          //     this.enableLocatorReporting(this.params);
          //   } else if (this.postfix === '$') {
          //     this.eraseRectangle(this.params);
          //   }
          //   break;

          // CSI Pm ' {
          // CSI Pt; Pl; Pb; Pr$ {
          // case '{':
          //   if (this.postfix === '\'') {
          //     this.setLocatorEvents(this.params);
          //   } else if (this.postfix === '$') {
          //     this.selectiveEraseRectangle(this.params);
          //   }
          //   break;

          // CSI Ps ' |
          // case '|':
          //   if (this.postfix === '\'') {
          //     this.requestLocatorPosition(this.params);
          //   }
          //   break;

          // CSI P m SP }
          // Insert P s Column(s) (default = 1) (DECIC), VT420 and up.
          // case '}':
          //   if (this.postfix === ' ') {
          //     this.insertColumns(this.params);
          //   }
          //   break;

          // CSI P m SP ~
          // Delete P s Column(s) (default = 1) (DECDC), VT420 and up
          // case '~':
          //   if (this.postfix === ' ') {
          //     this.deleteColumns(this.params);
          //   }
          //   break;

          default:
            this.error('Unknown CSI code: %s.', ch);
            break;
        }

        this.prefix = '';
        this.postfix = '';
        break;

      case dcs:
        if (ch === '\x1b' || ch === '\x07') {
          if (ch === '\x1b') i++;

          switch (this.prefix) {
            // User-Defined Keys (DECUDK).
            case '':
              break;

            // Request Status String (DECRQSS).
            // test: echo -e '\eP$q"p\e\\'
            case '$q':
              var pt = this.currentParam
                , valid = false;

              switch (pt) {
                // DECSCA
                case '"q':
                  pt = '0"q';
                  break;

                // DECSCL
                case '"p':
                  pt = '61"p';
                  break;

                // DECSTBM
                case 'r':
                  pt = ''
                    + (this.scrollTop + 1)
                    + ';'
                    + (this.scrollBottom + 1)
                    + 'r';
                  break;

                // SGR
                case 'm':
                  pt = '0m';
                  break;

                default:
                  this.error('Unknown DCS Pt: %s.', pt);
                  pt = '';
                  break;
              }

              this.send('\x1bP' + +valid + '$r' + pt + '\x1b\\');
              break;

            // Set Termcap/Terminfo Data (xterm, experimental).
            case '+p':
              break;

            // Request Termcap/Terminfo String (xterm, experimental)
            // Regular xterm does not even respond to this sequence.
            // This can cause a small glitch in vim.
            // test: echo -ne '\eP+q6b64\e\\'
            case '+q':
              var pt = this.currentParam
                , valid = false;

              this.send('\x1bP' + +valid + '+r' + pt + '\x1b\\');
              break;

            default:
              this.error('Unknown DCS prefix: %s.', this.prefix);
              break;
          }

          this.currentParam = 0;
          this.prefix = '';
          this.state = normal;
        } else if (!this.currentParam) {
          if (!this.prefix && ch !== '$' && ch !== '+') {
            this.currentParam = ch;
          } else if (this.prefix.length === 2) {
            this.currentParam = ch;
          } else {
            this.prefix += ch;
          }
        } else {
          this.currentParam += ch;
        }
        break;

      case ignore:
        // For PM and APC.
        if (ch === '\x1b' || ch === '\x07') {
          if (ch === '\x1b') i++;
          this.state = normal;
        }
        break;
    }
  }

  this.updateRange(this.y);
  this.refresh(this.refreshStart, this.refreshEnd);
};

Terminal.prototype.writeln = function(data) {
  this.write(data + '\r\n');
};

// Key Resources:
// https://developer.mozilla.org/en-US/docs/DOM/KeyboardEvent
Terminal.prototype.keyDown = function(ev) {
  var self = this
    , key;

  switch (ev.keyCode) {
    // backspace
    case 8:
      if (ev.shiftKey) {
        key = '\x08'; // ^H
        break;
      }
      key = '\x7f'; // ^?
      break;
    // tab
    case 9:
      if (ev.shiftKey) {
        key = '\x1b[Z';
        break;
      }
      key = '\t';
      break;
    // return/enter
    case 13:
      key = '\r';
      break;
    // escape
    case 27:
      key = '\x1b';
      break;
    // left-arrow
    case 37:
      if (this.applicationCursor) {
        key = '\x1bOD'; // SS3 as ^[O for 7-bit
        //key = '\x8fD'; // SS3 as 0x8f for 8-bit
        break;
      }
      key = '\x1b[D';
      break;
    // right-arrow
    case 39:
      if (this.applicationCursor) {
        key = '\x1bOC';
        break;
      }
      key = '\x1b[C';
      break;
    // up-arrow
    case 38:
      if (this.applicationCursor) {
        key = '\x1bOA';
        break;
      }
      if (ev.ctrlKey) {
        this.scrollDisp(-1);
        return cancel(ev);
      } else {
        key = '\x1b[A';
      }
      break;
    // down-arrow
    case 40:
      if (this.applicationCursor) {
        key = '\x1bOB';
        break;
      }
      if (ev.ctrlKey) {
        this.scrollDisp(1);
        return cancel(ev);
      } else {
        key = '\x1b[B';
      }
      break;
    // delete
    case 46:
      key = '\x1b[3~';
      break;
    // insert
    case 45:
      key = '\x1b[2~';
      break;
    // home
    case 36:
      if (this.applicationKeypad) {
        key = '\x1bOH';
        break;
      }
      key = '\x1bOH';
      break;
    // end
    case 35:
      if (this.applicationKeypad) {
        key = '\x1bOF';
        break;
      }
      key = '\x1bOF';
      break;
    // page up
    case 33:
      if (ev.shiftKey) {
        this.scrollDisp(-(this.rows - 1));
        return cancel(ev);
      } else {
        key = '\x1b[5~';
      }
      break;
    // page down
    case 34:
      if (ev.shiftKey) {
        this.scrollDisp(this.rows - 1);
        return cancel(ev);
      } else {
        key = '\x1b[6~';
      }
      break;
    // F1
    case 112:
      key = '\x1bOP';
      break;
    // F2
    case 113:
      key = '\x1bOQ';
      break;
    // F3
    case 114:
      key = '\x1bOR';
      break;
    // F4
    case 115:
      key = '\x1bOS';
      break;
    // F5
    case 116:
      key = '\x1b[15~';
      break;
    // F6
    case 117:
      key = '\x1b[17~';
      break;
    // F7
    case 118:
      key = '\x1b[18~';
      break;
    // F8
    case 119:
      key = '\x1b[19~';
      break;
    // F9
    case 120:
      key = '\x1b[20~';
      break;
    // F10
    case 121:
      key = '\x1b[21~';
      break;
    // F11
    case 122:
      key = '\x1b[23~';
      break;
    // F12
    case 123:
      key = '\x1b[24~';
      break;
    default:
      // a-z and space
      if (ev.ctrlKey) {
        if (ev.keyCode >= 65 && ev.keyCode <= 90) {
          // Ctrl-A
          if (this.screenKeys) {
            if (!this.prefixMode && !this.selectMode && ev.keyCode === 65) {
              this.enterPrefix();
              return cancel(ev);
            }
          }
          // Ctrl-V
          if (this.prefixMode && ev.keyCode === 86) {
            this.leavePrefix();
            return;
          }
          // Ctrl-C
          if ((this.prefixMode || this.selectMode) && ev.keyCode === 67) {
            if (this.visualMode) {
              setTimeout(function() {
                self.leaveVisual();
              }, 1);
            }
            return;
          }
          key = String.fromCharCode(ev.keyCode - 64);
        } else if (ev.keyCode === 32) {
          // NUL
          key = String.fromCharCode(0);
        } else if (ev.keyCode >= 51 && ev.keyCode <= 55) {
          // escape, file sep, group sep, record sep, unit sep
          key = String.fromCharCode(ev.keyCode - 51 + 27);
        } else if (ev.keyCode === 56) {
          // delete
          key = String.fromCharCode(127);
        } else if (ev.keyCode === 219) {
          // ^[ - escape
          key = String.fromCharCode(27);
        } else if (ev.keyCode === 221) {
          // ^] - group sep
          key = String.fromCharCode(29);
        }
      } else if ((!this.isMac && ev.altKey) || (this.isMac && ev.metaKey)) {
        if (ev.keyCode >= 65 && ev.keyCode <= 90) {
          key = '\x1b' + String.fromCharCode(ev.keyCode + 32);
        } else if (ev.keyCode === 192) {
          key = '\x1b`';
        } else if (ev.keyCode >= 48 && ev.keyCode <= 57) {
          key = '\x1b' + (ev.keyCode - 48);
        }
      }
      break;
  }

  if (!key) return true;

  if (this.prefixMode) {
    this.leavePrefix();
    return cancel(ev);
  }

  if (this.selectMode) {
    this.keySelect(ev, key);
    return cancel(ev);
  }

  this.emit('keydown', ev);
  this.emit('key', key, ev);

  this.showCursor();
  this.handler(key);

  return cancel(ev);
};

Terminal.prototype.setgLevel = function(g) {
  this.glevel = g;
  this.charset = this.charsets[g];
};

Terminal.prototype.setgCharset = function(g, charset) {
  this.charsets[g] = charset;
  if (this.glevel === g) {
    this.charset = charset;
  }
};

Terminal.prototype.keyPress = function(ev) {
  var key;

  cancel(ev);

  if (ev.charCode) {
    key = ev.charCode;
  } else if (ev.which == null) {
    key = ev.keyCode;
  } else if (ev.which !== 0 && ev.charCode !== 0) {
    key = ev.which;
  } else {
    return false;
  }

  if (!key || ev.ctrlKey || ev.altKey || ev.metaKey) return false;

  key = String.fromCharCode(key);

  if (this.prefixMode) {
    this.leavePrefix();
    this.keyPrefix(ev, key);
    return false;
  }

  if (this.selectMode) {
    this.keySelect(ev, key);
    return false;
  }

  this.emit('keypress', key, ev);
  this.emit('key', key, ev);

  this.showCursor();
  this.handler(key);

  return false;
};

Terminal.prototype.send = function(data) {
  var self = this;

  if (!this.queue) {
    setTimeout(function() {
      self.handler(self.queue);
      self.queue = '';
    }, 1);
  }

  this.queue += data;
};

Terminal.prototype.bell = function() {
  if (!this.visualBell) return;
  var self = this;
  this.element.style.borderColor = 'white';
  setTimeout(function() {
    self.element.style.borderColor = '';
  }, 10);
  if (this.popOnBell) this.focus();
};

Terminal.prototype.log = function() {
  if (!this.debug) return;
  if (!this.context.console || !this.context.console.log) return;
  var args = Array.prototype.slice.call(arguments);
  this.context.console.log.apply(this.context.console, args);
};

Terminal.prototype.error = function() {
  if (!this.debug) return;
  if (!this.context.console || !this.context.console.error) return;
  var args = Array.prototype.slice.call(arguments);
  this.context.console.error.apply(this.context.console, args);
};

Terminal.prototype.resize = function(x, y) {
  var line
    , el
    , i
    , j
    , ch;

  if (x < 1) x = 1;
  if (y < 1) y = 1;

  // resize cols
  j = this.cols;
  if (j < x) {
    ch = [this.defAttr, ' ']; // does xterm use the default attr?
    i = this.lines.length;
    while (i--) {
      while (this.lines[i].length < x) {
        this.lines[i].push(ch);
      }
    }
  } else if (j > x) {
    i = this.lines.length;
    while (i--) {
      while (this.lines[i].length > x) {
        this.lines[i].pop();
      }
    }
  }
  this.setupStops(j);
  this.cols = x;

  // resize rows
  j = this.rows;
  if (j < y) {
    el = this.element;
    while (j++ < y) {
      if (this.lines.length < y + this.ybase) {
        this.lines.push(this.blankLine());
      }
      if (this.children.length < y) {
        line = this.document.createElement('div');
        el.appendChild(line);
        this.children.push(line);
      }
    }
  } else if (j > y) {
    while (j-- > y) {
      if (this.lines.length > y + this.ybase) {
        this.lines.pop();
      }
      if (this.children.length > y) {
        el = this.children.pop();
        if (!el) continue;
        el.parentNode.removeChild(el);
      }
    }
  }
  this.rows = y;

  // make sure the cursor stays on screen
  if (this.y >= y) this.y = y - 1;
  if (this.x >= x) this.x = x - 1;

  this.scrollTop = 0;
  this.scrollBottom = y - 1;

  this.refresh(0, this.rows - 1);

  // it's a real nightmare trying
  // to resize the original
  // screen buffer. just set it
  // to null for now.
  this.normal = null;
};

Terminal.prototype.updateRange = function(y) {
  if (y < this.refreshStart) this.refreshStart = y;
  if (y > this.refreshEnd) this.refreshEnd = y;
  // if (y > this.refreshEnd) {
  //   this.refreshEnd = y;
  //   if (y > this.rows - 1) {
  //     this.refreshEnd = this.rows - 1;
  //   }
  // }
};

Terminal.prototype.maxRange = function() {
  this.refreshStart = 0;
  this.refreshEnd = this.rows - 1;
};

Terminal.prototype.setupStops = function(i) {
  if (i != null) {
    if (!this.tabs[i]) {
      i = this.prevStop(i);
    }
  } else {
    this.tabs = {};
    i = 0;
  }

  for (; i < this.cols; i += 8) {
    this.tabs[i] = true;
  }
};

Terminal.prototype.prevStop = function(x) {
  if (x == null) x = this.x;
  while (!this.tabs[--x] && x > 0);
  return x >= this.cols
    ? this.cols - 1
    : x < 0 ? 0 : x;
};

Terminal.prototype.nextStop = function(x) {
  if (x == null) x = this.x;
  while (!this.tabs[++x] && x < this.cols);
  return x >= this.cols
    ? this.cols - 1
    : x < 0 ? 0 : x;
};

Terminal.prototype.eraseRight = function(x, y) {
  var line = this.lines[this.ybase + y]
    , ch = [this.eraseAttr(), ' ']; // xterm


  for (; x < this.cols; x++) {
    line[x] = ch;
  }

  this.updateRange(y);
};

Terminal.prototype.eraseLeft = function(x, y) {
  var line = this.lines[this.ybase + y]
    , ch = [this.eraseAttr(), ' ']; // xterm

  x++;
  while (x--) line[x] = ch;

  this.updateRange(y);
};

Terminal.prototype.eraseLine = function(y) {
  this.eraseRight(0, y);
};

Terminal.prototype.blankLine = function(cur) {
  var attr = cur
    ? this.eraseAttr()
    : this.defAttr;

  var ch = [attr, ' ']
    , line = []
    , i = 0;

  for (; i < this.cols; i++) {
    line[i] = ch;
  }

  return line;
};

Terminal.prototype.ch = function(cur) {
  return cur
    ? [this.eraseAttr(), ' ']
    : [this.defAttr, ' '];
};

Terminal.prototype.is = function(term) {
  var name = this.termName;
  return (name + '').indexOf(term) === 0;
};

Terminal.prototype.handler = function(data) {
  this.emit('data', data);
};

Terminal.prototype.handleTitle = function(title) {
  this.emit('title', title);
};

/**
 * ESC
 */

// ESC D Index (IND is 0x84).
Terminal.prototype.index = function() {
  this.y++;
  if (this.y > this.scrollBottom) {
    this.y--;
    this.scroll();
  }
  this.state = normal;
};

// ESC M Reverse Index (RI is 0x8d).
Terminal.prototype.reverseIndex = function() {
  var j;
  this.y--;
  if (this.y < this.scrollTop) {
    this.y++;
    // possibly move the code below to term.reverseScroll();
    // test: echo -ne '\e[1;1H\e[44m\eM\e[0m'
    // blankLine(true) is xterm/linux behavior
    this.lines.splice(this.y + this.ybase, 0, this.blankLine(true));
    j = this.rows - 1 - this.scrollBottom;
    this.lines.splice(this.rows - 1 + this.ybase - j + 1, 1);
    // this.maxRange();
    this.updateRange(this.scrollTop);
    this.updateRange(this.scrollBottom);
  }
  this.state = normal;
};

// ESC c Full Reset (RIS).
Terminal.prototype.reset = function() {
  this.options.rows = this.rows;
  this.options.cols = this.cols;
  Terminal.call(this, this.options);
  this.refresh(0, this.rows - 1);
};

// ESC H Tab Set (HTS is 0x88).
Terminal.prototype.tabSet = function() {
  this.tabs[this.x] = true;
  this.state = normal;
};

/**
 * CSI
 */

// CSI Ps A
// Cursor Up Ps Times (default = 1) (CUU).
Terminal.prototype.cursorUp = function(params) {
  var param = params[0];
  if (param < 1) param = 1;
  this.y -= param;
  if (this.y < 0) this.y = 0;
};

// CSI Ps B
// Cursor Down Ps Times (default = 1) (CUD).
Terminal.prototype.cursorDown = function(params) {
  var param = params[0];
  if (param < 1) param = 1;
  this.y += param;
  if (this.y >= this.rows) {
    this.y = this.rows - 1;
  }
};

// CSI Ps C
// Cursor Forward Ps Times (default = 1) (CUF).
Terminal.prototype.cursorForward = function(params) {
  var param = params[0];
  if (param < 1) param = 1;
  this.x += param;
  if (this.x >= this.cols) {
    this.x = this.cols - 1;
  }
};

// CSI Ps D
// Cursor Backward Ps Times (default = 1) (CUB).
Terminal.prototype.cursorBackward = function(params) {
  var param = params[0];
  if (param < 1) param = 1;
  this.x -= param;
  if (this.x < 0) this.x = 0;
};

// CSI Ps ; Ps H
// Cursor Position [row;column] (default = [1,1]) (CUP).
Terminal.prototype.cursorPos = function(params) {
  var row, col;

  row = params[0] - 1;

  if (params.length >= 2) {
    col = params[1] - 1;
  } else {
    col = 0;
  }

  if (row < 0) {
    row = 0;
  } else if (row >= this.rows) {
    row = this.rows - 1;
  }

  if (col < 0) {
    col = 0;
  } else if (col >= this.cols) {
    col = this.cols - 1;
  }

  this.x = col;
  this.y = row;
};

// CSI Ps J  Erase in Display (ED).
//     Ps = 0  -> Erase Below (default).
//     Ps = 1  -> Erase Above.
//     Ps = 2  -> Erase All.
//     Ps = 3  -> Erase Saved Lines (xterm).
// CSI ? Ps J
//   Erase in Display (DECSED).
//     Ps = 0  -> Selective Erase Below (default).
//     Ps = 1  -> Selective Erase Above.
//     Ps = 2  -> Selective Erase All.
Terminal.prototype.eraseInDisplay = function(params) {
  var j;
  switch (params[0]) {
    case 0:
      this.eraseRight(this.x, this.y);
      j = this.y + 1;
      for (; j < this.rows; j++) {
        this.eraseLine(j);
      }
      break;
    case 1:
      this.eraseLeft(this.x, this.y);
      j = this.y;
      while (j--) {
        this.eraseLine(j);
      }
      break;
    case 2:
      j = this.rows;
      while (j--) this.eraseLine(j);
      break;
    case 3:
      ; // no saved lines
      break;
  }
};

// CSI Ps K  Erase in Line (EL).
//     Ps = 0  -> Erase to Right (default).
//     Ps = 1  -> Erase to Left.
//     Ps = 2  -> Erase All.
// CSI ? Ps K
//   Erase in Line (DECSEL).
//     Ps = 0  -> Selective Erase to Right (default).
//     Ps = 1  -> Selective Erase to Left.
//     Ps = 2  -> Selective Erase All.
Terminal.prototype.eraseInLine = function(params) {
  switch (params[0]) {
    case 0:
      this.eraseRight(this.x, this.y);
      break;
    case 1:
      this.eraseLeft(this.x, this.y);
      break;
    case 2:
      this.eraseLine(this.y);
      break;
  }
};

// CSI Pm m  Character Attributes (SGR).
//     Ps = 0  -> Normal (default).
//     Ps = 1  -> Bold.
//     Ps = 4  -> Underlined.
//     Ps = 5  -> Blink (appears as Bold).
//     Ps = 7  -> Inverse.
//     Ps = 8  -> Invisible, i.e., hidden (VT300).
//     Ps = 2 2  -> Normal (neither bold nor faint).
//     Ps = 2 4  -> Not underlined.
//     Ps = 2 5  -> Steady (not blinking).
//     Ps = 2 7  -> Positive (not inverse).
//     Ps = 2 8  -> Visible, i.e., not hidden (VT300).
//     Ps = 3 0  -> Set foreground color to Black.
//     Ps = 3 1  -> Set foreground color to Red.
//     Ps = 3 2  -> Set foreground color to Green.
//     Ps = 3 3  -> Set foreground color to Yellow.
//     Ps = 3 4  -> Set foreground color to Blue.
//     Ps = 3 5  -> Set foreground color to Magenta.
//     Ps = 3 6  -> Set foreground color to Cyan.
//     Ps = 3 7  -> Set foreground color to White.
//     Ps = 3 9  -> Set foreground color to default (original).
//     Ps = 4 0  -> Set background color to Black.
//     Ps = 4 1  -> Set background color to Red.
//     Ps = 4 2  -> Set background color to Green.
//     Ps = 4 3  -> Set background color to Yellow.
//     Ps = 4 4  -> Set background color to Blue.
//     Ps = 4 5  -> Set background color to Magenta.
//     Ps = 4 6  -> Set background color to Cyan.
//     Ps = 4 7  -> Set background color to White.
//     Ps = 4 9  -> Set background color to default (original).

//   If 16-color support is compiled, the following apply.  Assume
//   that xterm's resources are set so that the ISO color codes are
//   the first 8 of a set of 16.  Then the aixterm colors are the
//   bright versions of the ISO colors:
//     Ps = 9 0  -> Set foreground color to Black.
//     Ps = 9 1  -> Set foreground color to Red.
//     Ps = 9 2  -> Set foreground color to Green.
//     Ps = 9 3  -> Set foreground color to Yellow.
//     Ps = 9 4  -> Set foreground color to Blue.
//     Ps = 9 5  -> Set foreground color to Magenta.
//     Ps = 9 6  -> Set foreground color to Cyan.
//     Ps = 9 7  -> Set foreground color to White.
//     Ps = 1 0 0  -> Set background color to Black.
//     Ps = 1 0 1  -> Set background color to Red.
//     Ps = 1 0 2  -> Set background color to Green.
//     Ps = 1 0 3  -> Set background color to Yellow.
//     Ps = 1 0 4  -> Set background color to Blue.
//     Ps = 1 0 5  -> Set background color to Magenta.
//     Ps = 1 0 6  -> Set background color to Cyan.
//     Ps = 1 0 7  -> Set background color to White.

//   If xterm is compiled with the 16-color support disabled, it
//   supports the following, from rxvt:
//     Ps = 1 0 0  -> Set foreground and background color to
//     default.

//   If 88- or 256-color support is compiled, the following apply.
//     Ps = 3 8  ; 5  ; Ps -> Set foreground color to the second
//     Ps.
//     Ps = 4 8  ; 5  ; Ps -> Set background color to the second
//     Ps.
Terminal.prototype.charAttributes = function(params) {
  // Optimize a single SGR0.
  if (params.length === 1 && params[0] === 0) {
    this.curAttr = this.defAttr;
    return;
  }

  var l = params.length
    , i = 0
    , flags = this.curAttr >> 18
    , fg = (this.curAttr >> 9) & 0x1ff
    , bg = this.curAttr & 0x1ff
    , p;

  for (; i < l; i++) {
    p = params[i];
    if (p >= 30 && p <= 37) {
      // fg color 8
      fg = p - 30;
    } else if (p >= 40 && p <= 47) {
      // bg color 8
      bg = p - 40;
    } else if (p >= 90 && p <= 97) {
      // fg color 16
      p += 8;
      fg = p - 90;
    } else if (p >= 100 && p <= 107) {
      // bg color 16
      p += 8;
      bg = p - 100;
    } else if (p === 0) {
      // default
      flags = this.defAttr >> 18;
      fg = (this.defAttr >> 9) & 0x1ff;
      bg = this.defAttr & 0x1ff;
      // flags = 0;
      // fg = 0x1ff;
      // bg = 0x1ff;
    } else if (p === 1) {
      // bold text
      flags |= 1;
    } else if (p === 4) {
      // underlined text
      flags |= 2;
    } else if (p === 5) {
      // blink
      flags |= 4;
    } else if (p === 7) {
      // inverse and positive
      // test with: echo -e '\e[31m\e[42mhello\e[7mworld\e[27mhi\e[m'
      flags |= 8;
    } else if (p === 8) {
      // invisible
      flags |= 16;
    } else if (p === 22) {
      // not bold
      flags &= ~1;
    } else if (p === 24) {
      // not underlined
      flags &= ~2;
    } else if (p === 25) {
      // not blink
      flags &= ~4;
    } else if (p === 27) {
      // not inverse
      flags &= ~8;
    } else if (p === 28) {
      // not invisible
      flags &= ~16;
    } else if (p === 39) {
      // reset fg
      fg = (this.defAttr >> 9) & 0x1ff;
    } else if (p === 49) {
      // reset bg
      bg = this.defAttr & 0x1ff;
    } else if (p === 38) {
      // fg color 256
      if (params[i + 1] === 2) {
        i += 2;
        fg = matchColor(
          params[i] & 0xff,
          params[i + 1] & 0xff,
          params[i + 2] & 0xff);
        if (fg === -1) fg = 0x1ff;
        i += 2;
      } else if (params[i + 1] === 5) {
        i += 2;
        p = params[i] & 0xff;
        fg = p;
      }
    } else if (p === 48) {
      // bg color 256
      if (params[i + 1] === 2) {
        i += 2;
        bg = matchColor(
          params[i] & 0xff,
          params[i + 1] & 0xff,
          params[i + 2] & 0xff);
        if (bg === -1) bg = 0x1ff;
        i += 2;
      } else if (params[i + 1] === 5) {
        i += 2;
        p = params[i] & 0xff;
        bg = p;
      }
    } else if (p === 100) {
      // reset fg/bg
      fg = (this.defAttr >> 9) & 0x1ff;
      bg = this.defAttr & 0x1ff;
    } else {
      this.error('Unknown SGR attribute: %d.', p);
    }
  }

  this.curAttr = (flags << 18) | (fg << 9) | bg;
};

// CSI Ps n  Device Status Report (DSR).
//     Ps = 5  -> Status Report.  Result (``OK'') is
//   CSI 0 n
//     Ps = 6  -> Report Cursor Position (CPR) [row;column].
//   Result is
//   CSI r ; c R
// CSI ? Ps n
//   Device Status Report (DSR, DEC-specific).
//     Ps = 6  -> Report Cursor Position (CPR) [row;column] as CSI
//     ? r ; c R (assumes page is zero).
//     Ps = 1 5  -> Report Printer status as CSI ? 1 0  n  (ready).
//     or CSI ? 1 1  n  (not ready).
//     Ps = 2 5  -> Report UDK status as CSI ? 2 0  n  (unlocked)
//     or CSI ? 2 1  n  (locked).
//     Ps = 2 6  -> Report Keyboard status as
//   CSI ? 2 7  ;  1  ;  0  ;  0  n  (North American).
//   The last two parameters apply to VT400 & up, and denote key-
//   board ready and LK01 respectively.
//     Ps = 5 3  -> Report Locator status as
//   CSI ? 5 3  n  Locator available, if compiled-in, or
//   CSI ? 5 0  n  No Locator, if not.
Terminal.prototype.deviceStatus = function(params) {
  if (!this.prefix) {
    switch (params[0]) {
      case 5:
        // status report
        this.send('\x1b[0n');
        break;
      case 6:
        // cursor position
        this.send('\x1b['
          + (this.y + 1)
          + ';'
          + (this.x + 1)
          + 'R');
        break;
    }
  } else if (this.prefix === '?') {
    // modern xterm doesnt seem to
    // respond to any of these except ?6, 6, and 5
    switch (params[0]) {
      case 6:
        // cursor position
        this.send('\x1b[?'
          + (this.y + 1)
          + ';'
          + (this.x + 1)
          + 'R');
        break;
      case 15:
        // no printer
        // this.send('\x1b[?11n');
        break;
      case 25:
        // dont support user defined keys
        // this.send('\x1b[?21n');
        break;
      case 26:
        // north american keyboard
        // this.send('\x1b[?27;1;0;0n');
        break;
      case 53:
        // no dec locator/mouse
        // this.send('\x1b[?50n');
        break;
    }
  }
};

/**
 * Additions
 */

// CSI Ps @
// Insert Ps (Blank) Character(s) (default = 1) (ICH).
Terminal.prototype.insertChars = function(params) {
  var param, row, j, ch;

  param = params[0];
  if (param < 1) param = 1;

  row = this.y + this.ybase;
  j = this.x;
  ch = [this.eraseAttr(), ' ']; // xterm

  while (param-- && j < this.cols) {
    this.lines[row].splice(j++, 0, ch);
    this.lines[row].pop();
  }
};

// CSI Ps E
// Cursor Next Line Ps Times (default = 1) (CNL).
// same as CSI Ps B ?
Terminal.prototype.cursorNextLine = function(params) {
  var param = params[0];
  if (param < 1) param = 1;
  this.y += param;
  if (this.y >= this.rows) {
    this.y = this.rows - 1;
  }
  this.x = 0;
};

// CSI Ps F
// Cursor Preceding Line Ps Times (default = 1) (CNL).
// reuse CSI Ps A ?
Terminal.prototype.cursorPrecedingLine = function(params) {
  var param = params[0];
  if (param < 1) param = 1;
  this.y -= param;
  if (this.y < 0) this.y = 0;
  this.x = 0;
};

// CSI Ps G
// Cursor Character Absolute  [column] (default = [row,1]) (CHA).
Terminal.prototype.cursorCharAbsolute = function(params) {
  var param = params[0];
  if (param < 1) param = 1;
  this.x = param - 1;
};

// CSI Ps L
// Insert Ps Line(s) (default = 1) (IL).
Terminal.prototype.insertLines = function(params) {
  var param, row, j;

  param = params[0];
  if (param < 1) param = 1;
  row = this.y + this.ybase;

  j = this.rows - 1 - this.scrollBottom;
  j = this.rows - 1 + this.ybase - j + 1;

  while (param--) {
    // test: echo -e '\e[44m\e[1L\e[0m'
    // blankLine(true) - xterm/linux behavior
    this.lines.splice(row, 0, this.blankLine(true));
    this.lines.splice(j, 1);
  }

  // this.maxRange();
  this.updateRange(this.y);
  this.updateRange(this.scrollBottom);
};

// CSI Ps M
// Delete Ps Line(s) (default = 1) (DL).
Terminal.prototype.deleteLines = function(params) {
  var param, row, j;

  param = params[0];
  if (param < 1) param = 1;
  row = this.y + this.ybase;

  j = this.rows - 1 - this.scrollBottom;
  j = this.rows - 1 + this.ybase - j;

  while (param--) {
    // test: echo -e '\e[44m\e[1M\e[0m'
    // blankLine(true) - xterm/linux behavior
    this.lines.splice(j + 1, 0, this.blankLine(true));
    this.lines.splice(row, 1);
  }

  // this.maxRange();
  this.updateRange(this.y);
  this.updateRange(this.scrollBottom);
};

// CSI Ps P
// Delete Ps Character(s) (default = 1) (DCH).
Terminal.prototype.deleteChars = function(params) {
  var param, row, ch;

  param = params[0];
  if (param < 1) param = 1;

  row = this.y + this.ybase;
  ch = [this.eraseAttr(), ' ']; // xterm

  while (param--) {
    this.lines[row].splice(this.x, 1);
    this.lines[row].push(ch);
  }
};

// CSI Ps X
// Erase Ps Character(s) (default = 1) (ECH).
Terminal.prototype.eraseChars = function(params) {
  var param, row, j, ch;

  param = params[0];
  if (param < 1) param = 1;

  row = this.y + this.ybase;
  j = this.x;
  ch = [this.eraseAttr(), ' ']; // xterm

  while (param-- && j < this.cols) {
    this.lines[row][j++] = ch;
  }
};

// CSI Pm `  Character Position Absolute
//   [column] (default = [row,1]) (HPA).
Terminal.prototype.charPosAbsolute = function(params) {
  var param = params[0];
  if (param < 1) param = 1;
  this.x = param - 1;
  if (this.x >= this.cols) {
    this.x = this.cols - 1;
  }
};

// 141 61 a * HPR -
// Horizontal Position Relative
// reuse CSI Ps C ?
Terminal.prototype.HPositionRelative = function(params) {
  var param = params[0];
  if (param < 1) param = 1;
  this.x += param;
  if (this.x >= this.cols) {
    this.x = this.cols - 1;
  }
};

// CSI Ps c  Send Device Attributes (Primary DA).
//     Ps = 0  or omitted -> request attributes from terminal.  The
//     response depends on the decTerminalID resource setting.
//     -> CSI ? 1 ; 2 c  (``VT100 with Advanced Video Option'')
//     -> CSI ? 1 ; 0 c  (``VT101 with No Options'')
//     -> CSI ? 6 c  (``VT102'')
//     -> CSI ? 6 0 ; 1 ; 2 ; 6 ; 8 ; 9 ; 1 5 ; c  (``VT220'')
//   The VT100-style response parameters do not mean anything by
//   themselves.  VT220 parameters do, telling the host what fea-
//   tures the terminal supports:
//     Ps = 1  -> 132-columns.
//     Ps = 2  -> Printer.
//     Ps = 6  -> Selective erase.
//     Ps = 8  -> User-defined keys.
//     Ps = 9  -> National replacement character sets.
//     Ps = 1 5  -> Technical characters.
//     Ps = 2 2  -> ANSI color, e.g., VT525.
//     Ps = 2 9  -> ANSI text locator (i.e., DEC Locator mode).
// CSI > Ps c
//   Send Device Attributes (Secondary DA).
//     Ps = 0  or omitted -> request the terminal's identification
//     code.  The response depends on the decTerminalID resource set-
//     ting.  It should apply only to VT220 and up, but xterm extends
//     this to VT100.
//     -> CSI  > Pp ; Pv ; Pc c
//   where Pp denotes the terminal type
//     Pp = 0  -> ``VT100''.
//     Pp = 1  -> ``VT220''.
//   and Pv is the firmware version (for xterm, this was originally
//   the XFree86 patch number, starting with 95).  In a DEC termi-
//   nal, Pc indicates the ROM cartridge registration number and is
//   always zero.
// More information:
//   xterm/charproc.c - line 2012, for more information.
//   vim responds with ^[[?0c or ^[[?1c after the terminal's response (?)
Terminal.prototype.sendDeviceAttributes = function(params) {
  if (params[0] > 0) return;

  if (!this.prefix) {
    if (this.is('xterm')
        || this.is('rxvt-unicode')
        || this.is('screen')) {
      this.send('\x1b[?1;2c');
    } else if (this.is('linux')) {
      this.send('\x1b[?6c');
    }
  } else if (this.prefix === '>') {
    // xterm and urxvt
    // seem to spit this
    // out around ~370 times (?).
    if (this.is('xterm')) {
      this.send('\x1b[>0;276;0c');
    } else if (this.is('rxvt-unicode')) {
      this.send('\x1b[>85;95;0c');
    } else if (this.is('linux')) {
      // not supported by linux console.
      // linux console echoes parameters.
      this.send(params[0] + 'c');
    } else if (this.is('screen')) {
      this.send('\x1b[>83;40003;0c');
    }
  }
};

// CSI Pm d
// Line Position Absolute  [row] (default = [1,column]) (VPA).
Terminal.prototype.linePosAbsolute = function(params) {
  var param = params[0];
  if (param < 1) param = 1;
  this.y = param - 1;
  if (this.y >= this.rows) {
    this.y = this.rows - 1;
  }
};

// 145 65 e * VPR - Vertical Position Relative
// reuse CSI Ps B ?
Terminal.prototype.VPositionRelative = function(params) {
  var param = params[0];
  if (param < 1) param = 1;
  this.y += param;
  if (this.y >= this.rows) {
    this.y = this.rows - 1;
  }
};

// CSI Ps ; Ps f
//   Horizontal and Vertical Position [row;column] (default =
//   [1,1]) (HVP).
Terminal.prototype.HVPosition = function(params) {
  if (params[0] < 1) params[0] = 1;
  if (params[1] < 1) params[1] = 1;

  this.y = params[0] - 1;
  if (this.y >= this.rows) {
    this.y = this.rows - 1;
  }

  this.x = params[1] - 1;
  if (this.x >= this.cols) {
    this.x = this.cols - 1;
  }
};

// CSI Pm h  Set Mode (SM).
//     Ps = 2  -> Keyboard Action Mode (AM).
//     Ps = 4  -> Insert Mode (IRM).
//     Ps = 1 2  -> Send/receive (SRM).
//     Ps = 2 0  -> Automatic Newline (LNM).
// CSI ? Pm h
//   DEC Private Mode Set (DECSET).
//     Ps = 1  -> Application Cursor Keys (DECCKM).
//     Ps = 2  -> Designate USASCII for character sets G0-G3
//     (DECANM), and set VT100 mode.
//     Ps = 3  -> 132 Column Mode (DECCOLM).
//     Ps = 4  -> Smooth (Slow) Scroll (DECSCLM).
//     Ps = 5  -> Reverse Video (DECSCNM).
//     Ps = 6  -> Origin Mode (DECOM).
//     Ps = 7  -> Wraparound Mode (DECAWM).
//     Ps = 8  -> Auto-repeat Keys (DECARM).
//     Ps = 9  -> Send Mouse X & Y on button press.  See the sec-
//     tion Mouse Tracking.
//     Ps = 1 0  -> Show toolbar (rxvt).
//     Ps = 1 2  -> Start Blinking Cursor (att610).
//     Ps = 1 8  -> Print form feed (DECPFF).
//     Ps = 1 9  -> Set print extent to full screen (DECPEX).
//     Ps = 2 5  -> Show Cursor (DECTCEM).
//     Ps = 3 0  -> Show scrollbar (rxvt).
//     Ps = 3 5  -> Enable font-shifting functions (rxvt).
//     Ps = 3 8  -> Enter Tektronix Mode (DECTEK).
//     Ps = 4 0  -> Allow 80 -> 132 Mode.
//     Ps = 4 1  -> more(1) fix (see curses resource).
//     Ps = 4 2  -> Enable Nation Replacement Character sets (DECN-
//     RCM).
//     Ps = 4 4  -> Turn On Margin Bell.
//     Ps = 4 5  -> Reverse-wraparound Mode.
//     Ps = 4 6  -> Start Logging.  This is normally disabled by a
//     compile-time option.
//     Ps = 4 7  -> Use Alternate Screen Buffer.  (This may be dis-
//     abled by the titeInhibit resource).
//     Ps = 6 6  -> Application keypad (DECNKM).
//     Ps = 6 7  -> Backarrow key sends backspace (DECBKM).
//     Ps = 1 0 0 0  -> Send Mouse X & Y on button press and
//     release.  See the section Mouse Tracking.
//     Ps = 1 0 0 1  -> Use Hilite Mouse Tracking.
//     Ps = 1 0 0 2  -> Use Cell Motion Mouse Tracking.
//     Ps = 1 0 0 3  -> Use All Motion Mouse Tracking.
//     Ps = 1 0 0 4  -> Send FocusIn/FocusOut events.
//     Ps = 1 0 0 5  -> Enable Extended Mouse Mode.
//     Ps = 1 0 1 0  -> Scroll to bottom on tty output (rxvt).
//     Ps = 1 0 1 1  -> Scroll to bottom on key press (rxvt).
//     Ps = 1 0 3 4  -> Interpret "meta" key, sets eighth bit.
//     (enables the eightBitInput resource).
//     Ps = 1 0 3 5  -> Enable special modifiers for Alt and Num-
//     Lock keys.  (This enables the numLock resource).
//     Ps = 1 0 3 6  -> Send ESC   when Meta modifies a key.  (This
//     enables the metaSendsEscape resource).
//     Ps = 1 0 3 7  -> Send DEL from the editing-keypad Delete
//     key.
//     Ps = 1 0 3 9  -> Send ESC  when Alt modifies a key.  (This
//     enables the altSendsEscape resource).
//     Ps = 1 0 4 0  -> Keep selection even if not highlighted.
//     (This enables the keepSelection resource).
//     Ps = 1 0 4 1  -> Use the CLIPBOARD selection.  (This enables
//     the selectToClipboard resource).
//     Ps = 1 0 4 2  -> Enable Urgency window manager hint when
//     Control-G is received.  (This enables the bellIsUrgent
//     resource).
//     Ps = 1 0 4 3  -> Enable raising of the window when Control-G
//     is received.  (enables the popOnBell resource).
//     Ps = 1 0 4 7  -> Use Alternate Screen Buffer.  (This may be
//     disabled by the titeInhibit resource).
//     Ps = 1 0 4 8  -> Save cursor as in DECSC.  (This may be dis-
//     abled by the titeInhibit resource).
//     Ps = 1 0 4 9  -> Save cursor as in DECSC and use Alternate
//     Screen Buffer, clearing it first.  (This may be disabled by
//     the titeInhibit resource).  This combines the effects of the 1
//     0 4 7  and 1 0 4 8  modes.  Use this with terminfo-based
//     applications rather than the 4 7  mode.
//     Ps = 1 0 5 0  -> Set terminfo/termcap function-key mode.
//     Ps = 1 0 5 1  -> Set Sun function-key mode.
//     Ps = 1 0 5 2  -> Set HP function-key mode.
//     Ps = 1 0 5 3  -> Set SCO function-key mode.
//     Ps = 1 0 6 0  -> Set legacy keyboard emulation (X11R6).
//     Ps = 1 0 6 1  -> Set VT220 keyboard emulation.
//     Ps = 2 0 0 4  -> Set bracketed paste mode.
// Modes:
//   http://vt100.net/docs/vt220-rm/chapter4.html
Terminal.prototype.setMode = function(params) {
  if (typeof params === 'object') {
    var l = params.length
      , i = 0;

    for (; i < l; i++) {
      this.setMode(params[i]);
    }

    return;
  }

  if (!this.prefix) {
    switch (params) {
      case 4:
        this.insertMode = true;
        break;
      case 20:
        //this.convertEol = true;
        break;
    }
  } else if (this.prefix === '?') {
    switch (params) {
      case 1:
        this.applicationCursor = true;
        break;
      case 2:
        this.setgCharset(0, Terminal.charsets.US);
        this.setgCharset(1, Terminal.charsets.US);
        this.setgCharset(2, Terminal.charsets.US);
        this.setgCharset(3, Terminal.charsets.US);
        // set VT100 mode here
        break;
      case 3: // 132 col mode
        this.savedCols = this.cols;
        this.resize(132, this.rows);
        break;
      case 6:
        this.originMode = true;
        break;
      case 7:
        this.wraparoundMode = true;
        break;
      case 12:
        // this.cursorBlink = true;
        break;
      case 66:
        this.log('Serial port requested application keypad.');
        this.applicationKeypad = true;
        break;
      case 9: // X10 Mouse
        // no release, no motion, no wheel, no modifiers.
      case 1000: // vt200 mouse
        // no motion.
        // no modifiers, except control on the wheel.
      case 1002: // button event mouse
      case 1003: // any event mouse
        // any event - sends motion events,
        // even if there is no button held down.
        this.x10Mouse = params === 9;
        this.vt200Mouse = params === 1000;
        this.normalMouse = params > 1000;
        this.mouseEvents = true;
        this.element.style.cursor = 'default';
        this.log('Binding to mouse events.');
        break;
      case 1004: // send focusin/focusout events
        // focusin: ^[[I
        // focusout: ^[[O
        this.sendFocus = true;
        break;
      case 1005: // utf8 ext mode mouse
        this.utfMouse = true;
        // for wide terminals
        // simply encodes large values as utf8 characters
        break;
      case 1006: // sgr ext mode mouse
        this.sgrMouse = true;
        // for wide terminals
        // does not add 32 to fields
        // press: ^[[<b;x;yM
        // release: ^[[<b;x;ym
        break;
      case 1015: // urxvt ext mode mouse
        this.urxvtMouse = true;
        // for wide terminals
        // numbers for fields
        // press: ^[[b;x;yM
        // motion: ^[[b;x;yT
        break;
      case 25: // show cursor
        this.cursorHidden = false;
        break;
      case 1049: // alt screen buffer cursor
        //this.saveCursor();
        ; // FALL-THROUGH
      case 47: // alt screen buffer
      case 1047: // alt screen buffer
        if (!this.normal) {
          var normal = {
            lines: this.lines,
            ybase: this.ybase,
            ydisp: this.ydisp,
            x: this.x,
            y: this.y,
            scrollTop: this.scrollTop,
            scrollBottom: this.scrollBottom,
            tabs: this.tabs
            // XXX save charset(s) here?
            // charset: this.charset,
            // glevel: this.glevel,
            // charsets: this.charsets
          };
          this.reset();
          this.normal = normal;
          this.showCursor();
        }
        break;
    }
  }
};

// CSI Pm l  Reset Mode (RM).
//     Ps = 2  -> Keyboard Action Mode (AM).
//     Ps = 4  -> Replace Mode (IRM).
//     Ps = 1 2  -> Send/receive (SRM).
//     Ps = 2 0  -> Normal Linefeed (LNM).
// CSI ? Pm l
//   DEC Private Mode Reset (DECRST).
//     Ps = 1  -> Normal Cursor Keys (DECCKM).
//     Ps = 2  -> Designate VT52 mode (DECANM).
//     Ps = 3  -> 80 Column Mode (DECCOLM).
//     Ps = 4  -> Jump (Fast) Scroll (DECSCLM).
//     Ps = 5  -> Normal Video (DECSCNM).
//     Ps = 6  -> Normal Cursor Mode (DECOM).
//     Ps = 7  -> No Wraparound Mode (DECAWM).
//     Ps = 8  -> No Auto-repeat Keys (DECARM).
//     Ps = 9  -> Don't send Mouse X & Y on button press.
//     Ps = 1 0  -> Hide toolbar (rxvt).
//     Ps = 1 2  -> Stop Blinking Cursor (att610).
//     Ps = 1 8  -> Don't print form feed (DECPFF).
//     Ps = 1 9  -> Limit print to scrolling region (DECPEX).
//     Ps = 2 5  -> Hide Cursor (DECTCEM).
//     Ps = 3 0  -> Don't show scrollbar (rxvt).
//     Ps = 3 5  -> Disable font-shifting functions (rxvt).
//     Ps = 4 0  -> Disallow 80 -> 132 Mode.
//     Ps = 4 1  -> No more(1) fix (see curses resource).
//     Ps = 4 2  -> Disable Nation Replacement Character sets (DEC-
//     NRCM).
//     Ps = 4 4  -> Turn Off Margin Bell.
//     Ps = 4 5  -> No Reverse-wraparound Mode.
//     Ps = 4 6  -> Stop Logging.  (This is normally disabled by a
//     compile-time option).
//     Ps = 4 7  -> Use Normal Screen Buffer.
//     Ps = 6 6  -> Numeric keypad (DECNKM).
//     Ps = 6 7  -> Backarrow key sends delete (DECBKM).
//     Ps = 1 0 0 0  -> Don't send Mouse X & Y on button press and
//     release.  See the section Mouse Tracking.
//     Ps = 1 0 0 1  -> Don't use Hilite Mouse Tracking.
//     Ps = 1 0 0 2  -> Don't use Cell Motion Mouse Tracking.
//     Ps = 1 0 0 3  -> Don't use All Motion Mouse Tracking.
//     Ps = 1 0 0 4  -> Don't send FocusIn/FocusOut events.
//     Ps = 1 0 0 5  -> Disable Extended Mouse Mode.
//     Ps = 1 0 1 0  -> Don't scroll to bottom on tty output
//     (rxvt).
//     Ps = 1 0 1 1  -> Don't scroll to bottom on key press (rxvt).
//     Ps = 1 0 3 4  -> Don't interpret "meta" key.  (This disables
//     the eightBitInput resource).
//     Ps = 1 0 3 5  -> Disable special modifiers for Alt and Num-
//     Lock keys.  (This disables the numLock resource).
//     Ps = 1 0 3 6  -> Don't send ESC  when Meta modifies a key.
//     (This disables the metaSendsEscape resource).
//     Ps = 1 0 3 7  -> Send VT220 Remove from the editing-keypad
//     Delete key.
//     Ps = 1 0 3 9  -> Don't send ESC  when Alt modifies a key.
//     (This disables the altSendsEscape resource).
//     Ps = 1 0 4 0  -> Do not keep selection when not highlighted.
//     (This disables the keepSelection resource).
//     Ps = 1 0 4 1  -> Use the PRIMARY selection.  (This disables
//     the selectToClipboard resource).
//     Ps = 1 0 4 2  -> Disable Urgency window manager hint when
//     Control-G is received.  (This disables the bellIsUrgent
//     resource).
//     Ps = 1 0 4 3  -> Disable raising of the window when Control-
//     G is received.  (This disables the popOnBell resource).
//     Ps = 1 0 4 7  -> Use Normal Screen Buffer, clearing screen
//     first if in the Alternate Screen.  (This may be disabled by
//     the titeInhibit resource).
//     Ps = 1 0 4 8  -> Restore cursor as in DECRC.  (This may be
//     disabled by the titeInhibit resource).
//     Ps = 1 0 4 9  -> Use Normal Screen Buffer and restore cursor
//     as in DECRC.  (This may be disabled by the titeInhibit
//     resource).  This combines the effects of the 1 0 4 7  and 1 0
//     4 8  modes.  Use this with terminfo-based applications rather
//     than the 4 7  mode.
//     Ps = 1 0 5 0  -> Reset terminfo/termcap function-key mode.
//     Ps = 1 0 5 1  -> Reset Sun function-key mode.
//     Ps = 1 0 5 2  -> Reset HP function-key mode.
//     Ps = 1 0 5 3  -> Reset SCO function-key mode.
//     Ps = 1 0 6 0  -> Reset legacy keyboard emulation (X11R6).
//     Ps = 1 0 6 1  -> Reset keyboard emulation to Sun/PC style.
//     Ps = 2 0 0 4  -> Reset bracketed paste mode.
Terminal.prototype.resetMode = function(params) {
  if (typeof params === 'object') {
    var l = params.length
      , i = 0;

    for (; i < l; i++) {
      this.resetMode(params[i]);
    }

    return;
  }

  if (!this.prefix) {
    switch (params) {
      case 4:
        this.insertMode = false;
        break;
      case 20:
        //this.convertEol = false;
        break;
    }
  } else if (this.prefix === '?') {
    switch (params) {
      case 1:
        this.applicationCursor = false;
        break;
      case 3:
        if (this.cols === 132 && this.savedCols) {
          this.resize(this.savedCols, this.rows);
        }
        delete this.savedCols;
        break;
      case 6:
        this.originMode = false;
        break;
      case 7:
        this.wraparoundMode = false;
        break;
      case 12:
        // this.cursorBlink = false;
        break;
      case 66:
        this.log('Switching back to normal keypad.');
        this.applicationKeypad = false;
        break;
      case 9: // X10 Mouse
      case 1000: // vt200 mouse
      case 1002: // button event mouse
      case 1003: // any event mouse
        this.x10Mouse = false;
        this.vt200Mouse = false;
        this.normalMouse = false;
        this.mouseEvents = false;
        this.element.style.cursor = '';
        break;
      case 1004: // send focusin/focusout events
        this.sendFocus = false;
        break;
      case 1005: // utf8 ext mode mouse
        this.utfMouse = false;
        break;
      case 1006: // sgr ext mode mouse
        this.sgrMouse = false;
        break;
      case 1015: // urxvt ext mode mouse
        this.urxvtMouse = false;
        break;
      case 25: // hide cursor
        this.cursorHidden = true;
        break;
      case 1049: // alt screen buffer cursor
        ; // FALL-THROUGH
      case 47: // normal screen buffer
      case 1047: // normal screen buffer - clearing it first
        if (this.normal) {
          this.lines = this.normal.lines;
          this.ybase = this.normal.ybase;
          this.ydisp = this.normal.ydisp;
          this.x = this.normal.x;
          this.y = this.normal.y;
          this.scrollTop = this.normal.scrollTop;
          this.scrollBottom = this.normal.scrollBottom;
          this.tabs = this.normal.tabs;
          this.normal = null;
          // if (params === 1049) {
          //   this.x = this.savedX;
          //   this.y = this.savedY;
          // }
          this.refresh(0, this.rows - 1);
          this.showCursor();
        }
        break;
    }
  }
};

// CSI Ps ; Ps r
//   Set Scrolling Region [top;bottom] (default = full size of win-
//   dow) (DECSTBM).
// CSI ? Pm r
Terminal.prototype.setScrollRegion = function(params) {
  if (this.prefix) return;
  this.scrollTop = (params[0] || 1) - 1;
  this.scrollBottom = (params[1] || this.rows) - 1;
  this.x = 0;
  this.y = 0;
};

// CSI s
//   Save cursor (ANSI.SYS).
Terminal.prototype.saveCursor = function(params) {
  this.savedX = this.x;
  this.savedY = this.y;
};

// CSI u
//   Restore cursor (ANSI.SYS).
Terminal.prototype.restoreCursor = function(params) {
  this.x = this.savedX || 0;
  this.y = this.savedY || 0;
};

/**
 * Lesser Used
 */

// CSI Ps I
//   Cursor Forward Tabulation Ps tab stops (default = 1) (CHT).
Terminal.prototype.cursorForwardTab = function(params) {
  var param = params[0] || 1;
  while (param--) {
    this.x = this.nextStop();
  }
};

// CSI Ps S  Scroll up Ps lines (default = 1) (SU).
Terminal.prototype.scrollUp = function(params) {
  var param = params[0] || 1;
  while (param--) {
    this.lines.splice(this.ybase + this.scrollTop, 1);
    this.lines.splice(this.ybase + this.scrollBottom, 0, this.blankLine());
  }
  // this.maxRange();
  this.updateRange(this.scrollTop);
  this.updateRange(this.scrollBottom);
};

// CSI Ps T  Scroll down Ps lines (default = 1) (SD).
Terminal.prototype.scrollDown = function(params) {
  var param = params[0] || 1;
  while (param--) {
    this.lines.splice(this.ybase + this.scrollBottom, 1);
    this.lines.splice(this.ybase + this.scrollTop, 0, this.blankLine());
  }
  // this.maxRange();
  this.updateRange(this.scrollTop);
  this.updateRange(this.scrollBottom);
};

// CSI Ps ; Ps ; Ps ; Ps ; Ps T
//   Initiate highlight mouse tracking.  Parameters are
//   [func;startx;starty;firstrow;lastrow].  See the section Mouse
//   Tracking.
Terminal.prototype.initMouseTracking = function(params) {
  // Relevant: DECSET 1001
};

// CSI > Ps; Ps T
//   Reset one or more features of the title modes to the default
//   value.  Normally, "reset" disables the feature.  It is possi-
//   ble to disable the ability to reset features by compiling a
//   different default for the title modes into xterm.
//     Ps = 0  -> Do not set window/icon labels using hexadecimal.
//     Ps = 1  -> Do not query window/icon labels using hexadeci-
//     mal.
//     Ps = 2  -> Do not set window/icon labels using UTF-8.
//     Ps = 3  -> Do not query window/icon labels using UTF-8.
//   (See discussion of "Title Modes").
Terminal.prototype.resetTitleModes = function(params) {
  ;
};

// CSI Ps Z  Cursor Backward Tabulation Ps tab stops (default = 1) (CBT).
Terminal.prototype.cursorBackwardTab = function(params) {
  var param = params[0] || 1;
  while (param--) {
    this.x = this.prevStop();
  }
};

// CSI Ps b  Repeat the preceding graphic character Ps times (REP).
Terminal.prototype.repeatPrecedingCharacter = function(params) {
  var param = params[0] || 1
    , line = this.lines[this.ybase + this.y]
    , ch = line[this.x - 1] || [this.defAttr, ' '];

  while (param--) line[this.x++] = ch;
};

// CSI Ps g  Tab Clear (TBC).
//     Ps = 0  -> Clear Current Column (default).
//     Ps = 3  -> Clear All.
// Potentially:
//   Ps = 2  -> Clear Stops on Line.
//   http://vt100.net/annarbor/aaa-ug/section6.html
Terminal.prototype.tabClear = function(params) {
  var param = params[0];
  if (param <= 0) {
    delete this.tabs[this.x];
  } else if (param === 3) {
    this.tabs = {};
  }
};

// CSI Pm i  Media Copy (MC).
//     Ps = 0  -> Print screen (default).
//     Ps = 4  -> Turn off printer controller mode.
//     Ps = 5  -> Turn on printer controller mode.
// CSI ? Pm i
//   Media Copy (MC, DEC-specific).
//     Ps = 1  -> Print line containing cursor.
//     Ps = 4  -> Turn off autoprint mode.
//     Ps = 5  -> Turn on autoprint mode.
//     Ps = 1  0  -> Print composed display, ignores DECPEX.
//     Ps = 1  1  -> Print all pages.
Terminal.prototype.mediaCopy = function(params) {
  ;
};

// CSI > Ps; Ps m
//   Set or reset resource-values used by xterm to decide whether
//   to construct escape sequences holding information about the
//   modifiers pressed with a given key.  The first parameter iden-
//   tifies the resource to set/reset.  The second parameter is the
//   value to assign to the resource.  If the second parameter is
//   omitted, the resource is reset to its initial value.
//     Ps = 1  -> modifyCursorKeys.
//     Ps = 2  -> modifyFunctionKeys.
//     Ps = 4  -> modifyOtherKeys.
//   If no parameters are given, all resources are reset to their
//   initial values.
Terminal.prototype.setResources = function(params) {
  ;
};

// CSI > Ps n
//   Disable modifiers which may be enabled via the CSI > Ps; Ps m
//   sequence.  This corresponds to a resource value of "-1", which
//   cannot be set with the other sequence.  The parameter identi-
//   fies the resource to be disabled:
//     Ps = 1  -> modifyCursorKeys.
//     Ps = 2  -> modifyFunctionKeys.
//     Ps = 4  -> modifyOtherKeys.
//   If the parameter is omitted, modifyFunctionKeys is disabled.
//   When modifyFunctionKeys is disabled, xterm uses the modifier
//   keys to make an extended sequence of functions rather than
//   adding a parameter to each function key to denote the modi-
//   fiers.
Terminal.prototype.disableModifiers = function(params) {
  ;
};

// CSI > Ps p
//   Set resource value pointerMode.  This is used by xterm to
//   decide whether to hide the pointer cursor as the user types.
//   Valid values for the parameter:
//     Ps = 0  -> never hide the pointer.
//     Ps = 1  -> hide if the mouse tracking mode is not enabled.
//     Ps = 2  -> always hide the pointer.  If no parameter is
//     given, xterm uses the default, which is 1 .
Terminal.prototype.setPointerMode = function(params) {
  ;
};

// CSI ! p   Soft terminal reset (DECSTR).
// http://vt100.net/docs/vt220-rm/table4-10.html
Terminal.prototype.softReset = function(params) {
  this.cursorHidden = false;
  this.insertMode = false;
  this.originMode = false;
  this.wraparoundMode = false; // autowrap
  this.applicationKeypad = false; // ?
  this.applicationCursor = false;
  this.scrollTop = 0;
  this.scrollBottom = this.rows - 1;
  this.curAttr = this.defAttr;
  this.x = this.y = 0; // ?
  this.charset = null;
  this.glevel = 0; // ??
  this.charsets = [null]; // ??
};

// CSI Ps$ p
//   Request ANSI mode (DECRQM).  For VT300 and up, reply is
//     CSI Ps; Pm$ y
//   where Ps is the mode number as in RM, and Pm is the mode
//   value:
//     0 - not recognized
//     1 - set
//     2 - reset
//     3 - permanently set
//     4 - permanently reset
Terminal.prototype.requestAnsiMode = function(params) {
  ;
};

// CSI ? Ps$ p
//   Request DEC private mode (DECRQM).  For VT300 and up, reply is
//     CSI ? Ps; Pm$ p
//   where Ps is the mode number as in DECSET, Pm is the mode value
//   as in the ANSI DECRQM.
Terminal.prototype.requestPrivateMode = function(params) {
  ;
};

// CSI Ps ; Ps " p
//   Set conformance level (DECSCL).  Valid values for the first
//   parameter:
//     Ps = 6 1  -> VT100.
//     Ps = 6 2  -> VT200.
//     Ps = 6 3  -> VT300.
//   Valid values for the second parameter:
//     Ps = 0  -> 8-bit controls.
//     Ps = 1  -> 7-bit controls (always set for VT100).
//     Ps = 2  -> 8-bit controls.
Terminal.prototype.setConformanceLevel = function(params) {
  ;
};

// CSI Ps q  Load LEDs (DECLL).
//     Ps = 0  -> Clear all LEDS (default).
//     Ps = 1  -> Light Num Lock.
//     Ps = 2  -> Light Caps Lock.
//     Ps = 3  -> Light Scroll Lock.
//     Ps = 2  1  -> Extinguish Num Lock.
//     Ps = 2  2  -> Extinguish Caps Lock.
//     Ps = 2  3  -> Extinguish Scroll Lock.
Terminal.prototype.loadLEDs = function(params) {
  ;
};

// CSI Ps SP q
//   Set cursor style (DECSCUSR, VT520).
//     Ps = 0  -> blinking block.
//     Ps = 1  -> blinking block (default).
//     Ps = 2  -> steady block.
//     Ps = 3  -> blinking underline.
//     Ps = 4  -> steady underline.
Terminal.prototype.setCursorStyle = function(params) {
  ;
};

// CSI Ps " q
//   Select character protection attribute (DECSCA).  Valid values
//   for the parameter:
//     Ps = 0  -> DECSED and DECSEL can erase (default).
//     Ps = 1  -> DECSED and DECSEL cannot erase.
//     Ps = 2  -> DECSED and DECSEL can erase.
Terminal.prototype.setCharProtectionAttr = function(params) {
  ;
};

// CSI ? Pm r
//   Restore DEC Private Mode Values.  The value of Ps previously
//   saved is restored.  Ps values are the same as for DECSET.
Terminal.prototype.restorePrivateValues = function(params) {
  ;
};

// CSI Pt; Pl; Pb; Pr; Ps$ r
//   Change Attributes in Rectangular Area (DECCARA), VT400 and up.
//     Pt; Pl; Pb; Pr denotes the rectangle.
//     Ps denotes the SGR attributes to change: 0, 1, 4, 5, 7.
// NOTE: xterm doesn't enable this code by default.
Terminal.prototype.setAttrInRectangle = function(params) {
  var t = params[0]
    , l = params[1]
    , b = params[2]
    , r = params[3]
    , attr = params[4];

  var line
    , i;

  for (; t < b + 1; t++) {
    line = this.lines[this.ybase + t];
    for (i = l; i < r; i++) {
      line[i] = [attr, line[i][1]];
    }
  }

  // this.maxRange();
  this.updateRange(params[0]);
  this.updateRange(params[2]);
};

// CSI ? Pm s
//   Save DEC Private Mode Values.  Ps values are the same as for
//   DECSET.
Terminal.prototype.savePrivateValues = function(params) {
  ;
};

// CSI Ps ; Ps ; Ps t
//   Window manipulation (from dtterm, as well as extensions).
//   These controls may be disabled using the allowWindowOps
//   resource.  Valid values for the first (and any additional
//   parameters) are:
//     Ps = 1  -> De-iconify window.
//     Ps = 2  -> Iconify window.
//     Ps = 3  ;  x ;  y -> Move window to [x, y].
//     Ps = 4  ;  height ;  width -> Resize the xterm window to
//     height and width in pixels.
//     Ps = 5  -> Raise the xterm window to the front of the stack-
//     ing order.
//     Ps = 6  -> Lower the xterm window to the bottom of the
//     stacking order.
//     Ps = 7  -> Refresh the xterm window.
//     Ps = 8  ;  height ;  width -> Resize the text area to
//     [height;width] in characters.
//     Ps = 9  ;  0  -> Restore maximized window.
//     Ps = 9  ;  1  -> Maximize window (i.e., resize to screen
//     size).
//     Ps = 1 0  ;  0  -> Undo full-screen mode.
//     Ps = 1 0  ;  1  -> Change to full-screen.
//     Ps = 1 1  -> Report xterm window state.  If the xterm window
//     is open (non-iconified), it returns CSI 1 t .  If the xterm
//     window is iconified, it returns CSI 2 t .
//     Ps = 1 3  -> Report xterm window position.  Result is CSI 3
//     ; x ; y t
//     Ps = 1 4  -> Report xterm window in pixels.  Result is CSI
//     4  ;  height ;  width t
//     Ps = 1 8  -> Report the size of the text area in characters.
//     Result is CSI  8  ;  height ;  width t
//     Ps = 1 9  -> Report the size of the screen in characters.
//     Result is CSI  9  ;  height ;  width t
//     Ps = 2 0  -> Report xterm window's icon label.  Result is
//     OSC  L  label ST
//     Ps = 2 1  -> Report xterm window's title.  Result is OSC  l
//     label ST
//     Ps = 2 2  ;  0  -> Save xterm icon and window title on
//     stack.
//     Ps = 2 2  ;  1  -> Save xterm icon title on stack.
//     Ps = 2 2  ;  2  -> Save xterm window title on stack.
//     Ps = 2 3  ;  0  -> Restore xterm icon and window title from
//     stack.
//     Ps = 2 3  ;  1  -> Restore xterm icon title from stack.
//     Ps = 2 3  ;  2  -> Restore xterm window title from stack.
//     Ps >= 2 4  -> Resize to Ps lines (DECSLPP).
Terminal.prototype.manipulateWindow = function(params) {
  ;
};

// CSI Pt; Pl; Pb; Pr; Ps$ t
//   Reverse Attributes in Rectangular Area (DECRARA), VT400 and
//   up.
//     Pt; Pl; Pb; Pr denotes the rectangle.
//     Ps denotes the attributes to reverse, i.e.,  1, 4, 5, 7.
// NOTE: xterm doesn't enable this code by default.
Terminal.prototype.reverseAttrInRectangle = function(params) {
  ;
};

// CSI > Ps; Ps t
//   Set one or more features of the title modes.  Each parameter
//   enables a single feature.
//     Ps = 0  -> Set window/icon labels using hexadecimal.
//     Ps = 1  -> Query window/icon labels using hexadecimal.
//     Ps = 2  -> Set window/icon labels using UTF-8.
//     Ps = 3  -> Query window/icon labels using UTF-8.  (See dis-
//     cussion of "Title Modes")
Terminal.prototype.setTitleModeFeature = function(params) {
  ;
};

// CSI Ps SP t
//   Set warning-bell volume (DECSWBV, VT520).
//     Ps = 0  or 1  -> off.
//     Ps = 2 , 3  or 4  -> low.
//     Ps = 5 , 6 , 7 , or 8  -> high.
Terminal.prototype.setWarningBellVolume = function(params) {
  ;
};

// CSI Ps SP u
//   Set margin-bell volume (DECSMBV, VT520).
//     Ps = 1  -> off.
//     Ps = 2 , 3  or 4  -> low.
//     Ps = 0 , 5 , 6 , 7 , or 8  -> high.
Terminal.prototype.setMarginBellVolume = function(params) {
  ;
};

// CSI Pt; Pl; Pb; Pr; Pp; Pt; Pl; Pp$ v
//   Copy Rectangular Area (DECCRA, VT400 and up).
//     Pt; Pl; Pb; Pr denotes the rectangle.
//     Pp denotes the source page.
//     Pt; Pl denotes the target location.
//     Pp denotes the target page.
// NOTE: xterm doesn't enable this code by default.
Terminal.prototype.copyRectangle = function(params) {
  ;
};

// CSI Pt ; Pl ; Pb ; Pr ' w
//   Enable Filter Rectangle (DECEFR), VT420 and up.
//   Parameters are [top;left;bottom;right].
//   Defines the coordinates of a filter rectangle and activates
//   it.  Anytime the locator is detected outside of the filter
//   rectangle, an outside rectangle event is generated and the
//   rectangle is disabled.  Filter rectangles are always treated
//   as "one-shot" events.  Any parameters that are omitted default
//   to the current locator position.  If all parameters are omit-
//   ted, any locator motion will be reported.  DECELR always can-
//   cels any prevous rectangle definition.
Terminal.prototype.enableFilterRectangle = function(params) {
  ;
};

// CSI Ps x  Request Terminal Parameters (DECREQTPARM).
//   if Ps is a "0" (default) or "1", and xterm is emulating VT100,
//   the control sequence elicits a response of the same form whose
//   parameters describe the terminal:
//     Ps -> the given Ps incremented by 2.
//     Pn = 1  <- no parity.
//     Pn = 1  <- eight bits.
//     Pn = 1  <- 2  8  transmit 38.4k baud.
//     Pn = 1  <- 2  8  receive 38.4k baud.
//     Pn = 1  <- clock multiplier.
//     Pn = 0  <- STP flags.
Terminal.prototype.requestParameters = function(params) {
  ;
};

// CSI Ps x  Select Attribute Change Extent (DECSACE).
//     Ps = 0  -> from start to end position, wrapped.
//     Ps = 1  -> from start to end position, wrapped.
//     Ps = 2  -> rectangle (exact).
Terminal.prototype.selectChangeExtent = function(params) {
  ;
};

// CSI Pc; Pt; Pl; Pb; Pr$ x
//   Fill Rectangular Area (DECFRA), VT420 and up.
//     Pc is the character to use.
//     Pt; Pl; Pb; Pr denotes the rectangle.
// NOTE: xterm doesn't enable this code by default.
Terminal.prototype.fillRectangle = function(params) {
  var ch = params[0]
    , t = params[1]
    , l = params[2]
    , b = params[3]
    , r = params[4];

  var line
    , i;

  for (; t < b + 1; t++) {
    line = this.lines[this.ybase + t];
    for (i = l; i < r; i++) {
      line[i] = [line[i][0], String.fromCharCode(ch)];
    }
  }

  // this.maxRange();
  this.updateRange(params[1]);
  this.updateRange(params[3]);
};

// CSI Ps ; Pu ' z
//   Enable Locator Reporting (DECELR).
//   Valid values for the first parameter:
//     Ps = 0  -> Locator disabled (default).
//     Ps = 1  -> Locator enabled.
//     Ps = 2  -> Locator enabled for one report, then disabled.
//   The second parameter specifies the coordinate unit for locator
//   reports.
//   Valid values for the second parameter:
//     Pu = 0  <- or omitted -> default to character cells.
//     Pu = 1  <- device physical pixels.
//     Pu = 2  <- character cells.
Terminal.prototype.enableLocatorReporting = function(params) {
  var val = params[0] > 0;
  //this.mouseEvents = val;
  //this.decLocator = val;
};

// CSI Pt; Pl; Pb; Pr$ z
//   Erase Rectangular Area (DECERA), VT400 and up.
//     Pt; Pl; Pb; Pr denotes the rectangle.
// NOTE: xterm doesn't enable this code by default.
Terminal.prototype.eraseRectangle = function(params) {
  var t = params[0]
    , l = params[1]
    , b = params[2]
    , r = params[3];

  var line
    , i
    , ch;

  ch = [this.eraseAttr(), ' ']; // xterm?

  for (; t < b + 1; t++) {
    line = this.lines[this.ybase + t];
    for (i = l; i < r; i++) {
      line[i] = ch;
    }
  }

  // this.maxRange();
  this.updateRange(params[0]);
  this.updateRange(params[2]);
};

// CSI Pm ' {
//   Select Locator Events (DECSLE).
//   Valid values for the first (and any additional parameters)
//   are:
//     Ps = 0  -> only respond to explicit host requests (DECRQLP).
//                (This is default).  It also cancels any filter
//   rectangle.
//     Ps = 1  -> report button down transitions.
//     Ps = 2  -> do not report button down transitions.
//     Ps = 3  -> report button up transitions.
//     Ps = 4  -> do not report button up transitions.
Terminal.prototype.setLocatorEvents = function(params) {
  ;
};

// CSI Pt; Pl; Pb; Pr$ {
//   Selective Erase Rectangular Area (DECSERA), VT400 and up.
//     Pt; Pl; Pb; Pr denotes the rectangle.
Terminal.prototype.selectiveEraseRectangle = function(params) {
  ;
};

// CSI Ps ' |
//   Request Locator Position (DECRQLP).
//   Valid values for the parameter are:
//     Ps = 0 , 1 or omitted -> transmit a single DECLRP locator
//     report.

//   If Locator Reporting has been enabled by a DECELR, xterm will
//   respond with a DECLRP Locator Report.  This report is also
//   generated on button up and down events if they have been
//   enabled with a DECSLE, or when the locator is detected outside
//   of a filter rectangle, if filter rectangles have been enabled
//   with a DECEFR.

//     -> CSI Pe ; Pb ; Pr ; Pc ; Pp &  w

//   Parameters are [event;button;row;column;page].
//   Valid values for the event:
//     Pe = 0  -> locator unavailable - no other parameters sent.
//     Pe = 1  -> request - xterm received a DECRQLP.
//     Pe = 2  -> left button down.
//     Pe = 3  -> left button up.
//     Pe = 4  -> middle button down.
//     Pe = 5  -> middle button up.
//     Pe = 6  -> right button down.
//     Pe = 7  -> right button up.
//     Pe = 8  -> M4 button down.
//     Pe = 9  -> M4 button up.
//     Pe = 1 0  -> locator outside filter rectangle.
//   ``button'' parameter is a bitmask indicating which buttons are
//     pressed:
//     Pb = 0  <- no buttons down.
//     Pb & 1  <- right button down.
//     Pb & 2  <- middle button down.
//     Pb & 4  <- left button down.
//     Pb & 8  <- M4 button down.
//   ``row'' and ``column'' parameters are the coordinates of the
//     locator position in the xterm window, encoded as ASCII deci-
//     mal.
//   The ``page'' parameter is not used by xterm, and will be omit-
//   ted.
Terminal.prototype.requestLocatorPosition = function(params) {
  ;
};

// CSI P m SP }
// Insert P s Column(s) (default = 1) (DECIC), VT420 and up.
// NOTE: xterm doesn't enable this code by default.
Terminal.prototype.insertColumns = function() {
  var param = params[0]
    , l = this.ybase + this.rows
    , ch = [this.eraseAttr(), ' '] // xterm?
    , i;

  while (param--) {
    for (i = this.ybase; i < l; i++) {
      this.lines[i].splice(this.x + 1, 0, ch);
      this.lines[i].pop();
    }
  }

  this.maxRange();
};

// CSI P m SP ~
// Delete P s Column(s) (default = 1) (DECDC), VT420 and up
// NOTE: xterm doesn't enable this code by default.
Terminal.prototype.deleteColumns = function() {
  var param = params[0]
    , l = this.ybase + this.rows
    , ch = [this.eraseAttr(), ' '] // xterm?
    , i;

  while (param--) {
    for (i = this.ybase; i < l; i++) {
      this.lines[i].splice(this.x, 1);
      this.lines[i].push(ch);
    }
  }

  this.maxRange();
};

/**
 * Prefix/Select/Visual/Search Modes
 */

Terminal.prototype.enterPrefix = function() {
  this.prefixMode = true;
};

Terminal.prototype.leavePrefix = function() {
  this.prefixMode = false;
};

Terminal.prototype.enterSelect = function() {
  this._real = {
    x: this.x,
    y: this.y,
    ydisp: this.ydisp,
    ybase: this.ybase,
    cursorHidden: this.cursorHidden,
    lines: this.copyBuffer(this.lines),
    write: this.write
  };
  this.write = function() {};
  this.selectMode = true;
  this.visualMode = false;
  this.cursorHidden = false;
  this.refresh(this.y, this.y);
};

Terminal.prototype.leaveSelect = function() {
  this.x = this._real.x;
  this.y = this._real.y;
  this.ydisp = this._real.ydisp;
  this.ybase = this._real.ybase;
  this.cursorHidden = this._real.cursorHidden;
  this.lines = this._real.lines;
  this.write = this._real.write;
  delete this._real;
  this.selectMode = false;
  this.visualMode = false;
  this.refresh(0, this.rows - 1);
};

Terminal.prototype.enterVisual = function() {
  this._real.preVisual = this.copyBuffer(this.lines);
  this.selectText(this.x, this.x, this.ydisp + this.y, this.ydisp + this.y);
  this.visualMode = true;
};

Terminal.prototype.leaveVisual = function() {
  this.lines = this._real.preVisual;
  delete this._real.preVisual;
  delete this._selected;
  this.visualMode = false;
  this.refresh(0, this.rows - 1);
};

Terminal.prototype.enterSearch = function(down) {
  this.entry = '';
  this.searchMode = true;
  this.searchDown = down;
  this._real.preSearch = this.copyBuffer(this.lines);
  this._real.preSearchX = this.x;
  this._real.preSearchY = this.y;

  var bottom = this.ydisp + this.rows - 1;
  for (var i = 0; i < this.entryPrefix.length; i++) {
    //this.lines[bottom][i][0] = (this.defAttr & ~0x1ff) | 4;
    //this.lines[bottom][i][1] = this.entryPrefix[i];
    this.lines[bottom][i] = [
      (this.defAttr & ~0x1ff) | 4,
      this.entryPrefix[i]
    ];
  }

  this.y = this.rows - 1;
  this.x = this.entryPrefix.length;

  this.refresh(this.rows - 1, this.rows - 1);
};

Terminal.prototype.leaveSearch = function() {
  this.searchMode = false;

  if (this._real.preSearch) {
    this.lines = this._real.preSearch;
    this.x = this._real.preSearchX;
    this.y = this._real.preSearchY;
    delete this._real.preSearch;
    delete this._real.preSearchX;
    delete this._real.preSearchY;
  }

  this.refresh(this.rows - 1, this.rows - 1);
};

Terminal.prototype.copyBuffer = function(lines) {
  var lines = lines || this.lines
    , out = [];

  for (var y = 0; y < lines.length; y++) {
    out[y] = [];
    for (var x = 0; x < lines[y].length; x++) {
      out[y][x] = [lines[y][x][0], lines[y][x][1]];
    }
  }

  return out;
};

Terminal.prototype.getCopyTextarea = function(text) {
  var textarea = this._copyTextarea
    , document = this.document;

  if (!textarea) {
    textarea = document.createElement('textarea');
    textarea.style.position = 'absolute';
    textarea.style.left = '-32000px';
    textarea.style.top = '-32000px';
    textarea.style.width = '0px';
    textarea.style.height = '0px';
    textarea.style.opacity = '0';
    textarea.style.backgroundColor = 'transparent';
    textarea.style.borderStyle = 'none';
    textarea.style.outlineStyle = 'none';

    document.getElementsByTagName('body')[0].appendChild(textarea);

    this._copyTextarea = textarea;
  }

  return textarea;
};

// NOTE: Only works for primary selection on X11.
// Non-X11 users should use Ctrl-C instead.
Terminal.prototype.copyText = function(text) {
  var self = this
    , textarea = this.getCopyTextarea();

  this.emit('copy', text);

  textarea.focus();
  textarea.textContent = text;
  textarea.value = text;
  textarea.setSelectionRange(0, text.length);

  setTimeout(function() {
    self.element.focus();
    self.focus();
  }, 1);
};

Terminal.prototype.selectText = function(x1, x2, y1, y2) {
  var ox1
    , ox2
    , oy1
    , oy2
    , tmp
    , x
    , y
    , xl
    , attr;

  if (this._selected) {
    ox1 = this._selected.x1;
    ox2 = this._selected.x2;
    oy1 = this._selected.y1;
    oy2 = this._selected.y2;

    if (oy2 < oy1) {
      tmp = ox2;
      ox2 = ox1;
      ox1 = tmp;
      tmp = oy2;
      oy2 = oy1;
      oy1 = tmp;
    }

    if (ox2 < ox1 && oy1 === oy2) {
      tmp = ox2;
      ox2 = ox1;
      ox1 = tmp;
    }

    for (y = oy1; y <= oy2; y++) {
      x = 0;
      xl = this.cols - 1;
      if (y === oy1) {
        x = ox1;
      }
      if (y === oy2) {
        xl = ox2;
      }
      for (; x <= xl; x++) {
        if (this.lines[y][x].old != null) {
          //this.lines[y][x][0] = this.lines[y][x].old;
          //delete this.lines[y][x].old;
          attr = this.lines[y][x].old;
          delete this.lines[y][x].old;
          this.lines[y][x] = [attr, this.lines[y][x][1]];
        }
      }
    }

    y1 = this._selected.y1;
    x1 = this._selected.x1;
  }

  y1 = Math.max(y1, 0);
  y1 = Math.min(y1, this.ydisp + this.rows - 1);

  y2 = Math.max(y2, 0);
  y2 = Math.min(y2, this.ydisp + this.rows - 1);

  this._selected = { x1: x1, x2: x2, y1: y1, y2: y2 };

  if (y2 < y1) {
    tmp = x2;
    x2 = x1;
    x1 = tmp;
    tmp = y2;
    y2 = y1;
    y1 = tmp;
  }

  if (x2 < x1 && y1 === y2) {
    tmp = x2;
    x2 = x1;
    x1 = tmp;
  }

  for (y = y1; y <= y2; y++) {
    x = 0;
    xl = this.cols - 1;
    if (y === y1) {
      x = x1;
    }
    if (y === y2) {
      xl = x2;
    }
    for (; x <= xl; x++) {
      //this.lines[y][x].old = this.lines[y][x][0];
      //this.lines[y][x][0] &= ~0x1ff;
      //this.lines[y][x][0] |= (0x1ff << 9) | 4;
      attr = this.lines[y][x][0];
      this.lines[y][x] = [
        (attr & ~0x1ff) | ((0x1ff << 9) | 4),
        this.lines[y][x][1]
      ];
      this.lines[y][x].old = attr;
    }
  }

  y1 = y1 - this.ydisp;
  y2 = y2 - this.ydisp;

  y1 = Math.max(y1, 0);
  y1 = Math.min(y1, this.rows - 1);

  y2 = Math.max(y2, 0);
  y2 = Math.min(y2, this.rows - 1);

  //this.refresh(y1, y2);
  this.refresh(0, this.rows - 1);
};

Terminal.prototype.grabText = function(x1, x2, y1, y2) {
  var out = ''
    , buf = ''
    , ch
    , x
    , y
    , xl
    , tmp;

  if (y2 < y1) {
    tmp = x2;
    x2 = x1;
    x1 = tmp;
    tmp = y2;
    y2 = y1;
    y1 = tmp;
  }

  if (x2 < x1 && y1 === y2) {
    tmp = x2;
    x2 = x1;
    x1 = tmp;
  }

  for (y = y1; y <= y2; y++) {
    x = 0;
    xl = this.cols - 1;
    if (y === y1) {
      x = x1;
    }
    if (y === y2) {
      xl = x2;
    }
    for (; x <= xl; x++) {
      ch = this.lines[y][x][1];
      if (ch === ' ') {
        buf += ch;
        continue;
      }
      if (buf) {
        out += buf;
        buf = '';
      }
      out += ch;
      if (isWide(ch)) x++;
    }
    buf = '';
    out += '\n';
  }

  // If we're not at the end of the
  // line, don't add a newline.
  for (x = x2, y = y2; x < this.cols; x++) {
    if (this.lines[y][x][1] !== ' ') {
      out = out.slice(0, -1);
      break;
    }
  }

  return out;
};

Terminal.prototype.keyPrefix = function(ev, key) {
  if (key === 'k' || key === '&') {
    this.destroy();
  } else if (key === 'p' || key === ']') {
    this.emit('request paste');
  } else if (key === 'c') {
    this.emit('request create');
  } else if (key >= '0' && key <= '9') {
    key = +key - 1;
    if (!~key) key = 9;
    this.emit('request term', key);
  } else if (key === 'n') {
    this.emit('request term next');
  } else if (key === 'P') {
    this.emit('request term previous');
  } else if (key === ':') {
    this.emit('request command mode');
  } else if (key === '[') {
    this.enterSelect();
  }
};

Terminal.prototype.keySelect = function(ev, key) {
  this.showCursor();

  if (this.searchMode || key === 'n' || key === 'N') {
    return this.keySearch(ev, key);
  }

  if (key === '\x04') { // ctrl-d
    var y = this.ydisp + this.y;
    if (this.ydisp === this.ybase) {
      // Mimic vim behavior
      this.y = Math.min(this.y + (this.rows - 1) / 2 | 0, this.rows - 1);
      this.refresh(0, this.rows - 1);
    } else {
      this.scrollDisp((this.rows - 1) / 2 | 0);
    }
    if (this.visualMode) {
      this.selectText(this.x, this.x, y, this.ydisp + this.y);
    }
    return;
  }

  if (key === '\x15') { // ctrl-u
    var y = this.ydisp + this.y;
    if (this.ydisp === 0) {
      // Mimic vim behavior
      this.y = Math.max(this.y - (this.rows - 1) / 2 | 0, 0);
      this.refresh(0, this.rows - 1);
    } else {
      this.scrollDisp(-(this.rows - 1) / 2 | 0);
    }
    if (this.visualMode) {
      this.selectText(this.x, this.x, y, this.ydisp + this.y);
    }
    return;
  }

  if (key === '\x06') { // ctrl-f
    var y = this.ydisp + this.y;
    this.scrollDisp(this.rows - 1);
    if (this.visualMode) {
      this.selectText(this.x, this.x, y, this.ydisp + this.y);
    }
    return;
  }

  if (key === '\x02') { // ctrl-b
    var y = this.ydisp + this.y;
    this.scrollDisp(-(this.rows - 1));
    if (this.visualMode) {
      this.selectText(this.x, this.x, y, this.ydisp + this.y);
    }
    return;
  }

  if (key === 'k' || key === '\x1b[A') {
    var y = this.ydisp + this.y;
    this.y--;
    if (this.y < 0) {
      this.y = 0;
      this.scrollDisp(-1);
    }
    if (this.visualMode) {
      this.selectText(this.x, this.x, y, this.ydisp + this.y);
    } else {
      this.refresh(this.y, this.y + 1);
    }
    return;
  }

  if (key === 'j' || key === '\x1b[B') {
    var y = this.ydisp + this.y;
    this.y++;
    if (this.y >= this.rows) {
      this.y = this.rows - 1;
      this.scrollDisp(1);
    }
    if (this.visualMode) {
      this.selectText(this.x, this.x, y, this.ydisp + this.y);
    } else {
      this.refresh(this.y - 1, this.y);
    }
    return;
  }

  if (key === 'h' || key === '\x1b[D') {
    var x = this.x;
    this.x--;
    if (this.x < 0) {
      this.x = 0;
    }
    if (this.visualMode) {
      this.selectText(x, this.x, this.ydisp + this.y, this.ydisp + this.y);
    } else {
      this.refresh(this.y, this.y);
    }
    return;
  }

  if (key === 'l' || key === '\x1b[C') {
    var x = this.x;
    this.x++;
    if (this.x >= this.cols) {
      this.x = this.cols - 1;
    }
    if (this.visualMode) {
      this.selectText(x, this.x, this.ydisp + this.y, this.ydisp + this.y);
    } else {
      this.refresh(this.y, this.y);
    }
    return;
  }

  if (key === 'v' || key === ' ') {
    if (!this.visualMode) {
      this.enterVisual();
    } else {
      this.leaveVisual();
    }
    return;
  }

  if (key === 'y') {
    if (this.visualMode) {
      var text = this.grabText(
        this._selected.x1, this._selected.x2,
        this._selected.y1, this._selected.y2);
      this.copyText(text);
      this.leaveVisual();
      // this.leaveSelect();
    }
    return;
  }

  if (key === 'q' || key === '\x1b') {
    if (this.visualMode) {
      this.leaveVisual();
    } else {
      this.leaveSelect();
    }
    return;
  }

  if (key === 'w' || key === 'W') {
    var ox = this.x;
    var oy = this.y;
    var oyd = this.ydisp;

    var x = this.x;
    var y = this.y;
    var yb = this.ydisp;
    var saw_space = false;

    for (;;) {
      var line = this.lines[yb + y];
      while (x < this.cols) {
        if (line[x][1] <= ' ') {
          saw_space = true;
        } else if (saw_space) {
          break;
        }
        x++;
      }
      if (x >= this.cols) x = this.cols - 1;
      if (x === this.cols - 1 && line[x][1] <= ' ') {
        x = 0;
        if (++y >= this.rows) {
          y--;
          if (++yb > this.ybase) {
            yb = this.ybase;
            x = this.x;
            break;
          }
        }
        continue;
      }
      break;
    }

    this.x = x, this.y = y;
    this.scrollDisp(-this.ydisp + yb);

    if (this.visualMode) {
      this.selectText(ox, this.x, oy + oyd, this.ydisp + this.y);
    }
    return;
  }

  if (key === 'b' || key === 'B') {
    var ox = this.x;
    var oy = this.y;
    var oyd = this.ydisp;

    var x = this.x;
    var y = this.y;
    var yb = this.ydisp;

    for (;;) {
      var line = this.lines[yb + y];
      var saw_space = x > 0 && line[x][1] > ' ' && line[x - 1][1] > ' ';
      while (x >= 0) {
        if (line[x][1] <= ' ') {
          if (saw_space && (x + 1 < this.cols && line[x + 1][1] > ' ')) {
            x++;
            break;
          } else {
            saw_space = true;
          }
        }
        x--;
      }
      if (x < 0) x = 0;
      if (x === 0 && (line[x][1] <= ' ' || !saw_space)) {
        x = this.cols - 1;
        if (--y < 0) {
          y++;
          if (--yb < 0) {
            yb++;
            x = 0;
            break;
          }
        }
        continue;
      }
      break;
    }

    this.x = x, this.y = y;
    this.scrollDisp(-this.ydisp + yb);

    if (this.visualMode) {
      this.selectText(ox, this.x, oy + oyd, this.ydisp + this.y);
    }
    return;
  }

  if (key === 'e' || key === 'E') {
    var x = this.x + 1;
    var y = this.y;
    var yb = this.ydisp;
    if (x >= this.cols) x--;

    for (;;) {
      var line = this.lines[yb + y];
      while (x < this.cols) {
        if (line[x][1] <= ' ') {
          x++;
        } else {
          break;
        }
      }
      while (x < this.cols) {
        if (line[x][1] <= ' ') {
          if (x - 1 >= 0 && line[x - 1][1] > ' ') {
            x--;
            break;
          }
        }
        x++;
      }
      if (x >= this.cols) x = this.cols - 1;
      if (x === this.cols - 1 && line[x][1] <= ' ') {
        x = 0;
        if (++y >= this.rows) {
          y--;
          if (++yb > this.ybase) {
            yb = this.ybase;
            break;
          }
        }
        continue;
      }
      break;
    }

    this.x = x, this.y = y;
    this.scrollDisp(-this.ydisp + yb);

    if (this.visualMode) {
      this.selectText(ox, this.x, oy + oyd, this.ydisp + this.y);
    }
    return;
  }

  if (key === '^' || key === '0') {
    var ox = this.x;

    if (key === '0') {
      this.x = 0;
    } else if (key === '^') {
      var line = this.lines[this.ydisp + this.y];
      var x = 0;
      while (x < this.cols) {
        if (line[x][1] > ' ') {
          break;
        }
        x++;
      }
      if (x >= this.cols) x = this.cols - 1;
      this.x = x;
    }

    if (this.visualMode) {
      this.selectText(ox, this.x, this.ydisp + this.y, this.ydisp + this.y);
    } else {
      this.refresh(this.y, this.y);
    }
    return;
  }

  if (key === '$') {
    var ox = this.x;
    var line = this.lines[this.ydisp + this.y];
    var x = this.cols - 1;
    while (x >= 0) {
      if (line[x][1] > ' ') {
        if (this.visualMode && x < this.cols - 1) x++;
        break;
      }
      x--;
    }
    if (x < 0) x = 0;
    this.x = x;
    if (this.visualMode) {
      this.selectText(ox, this.x, this.ydisp + this.y, this.ydisp + this.y);
    } else {
      this.refresh(this.y, this.y);
    }
    return;
  }

  if (key === 'g' || key === 'G') {
    var ox = this.x;
    var oy = this.y;
    var oyd = this.ydisp;
    if (key === 'g') {
      this.x = 0, this.y = 0;
      this.scrollDisp(-this.ydisp);
    } else if (key === 'G') {
      this.x = 0, this.y = this.rows - 1;
      this.scrollDisp(this.ybase);
    }
    if (this.visualMode) {
      this.selectText(ox, this.x, oy + oyd, this.ydisp + this.y);
    }
    return;
  }

  if (key === 'H' || key === 'M' || key === 'L') {
    var ox = this.x;
    var oy = this.y;
    if (key === 'H') {
      this.x = 0, this.y = 0;
    } else if (key === 'M') {
      this.x = 0, this.y = this.rows / 2 | 0;
    } else if (key === 'L') {
      this.x = 0, this.y = this.rows - 1;
    }
    if (this.visualMode) {
      this.selectText(ox, this.x, this.ydisp + oy, this.ydisp + this.y);
    } else {
      this.refresh(oy, oy);
      this.refresh(this.y, this.y);
    }
    return;
  }

  if (key === '{' || key === '}') {
    var ox = this.x;
    var oy = this.y;
    var oyd = this.ydisp;

    var line;
    var saw_full = false;
    var found = false;
    var first_is_space = -1;
    var y = this.y + (key === '{' ? -1 : 1);
    var yb = this.ydisp;
    var i;

    if (key === '{') {
      if (y < 0) {
        y++;
        if (yb > 0) yb--;
      }
    } else if (key === '}') {
      if (y >= this.rows) {
        y--;
        if (yb < this.ybase) yb++;
      }
    }

    for (;;) {
      line = this.lines[yb + y];

      for (i = 0; i < this.cols; i++) {
        if (line[i][1] > ' ') {
          if (first_is_space === -1) {
            first_is_space = 0;
          }
          saw_full = true;
          break;
        } else if (i === this.cols - 1) {
          if (first_is_space === -1) {
            first_is_space = 1;
          } else if (first_is_space === 0) {
            found = true;
          } else if (first_is_space === 1) {
            if (saw_full) found = true;
          }
          break;
        }
      }

      if (found) break;

      if (key === '{') {
        y--;
        if (y < 0) {
          y++;
          if (yb > 0) yb--;
          else break;
        }
      } else if (key === '}') {
        y++;
        if (y >= this.rows) {
          y--;
          if (yb < this.ybase) yb++;
          else break;
        }
      }
    }

    if (!found) {
      if (key === '{') {
        y = 0;
        yb = 0;
      } else if (key === '}') {
        y = this.rows - 1;
        yb = this.ybase;
      }
    }

    this.x = 0, this.y = y;
    this.scrollDisp(-this.ydisp + yb);

    if (this.visualMode) {
      this.selectText(ox, this.x, oy + oyd, this.ydisp + this.y);
    }
    return;
  }

  if (key === '/' || key === '?') {
    if (!this.visualMode) {
      this.enterSearch(key === '/');
    }
    return;
  }

  return false;
};

Terminal.prototype.keySearch = function(ev, key) {
  if (key === '\x1b') {
    this.leaveSearch();
    return;
  }

  if (key === '\r' || (!this.searchMode && (key === 'n' || key === 'N'))) {
    this.leaveSearch();

    var entry = this.entry;

    if (!entry) {
      this.refresh(0, this.rows - 1);
      return;
    }

    var ox = this.x;
    var oy = this.y;
    var oyd = this.ydisp;

    var line;
    var found = false;
    var wrapped = false;
    var x = this.x + 1;
    var y = this.ydisp + this.y;
    var yb, i;
    var up = key === 'N'
      ? this.searchDown
      : !this.searchDown;

    for (;;) {
      line = this.lines[y];

      while (x < this.cols) {
        for (i = 0; i < entry.length; i++) {
          if (x + i >= this.cols) break;
          if (line[x + i][1] !== entry[i]) {
            break;
          } else if (line[x + i][1] === entry[i] && i === entry.length - 1) {
            found = true;
            break;
          }
        }
        if (found) break;
        x += i + 1;
      }
      if (found) break;

      x = 0;

      if (!up) {
        y++;
        if (y > this.ybase + this.rows - 1) {
          if (wrapped) break;
          // this.setMessage('Search wrapped. Continuing at TOP.');
          wrapped = true;
          y = 0;
        }
      } else {
        y--;
        if (y < 0) {
          if (wrapped) break;
          // this.setMessage('Search wrapped. Continuing at BOTTOM.');
          wrapped = true;
          y = this.ybase + this.rows - 1;
        }
      }
    }

    if (found) {
      if (y - this.ybase < 0) {
        yb = y;
        y = 0;
        if (yb > this.ybase) {
          y = yb - this.ybase;
          yb = this.ybase;
        }
      } else {
        yb = this.ybase;
        y -= this.ybase;
      }

      this.x = x, this.y = y;
      this.scrollDisp(-this.ydisp + yb);

      if (this.visualMode) {
        this.selectText(ox, this.x, oy + oyd, this.ydisp + this.y);
      }
      return;
    }

    // this.setMessage("No matches found.");
    this.refresh(0, this.rows - 1);

    return;
  }

  if (key === '\b' || key === '\x7f') {
    if (this.entry.length === 0) return;
    var bottom = this.ydisp + this.rows - 1;
    this.entry = this.entry.slice(0, -1);
    var i = this.entryPrefix.length + this.entry.length;
    //this.lines[bottom][i][1] = ' ';
    this.lines[bottom][i] = [
      this.lines[bottom][i][0],
      ' '
    ];
    this.x--;
    this.refresh(this.rows - 1, this.rows - 1);
    this.refresh(this.y, this.y);
    return;
  }

  if (key.length === 1 && key >= ' ' && key <= '~') {
    var bottom = this.ydisp + this.rows - 1;
    this.entry += key;
    var i = this.entryPrefix.length + this.entry.length - 1;
    //this.lines[bottom][i][0] = (this.defAttr & ~0x1ff) | 4;
    //this.lines[bottom][i][1] = key;
    this.lines[bottom][i] = [
      (this.defAttr & ~0x1ff) | 4,
      key
    ];
    this.x++;
    this.refresh(this.rows - 1, this.rows - 1);
    this.refresh(this.y, this.y);
    return;
  }

  return false;
};

/**
 * Character Sets
 */

Terminal.charsets = {};

// DEC Special Character and Line Drawing Set.
// http://vt100.net/docs/vt102-ug/table5-13.html
// A lot of curses apps use this if they see TERM=xterm.
// testing: echo -e '\e(0a\e(B'
// The xterm output sometimes seems to conflict with the
// reference above. xterm seems in line with the reference
// when running vttest however.
// The table below now uses xterm's output from vttest.
Terminal.charsets.SCLD = { // (0
  '`': '\u25c6', // ''
  'a': '\u2592', // ''
  'b': '\u0009', // '\t'
  'c': '\u000c', // '\f'
  'd': '\u000d', // '\r'
  'e': '\u000a', // '\n'
  'f': '\u00b0', // ''
  'g': '\u00b1', // ''
  'h': '\u2424', // '\u2424' (NL)
  'i': '\u000b', // '\v'
  'j': '\u2518', // ''
  'k': '\u2510', // ''
  'l': '\u250c', // ''
  'm': '\u2514', // ''
  'n': '\u253c', // ''
  'o': '\u23ba', // ''
  'p': '\u23bb', // ''
  'q': '\u2500', // ''
  'r': '\u23bc', // ''
  's': '\u23bd', // ''
  't': '\u251c', // ''
  'u': '\u2524', // ''
  'v': '\u2534', // ''
  'w': '\u252c', // ''
  'x': '\u2502', // ''
  'y': '\u2264', // ''
  'z': '\u2265', // ''
  '{': '\u03c0', // ''
  '|': '\u2260', // ''
  '}': '\u00a3', // ''
  '~': '\u00b7'  // ''
};

Terminal.charsets.UK = null; // (A
Terminal.charsets.US = null; // (B (USASCII)
Terminal.charsets.Dutch = null; // (4
Terminal.charsets.Finnish = null; // (C or (5
Terminal.charsets.French = null; // (R
Terminal.charsets.FrenchCanadian = null; // (Q
Terminal.charsets.German = null; // (K
Terminal.charsets.Italian = null; // (Y
Terminal.charsets.NorwegianDanish = null; // (E or (6
Terminal.charsets.Spanish = null; // (Z
Terminal.charsets.Swedish = null; // (H or (7
Terminal.charsets.Swiss = null; // (=
Terminal.charsets.ISOLatin = null; // /A

/**
 * Helpers
 */

function on(el, type, handler, capture) {
  el.addEventListener(type, handler, capture || false);
}

function off(el, type, handler, capture) {
  el.removeEventListener(type, handler, capture || false);
}

function cancel(ev) {
  if (ev.preventDefault) ev.preventDefault();
  ev.returnValue = false;
  if (ev.stopPropagation) ev.stopPropagation();
  ev.cancelBubble = true;
  return false;
}

function inherits(child, parent) {
  function f() {
    this.constructor = child;
  }
  f.prototype = parent.prototype;
  child.prototype = new f;
}

// if bold is broken, we can't
// use it in the terminal.
function isBoldBroken(document) {
  var body = document.getElementsByTagName('body')[0];
  var el = document.createElement('span');
  el.innerHTML = 'hello world';
  body.appendChild(el);
  var w1 = el.scrollWidth;
  el.style.fontWeight = 'bold';
  var w2 = el.scrollWidth;
  body.removeChild(el);
  return w1 !== w2;
}

var String = this.String;
var setTimeout = this.setTimeout;
var setInterval = this.setInterval;

function indexOf(obj, el) {
  var i = obj.length;
  while (i--) {
    if (obj[i] === el) return i;
  }
  return -1;
}

function isWide(ch) {
  if (ch <= '\uff00') return false;
  return (ch >= '\uff01' && ch <= '\uffbe')
      || (ch >= '\uffc2' && ch <= '\uffc7')
      || (ch >= '\uffca' && ch <= '\uffcf')
      || (ch >= '\uffd2' && ch <= '\uffd7')
      || (ch >= '\uffda' && ch <= '\uffdc')
      || (ch >= '\uffe0' && ch <= '\uffe6')
      || (ch >= '\uffe8' && ch <= '\uffee');
}

function matchColor(r1, g1, b1) {
  var hash = (r1 << 16) | (g1 << 8) | b1;

  if (matchColor._cache[hash] != null) {
    return matchColor._cache[hash];
  }

  var ldiff = Infinity
    , li = -1
    , i = 0
    , c
    , r2
    , g2
    , b2
    , diff;

  for (; i < Terminal.vcolors.length; i++) {
    c = Terminal.vcolors[i];
    r2 = c[0];
    g2 = c[1];
    b2 = c[2];

    diff = matchColor.distance(r1, g1, b1, r2, g2, b2);

    if (diff === 0) {
      li = i;
      break;
    }

    if (diff < ldiff) {
      ldiff = diff;
      li = i;
    }
  }

  return matchColor._cache[hash] = li;
}

matchColor._cache = {};

// http://stackoverflow.com/questions/1633828
matchColor.distance = function(r1, g1, b1, r2, g2, b2) {
  return Math.pow(30 * (r1 - r2), 2)
    + Math.pow(59 * (g1 - g2), 2)
    + Math.pow(11 * (b1 - b2), 2);
};

function each(obj, iter, con) {
  if (obj.forEach) return obj.forEach(iter, con);
  for (var i = 0; i < obj.length; i++) {
    iter.call(con, obj[i], i, obj);
  }
}

function keys(obj) {
  if (Object.keys) return Object.keys(obj);
  var key, keys = [];
  for (key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
}

/**
 * Expose
 */

Terminal.EventEmitter = EventEmitter;
Terminal.inherits = inherits;
Terminal.on = on;
Terminal.off = off;
Terminal.cancel = cancel;

if (typeof module !== 'undefined') {
  module.exports = Terminal;
} else {
  this.Terminal = Terminal;
}

}).call(function() {
  return this || (typeof window !== 'undefined' ? window : global);
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[15])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJjbGllbnQtc3JjL2NvbXBvbmVudHMvY29uc29sZS5qcyIsImNsaWVudC1zcmMvY29tcG9uZW50cy9lZGl0b3JzL2FjZS5qcyIsImNsaWVudC1zcmMvY29tcG9uZW50cy9lZGl0b3JzL2NvbW1hbmQuanMiLCJjbGllbnQtc3JjL2NvbXBvbmVudHMvZWRpdG9ycy9jb21taXQuanMiLCJjbGllbnQtc3JjL2NvbXBvbmVudHMvZWRpdG9ycy9pbmZvLmpzIiwiY2xpZW50LXNyYy9jb21wb25lbnRzL2VkaXRvcnMvbmV3LWRvY3VtZW50LmpzIiwiY2xpZW50LXNyYy9jb21wb25lbnRzL2VkaXRvcnMvbmV3LWZvbGRlci5qcyIsImNsaWVudC1zcmMvY29tcG9uZW50cy9lZGl0b3JzL3ByZXZpZXdlci5qcyIsImNsaWVudC1zcmMvY29tcG9uZW50cy9lZGl0b3JzL3Rlcm1pbmFscy5qcyIsImNsaWVudC1zcmMvY29tcG9uZW50cy9lbnRpdHktc2VsZWN0b3IuanMiLCJjbGllbnQtc3JjL2NvbXBvbmVudHMvbGF5b3V0LmpzIiwiY2xpZW50LXNyYy9jb21wb25lbnRzL21vZGFsLmpzIiwiY2xpZW50LXNyYy9jb21wb25lbnRzL3Nlc3Npb25zLmpzIiwiY2xpZW50LXNyYy9jb21wb25lbnRzL3RvcC1tZW51LmpzIiwiY2xpZW50LXNyYy9lbnRyeS5qcyIsImNsaWVudC1zcmMvbGliL2ZpbGUtc3lzdGVtLmpzIiwiY2xpZW50LXNyYy9saWIvcmVtb3RlLmpzIiwiY2xpZW50LXNyYy9saWIvc29ja3MuanMiLCJub2RlX21vZHVsZXMvYnJhY2UvbW9kZS9qYXZhc2NyaXB0LmpzIiwibm9kZV9tb2R1bGVzL2JyYWNlL3dvcmtlci9qYXZhc2NyaXB0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVxdWVzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbG9uZS1kZWVwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nsb25lLWRlZXAvbm9kZV9tb2R1bGVzL2Zvci1vd24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2xvbmUtZGVlcC9ub2RlX21vZHVsZXMvZm9yLW93bi9ub2RlX21vZHVsZXMvZm9yLWluL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nsb25lLWRlZXAvbm9kZV9tb2R1bGVzL2lzLXBsYWluLW9iamVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbG9uZS1kZWVwL25vZGVfbW9kdWxlcy9raW5kLW9mL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Nsb25lLWRlZXAvbm9kZV9tb2R1bGVzL21peGluLW9iamVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kaWZmLW1hdGNoLXBhdGNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RvbWlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9maWxlc2l6ZS9saWIvZmlsZXNpemUuanMiLCJub2RlX21vZHVsZXMvZm9yZWFjaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nbS1nYXRoZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3JlZW4tbWVzYS1kb20vaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3JlZW4tbWVzYS1kb20vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1jbGFzc2VzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyZWVuLW1lc2EtZG9tL25vZGVfbW9kdWxlcy9jb21wb25lbnQtZGVsZWdhdGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3JlZW4tbWVzYS1kb20vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1kZWxlZ2F0ZS9ub2RlX21vZHVsZXMvZGlzY29yZS1jbG9zZXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyZWVuLW1lc2EtZG9tL25vZGVfbW9kdWxlcy9jb21wb25lbnQtZGVsZWdhdGUvbm9kZV9tb2R1bGVzL2Rpc2NvcmUtY2xvc2VzdC9ub2RlX21vZHVsZXMvbWF0Y2hlcy1zZWxlY3Rvci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmVlbi1tZXNhLWRvbS9ub2RlX21vZHVsZXMvY29tcG9uZW50LWRvbWlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmVlbi1tZXNhLWRvbS9ub2RlX21vZHVsZXMvY29tcG9uZW50LWV2ZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyZWVuLW1lc2EtZG9tL25vZGVfbW9kdWxlcy9jb21wb25lbnQtaW5kZXhvZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmVlbi1tZXNhLWRvbS9ub2RlX21vZHVsZXMvY29tcG9uZW50LW1hdGNoZXMtc2VsZWN0b3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3JlZW4tbWVzYS1kb20vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1xdWVyeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncmVlbi1tZXNhLWRvbS9ub2RlX21vZHVsZXMvY29tcG9uZW50LXR5cGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3JlZW4tbWVzYS1kb20vbm9kZV9tb2R1bGVzL2dyZWVuLW1lc2EtY3NzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyZWVuLW1lc2EtZG9tL25vZGVfbW9kdWxlcy9ncmVlbi1tZXNhLXRyYXZlcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyZWVuLW1lc2EtZG9tL25vZGVfbW9kdWxlcy9ncmVlbi1tZXNhLXZhbHVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dyZWVuLW1lc2EtZG9tL25vZGVfbW9kdWxlcy90cmltL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pcy1hcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL21hcmtlZC9saWIvbWFya2VkLmpzIiwibm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCJub2RlX21vZHVsZXMvc3ZnLXBhbi16b29tL3NyYy9icm93c2VyaWZ5LmpzIiwibm9kZV9tb2R1bGVzL3N2Zy1wYW4tem9vbS9zcmMvY29udHJvbC1pY29ucy5qcyIsIm5vZGVfbW9kdWxlcy9zdmctcGFuLXpvb20vc3JjL3NoYWRvdy12aWV3cG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9zdmctcGFuLXpvb20vc3JjL3N2Zy1wYW4tem9vbS5qcyIsIm5vZGVfbW9kdWxlcy9zdmctcGFuLXpvb20vc3JjL3N2Zy11dGlsaXRpZXMuanMiLCJub2RlX21vZHVsZXMvc3ZnLXBhbi16b29tL3NyYy91bml3aGVlbC5qcyIsIm5vZGVfbW9kdWxlcy9zdmctcGFuLXpvb20vc3JjL3V0aWxpdGllcy5qcyIsIm5vZGVfbW9kdWxlcy90ZXJtLmpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rlcm0uanMvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rlcm0uanMvc3JjL3Rlcm0uanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9PQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6N0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25uQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ24wRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcjlCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqcEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDajNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ256Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25zQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4dkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWdHQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3B0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xSQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwidmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xuXG52YXIgYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbG9nIDogZnVuY3Rpb24gKHN0cil7XG4gICAgYm94LmlubmVySFRNTCArPSBcIjxwPjxlbT5cIiArIG1vbWVudCgpLmZvcm1hdCgnaDptbTpzcyBhJykrXCI8L2VtPjogXCIgKyBzdHIgKyBcIjwvcD5cIjtcbiAgICBib3gucGFyZW50Tm9kZS5zY3JvbGxUb3AgPSBib3gucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHQ7XG4gIH0sXG4gIGVycm9yIDogZnVuY3Rpb24gKHN0cil7XG4gICAgYm94LmlubmVySFRNTCArPSBcIjxwIGNsYXNzPSdlcnJvcic+PGVtPlwiICsgbW9tZW50KCkuZm9ybWF0KCdoOm1tOnNzIGEnKStcIjwvZW0+OiBcIiArIHN0ciArIFwiPC9wPlwiO1xuICAgIGJveC5wYXJlbnROb2RlLnNjcm9sbFRvcCA9IGJveC5wYXJlbnROb2RlLnNjcm9sbEhlaWdodDsgXG4gIH0sXG4gIGFwcGVuZFRvIDogZnVuY3Rpb24gKGVsZW1lbnQpe1xuXG4gICAgZWxlbWVudC5hcHBlbmRDaGlsZChib3gpO1xuICAgIGVsZW1lbnQuc3R5bGUuT3ZlcmZsb3dZID0gXCJzY3JvbGxcIjtcbiAgICBlbGVtZW50LnN0eWxlLk92ZXJmbG93WCA9IFwiaGlkZGVuXCI7XG5cbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzLmVsZW1lbnQgPSBib3g7XG5cbiIsIi8qXG4gIFxuICBTaW1wbGUgd3JhcHBlciBhcm91bmQgQUNFLiBJdCB0cmlnZ2VycyAnc2F2ZScgc2lnbmFscyBhbmQgY2FuIG9ubHkgZWRpdCBvbmUgdGhpbmcgYXQgb25jZS5cbiAgU29tZXRoaW5nIGVsc2UgbmVlZHMgdG8gZGVhbCB3aXRoIHVwZGF0aW5nIHRoaXMuXG5cbiovXG5cbnZhciBhY2UgPSByZXF1aXJlKCdicmFjZScpO1xucmVxdWlyZSgnYnJhY2UvbW9kZS9qc29uJyk7XG5yZXF1aXJlKCdicmFjZS9tb2RlL2phdmFzY3JpcHQnKTtcbnJlcXVpcmUoJ2JyYWNlL21vZGUvbWFya2Rvd24nKTtcbnJlcXVpcmUoJ2JyYWNlL3RoZW1lL21vbm9rYWknKTtcblxudmFyIGRvbSA9IHJlcXVpcmUoJ2dyZWVuLW1lc2EtZG9tJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCwgY29udGVudFZpZXcpe1xuXG4gIHZhciBlbWl0dGVyID0gbmV3IChyZXF1aXJlKCdldmVudHMnKSkuRXZlbnRFbWl0dGVyKCk7XG5cbiAgdmFyICRlbGVtZW50ID0gZG9tKCc8ZGl2PjwvZGl2PicpO1xuXG4gICRlbGVtZW50LmNzcyh7XG4gICAgZGlzcGxheSA6ICdub25lJyxcbiAgICB3aWR0aCA6IGNvbnRlbnRWaWV3LnNpemUoKS54ICsgXCJweFwiLFxuICAgIGhlaWdodCA6IGNvbnRlbnRWaWV3LnNpemUoKS55ICsgXCJweFwiLFxuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcCA6ICcwcHgnLFxuICAgIGxlZnQgOiAnMHB4J1xuICB9KTtcblxuXG4gIGNvbnRlbnRWaWV3LmFkZEVsZW1lbnQoJGVsZW1lbnQuZWxzWzBdKTtcbiAgXG4gIGFwcC5sYXlvdXQub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KXtcblxuICAgIC8vIGZvciB0aGlzIHRvIHdvcmsgd2UnbGwgaGF2ZSB0byBnbyB0aHJvdWdoIGFuZCBmaW5kIGFsbCB0aGUgZWRpdG9yIGluc3RhbmNlcy4gXG4gICAgLy8gYW5kIGNhbGwgcmVzaXplLi4uIFxuICAgIGZvciAodmFyIGlkIGluIGVkaXRTZXNzaW9ucyl7XG4gICAgICBpZiAoZWRpdFNlc3Npb25zLmhhc093blByb3BlcnR5KGlkKSl7XG4gICAgICAgIGVkaXRTZXNzaW9uc1tpZF0uJGNvbnRhaW5lci5jc3Moe1xuICAgICAgICAgIHdpZHRoOiBjb250ZW50Vmlldy5zaXplKCkueCArIFwicHhcIixcbiAgICAgICAgICBoZWlnaHQgOiBjb250ZW50Vmlldy5zaXplKCkueSArIFwicHhcIlxuICAgICAgICB9KTtcbiAgICAgICAgZWRpdFNlc3Npb25zW2lkXS5lZGl0b3IucmVzaXplKCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIHZhciBlZGl0U2Vzc2lvbnMgPSB7fTtcbiAgLy8gd2Uga2VlcCBhIHRyYWNrIG9mIHdoaWNoIHNlc3Npb24gaXMgYWN0aXZlIHNvIHRoYXQgaWYgdGhlIGdsb2JhbCAnc2F2ZSBlbnRpdHknIHNpZ25hbCBjb21lcyBhbG9uZywgXG4gIC8vIHdlIGtub3cgaWYgdGhlIGVkaXRvciBpcyBhY3RpdmUgYW5kIHRoYXQgdGhlIHVzZXIgd2lzaGVzIHRvIHNhdmUgdGhlaXIgd29yay5cbiAgdmFyIGN1cnJlbnRTZXNzaW9uID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZmluZFNlc3Npb25zIChwYXRoKXtcbiAgICBmb3IgKHZhciBzZXNzaW9uIGluIGVkaXRTZXNzaW9ucyl7XG4gICAgICBpZiAoZWRpdFNlc3Npb25zLmhhc093blByb3BlcnR5KHNlc3Npb24pKXtcbiAgICAgICAgaWYgKGVkaXRTZXNzaW9uc1tzZXNzaW9uXS5lbnRpdHkucGF0aCA9PT0gcGF0aCl7XG4gICAgICAgICAgcmV0dXJuIGVkaXRTZXNzaW9uc1tzZXNzaW9uXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFwcC5vbignZW50aXR5LXVwZGF0ZWQnLCBmdW5jdGlvbiAodHlwZSwgcGF0aCl7XG5cbiAgICAvLyBsZXQncyBhdHRlbXB0IHRvIG1hdGNoIHRoaXMgcGF0aCB0byBhIHNlc3Npb24uLlxuICAgIHZhciBzZXNzaW9uID0gZmluZFNlc3Npb25zKHBhdGgpO1xuICAgIC8vaWYgKGN1cnJlbnRTZXNzaW9uKXtcblxuICAgIGlmIChzZXNzaW9uKXtcblxuICAgICAgaWYgKHR5cGUgPT09IFwidXBkYXRlXCIpe1xuICAgICAgICAvLyBsZXQncyBsb2FkIHRoZSBmaWxlLi4uIEFMVEhPVUdIIGF0IHRoaXMgcG9pbnQgaXQncyBoaWdobHkgbGlrZWx5IHRoYXQgdGhlIGVudGl0eSBkYXRhIGlzIG91dCBvZiBkYXRlLi4uXG4gICAgICAgIGFwcC52ZnMucmVhZEZpbGUocGF0aCwgZnVuY3Rpb24gKGVyciwgZW50aXR5LCBib2R5KXtcblxuICAgICAgICAgICAgICAvLyBva2F5LCBmaXJzdCBvZiBhbGwsIGxldCdzIHNlZSBpZiB0aGUgdXNlciBoYXMgYW55IGxvY2FsIGNoYW5nZXM6XG4gICAgICAgICAgaWYgKHNlc3Npb24uYm9kaWVzLnVzZXIgPT09IHNlc3Npb24uYm9kaWVzLnBlcnNpc3RlZCl7XG4gICAgICAgICAgICAvLyBuby4gVGhleSBkb24ndCBoYXZlIGFueSBjaGFuZ2VzLiBUaGVyZWZvcmUgd2Ugd2lsbCBqdXN0IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGVtIHRvIHRoaXMgbGF0ZXN0IHZlcnNpb24gZnJvbSB0aGUgc2VydmVyLlxuICAgICAgICAgICAgc2Vzc2lvbi5ib2RpZXMuY29uZmxpY3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHNlc3Npb24uYm9kaWVzLnBlcnNpc3RlZCA9IHNlc3Npb24uYm9kaWVzLnVzZXIgPSBib2R5O1xuXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgc2Vzc2lvbi5ib2RpZXMucGVyc2lzdGVkID0gYm9keTtcbiAgICAgICAgICAgIHNlc3Npb24uYm9kaWVzLmNvbmZsaWN0ID0gKGJvZHkgIT09IHNlc3Npb24uYm9kaWVzLnNhdmluZyk7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2Vzc2lvbi5ib2RpZXMudXNlciA9PT0gc2Vzc2lvbi5ib2RpZXMucGVyc2lzdGVkKXtcbiAgICAgICAgICAgIGFwcC5lbWl0KCdzZXNzaW9uLXN5bmNocm9uaXNlZCcsIHNlc3Npb24uZW50aXR5Ll9zZXNzaW9uSWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHAuZW1pdCgnc2Vzc2lvbi1kZXN5bmNocm9uaXNlZCcsIHNlc3Npb24uZW50aXR5Ll9zZXNzaW9uSWQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbiAmJiBjdXJyZW50U2Vzc2lvbi5lbnRpdHkuX3Nlc3Npb25JZCA9PT0gc2Vzc2lvbi5lbnRpdHkuX3Nlc3Npb25JZCl7XG4gICAgICAgICAgICBlbWl0dGVyLnJlc3VtZShzZXNzaW9uLmVudGl0eSk7XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgfSk7XG5cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJkZWxldGVcIil7XG5cbiAgICAgICAgc2Vzc2lvbi5ib2RpZXMucGVyc2lzdGVkID0gXCJcIjtcbiAgICAgICAgaWYgKGN1cnJlbnRTZXNzaW9uICYmIGN1cnJlbnRTZXNzaW9uLmVudGl0eS5fc2Vzc2lvbklkID09PSBzZXNzaW9uLmVudGl0eS5fc2Vzc2lvbklkKXtcbiAgICAgICAgICBlbWl0dGVyLnJlc3VtZShzZXNzaW9uLmVudGl0eSk7XG4gICAgICAgICAgYXBwLmVtaXQoJ3Nlc3Npb24tZGVzeW5jaHJvbmlzZWQnLCBzZXNzaW9uLmVudGl0eS5fc2Vzc2lvbklkKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvL31cblxuICB9KTtcblxuYXBwLm9uKCdlbnRpdHktcmVuYW1lZCcsIGZ1bmN0aW9uICh0eXBlLCBwYXRoLCBvbGRQYXRoKXtcblxuICB2YXIgc2Vzc2lvbiA9IGZpbmRTZXNzaW9ucyhvbGRQYXRoKTtcblxuICBpZiAoc2Vzc2lvbil7XG5cbiAgICBkZWJ1Z2dlcjtcblxuICB9XG5cbn0pO1xuXG4gIGFwcC5vbignc2F2ZS1lbnRpdHknLCBmdW5jdGlvbiAoKXtcblxuICAgIC8vIHdlIG9ubHkgd2FudCB0byBzYXZlIGlmIHdlJ3JlIHRoZSBhY3RpdmUgc2Vzc2lvbi4uLlxuICAgIGlmIChjdXJyZW50U2Vzc2lvbiAmJiAhY3VycmVudFNlc3Npb24uc3luY2hyb25pc2VkKXtcblxuICAgICAgY3VycmVudFNlc3Npb24uY3Vyc29yID0gY3VycmVudFNlc3Npb24uZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG5cbiAgICAgIGFwcC5lbWl0KCdzZXNzaW9uLXN5bmNocm9uaXNpbmcnLCBjdXJyZW50U2Vzc2lvbi5lbnRpdHkuX3Nlc3Npb25JZCk7XG5cbiAgICAgIHZhciBzYXZlU2Vzc2lvbiA9IGN1cnJlbnRTZXNzaW9uO1xuXG4gICAgICBjdXJyZW50U2Vzc2lvbi5ib2RpZXMuc2F2aW5nID0gY3VycmVudFNlc3Npb24uYm9kaWVzLnVzZXI7XG4gICAgICBhcHAudmZzLndyaXRlRmlsZShjdXJyZW50U2Vzc2lvbi5lbnRpdHkucGF0aCwgY3VycmVudFNlc3Npb24uYm9kaWVzLnVzZXIsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlKXtcbiAgICAgICAgXG4gICAgICAgIHNhdmVTZXNzaW9uLmJvZGllcy5wZXJzaXN0ZWQgPSBzYXZlU2Vzc2lvbi5ib2RpZXMuc2F2aW5nO1xuICAgICAgICAvL2lmIChzYXZlU2Vzc2lvbi5ib2RpZXMucGVyc2lzdGVkID09PSBzYXZlU2Vzc2lvbi5ib2RpZXMudXNlcil7XG4gICAgICAgIC8vICBhcHAuZW1pdCgnc2Vzc2lvbi1zeW5jaHJvbmlzZWQnLCBzYXZlU2Vzc2lvbi5lbnRpdHkuX3Nlc3Npb25JZCk7XG4gICAgICAgIC8vfVxuICAgICAgICAvLyBzZW5kICduZXcnIGFuZCAnb2xkJ1xuICAgICAgICAvL2FwcC5lbWl0KCdlbnRpdHktdXBkYXRlZCcsICd1cGRhdGUnLCBzYXZlU2Vzc2lvbi5lbnRpdHkucGF0aCk7XG5cbiAgICAgIH0pO1xuICAgIH1cblxuICB9KTtcblxuXG5cbiAgZW1pdHRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVFZGl0U2Vzc2lvbiAoZW50aXR5LCBjYWxsYmFjayl7XG5cbiAgICB2YXIgc2Vzc2lvbiA9IGVkaXRTZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF0gPSB7XG4gICAgICBlbnRpdHkgOiBlbnRpdHksXG4gICAgICBib2RpZXMgOiB7fSxcbiAgICAgIHN5bmNocm9uaXNlZCA6IGZhbHNlXG4gICAgfTtcblxuICAgIHZhciAkY29udGFpbmVyID0gZG9tKCc8ZGl2PjwvZGl2PicpO1xuICAgICRjb250YWluZXIuY3NzKHtcbiAgICAgIHBvc2l0aW9uIDogJ2Fic29sdXRlJyxcbiAgICAgIHRvcCA6ICcwcHgnLFxuICAgICAgbGVmdCA6ICcwcHgnLFxuICAgICAgd2lkdGggOiBjb250ZW50Vmlldy5zaXplKCkueCArIFwicHhcIixcbiAgICAgIGhlaWdodCA6IGNvbnRlbnRWaWV3LnNpemUoKS55ICsgXCJweFwiLFxuICAgICAgZGlzcGxheSA6ICdub25lJ1xuICAgIH0pO1xuXG4gICAgc2Vzc2lvbi4kY29udGFpbmVyID0gJGNvbnRhaW5lcjtcblxuICAgICRlbGVtZW50LmFwcGVuZCgkY29udGFpbmVyKTtcblxuICAgIHZhciBlZGl0b3IgPSBhY2UuZWRpdCgkY29udGFpbmVyLmVsc1swXSk7XG4gICAgZWRpdG9yLnNldFRoZW1lKCdhY2UvdGhlbWUvbW9ub2thaScpO1xuICAgIGVkaXRvci5nZXRTZXNzaW9uKCkuc2V0VXNlV3JhcE1vZGUodHJ1ZSk7XG4gICAgZWRpdG9yLnNldFNob3dQcmludE1hcmdpbihmYWxzZSk7XG5cbiAgICBlZGl0b3Iub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpe1xuXG4gICAgICBpZiAoY3VycmVudFNlc3Npb24pe1xuICAgICAgICBjdXJyZW50U2Vzc2lvbi5ib2RpZXMudXNlciA9IGVkaXRvci5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAoY3VycmVudFNlc3Npb24uc3luY2hyb25pc2VkICYmIGN1cnJlbnRTZXNzaW9uLmJvZGllcy51c2VyICE9PSBjdXJyZW50U2Vzc2lvbi5ib2RpZXMucGVyc2lzdGVkKXtcbiAgICAgICAgICBjdXJyZW50U2Vzc2lvbi5zeW5jaHJvbmlzZWQgPSBmYWxzZTtcbiAgICAgICAgICBhcHAuZW1pdCgnc2Vzc2lvbi1kZXN5bmNocm9uaXNlZCcsIGN1cnJlbnRTZXNzaW9uLmVudGl0eS5fc2Vzc2lvbklkKTtcbiAgICAgICAgfSBlbHNlIGlmICghY3VycmVudFNlc3Npb24uc3luY2hyb25pc2VkICYmIChjdXJyZW50U2Vzc2lvbi5ib2RpZXMudXNlciA9PT0gY3VycmVudFNlc3Npb24uYm9kaWVzLnBlcnNpc3RlZCkpe1xuICAgICAgICAgIGN1cnJlbnRTZXNzaW9uLnN5bmNocm9uaXNlZCA9IHRydWU7XG4gICAgICAgICAgYXBwLmVtaXQoJ3Nlc3Npb24tc3luY2hyb25pc2VkJywgY3VycmVudFNlc3Npb24uZW50aXR5Ll9zZXNzaW9uSWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9KTtcblxuICAgIHNlc3Npb24uZWRpdG9yID0gZWRpdG9yO1xuXG4gICAgYXBwLmVtaXQoJ3Nlc3Npb24tc3luY2hyb25pc2luZycsIGVudGl0eS5fc2Vzc2lvbklkKTtcblxuICAgIGFwcC52ZnMucmVhZEZpbGUoZW50aXR5LnBhdGgsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlLCBib2R5KXtcblxuICAgICAgaWYgKGVycil7XG4gICAgICAgIGNhbGxiYWNrIChmYWxzZSwgZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBzZXNzaW9uLmJvZGllcy5wZXJzaXN0ZWQgPSBzZXNzaW9uLmJvZGllcy51c2VyID0gIGJvZHk7XG4gICAgICBzZXNzaW9uLmJvZGllcy5zYXZpbmcgPSBmYWxzZTtcblxuICAgICAgYXBwLmVtaXQoJ3Nlc3Npb24tc3luY2hyb25pc2VkJywgZW50aXR5Ll9zZXNzaW9uSWQpO1xuXG4gICAgICBzZXNzaW9uLnN5bmNocm9uaXNlZCA9IHRydWU7XG5cbiAgICAgIGNhbGxiYWNrKHRydWUpO1xuXG4gICAgfSk7XG5cbiAgfVxuXG4gIGVtaXR0ZXIucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lRWRpdFNlc3Npb24gKGVudGl0eSl7XG5cbiAgICBjdXJyZW50U2Vzc2lvbiA9IGVkaXRTZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF07XG5cbiAgICBpZiAoIWN1cnJlbnRTZXNzaW9uKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFNlc3Npb24uZW50aXR5Lm1pbWUgPT09IFwidGV4dC94LW1hcmtkb3duXCIpe1xuICAgICAgY3VycmVudFNlc3Npb24uZWRpdG9yLmdldFNlc3Npb24oKS5zZXRNb2RlKCdhY2UvbW9kZS9tYXJrZG93bicpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFNlc3Npb24uZW50aXR5Lm1pbWUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKXtcbiAgICAgIGN1cnJlbnRTZXNzaW9uLmVkaXRvci5nZXRTZXNzaW9uKCkuc2V0TW9kZSgnYWNlL21vZGUvanNvbicpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudFNlc3Npb24uZW50aXR5Lm1pbWUgPT09IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiKXtcbiAgICAgIGN1cnJlbnRTZXNzaW9uLmVkaXRvci5nZXRTZXNzaW9uKCkuc2V0TW9kZSgnYWNlL21vZGUvamF2YXNjcmlwdCcpO1xuICAgIH1cblxuICAgIGN1cnJlbnRTZXNzaW9uLiRjb250YWluZXIuY3NzKHtcbiAgICAgIGRpc3BsYXkgOiAnJ1xuICAgIH0pXG5cbiAgICBjdXJyZW50U2Vzc2lvbi5lZGl0b3Iuc2V0VmFsdWUoY3VycmVudFNlc3Npb24uYm9kaWVzLnVzZXIsIDEpO1xuICAgIGlmIChjdXJyZW50U2Vzc2lvbi5jdXJzb3Ipe1xuICAgICAgY3VycmVudFNlc3Npb24uZWRpdG9yLm1vdmVDdXJzb3JUb1Bvc2l0aW9uKGN1cnJlbnRTZXNzaW9uLmN1cnNvcik7XG4gICAgfVxuICAgIGN1cnJlbnRTZXNzaW9uLmVkaXRvci5mb2N1cygpO1xuXG4gICAgJGVsZW1lbnQuY3NzKHtcbiAgICAgIGRpc3BsYXkgOiAnJ1xuICAgIH0pXG5cbiAgfVxuXG4gIGVtaXR0ZXIucGF1c2UgPSBmdW5jdGlvbiBwYXVzZUVkaXRTZXNzaW9uIChlbnRpdHkpe1xuXG4gICAgdmFyIHNlc3Npb24gPSBlZGl0U2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdO1xuICAgIHNlc3Npb24uY3Vyc29yID0gc2Vzc2lvbi5lZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcblxuICAgIHNlc3Npb24uJGNvbnRhaW5lci5jc3Moe1xuICAgICAgZGlzcGxheSA6ICdub25lJ1xuICAgIH0pO1xuXG4gICAgY3VycmVudFNlc3Npb24gPSBmYWxzZTtcblxuXG4gICAgJGVsZW1lbnQuY3NzKHtcbiAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgIH0pO1xuXG5cbiAgfVxuXG4gIGVtaXR0ZXIuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3lFZGl0U2Vzc2lvbiAoZW50aXR5LCBjYWxsYmFjayl7XG5cbiAgICAvLyB0aGlzIGlzIHdoZXJlIHdlIGZpZ3VyZSBvdXQgd2hldGhlciBpdCdzIG9rYXkgdG8gY2xvc2UgdGhpcyB0aGluZy4uLlxuICAgIHZhciBzZXNzaW9uID0gZWRpdFNlc3Npb25zW2VudGl0eS5fc2Vzc2lvbklkXTtcblxuXG4gICAgaWYgKCFzZXNzaW9uKXtcblxuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAoc2Vzc2lvbi5ib2RpZXMucGVyc2lzdGVkICE9PSBzZXNzaW9uLmJvZGllcy51c2VyKXtcbiAgICAgICAgdmFyIGNsb3NlID0gY29uZmlybSgnWW91IGhhdmUgdW5zYXZlZCBjaGFuZ2VzISBDbG9zZSBhbnl3YXk/Jyk7XG5cbiAgICAgICAgaWYgKCFjbG9zZSl7XG4gICAgICAgICAgY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXNzaW9uLmVkaXRvci5kZXN0cm95KCk7XG4gICAgICBzZXNzaW9uLiRjb250YWluZXIucmVtb3ZlKCk7XG5cbiAgICAgIGVkaXRTZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF0gPSBudWxsO1xuICAgICAgZGVsZXRlIGVkaXRTZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF07XG4gICAgICBcbiAgICAgICRlbGVtZW50LmNzcyh7XG4gICAgICAgIGRpc3BsYXkgOiAnbm9uZSdcbiAgICAgIH0pO1xuICAgICAgY2FsbGJhY2sodHJ1ZSk7XG5cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBlbWl0dGVyO1xuXG59IiwidmFyIGRvbSA9IHJlcXVpcmUoJ2dyZWVuLW1lc2EtZG9tJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCwgY29udGVudFZpZXcpe1xuXG4gIC8qXG4gIHZhciB0ZXJtID0gbmV3IFRlcm1pbmFsKHtcbiAgICBjb2xzOiA4MCxcbiAgICByb3dzOiAyNCxcbiAgICBzY3JlZW5LZXlzOiB0cnVlXG4gIH0pO1xuKi9cblxuICB2YXIgJGVsZW1lbnQgPSBkb20oJzxkaXY+PC9kaXY+Jyk7XG5cbiAgdmFyIHJ1blQgPSBmdW5jdGlvbihvKXtcbiAgICByZXR1cm4gW1xuICAgICAgJzxkaXYgY2xhc3M9XCJlZGl0LWZpbGUtaW5mb1wiPicsXG4gICAgICAnPGZvcm0gY2xhc3M9XCJlZGl0XCI+JyxcbiAgICAgICc8ZmllbGRzZXQ+JyxcbiAgICAgICc8bGVnZW5kPlJ1biBjb21tYW5kPC9sZWdlbmQ+JyxcbiAgICAgICc8dWw+JyxcbiAgICAgICc8bGk+PGxhYmVsPk5hbWU6PC9sYWJlbD48aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwiY29tbWFuZFwiIHZhbHVlPVwiXCIgcGxhY2Vob2xkZXI9XCJDb21tYW5kIHRvIHJ1biBvbiB0aGUgc2VydmVyXCI+PC9pbnB1dD48L2xpPicsXG4gICAgICAnPGxpPjxsYWJlbD48L2xhYmVsPjxidXR0b24+UnVuPC9idXR0b24+PC9saT4nLFxuICAgICAgJzwvdWw+JyxcbiAgICAgICc8L2ZpZWxkc2V0PicsXG4gICAgICAnPC9mb3JtPicsXG4gICAgICAnPGRpdiBjbGFzcz1cIm91dHB1dFwiPjwvZGl2PicsXG4gICAgICAnPC9kaXY+J1xuICAgIF0uam9pbignXFxuJyk7XG5cbiAgfTtcblxuXG4gICRlbGVtZW50LmFkZENsYXNzKCdjb21tYW5kcycpO1xuICAkZWxlbWVudC5jc3Moe1xuICAgIGRpc3BsYXkgOiAnbm9uZScsXG4gICAgJ21pbi13aWR0aCcgOiBjb250ZW50Vmlldy5zaXplKCkueCArICdweCcsXG4gICAgJ21pbi1oZWlnaHQnIDogY29udGVudFZpZXcuc2l6ZSgpLnkgKyAncHgnLFxuICAgIHBvc2l0aW9uIDogJ2Fic29sdXRlJyxcbiAgICB0b3AgOiAwLFxuICAgIGxlZnQgOiAwXG4gIH0pO1xuXG4gICRlbGVtZW50LmFwcGVuZFRvKGNvbnRlbnRWaWV3LmVsZW1lbnQpO1xuXG4gIHZhciBjb21tYW5kU2Vzc2lvbnMgPSB7fTtcblxuICB2YXIgY29tbWFuZHMgPSB7fTtcblxuICAvL3Rlcm0ub3BlbigkZWxlbWVudC5lbHNbMF0pO1xuXG4gIGFwcC5vbignY29tbWFuZC1zdGRvdXQnLCBmdW5jdGlvbiAobyl7XG5cbiAgICAvLyBhY3R1YWxseSB0aGlzIGlzIFxuICAgIGlmIChjb21tYW5kU2Vzc2lvbnNbby5pZF0pIGNvbW1hbmRTZXNzaW9uc1tvLmlkXS4kZWwuYXBwZW5kKCc8cHJlPicgKyBvLnBhY2tldCArICc8L3ByZT4nKTtcblxuXG4gIH0pO1xuXG4gIGFwcC5vbignY29tbWFuZC1zdGRlcnInLCBmdW5jdGlvbiAobyl7XG5cbiAgICAvLyBhY3R1YWxseSB0aGlzIGlzIFxuICAgIGlmIChjb21tYW5kU2Vzc2lvbnNbby5pZF0pIGNvbW1hbmRTZXNzaW9uc1tvLmlkXS4kZWwuYXBwZW5kKCc8cHJlIGNsYXNzPVwiZXJyb3JcIj4nICsgby5wYWNrZXQgKyAnPC9wcmU+Jyk7XG5cbiAgfSk7XG5cbiAgYXBwLm9uKCdjb21tYW5kLWNsb3NlJywgZnVuY3Rpb24gKG8pe1xuICAgIGlmIChjb21tYW5kU2Vzc2lvbnNbby5pZF0pIGNvbW1hbmRTZXNzaW9uc1tvLmlkXS4kZWwuYXBwZW5kKCc8cD5Db21wbGV0ZWQgd2l0aCBlcnJvciBjb2RlICcgKyBvLnBhY2tldCArICc8L3A+Jyk7XG4gIH0pO1xuXG4gIHZhciByZXF1ZXN0SWQgPSAwO1xuXG4gIGFwcC5sYXlvdXQub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KXtcblxuICAgICRlbGVtZW50LmNzcyh7XG4gICAgICAnbWluLXdpZHRoJyA6IGNvbnRlbnRWaWV3LnNpemUoKS54ICsgJ3B4JyxcbiAgICAgICdtaW4taGVpZ2h0JyA6IGNvbnRlbnRWaWV3LnNpemUoKS55ICsgJ3B4JyxcbiAgICB9KTtcblxuICB9KTtcblxuXG4gIHZhciBlbWl0dGVyID0ge307XG5cbiAgZW1pdHRlci5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGVDb21tYW5kU2Vzc2lvbiAoZW50aXR5LCBjYWxsYmFjayl7XG5cbiAgICB2YXIgc2Vzc2lvbiA9IGNvbW1hbmRTZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF0gPSB7XG4gICAgICBlbnRpdHkgOiBlbnRpdHlcbiAgICB9XG5cbiAgICBzZXNzaW9uLiRlbCA9IGRvbShydW5UKCkpO1xuICAgICRlbGVtZW50LmFwcGVuZChzZXNzaW9uLiRlbCk7XG5cbiAgICBzZXNzaW9uLiRlbC5jc3MoeyBkaXNwbGF5OiAnbm9uZSd9KTtcblxuICAgIGFwcC5lbWl0KCdzZXNzaW9uLXN5bmNocm9uaXNlZCcsIGVudGl0eS5fc2Vzc2lvbklkKTtcbiAgICAvKlxuXG4qL1xuXG4gICAgZG9tKCdmb3JtJywgc2Vzc2lvbi4kZWwpLm9uKCdzdWJtaXQnLCBmdW5jdGlvbiAoZSl7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIGNvbW1hbmQgPSBkb20oJ2lucHV0W25hbWU9XCJjb21tYW5kXCJdJywgc2Vzc2lvbi4kZWwpLnZhbCgpO1xuXG4gICAgICBpZiAoY29tbWFuZCAhPT0gXCJcIil7XG5cbiAgICAgICAgc2Vzc2lvbi4kZWwucmVtb3ZlKCk7XG4gICAgICAgIHNlc3Npb24uJGVsID0gZG9tKCc8ZGl2IGNsYXNzPVwib3V0cHV0XCI+PC9kaXY+Jyk7XG4gICAgICAgICRlbGVtZW50LmFwcGVuZChzZXNzaW9uLiRlbCk7XG5cbiAgICAgICAgYXBwLnJlbW90ZVNlbmQoJ3J1bi1jb21tYW5kJywge1xuICAgICAgICAgIGlkIDogZW50aXR5Ll9zZXNzaW9uSWQsXG4gICAgICAgICAgY21kIDogY29tbWFuZFxuICAgICAgICB9KTtcblxuICAgICAgfVxuXG4gICAgfSlcblxuICAgIGNhbGxiYWNrKHRydWUpO1xuXG4gIH1cblxuICBlbWl0dGVyLnBhdXNlID0gZnVuY3Rpb24gcGF1c2VDb21tYW5kU2Vzc2lvbiAoZW50aXR5KXtcblxuICAgIHZhciBzZXNzaW9uID0gY29tbWFuZFNlc3Npb25zW2VudGl0eS5fc2Vzc2lvbklkXTtcblxuICAgIHNlc3Npb24uJGVsLmNzcyh7XG4gICAgICBkaXNwbGF5IDogJ25vbmUnXG4gICAgfSk7XG5cbiAgICAvLyBoaWRlcyB0aGUgbWFpbiB0ZXJtaW5hbHMgZWRpdG9yLi5cbiAgICAkZWxlbWVudC5jc3Moe1xuICAgICAgZGlzcGxheSA6ICdub25lJyxcbiAgICB9KTtcblxuXG4gIH1cblxuICBlbWl0dGVyLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZUNvbW1hbmRTZXNzaW9uIChlbnRpdHkpe1xuXG4gICAgdmFyIHNlc3Npb24gPSBjb21tYW5kU2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdO1xuXG4gICAgc2Vzc2lvbi4kZWwuY3NzKHtcbiAgICAgIGRpc3BsYXkgOiAnJ1xuICAgIH0pO1xuXG4gICAgJGVsZW1lbnQuY3NzKHtcbiAgICAgIGRpc3BsYXkgOiAnJ1xuICAgIH0pO1xuXG4gIH1cblxuICBlbWl0dGVyLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95Q29tbWFuZFNlc3Npb24gKGVudGl0eSwgY2FsbGJhY2spe1xuXG4gICAgdmFyIHNlc3Npb24gPSBjb21tYW5kU2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdO1xuXG4gICAgc2Vzc2lvbi4kZWwucmVtb3ZlKCk7XG5cbiAgICBhcHAucmVtb3RlU2VuZCgndGVybWluYXRlLWNvbW1hbmQnLCBlbnRpdHkuX3Nlc3Npb25JZCk7XG5cbiAgICBjb21tYW5kU2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdID0gbnVsbDtcblxuICAgIGRlbGV0ZSBjb21tYW5kU2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdO1xuXG4gICAgJGVsZW1lbnQuY3NzKHtcbiAgICAgIGRpc3BsYXkgOiAnbm9uZScsXG4gICAgfSk7XG4gICAgLy8gY2FsbGJhY2sgdHJ1ZSA9IG9rYXkgdG8gZGVzdHJveSB0aGlzIHNlc3Npb24uLi5cbiAgICBjYWxsYmFjayh0cnVlKTtcblxuICB9XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG5cbn0iLCJ2YXIgZG9tID0gcmVxdWlyZSgnZ3JlZW4tbWVzYS1kb20nKTtcbnZhciBlYWNoID0gcmVxdWlyZSgnZm9yZWFjaCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHAsIGNvbnRlbnRWaWV3KXtcblxuICAvKlxuICB2YXIgdGVybSA9IG5ldyBUZXJtaW5hbCh7XG4gICAgY29sczogODAsXG4gICAgcm93czogMjQsXG4gICAgc2NyZWVuS2V5czogdHJ1ZVxuICB9KTtcbiovXG5cbiAgdmFyICRlbGVtZW50ID0gZG9tKCc8ZGl2PjwvZGl2PicpO1xuXG4gIHZhciBzdGFnaW5nID0gZnVuY3Rpb24gKCl7XG5cbiAgICByZXR1cm4gW1xuICAgICAgJzxkaXYgY2xhc3MgPVwib3V0cHV0XCI+JyxcbiAgICAgICc8Zm9ybT4nLFxuICAgICAgICAnPHRhYmxlPicsXG4gICAgICAgICAgJzx0aGVhZD4nLFxuICAgICAgICAgICAgJzx0cj4nLFxuICAgICAgICAgICAgICAnPHRoPkNvbW1pdD88L3RoPicsXG4gICAgICAgICAgICAgICc8dGg+RmlsZTwvdGg+JyxcbiAgICAgICAgICAgICAgJzx0aD5DaGFuZ2U8L3RoPicsXG4gICAgICAgICAgICAnPC90cj4nLFxuICAgICAgICAgICc8L3RoZWFkPicsXG4gICAgICAgICAgJzx0Ym9keT4nLFxuICAgICAgICAgICc8L3Rib2R5PicsXG4gICAgICAgICc8L3RhYmxlPicsXG4gICAgICAgICc8dWw+JyxcbiAgICAgICAgJzxsaT48bGFiZWw+Q29tbWl0IG1lc3NhZ2U8L2xhYmVsPjwvbGk+JyxcbiAgICAgICAgJzxsaT48dGV4dGFyZWEgbmFtZT1cImNvbW1pdC1tZXNzYWdlXCI+PC90ZXh0YXJlYT48L2xpPicsXG4gICAgICAgICc8bGk+PGJ1dHRvbj5Db21taXQ8L2J1dHRvbj48L2xpPicsXG4gICAgICAgICc8L3VsPicsXG4gICAgICAnPC9mb3JtPicsXG4gICAgICAnPC9kaXY+J1xuICAgIF0uam9pbignXFxuJylcblxuICB9XG5cbiAgdmFyIGVudGl0eVQgPSBmdW5jdGlvbiAoZmlsZSwgc3RhdHVzKXtcblxuICAgIHZhciBzdGF0ZSA9IFwiQWRkZWRcIjtcblxuICAgIC8qXG4gICAgICAnICcgPSB1bm1vZGlmaWVkXG5cbiAgICAgIE0gPSBtb2RpZmllZFxuXG4gICAgICBBID0gYWRkZWRcblxuICAgICAgRCA9IGRlbGV0ZWRcblxuICAgICAgUiA9IHJlbmFtZWRcblxuICAgICAgQyA9IGNvcGllZFxuXG4gICAgICBVID0gdXBkYXRlZCBidXQgdW5tZXJnZWRcbiAgICAqL1xuXG4gICAgaWYgKHR5cGVvZiBzdGF0dXMudHlwZSAhPSBcInVuZGVmaW5lZFwiKXtcblxuICAgICAgc3dpdGNoIChzdGF0dXMudHlwZSl7XG5cbiAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICBzdGF0ZSA9IFwiVW5tb2RpZmllZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgIHN0YXRlID0gXCJNb2RpZmllZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQVwiOlxuICAgICAgICAgIHN0YXRlID0gXCJBZGRlZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiUlwiOlxuICAgICAgICAgIHN0YXRlID0gXCJSZW5hbWVkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDXCI6XG4gICAgICAgICAgc3RhdGUgPSBcIkNvcGllZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVVwiOlxuICAgICAgICAgIHN0YXRlID0gXCJVcGRhdGVkIGJ1dCB1bm1lcmdlZFwiXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9XG5cblxuICAgIGRlYnVnZ2VyO1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICc8dHI+JyxcbiAgICAgICc8dGQ+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiIG5hbWU9XCJmaWxlc1wiIHZhbHVlPVwiJyArIGZpbGUucmVwbGFjZSgnXCInLCcnKS50cmltKCkgKycgXCIgY2hlY2tlZD1cImNoZWNrZWRcIj48L2lucHV0PjwvdGQ+JyxcbiAgICAgICc8dGQ+JyArIGZpbGUgKyAnPC90ZD4nLFxuICAgICAgJzx0ZD4nICsgc3RhdGUgKyAnPC90ZD4nLFxuICAgICAgJzwvdHI+J1xuICAgIF0uam9pbignXFxuJyk7XG5cbiAgfVxuXG5cbiAgJGVsZW1lbnQuYWRkQ2xhc3MoJ2NvbW1pdCcpO1xuICAkZWxlbWVudC5jc3Moe1xuICAgIGRpc3BsYXkgOiAnbm9uZScsXG4gICAgJ21pbi13aWR0aCcgOiBjb250ZW50Vmlldy5zaXplKCkueCArICdweCcsXG4gICAgJ21pbi1oZWlnaHQnIDogY29udGVudFZpZXcuc2l6ZSgpLnkgKyAncHgnLFxuICAgIHBvc2l0aW9uIDogJ2Fic29sdXRlJyxcbiAgICB0b3AgOiAwLFxuICAgIGxlZnQgOiAwXG4gIH0pO1xuXG4gICRlbGVtZW50LmFwcGVuZFRvKGNvbnRlbnRWaWV3LmVsZW1lbnQpO1xuXG4gIHZhciBzZXNzaW9ucyA9IHt9O1xuXG4gIC8vdGVybS5vcGVuKCRlbGVtZW50LmVsc1swXSk7XG5cbiAgYXBwLm9uKCdnaXQtc3RhdHVzJywgZnVuY3Rpb24gKG8pe1xuXG4gICAgaWYgKHNlc3Npb25zW28uaWRdKXtcblxuICAgICAgdmFyIHN0YXR1cyA9IG8ucGFja2V0O1xuXG4gICAgICBzZXNzaW9uc1tvLmlkXS5zdGF0dXMgPSBzdGF0dXM7XG5cbiAgICAgIGVhY2goc3RhdHVzLCBmdW5jdGlvbiAoc3RhdHVzLCBmaWxlKXtcblxuICAgICAgICBzZXNzaW9uc1tvLmlkXS4kZWwuZmluZCgndGJvZHknKS5hcHBlbmQoZG9tKGVudGl0eVQoZmlsZSwgc3RhdHVzKSkpO1xuXG4gICAgICB9KTtcblxuICAgIH1cblxuICB9KTtcblxuICBhcHAub24oJ2dpdC1jb21taXQnLCBmdW5jdGlvbiAobyl7XG5cbiAgICBpZiAoc2Vzc2lvbnNbby5pZF0pe1xuXG4gICAgICB2YXIgc3RhdHVzID0gby5wYWNrZXQ7XG5cbiAgICAgIHNlc3Npb25zW28uaWRdLiRlbC5odG1sKCc8cHJlPicgKyBvLnBhY2tldCArICAnPC9wcmU+Jyk7XG5cbiAgICB9XG5cbiAgfSk7XG5cblxuICBhcHAubGF5b3V0Lm9uKCdyZXNpemUnLCBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCl7XG5cbiAgICAkZWxlbWVudC5jc3Moe1xuICAgICAgJ21pbi13aWR0aCcgOiBjb250ZW50Vmlldy5zaXplKCkueCArICdweCcsXG4gICAgICAnbWluLWhlaWdodCcgOiBjb250ZW50Vmlldy5zaXplKCkueSArICdweCcsXG4gICAgfSk7XG5cbiAgfSk7XG5cbiAgdmFyIGVtaXR0ZXIgPSB7fTtcblxuICBlbWl0dGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZUNvbW1hbmRTZXNzaW9uIChlbnRpdHksIGNhbGxiYWNrKXtcblxuICAgIHZhciBzZXNzaW9uID0gc2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdID0ge1xuICAgICAgZW50aXR5IDogZW50aXR5XG4gICAgfVxuXG5cbiAgICAgICAgLy9zZXNzaW9uLiRlbC5yZW1vdmUoKTtcbiAgICBzZXNzaW9uLiRlbCA9IGRvbShzdGFnaW5nKCkpO1xuICAgICRlbGVtZW50LmFwcGVuZChzZXNzaW9uLiRlbCk7XG5cbiAgICBzZXNzaW9uLiRlbC5maW5kKCdmb3JtJykub24oJ3N1Ym1pdCcsIGZ1bmN0aW9uIChlKXtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgZm9ybSA9IGRvbShlLnRhcmdldCk7XG4gICAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgICB2YXIgbXNnID0gZm9ybS5maW5kKCd0ZXh0YXJlYVtuYW1lPVwiY29tbWl0LW1lc3NhZ2VcIl0nKS52YWwoKS50cmltKCk7XG5cbiAgICAgIGlmIChtc2cgIT09IFwiXCIpe1xuXG4gICAgICAgIGVhY2goZS50YXJnZXQuZWxlbWVudHMsIGZ1bmN0aW9uIChlbCl7XG5cbiAgICAgICAgICBlbCA9IGRvbShlbCk7XG5cbiAgICAgICAgICBpZiAoZWwuYXR0cignbmFtZScpID09PSBcImZpbGVzXCIpe1xuICAgICAgICAgICAgbGlzdC5wdXNoKGVsLnZhbCgpLnRyaW0oKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICB9XG5cbiAgICAgIGFwcC5yZW1vdGVTZW5kKCdnaXQtY29tbWl0Jywge1xuICAgICAgICBpZCA6IGVudGl0eS5fc2Vzc2lvbklkLFxuICAgICAgICBtc2cgOiBtc2csXG4gICAgICAgIHN0YWdlIDogbGlzdFxuICAgICAgfSk7XG5cblxuICAgIH0pO1xuXG4gICAgYXBwLnJlbW90ZVNlbmQoJ2dpdC1zdGF0dXMnLCB7XG4gICAgICBpZCA6IGVudGl0eS5fc2Vzc2lvbklkXG4gICAgfSk7XG5cbiAgICBzZXNzaW9uLiRlbC5jc3MoeyBkaXNwbGF5OiAnbm9uZSd9KTtcblxuICAgIGFwcC5lbWl0KCdzZXNzaW9uLXN5bmNocm9uaXNlZCcsIGVudGl0eS5fc2Vzc2lvbklkKTtcblxuXG4gICAgY2FsbGJhY2sodHJ1ZSk7XG5cbiAgfVxuXG4gIGVtaXR0ZXIucGF1c2UgPSBmdW5jdGlvbiBwYXVzZUNvbW1hbmRTZXNzaW9uIChlbnRpdHkpe1xuXG4gICAgdmFyIHNlc3Npb24gPSBzZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF07XG5cbiAgICBzZXNzaW9uLiRlbC5jc3Moe1xuICAgICAgZGlzcGxheSA6ICdub25lJ1xuICAgIH0pO1xuXG4gICAgLy8gaGlkZXMgdGhlIG1haW4gdGVybWluYWxzIGVkaXRvci4uXG4gICAgJGVsZW1lbnQuY3NzKHtcbiAgICAgIGRpc3BsYXkgOiAnbm9uZScsXG4gICAgfSk7XG5cblxuICB9XG5cbiAgZW1pdHRlci5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWVDb21tYW5kU2Vzc2lvbiAoZW50aXR5KXtcblxuICAgIHZhciBzZXNzaW9uID0gc2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdO1xuXG4gICAgc2Vzc2lvbi4kZWwuY3NzKHtcbiAgICAgIGRpc3BsYXkgOiAnJ1xuICAgIH0pO1xuXG4gICAgJGVsZW1lbnQuY3NzKHtcbiAgICAgIGRpc3BsYXkgOiAnJ1xuICAgIH0pO1xuXG4gIH1cblxuICBlbWl0dGVyLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95Q29tbWFuZFNlc3Npb24gKGVudGl0eSwgY2FsbGJhY2spe1xuXG4gICAgdmFyIHNlc3Npb24gPSBzZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF07XG5cbiAgICBzZXNzaW9uLiRlbC5yZW1vdmUoKTtcblxuXG5cbiAgICBzZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF0gPSBudWxsO1xuXG4gICAgZGVsZXRlIHNlc3Npb25zW2VudGl0eS5fc2Vzc2lvbklkXTtcblxuICAgICRlbGVtZW50LmNzcyh7XG4gICAgICBkaXNwbGF5IDogJ25vbmUnLFxuICAgIH0pO1xuICAgIC8vIGNhbGxiYWNrIHRydWUgPSBva2F5IHRvIGRlc3Ryb3kgdGhpcyBzZXNzaW9uLi4uXG4gICAgY2FsbGJhY2sodHJ1ZSk7XG5cbiAgfVxuXG4gIHJldHVybiBlbWl0dGVyO1xuXG59IiwidmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xudmFyIG1vbWVudCA9IHJlcXVpcmUoJ21vbWVudCcpO1xudmFyIGZpbGVzaXplID0gcmVxdWlyZSgnZmlsZXNpemUnKTtcblxudmFyIGRvbSA9IHJlcXVpcmUoJ2dyZWVuLW1lc2EtZG9tJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCwgY29udGVudFZpZXcpe1xuXG4gIHZhciBlbWl0dGVyID0gbmV3IChyZXF1aXJlKCdldmVudHMnKSkuRXZlbnRFbWl0dGVyKCk7XG5cbiAgdmFyICRlbGVtZW50ID0gZG9tKCc8ZGl2PjwvZGl2PicpO1xuXG4gICRlbGVtZW50LmFkZENsYXNzKCdpbmZvJyk7XG4gICRlbGVtZW50LmNzcyh7XG4gICAgZGlzcGxheSA6ICdub25lJyxcbiAgICAnbWluLXdpZHRoJyA6IGNvbnRlbnRWaWV3LnNpemUoKS54ICsgJ3B4JyxcbiAgICAnbWluLWhlaWdodCcgOiBjb250ZW50Vmlldy5zaXplKCkueSArICdweCcsXG4gICAgcG9zaXRpb24gOiAnYWJzb2x1dGUnLFxuICAgIHRvcCA6IDAsXG4gICAgbGVmdCA6IDBcbiAgfSk7XG5cbiAgJGVsZW1lbnQuYXBwZW5kVG8oY29udGVudFZpZXcuZWxlbWVudCk7XG5cbiAgYXBwLmxheW91dC5vbigncmVzaXplJywgZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpe1xuXG4gICAgJGVsZW1lbnQuY3NzKHtcbiAgICAgICdtaW4td2lkdGgnIDogY29udGVudFZpZXcuc2l6ZSgpLnggKyAncHgnLFxuICAgICAgJ21pbi1oZWlnaHQnIDogY29udGVudFZpZXcuc2l6ZSgpLnkgKyAncHgnXG4gICAgfSk7XG5cbiAgfSk7XG5cbiAgdmFyIGZpbGVUID0gZnVuY3Rpb24obyl7XG4gICAgcmV0dXJuIFtcbiAgICAgICc8ZGl2IGNsYXNzPVwiZWRpdC1maWxlLWluZm9cIj4nLFxuICAgICAgJzxmb3JtIGNsYXNzPVwiZWRpdFwiPicsXG4gICAgICAnPGZpZWxkc2V0PicsXG4gICAgICAnPGxlZ2VuZD5Qcm9wZXJ0aWVzPC9sZWdlbmQ+JyxcbiAgICAgICc8dWw+JyxcbiAgICAgICc8bGk+PGxhYmVsPk5hbWU6PC9sYWJlbD48aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwibmFtZVwiIHZhbHVlPVwiJyArIG8ubmFtZSArICdcIj48L2lucHV0PjwvbGk+JyxcbiAgICAgICc8bGk+PGxhYmVsPlBhdGg6PC9sYWJlbD4nICsgby5wYXRoICsgJzwvbGk+JyxcbiAgICAgICc8bGk+PGxhYmVsPk1pbWUgdHlwZTo8L2xhYmVsPicgKyBvLm1pbWUgKyAnPC9saT4nLFxuICAgICAgJzxsaT48bGFiZWw+TW9kaWZpZWQ6PC9sYWJlbD4nICsgbW9tZW50KG8ubXRpbWUpLmZvcm1hdCgnTU1NTSBEbyBZWVlZLCBoOm1tOnNzIGEnKSArICc8L2xpPicsXG4gICAgICAnPGxpPjxsYWJlbD5TaXplOjwvbGFiZWw+JyArIGZpbGVzaXplKG8uc2l6ZSkgKyAnPC9saT4nLFxuICAgICAgJzxsaT48bGFiZWw+PC9sYWJlbD48YnV0dG9uPlVwZGF0ZTwvYnV0dG9uPjwvbGk+JyxcbiAgICAgICc8L3VsPicsXG4gICAgICAnPC9maWVsZHNldD4nLFxuICAgICAgJzwvZm9ybT4nLFxuICAgICAgJzxmb3JtIGNsYXNzPVwiZGVsZXRlXCI+JyxcbiAgICAgICc8ZmllbGRzZXQ+JyxcbiAgICAgICc8bGVnZW5kPkRlbGV0ZTwvbGVnZW5kPicsXG4gICAgICAnPHVsPicsXG4gICAgICAnPGxpPjxsYWJlbD48L2xhYmVsPjxidXR0b24+RGVsZXRlPC9idXR0b24+PC9saT4nLFxuICAgICAgJzwvdWw+JyxcbiAgICAgICc8L2ZpZWxkc2V0PicsXG4gICAgICAnPC9mb3JtPicsXG4gICAgICAnPC9kaXY+J1xuICAgIF0uam9pbignXFxuJyk7XG5cbiAgfTtcblxuXG4gIHZhciBmb2xkZXJUID0gZnVuY3Rpb24obyl7XG4gICAgcmV0dXJuIFtcbiAgICAgICc8ZGl2IGNsYXNzPVwiZWRpdC1maWxlLWluZm9cIj4nLFxuICAgICAgJzxmb3JtIGNsYXNzPVwiZWRpdFwiPicsXG4gICAgICAnPGZpZWxkc2V0PicsXG4gICAgICAnPGxlZ2VuZD5Qcm9wZXJ0aWVzPC9sZWdlbmQ+JyxcbiAgICAgICc8dWw+JyxcbiAgICAgICc8bGk+PGxhYmVsPk5hbWU6PC9sYWJlbD48aW5wdXQgdHlwZT1cInRleHRcIiBuYW1lPVwibmFtZVwiIHZhbHVlPVwiJyArIG8ubmFtZSArICdcIj48L2lucHV0PjwvbGk+JyxcbiAgICAgICc8bGk+PGxhYmVsPlBhdGg6PC9sYWJlbD4nICsgby5wYXRoICsgJzwvbGk+JyxcbiAgICAgICc8bGk+PGxhYmVsPjwvbGFiZWw+PGJ1dHRvbj5VcGRhdGU8L2J1dHRvbj48L2xpPicsXG4gICAgICAnPC91bD4nLFxuICAgICAgJzwvZmllbGRzZXQ+JyxcbiAgICAgICc8L2Zvcm0+JyxcbiAgICAgICc8Zm9ybSBjbGFzcz1cImRlbGV0ZVwiPicsXG4gICAgICAnPGZpZWxkc2V0PicsXG4gICAgICAnPGxlZ2VuZD5EZWxldGU8L2xlZ2VuZD4nLFxuICAgICAgJzx1bD4nLFxuICAgICAgJzxsaT48bGFiZWw+PC9sYWJlbD48YnV0dG9uPkRlbGV0ZTwvYnV0dG9uPjwvbGk+JyxcbiAgICAgICc8L3VsPicsXG4gICAgICAnPC9maWVsZHNldD4nLFxuICAgICAgJzwvZm9ybT4nLFxuICAgICAgJzwvZGl2PidcbiAgICBdLmpvaW4oJ1xcbicpO1xuXG4gIH07XG5cblxuICB2YXIgc2Vzc2lvbnMgPSB7fTtcbiAgdmFyIGN1cnJlbnRTZXNzaW9uID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gbWFrZUZpbGVTZXNzaW9uIChzZXNzaW9uKXtcblxuICAgIHZhciAkZWwgPSBzZXNzaW9uLiRlbCA9IGRvbShmaWxlVChzZXNzaW9uLmVudGl0eSkpO1xuXG4gIH1cblxuICBmdW5jdGlvbiBtYWtlRm9sZGVyU2Vzc2lvbiAoc2Vzc2lvbil7XG5cbiAgICB2YXIgJGVsID0gc2Vzc2lvbi4kZWwgPSBkb20oZm9sZGVyVChzZXNzaW9uLmVudGl0eSkpO1xuXG5cbiAgfVxuXG4gIGFwcC5vbignZW50aXR5LXVwZGF0ZWQnLCBmdW5jdGlvbiAodHlwZSwgcGF0aCl7XG5cbiAgICAvLyBva2F5IHdvcnJ5IGFib3V0IHRoaXMgbGF0ZXIuLi4gZmlyc3Qgb2YgYWxsIEkgbmVlZCB0byBiZSBhYmxlIHRvIFxuICAgIC8vIGxvYWQgdGhlIGZpbGUgbWV0YWRhdGEgZnJvbSB0aGUgVkZTLi4uXG5cbiAgfSk7XG5cbiAgZW1pdHRlci5jcmVhdGUgPSBmdW5jdGlvbiAoZW50aXR5LCBjYWxsYmFjayl7XG5cbiAgICAvLyB0aGUgZW50aXR5IHNob3VkbCBjb250YWluIGFsbCB0aGUgbWV0YWRhdGEgd2UgbmVlZCBmb3IgdGhpc1xuXG4gICAgdmFyIHNlc3Npb24gPSBzZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF0gPSB7XG4gICAgICBlbnRpdHkgOiBlbnRpdHksXG4gICAgICBzeW5jaHJvbmlzZWQgOiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChzZXNzaW9uLmVudGl0eS50eXBlID09PSAnZmlsZScpe1xuXG4gICAgICBtYWtlRmlsZVNlc3Npb24oc2Vzc2lvbik7XG5cbiAgICB9IGVsc2UgaWYgKHNlc3Npb24uZW50aXR5LnR5cGUgPT09ICdmb2xkZXInKXtcblxuICAgICAgbWFrZUZvbGRlclNlc3Npb24oc2Vzc2lvbik7XG5cbiAgICB9XG5cbiAgICBzZXNzaW9uLiRlbC5jc3MoeyBkaXNwbGF5IDogJ25vbmUnfSk7XG5cbiAgICBkb20oJ2Zvcm0uZWRpdCcsIHNlc3Npb24uJGVsKS5vbignc3VibWl0JywgZnVuY3Rpb24gKGUpe1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIC8vYXBwLmVtaXQoJ3JlbmFtZS1lbnRpdHknLCBzZXNzaW9uLmVudGl0eSwgZG9tKCdmb3JtLmVkaXQgaW5wdXRbbmFtZT1cIm5hbWVcIl0nKS52YWwoKSk7XG5cbiAgICAgIC8qIFxuICAgICAgICBMZXQncyBhY3R1YWxseSBqdXN0IGdvIGFoZWFkIGFuZCByZW5hbWUgaXQuIEJlY2F1c2UgdGhpcyBpcyBodGUgb25seSBwbGFjZSB0aGF0IGNhbiBkbyB0aGF0LlxuICAgICAgKi9cbiAgICAgIGlmIChzZXNzaW9uLmVudGl0eS50eXBlID09PSAnZmlsZScpe1xuXG4gICAgICAgIGFwcC52ZnMucmVuYW1lRmlsZShzZXNzaW9uLmVudGl0eS5wYXRoLCBkb20oJ2Zvcm0uZWRpdCBpbnB1dFtuYW1lPVwibmFtZVwiXScpLnZhbCgpLCBmdW5jdGlvbiAoZXJyLCBuZXdFbnRpdHksIG9sZEVudGl0eSl7XG5cbiAgICAgICAgICBhcHAuZW1pdCgncmVxdWVzdC10ZXJtaW5hdGUtc2Vzc2lvbicsIGVudGl0eS5fc2Vzc2lvbklkKTtcblxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoc2Vzc2lvbi5lbnRpdHkudHlwZSA9PT0gJ2ZvbGRlcicpe1xuXG4gICAgICAgIGFwcC52ZnMucmVuYW1lRm9sZGVyKHNlc3Npb24uZW50aXR5LnBhdGgsIGRvbSgnZm9ybS5lZGl0IGlucHV0W25hbWU9XCJuYW1lXCJdJykudmFsKCksIGZ1bmN0aW9uIChlcnIsIG5ld0VudGl0eSwgb2xkRW50aXR5KXtcblxuICAgICAgICAgIGFwcC5lbWl0KCdyZXF1ZXN0LXRlcm1pbmF0ZS1zZXNzaW9uJywgZW50aXR5Ll9zZXNzaW9uSWQpO1xuXG4gICAgICAgIH0pOyAgICAgIFxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBkb20oJ2Zvcm0uZGVsZXRlJywgc2Vzc2lvbi4kZWwpLm9uKCdzdWJtaXQnLCBmdW5jdGlvbiAoZSl7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgaWYgKHNlc3Npb24uZW50aXR5LnR5cGUgPT09ICdmaWxlJyl7XG5cbiAgICAgICAgYXBwLnZmcy5kZWxldGVGaWxlKHNlc3Npb24uZW50aXR5LnBhdGgsIGZ1bmN0aW9uIChlcnIsIG5ld0VudGl0eSwgb2xkRW50aXR5KXtcbiAgICAgICAgICBhcHAuZW1pdCgncmVxdWVzdC10ZXJtaW5hdGUtc2Vzc2lvbicsIGVudGl0eS5fc2Vzc2lvbklkKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHNlc3Npb24uZW50aXR5LnR5cGUgPT09ICdmb2xkZXInKXtcblxuICAgICAgICBhcHAudmZzLmRlbGV0ZUZvbGRlcihzZXNzaW9uLmVudGl0eS5wYXRoLCBmdW5jdGlvbiAoZXJyLCBuZXdFbnRpdHksIG9sZEVudGl0eSl7XG5cbiAgICAgICAgICBhcHAuZW1pdCgncmVxdWVzdC10ZXJtaW5hdGUtc2Vzc2lvbicsIGVudGl0eS5fc2Vzc2lvbklkKTtcblxuICAgICAgICB9KTsgICAgICBcbiAgICAgIH1cblxuICAgICAgLy9hcHAuZW1pdCgnZGVsZXRlLWVudGl0eScsIHNlc3Npb24uZW50aXR5KTtcbiAgICAgIGFwcC5lbWl0KCdyZXF1ZXN0LXRlcm1pbmF0ZS1zZXNzaW9uJywgZW50aXR5Ll9zZXNzaW9uSWQpO1xuXG4gICAgfSk7XG5cbiAgICAkZWxlbWVudC5hcHBlbmQoc2Vzc2lvbi4kZWwpO1xuXG4gICAgYXBwLmVtaXQoJ3Nlc3Npb24tc3luY2hyb25pc2VkJywgZW50aXR5Ll9zZXNzaW9uSWQpO1xuXG4gICAgY2FsbGJhY2sodHJ1ZSk7XG5cblxuICB9XG5cbiAgZW1pdHRlci5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWVJbmZvU2Vzc2lvbiAoZW50aXR5KXtcbiAgICAvLyB3ZSBhY3R1YWxseSBrZWVwIGEgdHJhY2sgb2Ygb3VyIHNlc3Npb25zIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyBhY3RpdmVseSBcbiAgICAvLyBsb29rZWQgYXQgYnkgdGhlIHVzZXIhXG4gICAgY3VycmVudFNlc3Npb24gPSBzZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF07XG5cbiAgICAvLyBzaG93IHRoaXMgc2Vzc2lvbi4uXG4gICAgY3VycmVudFNlc3Npb24uJGVsLmNzcyh7IGRpc3BsYXkgOiAnJ30pO1xuICAgIC8vIHNob3cgb3VyIGVkaXRvci4uLlxuICAgICRlbGVtZW50LmNzcyh7IGRpc3BsYXkgOiAnJ30pO1xuXG4gIH1cblxuICBlbWl0dGVyLnBhdXNlID0gZnVuY3Rpb24gcGF1c2VJbmZvU2Vzc2lvbiAoZW50aXR5KXtcblxuICAgIGN1cnJlbnRTZXNzaW9uID0gZmFsc2U7XG5cbiAgICB2YXIgc2Vzc2lvbiA9IHNlc3Npb25zW2VudGl0eS5fc2Vzc2lvbklkXTtcblxuICAgIC8vIGhpZGUgdGhlIHNlc3Npb24uLlxuICAgIHNlc3Npb24uJGVsLmNzcyh7IGRpc3BsYXkgOiAnbm9uZSd9KTtcblxuICAgIC8vIGhpZGUgdGhlIGVkaXRvciBhcyB3ZWxsLlxuICAgICRlbGVtZW50LmNzcyh7IGRpc3BsYXkgOiAnbm9uZSd9KTtcblxuICB9XG5cbiAgZW1pdHRlci5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveUluZm9TZXNzaW9uIChlbnRpdHksIGNhbGxiYWNrKXtcblxuICAgIHZhciBzZXNzaW9uID0gc2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdO1xuXG4gICAgLy8gcmVtb3ZlIHRoYXQgZWxlbWVudFxuICAgIHNlc3Npb24uJGVsLnJlbW92ZSgpO1xuXG4gICAgc2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdID0gbnVsbDtcbiAgICBkZWxldGUgc2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdO1xuXG4gICAgJGVsZW1lbnQuY3NzKHtcbiAgICAgIGRpc3BsYXkgOiAnbm9uZSdcbiAgICB9KTtcblxuICAgIGNhbGxiYWNrKCdva2F5IHRvIGNsb3NlJyk7XG5cbiAgfTtcblxuICByZXR1cm4gZW1pdHRlcjtcblxufSIsInZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbnZhciBmaWxlc2l6ZSA9IHJlcXVpcmUoJ2ZpbGVzaXplJyk7XG5cbnZhciBkb20gPSByZXF1aXJlKCdncmVlbi1tZXNhLWRvbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHAsIGNvbnRlbnRWaWV3KXtcblxuICB2YXIgZW1pdHRlciA9IG5ldyAocmVxdWlyZSgnZXZlbnRzJykpLkV2ZW50RW1pdHRlcigpO1xuXG4gIHZhciAkZWxlbWVudCA9IGRvbSgnPGRpdj48L2Rpdj4nKTtcblxuICAkZWxlbWVudC5hZGRDbGFzcygnaW5mbycpO1xuICAkZWxlbWVudC5jc3Moe1xuICAgIGRpc3BsYXkgOiAnbm9uZScsXG4gICAgJ21pbi13aWR0aCcgOiBjb250ZW50Vmlldy5zaXplKCkueCArICdweCcsXG4gICAgJ21pbi1oZWlnaHQnIDogY29udGVudFZpZXcuc2l6ZSgpLnkgKyAncHgnLFxuICAgIHBvc2l0aW9uIDogJ2Fic29sdXRlJyxcbiAgICB0b3AgOiAwLFxuICAgIGxlZnQgOiAwXG4gIH0pO1xuXG4gICRlbGVtZW50LmFwcGVuZFRvKGNvbnRlbnRWaWV3LmVsZW1lbnQpO1xuXG4gIGFwcC5sYXlvdXQub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KXtcblxuICAgICRlbGVtZW50LmNzcyh7XG4gICAgICAnbWluLXdpZHRoJyA6IGNvbnRlbnRWaWV3LnNpemUoKS54ICsgJ3B4JyxcbiAgICAgICdtaW4taGVpZ2h0JyA6IGNvbnRlbnRWaWV3LnNpemUoKS55ICsgJ3B4J1xuICAgIH0pO1xuXG4gIH0pO1xuXG4gIHZhciBmb2xkZXJUID0gZnVuY3Rpb24obyl7XG4gICAgcmV0dXJuIFtcbiAgICAgICc8ZGl2IGNsYXNzPVwiZWRpdC1maWxlLWluZm9cIj4nLFxuICAgICAgJzxmb3JtIGNsYXNzPVwiZWRpdFwiPicsXG4gICAgICAnPGZpZWxkc2V0PicsXG4gICAgICAnPGxlZ2VuZD5OZXcgZG9jdW1lbnQgcHJvcGVydGllczwvbGVnZW5kPicsXG4gICAgICAnPHVsPicsXG4gICAgICAnPGxpPjxsYWJlbD5OYW1lOjwvbGFiZWw+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmFtZT1cIm5hbWVcIiB2YWx1ZT1cIlVudGl0bGVkLm1kXCI+PC9pbnB1dD48L2xpPicsXG4gICAgICAnPGxpPjxsYWJlbD5QYXRoOjwvbGFiZWw+JyArIG8ucGF0aCArICc8L2xpPicsXG4gICAgICAnPGxpPjxsYWJlbD48L2xhYmVsPjxidXR0b24+Q3JlYXRlPC9idXR0b24+PC9saT4nLFxuICAgICAgJzwvdWw+JyxcbiAgICAgICc8L2ZpZWxkc2V0PicsXG4gICAgICAnPC9mb3JtPicsXG4gICAgICAnPC9kaXY+J1xuICAgIF0uam9pbignXFxuJyk7XG5cbiAgfTtcblxuXG4gIHZhciBzZXNzaW9ucyA9IHt9O1xuICB2YXIgY3VycmVudFNlc3Npb24gPSBmYWxzZTtcblxuICBmdW5jdGlvbiBtYWtlRmlsZVNlc3Npb24gKHNlc3Npb24pe1xuXG4gICAgdmFyICRlbCA9IHNlc3Npb24uJGVsID0gZG9tKGZvbGRlclQoc2Vzc2lvbi5lbnRpdHkpKTtcblxuICB9XG5cbiAgZW1pdHRlci5jcmVhdGUgPSBmdW5jdGlvbiAoZW50aXR5LCBjYWxsYmFjayl7XG5cbiAgICAvLyB0aGUgZW50aXR5IHNob3VkbCBjb250YWluIGFsbCB0aGUgbWV0YWRhdGEgd2UgbmVlZCBmb3IgdGhpc1xuXG4gICAgdmFyIHNlc3Npb24gPSBzZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF0gPSB7XG4gICAgICBlbnRpdHkgOiBlbnRpdHksXG4gICAgICBzeW5jaHJvbmlzZWQgOiBmYWxzZVxuICAgIH1cblxuICAgIG1ha2VGaWxlU2Vzc2lvbihzZXNzaW9uKTtcblxuICAgIHNlc3Npb24uJGVsLmNzcyh7IGRpc3BsYXkgOiAnbm9uZSd9KTtcblxuICAgIGRvbSgnZm9ybS5lZGl0Jywgc2Vzc2lvbi4kZWwpLm9uKCdzdWJtaXQnLCBmdW5jdGlvbiAoZSl7XG5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIGZvbGRlck5hbWUgPSBkb20oJ2Zvcm0uZWRpdCBpbnB1dFtuYW1lPVwibmFtZVwiXScpLnZhbCgpO1xuXG4gICAgICBpZiAoZm9sZGVyTmFtZSAhPT0gXCJcIiAmJiBmb2xkZXJOYW1lLnN1YnN0cigwLDEpICE9PSBcIi5cIil7XG5cbiAgICAgICAgYXBwLnZmcy5jcmVhdGVGaWxlKHNlc3Npb24uZW50aXR5LnBhdGgsIGZvbGRlck5hbWUsIGZ1bmN0aW9uIChlcnIpe1xuXG4gICAgICAgICAgaWYgKCFlcnIpe1xuICAgICAgICAgICAgYXBwLmVtaXQoJ3JlcXVlc3QtdGVybWluYXRlLXNlc3Npb24nLCBlbnRpdHkuX3Nlc3Npb25JZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pXG5cbiAgICAgIH1cblxuICAgICAgLy9hcHAuZW1pdCgncmVuYW1lLWVudGl0eScsIHNlc3Npb24uZW50aXR5LCBkb20oJ2Zvcm0uZWRpdCBpbnB1dFtuYW1lPVwibmFtZVwiXScpLnZhbCgpKTtcblxuICAgICAgLyogXG4gICAgICAgIExldCdzIGFjdHVhbGx5IGp1c3QgZ28gYWhlYWQgYW5kIHJlbmFtZSBpdC4gQmVjYXVzZSB0aGlzIGlzIGh0ZSBvbmx5IHBsYWNlIHRoYXQgY2FuIGRvIHRoYXQuXG4gICAgICAqL1xuXG4gICAgICAvKlxuICAgICAgaWYgKHNlc3Npb24uZW50aXR5LnR5cGUgPT09ICdmaWxlJyl7XG5cbiAgICAgICAgYXBwLnZmcy5yZW5hbWVGaWxlKHNlc3Npb24uZW50aXR5LnBhdGgsIGRvbSgnZm9ybS5lZGl0IGlucHV0W25hbWU9XCJuYW1lXCJdJykudmFsKCksIGZ1bmN0aW9uIChlcnIsIG5ld0VudGl0eSwgb2xkRW50aXR5KXtcblxuICAgICAgICAgIGFwcC5lbWl0KCdyZXF1ZXN0LXRlcm1pbmF0ZS1zZXNzaW9uJywgZW50aXR5Ll9zZXNzaW9uSWQpO1xuXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChzZXNzaW9uLmVudGl0eS50eXBlID09PSAnZm9sZGVyJyl7XG5cbiAgICAgICAgYXBwLnZmcy5yZW5hbWVGb2xkZXIoc2Vzc2lvbi5lbnRpdHkucGF0aCwgZG9tKCdmb3JtLmVkaXQgaW5wdXRbbmFtZT1cIm5hbWVcIl0nKS52YWwoKSwgZnVuY3Rpb24gKGVyciwgbmV3RW50aXR5LCBvbGRFbnRpdHkpe1xuXG4gICAgICAgICAgYXBwLmVtaXQoJ3JlcXVlc3QtdGVybWluYXRlLXNlc3Npb24nLCBlbnRpdHkuX3Nlc3Npb25JZCk7XG5cbiAgICAgICAgfSk7ICAgICAgXG4gICAgICB9XG4gICAgICAqL1xuXG4gICAgfSk7XG5cbiAgICAkZWxlbWVudC5hcHBlbmQoc2Vzc2lvbi4kZWwpO1xuXG4gICAgYXBwLmVtaXQoJ3Nlc3Npb24tc3luY2hyb25pc2VkJywgZW50aXR5Ll9zZXNzaW9uSWQpO1xuXG4gICAgY2FsbGJhY2sodHJ1ZSk7XG5cblxuICB9XG5cbiAgZW1pdHRlci5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWVJbmZvU2Vzc2lvbiAoZW50aXR5KXtcbiAgICAvLyB3ZSBhY3R1YWxseSBrZWVwIGEgdHJhY2sgb2Ygb3VyIHNlc3Npb25zIHRoYXQgYXJlIGN1cnJlbnRseSBiZWluZyBhY3RpdmVseSBcbiAgICAvLyBsb29rZWQgYXQgYnkgdGhlIHVzZXIhXG4gICAgY3VycmVudFNlc3Npb24gPSBzZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF07XG5cbiAgICAvLyBzaG93IHRoaXMgc2Vzc2lvbi4uXG4gICAgY3VycmVudFNlc3Npb24uJGVsLmNzcyh7IGRpc3BsYXkgOiAnJ30pO1xuICAgIC8vIHNob3cgb3VyIGVkaXRvci4uLlxuICAgICRlbGVtZW50LmNzcyh7IGRpc3BsYXkgOiAnJ30pO1xuXG4gIH1cblxuICBlbWl0dGVyLnBhdXNlID0gZnVuY3Rpb24gcGF1c2VJbmZvU2Vzc2lvbiAoZW50aXR5KXtcblxuICAgIGN1cnJlbnRTZXNzaW9uID0gZmFsc2U7XG5cbiAgICB2YXIgc2Vzc2lvbiA9IHNlc3Npb25zW2VudGl0eS5fc2Vzc2lvbklkXTtcblxuICAgIC8vIGhpZGUgdGhlIHNlc3Npb24uLlxuICAgIHNlc3Npb24uJGVsLmNzcyh7IGRpc3BsYXkgOiAnbm9uZSd9KTtcblxuICAgIC8vIGhpZGUgdGhlIGVkaXRvciBhcyB3ZWxsLlxuICAgICRlbGVtZW50LmNzcyh7IGRpc3BsYXkgOiAnbm9uZSd9KTtcblxuICB9XG5cbiAgZW1pdHRlci5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveUluZm9TZXNzaW9uIChlbnRpdHksIGNhbGxiYWNrKXtcblxuICAgIHZhciBzZXNzaW9uID0gc2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdO1xuXG4gICAgLy8gcmVtb3ZlIHRoYXQgZWxlbWVudFxuICAgIHNlc3Npb24uJGVsLnJlbW92ZSgpO1xuXG4gICAgc2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdID0gbnVsbDtcbiAgICBkZWxldGUgc2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdO1xuXG4gICAgJGVsZW1lbnQuY3NzKHtcbiAgICAgIGRpc3BsYXkgOiAnbm9uZSdcbiAgICB9KTtcblxuICAgIGNhbGxiYWNrKCdva2F5IHRvIGNsb3NlJyk7XG5cbiAgfTtcblxuICByZXR1cm4gZW1pdHRlcjtcblxufSIsInZhciBtYXJrZWQgPSByZXF1aXJlKCdtYXJrZWQnKTtcbnZhciBtb21lbnQgPSByZXF1aXJlKCdtb21lbnQnKTtcbnZhciBmaWxlc2l6ZSA9IHJlcXVpcmUoJ2ZpbGVzaXplJyk7XG5cbnZhciBkb20gPSByZXF1aXJlKCdncmVlbi1tZXNhLWRvbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHAsIGNvbnRlbnRWaWV3KXtcblxuICB2YXIgZW1pdHRlciA9IG5ldyAocmVxdWlyZSgnZXZlbnRzJykpLkV2ZW50RW1pdHRlcigpO1xuXG4gIHZhciAkZWxlbWVudCA9IGRvbSgnPGRpdj48L2Rpdj4nKTtcblxuICAkZWxlbWVudC5hZGRDbGFzcygnaW5mbycpO1xuICAkZWxlbWVudC5jc3Moe1xuICAgIGRpc3BsYXkgOiAnbm9uZScsXG4gICAgJ21pbi13aWR0aCcgOiBjb250ZW50Vmlldy5zaXplKCkueCArICdweCcsXG4gICAgJ21pbi1oZWlnaHQnIDogY29udGVudFZpZXcuc2l6ZSgpLnkgKyAncHgnLFxuICAgIHBvc2l0aW9uIDogJ2Fic29sdXRlJyxcbiAgICB0b3AgOiAwLFxuICAgIGxlZnQgOiAwXG4gIH0pO1xuXG4gICRlbGVtZW50LmFwcGVuZFRvKGNvbnRlbnRWaWV3LmVsZW1lbnQpO1xuXG4gIGFwcC5sYXlvdXQub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KXtcblxuICAgICRlbGVtZW50LmNzcyh7XG4gICAgICAnbWluLXdpZHRoJyA6IGNvbnRlbnRWaWV3LnNpemUoKS54ICsgJ3B4JyxcbiAgICAgICdtaW4taGVpZ2h0JyA6IGNvbnRlbnRWaWV3LnNpemUoKS55ICsgJ3B4J1xuICAgIH0pO1xuXG4gIH0pO1xuXG4gIHZhciBmb2xkZXJUID0gZnVuY3Rpb24obyl7XG4gICAgcmV0dXJuIFtcbiAgICAgICc8ZGl2IGNsYXNzPVwiZWRpdC1maWxlLWluZm9cIj4nLFxuICAgICAgJzxmb3JtIGNsYXNzPVwiZWRpdFwiPicsXG4gICAgICAnPGZpZWxkc2V0PicsXG4gICAgICAnPGxlZ2VuZD5OZXcgZm9sZGVyIHByb3BlcnRpZXM8L2xlZ2VuZD4nLFxuICAgICAgJzx1bD4nLFxuICAgICAgJzxsaT48bGFiZWw+TmFtZTo8L2xhYmVsPjxpbnB1dCB0eXBlPVwidGV4dFwiIG5hbWU9XCJuYW1lXCIgdmFsdWU9XCJOZXcgZm9sZGVyXCI+PC9pbnB1dD48L2xpPicsXG4gICAgICAnPGxpPjxsYWJlbD5QYXRoOjwvbGFiZWw+JyArIG8ucGF0aCArICc8L2xpPicsXG4gICAgICAnPGxpPjxsYWJlbD48L2xhYmVsPjxidXR0b24+Q3JlYXRlPC9idXR0b24+PC9saT4nLFxuICAgICAgJzwvdWw+JyxcbiAgICAgICc8L2ZpZWxkc2V0PicsXG4gICAgICAnPC9mb3JtPicsXG4gICAgICAnPC9kaXY+J1xuICAgIF0uam9pbignXFxuJyk7XG5cbiAgfTtcblxuXG4gIHZhciBzZXNzaW9ucyA9IHt9O1xuICB2YXIgY3VycmVudFNlc3Npb24gPSBmYWxzZTtcblxuICBmdW5jdGlvbiBtYWtlRm9sZGVyU2Vzc2lvbiAoc2Vzc2lvbil7XG5cbiAgICB2YXIgJGVsID0gc2Vzc2lvbi4kZWwgPSBkb20oZm9sZGVyVChzZXNzaW9uLmVudGl0eSkpO1xuXG4gIH1cblxuICBlbWl0dGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbnRpdHksIGNhbGxiYWNrKXtcblxuICAgIC8vIHRoZSBlbnRpdHkgc2hvdWRsIGNvbnRhaW4gYWxsIHRoZSBtZXRhZGF0YSB3ZSBuZWVkIGZvciB0aGlzXG5cbiAgICB2YXIgc2Vzc2lvbiA9IHNlc3Npb25zW2VudGl0eS5fc2Vzc2lvbklkXSA9IHtcbiAgICAgIGVudGl0eSA6IGVudGl0eSxcbiAgICAgIHN5bmNocm9uaXNlZCA6IGZhbHNlXG4gICAgfVxuXG4gICAgbWFrZUZvbGRlclNlc3Npb24oc2Vzc2lvbik7XG5cbiAgICBzZXNzaW9uLiRlbC5jc3MoeyBkaXNwbGF5IDogJ25vbmUnfSk7XG5cbiAgICBkb20oJ2Zvcm0uZWRpdCcsIHNlc3Npb24uJGVsKS5vbignc3VibWl0JywgZnVuY3Rpb24gKGUpe1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBmb2xkZXJOYW1lID0gZG9tKCdmb3JtLmVkaXQgaW5wdXRbbmFtZT1cIm5hbWVcIl0nKS52YWwoKTtcblxuICAgICAgaWYgKGZvbGRlck5hbWUgIT09IFwiXCIgJiYgZm9sZGVyTmFtZS5zdWJzdHIoMCwxKSAhPT0gXCIuXCIpe1xuXG4gICAgICAgIGFwcC52ZnMud3JpdGVGb2xkZXIoc2Vzc2lvbi5lbnRpdHkucGF0aCwgZm9sZGVyTmFtZSwgZnVuY3Rpb24gKGVycil7XG5cbiAgICAgICAgICBpZiAoIWVycil7XG4gICAgICAgICAgICBhcHAuZW1pdCgncmVxdWVzdC10ZXJtaW5hdGUtc2Vzc2lvbicsIGVudGl0eS5fc2Vzc2lvbklkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSlcblxuICAgICAgfVxuXG4gICAgICAvL2FwcC5lbWl0KCdyZW5hbWUtZW50aXR5Jywgc2Vzc2lvbi5lbnRpdHksIGRvbSgnZm9ybS5lZGl0IGlucHV0W25hbWU9XCJuYW1lXCJdJykudmFsKCkpO1xuXG4gICAgICAvKiBcbiAgICAgICAgTGV0J3MgYWN0dWFsbHkganVzdCBnbyBhaGVhZCBhbmQgcmVuYW1lIGl0LiBCZWNhdXNlIHRoaXMgaXMgaHRlIG9ubHkgcGxhY2UgdGhhdCBjYW4gZG8gdGhhdC5cbiAgICAgICovXG5cbiAgICAgIC8qXG4gICAgICBpZiAoc2Vzc2lvbi5lbnRpdHkudHlwZSA9PT0gJ2ZpbGUnKXtcblxuICAgICAgICBhcHAudmZzLnJlbmFtZUZpbGUoc2Vzc2lvbi5lbnRpdHkucGF0aCwgZG9tKCdmb3JtLmVkaXQgaW5wdXRbbmFtZT1cIm5hbWVcIl0nKS52YWwoKSwgZnVuY3Rpb24gKGVyciwgbmV3RW50aXR5LCBvbGRFbnRpdHkpe1xuXG4gICAgICAgICAgYXBwLmVtaXQoJ3JlcXVlc3QtdGVybWluYXRlLXNlc3Npb24nLCBlbnRpdHkuX3Nlc3Npb25JZCk7XG5cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHNlc3Npb24uZW50aXR5LnR5cGUgPT09ICdmb2xkZXInKXtcblxuICAgICAgICBhcHAudmZzLnJlbmFtZUZvbGRlcihzZXNzaW9uLmVudGl0eS5wYXRoLCBkb20oJ2Zvcm0uZWRpdCBpbnB1dFtuYW1lPVwibmFtZVwiXScpLnZhbCgpLCBmdW5jdGlvbiAoZXJyLCBuZXdFbnRpdHksIG9sZEVudGl0eSl7XG5cbiAgICAgICAgICBhcHAuZW1pdCgncmVxdWVzdC10ZXJtaW5hdGUtc2Vzc2lvbicsIGVudGl0eS5fc2Vzc2lvbklkKTtcblxuICAgICAgICB9KTsgICAgICBcbiAgICAgIH1cbiAgICAgICovXG5cbiAgICB9KTtcblxuICAgICRlbGVtZW50LmFwcGVuZChzZXNzaW9uLiRlbCk7XG5cbiAgICBhcHAuZW1pdCgnc2Vzc2lvbi1zeW5jaHJvbmlzZWQnLCBlbnRpdHkuX3Nlc3Npb25JZCk7XG5cbiAgICBjYWxsYmFjayh0cnVlKTtcblxuXG4gIH1cblxuICBlbWl0dGVyLnJlc3VtZSA9IGZ1bmN0aW9uIHJlc3VtZUluZm9TZXNzaW9uIChlbnRpdHkpe1xuICAgIC8vIHdlIGFjdHVhbGx5IGtlZXAgYSB0cmFjayBvZiBvdXIgc2Vzc2lvbnMgdGhhdCBhcmUgY3VycmVudGx5IGJlaW5nIGFjdGl2ZWx5IFxuICAgIC8vIGxvb2tlZCBhdCBieSB0aGUgdXNlciFcbiAgICBjdXJyZW50U2Vzc2lvbiA9IHNlc3Npb25zW2VudGl0eS5fc2Vzc2lvbklkXTtcblxuICAgIC8vIHNob3cgdGhpcyBzZXNzaW9uLi5cbiAgICBjdXJyZW50U2Vzc2lvbi4kZWwuY3NzKHsgZGlzcGxheSA6ICcnfSk7XG4gICAgLy8gc2hvdyBvdXIgZWRpdG9yLi4uXG4gICAgJGVsZW1lbnQuY3NzKHsgZGlzcGxheSA6ICcnfSk7XG5cbiAgfVxuXG4gIGVtaXR0ZXIucGF1c2UgPSBmdW5jdGlvbiBwYXVzZUluZm9TZXNzaW9uIChlbnRpdHkpe1xuXG4gICAgY3VycmVudFNlc3Npb24gPSBmYWxzZTtcblxuICAgIHZhciBzZXNzaW9uID0gc2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdO1xuXG4gICAgLy8gaGlkZSB0aGUgc2Vzc2lvbi4uXG4gICAgc2Vzc2lvbi4kZWwuY3NzKHsgZGlzcGxheSA6ICdub25lJ30pO1xuXG4gICAgLy8gaGlkZSB0aGUgZWRpdG9yIGFzIHdlbGwuXG4gICAgJGVsZW1lbnQuY3NzKHsgZGlzcGxheSA6ICdub25lJ30pO1xuXG4gIH1cblxuICBlbWl0dGVyLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95SW5mb1Nlc3Npb24gKGVudGl0eSwgY2FsbGJhY2spe1xuXG4gICAgdmFyIHNlc3Npb24gPSBzZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF07XG5cbiAgICAvLyByZW1vdmUgdGhhdCBlbGVtZW50XG4gICAgc2Vzc2lvbi4kZWwucmVtb3ZlKCk7XG5cbiAgICBzZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF0gPSBudWxsO1xuICAgIGRlbGV0ZSBzZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF07XG5cbiAgICAkZWxlbWVudC5jc3Moe1xuICAgICAgZGlzcGxheSA6ICdub25lJ1xuICAgIH0pO1xuXG4gICAgY2FsbGJhY2soJ29rYXkgdG8gY2xvc2UnKTtcblxuICB9O1xuXG4gIHJldHVybiBlbWl0dGVyO1xuXG59IiwidmFyIG1hcmtlZCA9IHJlcXVpcmUoJ21hcmtlZCcpO1xuXG52YXIgZG9tID0gcmVxdWlyZSgnZ3JlZW4tbWVzYS1kb20nKTtcblxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgc3ZnUGFuWm9vbSA9IHJlcXVpcmUoJ3N2Zy1wYW4tem9vbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHAsIGNvbnRlbnRWaWV3KXtcblxuICB2YXIgZW1pdHRlciA9IG5ldyAocmVxdWlyZSgnZXZlbnRzJykpLkV2ZW50RW1pdHRlcigpO1xuXG4gIHZhciAkZWxlbWVudCA9IGRvbSgnPGRpdj48L2Rpdj4nKTtcblxuICAkZWxlbWVudC5hZGRDbGFzcygncHJldmlldycpO1xuICAkZWxlbWVudC5jc3Moe1xuICAgIGRpc3BsYXkgOiAnbm9uZScsXG4gICAgJ3dpZHRoJyA6IGNvbnRlbnRWaWV3LnNpemUoKS54ICsgJ3B4JyxcbiAgICAnaGVpZ2h0JyA6IGNvbnRlbnRWaWV3LnNpemUoKS55ICsgJ3B4JyxcbiAgICBwb3NpdGlvbiA6ICdhYnNvbHV0ZScsXG4gICAgb3ZlcmZsb3cgOiAnc2Nyb2xsJyxcbiAgICB0b3AgOiAwLFxuICAgIGxlZnQgOiAwXG4gIH0pO1xuXG4gICRlbGVtZW50LmFwcGVuZFRvKGNvbnRlbnRWaWV3LmVsZW1lbnQpO1xuXG4gIGFwcC5sYXlvdXQub24oJ3Jlc2l6ZScsIGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KXtcblxuICAgICRlbGVtZW50LmNzcyh7XG4gICAgICAnd2lkdGgnIDogY29udGVudFZpZXcuc2l6ZSgpLnggKyAncHgnLFxuICAgICAgJ2hlaWdodCcgOiBjb250ZW50Vmlldy5zaXplKCkueSArICdweCdcbiAgICB9KTtcblxuICB9KTtcblxuICB2YXIgcHJldmlld1Nlc3Npb25zID0ge307XG4gIHZhciBjdXJyZW50U2Vzc2lvbiA9IGZhbHNlO1xuXG4gIGFwcC5vbignY29tbWFuZC1zdGRvdXQnLCBmdW5jdGlvbiAobyl7XG5cbiAgICBpZiAoby5pZC5pbmRleE9mICYmIG8uaWQuaW5kZXhPZignLXByZXZpZXcnKSAhPT0gLTEpe1xuXG4gICAgICB2YXIgaWQgPSBvLmlkLnJlcGxhY2UoJy1wcmV2aWV3JywgJycpO1xuXG4gICAgICAvLyBhY3R1YWxseSB0aGlzIGlzIFxuICAgICAgaWYgKHByZXZpZXdTZXNzaW9uc1tpZF0pe1xuXG4gICAgICAgIHByZXZpZXdTZXNzaW9uc1tpZF0uY29udmVydGVkICs9IG8ucGFja2V0O1xuICAgICAgfVxuXG4gICAgfVxuXG4gIH0pO1xuXG4gIGFwcC5vbignY29tbWFuZC1zdGRlcnInLCBmdW5jdGlvbiAobyl7XG5cbiAgICBpZiAoby5pZC5pbmRleE9mICYmIG8uaWQuaW5kZXhPZignLXByZXZpZXcnKSAhPT0gLTEpe1xuXG4gICAgICB2YXIgaWQgPSBvLmlkLnJlcGxhY2UoJy1wcmV2aWV3JywgJycpO1xuXG4gICAgICAvLyBhY3R1YWxseSB0aGlzIGlzIFxuICAgICAgaWYgKHByZXZpZXdTZXNzaW9uc1tpZF0pe1xuICAgICAgICAvLyB3aGF0IHNob3VsZCB3ZSBkbyB3aXRoIGVycm9ycz8gUHJvYmFibHkganVzdCBzdG9wIGFuZCBkaXNwbGF5IFwic29ycnkhXCI7XG4gICAgICAgIC8vIGxldCdzIGFjdHVhbGx5IGdldCB0aGUgc2Vzc2lvbiBzeW5jaHJvbmlzZWQgYW55d2F5Li4uXG4gICAgICAgIGFwcC5lbWl0KCdzZXNzaW9uLXN5bmNocm9uaXNlZCcsIGlkKTtcbiAgICAgIH1cblxuICAgIH1cblxuICB9KTtcblxuICBhcHAub24oJ2NvbW1hbmQtY2xvc2UnLCBmdW5jdGlvbiAobyl7XG5cbiAgICBpZiAoby5pZC5pbmRleE9mICYmIG8uaWQuaW5kZXhPZignLXByZXZpZXcnKSAhPT0gLTEpe1xuXG4gICAgICB2YXIgaWQgPSBvLmlkLnJlcGxhY2UoJy1wcmV2aWV3JywgJycpO1xuXG4gICAgICAvLyBhY3R1YWxseSB0aGlzIGlzIFxuICAgICAgaWYgKHByZXZpZXdTZXNzaW9uc1tpZF0pe1xuXG4gICAgICAgIHByZXZpZXdTZXNzaW9uc1tpZF0uYm9keSA9IHByZXZpZXdTZXNzaW9uc1tpZF0uY29udmVydGVkO1xuICAgICAgICBwcmV2aWV3U2Vzc2lvbnNbaWRdLmNvbXBsZXRlID0gdHJ1ZTtcblxuICAgICAgICAvLyBvbmx5IGlmIHRoZSBzZXNzaW9uIGlzIHRlaCBjdXJyZW50IHNlc3Npb24uLi5cbiAgICAgICAgYXBwLmVtaXQoJ3Nlc3Npb24tc3luY2hyb25pc2VkJywgaWQpO1xuXG4gICAgICAgIGlmIChwcmV2aWV3U2Vzc2lvbnNbaWRdID09PSBjdXJyZW50U2Vzc2lvbil7XG4gICAgICAgICAgJGVsZW1lbnQuaHRtbChwcmV2aWV3U2Vzc2lvbnNbaWRdLmJvZHkpO1xuICAgICAgICAgIC8vJGVsZW1lbnQuY3NzKHsgZGlzcGxheSA6ICcnfSk7XG4gICAgICAgICAgc3ZnUGFuWm9vbSgkZWxlbWVudC5maW5kKCdzdmcnKS5lbHNbMF0sIHsgbWluWm9vbTogMC4xfSk7XG4gICAgICAgICAgJGVsZW1lbnQuZmluZCgnc3ZnJykuYXR0cignd2lkdGgnLCBwYXJzZUZsb2F0KCRlbGVtZW50LmZpbmQoJ3N2ZycpLmF0dHIoJ3dpZHRoJyksIDEwKSAvIDIgKyBcInB0XCIpO1xuICAgICAgICAgICRlbGVtZW50LmZpbmQoJ3N2ZycpLmF0dHIoJ2hlaWdodCcsIHBhcnNlRmxvYXQoJGVsZW1lbnQuZmluZCgnc3ZnJykuYXR0cignaGVpZ2h0JyksIDEwKSAvIDIgKyBcInB0XCIpO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9KTtcblxuICBlbWl0dGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZVByZXZpZXdTZXNzaW9uIChlbnRpdHksIGNhbGxiYWNrKXtcbiAgICB2YXIgc2Vzc2lvbiA9IHByZXZpZXdTZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF0gPSB7XG4gICAgICBlbnRpdHkgOiBlbnRpdHksXG4gICAgICBib2R5IDoge31cbiAgICB9O1xuXG4gICAgdmFyIGZpbGVFeHQgPSBwYXRoLmV4dG5hbWUoZW50aXR5Lm5hbWUpO1xuXG4gICAgaWYgKGZpbGVFeHQgPT09IFwiLm1kXCIgfHwgZmlsZUV4dCA9PT0gXCIudHh0XCIgfHwgZmlsZUV4dCA9PT0gXCJcIiB8fCBmaWxlRXh0ID09PSBcIi5odG1sXCIpe1xuXG4gICAgICBhcHAudmZzLnJlYWRGaWxlKGVudGl0eS5wYXRoLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSwgYm9keSl7XG5cbiAgICAgICAgaWYgKGVycil7XG4gICAgICAgICAgY2FsbGJhY2sgKGZhbHNlLCBlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlc3Npb24uYm9keSA9IGJvZHk7XG5cbiAgICAgICAgYXBwLmVtaXQoJ3Nlc3Npb24tc3luY2hyb25pc2VkJywgZW50aXR5Ll9zZXNzaW9uSWQpO1xuXG4gICAgICAgIGNhbGxiYWNrKHRydWUpO1xuXG4gICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiAoZmlsZUV4dCA9PT0gXCIucG5nXCIgfHwgZmlsZUV4dCA9PT0gXCIuanBnXCIgfHwgZmlsZUV4dCA9PT0gXCIuZ2lmXCIpIHtcblxuICAgICAgYXBwLnZmcy5yZWFkRmlsZUFzQmFzZTY0KGVudGl0eS5wYXRoLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSwgYm9keSl7XG5cbiAgICAgICAgaWYgKGVycil7XG4gICAgICAgICAgY2FsbGJhY2sgKGZhbHNlLCBlcnIpO1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgc2Vzc2lvbi5ib2R5ID0gYm9keTtcblxuICAgICAgICBhcHAuZW1pdCgnc2Vzc2lvbi1zeW5jaHJvbmlzZWQnLCBlbnRpdHkuX3Nlc3Npb25JZCk7XG5cbiAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG5cbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmIChmaWxlRXh0ID09PSBcIi50dGxcIikge1xuXG4gICAgICBzZXNzaW9uLmNvbnZlcnRlZCA9IFwiXCI7XG4gICAgICBzZXNzaW9uLmNvbXBsZXRlID0gZmFsc2U7XG5cbiAgICAgIGFwcC5yZW1vdGVTZW5kKCdydW4tY29tbWFuZCcsIHtcbiAgICAgICAgaWQgOiBlbnRpdHkuX3Nlc3Npb25JZCArICctcHJldmlldycsXG4gICAgICAgIGNtZCA6ICdyYXBwZXIgLWkgdHVydGxlICcgKyBwYXRoLmpvaW4oJy4nLCBlbnRpdHkucGF0aCkgKyAnIC1vIGRvdCB8IGRvdCAtVHN2ZydcbiAgICAgIH0pO1xuXG4gICAgICBhcHAuZW1pdCgnc2Vzc2lvbi1zeW5jaHJvbmlzZWQnLCBlbnRpdHkuX3Nlc3Npb25JZCk7XG5cbiAgICAgIGNhbGxiYWNrKHRydWUpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIGxvYWQuLi5cbiAgICAgIHNlc3Npb24uYm9keSA9IFwiXCJcbiAgICAgIGFwcC5lbWl0KCdzZXNzaW9uLXN5bmNocm9uaXNlZCcsIGVudGl0eS5fc2Vzc2lvbklkKTtcbiAgICAgIGNhbGxiYWNrKHRydWUpO1xuXG4gICAgfVxuXG5cbiAgfVxuXG4gIGVtaXR0ZXIucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lUHJldmlld1Nlc3Npb24gKGVudGl0eSl7XG5cbiAgICBjdXJyZW50U2Vzc2lvbiA9IHByZXZpZXdTZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF07XG5cbiAgICBpZiAoIWN1cnJlbnRTZXNzaW9uKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudFNlc3Npb24uZW50aXR5Lm1pbWUgPT09IFwidGV4dC94LW1hcmtkb3duXCIpe1xuICAgICAgJGVsZW1lbnQuaHRtbCgnPGRpdiBjbGFzcz1cIm1kLXByZXZpZXctY29udGVudFwiPicgKyBtYXJrZWQoY3VycmVudFNlc3Npb24uYm9keSkgKyAnPC9kaXY+Jyk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50U2Vzc2lvbi5lbnRpdHkubWltZSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpe1xuICAgICAgJGVsZW1lbnQuaHRtbCgnPGRpdiBjbGFzcz1cIm1kLXByZXZpZXctY29udGVudFwiPicgKyBtYXJrZWQoJ35+fmpzb25cXG4nICsgSlNPTi5zdHJpbmdpZnkoSlNPTi5wYXJzZShjdXJyZW50U2Vzc2lvbi5ib2R5KSwgZmFsc2UsIDQpICsgJ35+flxcbicpICsgJzwvZGl2PicpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdmFyIGZpbGVFeHQgPSBwYXRoLmV4dG5hbWUoZW50aXR5Lm5hbWUpO1xuXG4gICAgICBpZiAoZmlsZUV4dCA9PT0gXCIucG5nXCIgfHwgZmlsZUV4dCA9PT0gXCIuZ2lmXCIgfHwgZmlsZUV4dCA9PT0gXCIuanBnXCIpe1xuXG4gICAgICAgICRlbGVtZW50Lmh0bWwoJzxpbWc+PC9pbWc+Jyk7XG4gICAgICAgICRlbGVtZW50LmZpbmQoJ2ltZycpLmF0dHIoJ3NyYycsIGN1cnJlbnRTZXNzaW9uLmJvZHkpO1xuXG4gICAgICB9IGVsc2UgaWYgKGZpbGVFeHQgPT09IFwiLnR0bFwiKXtcbiAgICAgICAgLy8gdGhlIGJvZHkgc2hvdWxkIGJlIGFuIFNWRyBhdCB0aGlzIHBvaW50Li4uXG5cbiAgICAgICAgLy8gd2lsbCBoYXZlIHRvIGxvb2sgdXAgaG93IHRvIHJlbmRlciBhbiBTVkcgZG9jdW1lbnQgZGlyZWN0bHkgaW4gdGhlIGJyb3dzZXIsIGhhdmVuJ3QgZG9uZSBpdCBcbiAgICAgICAgLy8gaW4gYSB3aGlsZSBpZiBJJ20gaG9uZXN0Li4uXG4gICAgICAgIGlmIChjdXJyZW50U2Vzc2lvbi5jb21wbGV0ZSl7XG5cbiAgICAgICAgICAkZWxlbWVudC5odG1sKGN1cnJlbnRTZXNzaW9uLmJvZHkpO1xuICAgICAgICAgICRlbGVtZW50LmNzcyh7IGRpc3BsYXkgOiAnJ30pO1xuICAgICAgICAgIHN2Z1Bhblpvb20oJGVsZW1lbnQuZmluZCgnc3ZnJykuZWxzWzBdLCB7IG1pblpvb206IDAuMX0pO1xuICAgICAgICAgICRlbGVtZW50LmZpbmQoJ3N2ZycpLmF0dHIoJ3dpZHRoJywgcGFyc2VGbG9hdCgkZWxlbWVudC5maW5kKCdzdmcnKS5hdHRyKCd3aWR0aCcpLCAxMCkgLyAyICsgXCJwdFwiKTtcbiAgICAgICAgICAkZWxlbWVudC5maW5kKCdzdmcnKS5hdHRyKCdoZWlnaHQnLCBwYXJzZUZsb2F0KCRlbGVtZW50LmZpbmQoJ3N2ZycpLmF0dHIoJ2hlaWdodCcpLCAxMCkgLyAyICsgXCJwdFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkZWxlbWVudC5odG1sKCc8ZGl2IGNsYXNzPVwibWQtcHJldmlldy1jb250ZW50XCI+UGxlYXNlIHdhaXQgd2hpbGUgd2UgY29udmVydCB0aGlzIHR1cnRsZSBmaWxlPC9kaXY+JylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIH0gZWxzZSBpZiAoZmlsZUV4dCA9PT0gXCIuaHRtbFwiKXtcblxuICAgICAgICAkZWxlbWVudC5odG1sKCc8ZGl2IGNsYXNzPVwibWQtcHJldmlldy1jb250ZW50XCI+JyArIGN1cnJlbnRTZXNzaW9uLmJvZHkgKyAnPC9kaXY+Jyk7ICBcbiAgICAgICAgXG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgJGVsZW1lbnQuaHRtbCgnPGRpdiBjbGFzcz1cIm1kLXByZXZpZXctY29udGVudFwiPlRoZXJlIGlzIG5vIGJ1aWx0LWluIHZpZXdlciBmb3IgdGhpcyB0eXBlIG9mIGZpbGUuIDxhIGhyZWY9XCInICsgYXBwLnZmcy5nZXRVUkkoY3VycmVudFNlc3Npb24uZW50aXR5LnBhdGgpICsgJ1wiIHRhcmdldD1cImJsYW5rXCI+RG93bmxvYWQgJyArIGN1cnJlbnRTZXNzaW9uLmVudGl0eS5uYW1lICsgJzwvYT48L2Rpdj4nKTtcbiAgICAgIFxuICAgICAgfVxuICAgIH1cblxuICAgICRlbGVtZW50LmNzcyh7IGRpc3BsYXkgOiAnJ30pO1xuXG4gIH1cblxuICBlbWl0dGVyLnBhdXNlID0gZnVuY3Rpb24gcGF1c2VQcmV2aWV3U2Vzc2lvbiAoZW50aXR5KXtcblxuICAgIGN1cnJlbnRTZXNzaW9uID0gZmFsc2U7XG4gICAgJGVsZW1lbnQuY3NzKHsgZGlzcGxheSA6ICdub25lJ30pO1xuXG4gIH1cblxuICBlbWl0dGVyLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95UHJldmlld1Nlc3Npb24gKGVudGl0eSwgY2FsbGJhY2spe1xuXG4gICAgaWYgKHByZXZpZXdTZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF0pe1xuICAgICAgcHJldmlld1Nlc3Npb25zW2VudGl0eS5fc2Vzc2lvbklkXSA9IG51bGw7XG4gICAgICBkZWxldGUgcHJldmlld1Nlc3Npb25zW2VudGl0eS5fc2Vzc2lvbklkXTtcbiAgICAgIGNhbGxiYWNrKHRydWUpOyAvLyBhbHdheXMgb2theSB0byBjbG9zZSFcbiAgICB9XG5cbiAgICAkZWxlbWVudC5jc3Moe1xuICAgICAgZGlzcGxheSA6ICdub25lJ1xuICAgIH0pO1xuXG5cbiAgfVxuXG4gIHJldHVybiBlbWl0dGVyO1xuXG59IiwidmFyIFRlcm1pbmFsID0gcmVxdWlyZSgndGVybS5qcycpO1xudmFyIGRvbSA9IHJlcXVpcmUoJ2dyZWVuLW1lc2EtZG9tJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCwgY29udGVudFZpZXcpe1xuXG4gIC8qXG4gIHZhciB0ZXJtID0gbmV3IFRlcm1pbmFsKHtcbiAgICBjb2xzOiA4MCxcbiAgICByb3dzOiAyNCxcbiAgICBzY3JlZW5LZXlzOiB0cnVlXG4gIH0pO1xuKi9cblxuICB2YXIgJGVsZW1lbnQgPSBkb20oJzxkaXY+PC9kaXY+Jyk7XG5cbiAgJGVsZW1lbnQuYWRkQ2xhc3MoJ3Rlcm1pbmFscycpO1xuICAkZWxlbWVudC5jc3Moe1xuICAgIGRpc3BsYXkgOiAnbm9uZScsXG4gICAgJ21pbi13aWR0aCcgOiBjb250ZW50Vmlldy5zaXplKCkueCArICdweCcsXG4gICAgJ21pbi1oZWlnaHQnIDogY29udGVudFZpZXcuc2l6ZSgpLnkgKyAncHgnLFxuICAgIHBvc2l0aW9uIDogJ2Fic29sdXRlJyxcbiAgICB0b3AgOiAwLFxuICAgIGxlZnQgOiAwXG4gIH0pO1xuXG5cblxuICAkZWxlbWVudC5hcHBlbmRUbyhjb250ZW50Vmlldy5lbGVtZW50KTtcblxuICB2YXIgdGVybWluYWxTZXNzaW9ucyA9IHt9O1xuXG4gIHZhciB0ZXJtaW5hbHMgPSB7fTtcblxuICAvL3Rlcm0ub3BlbigkZWxlbWVudC5lbHNbMF0pO1xuXG4gIGFwcC5vbigndGVybScsIGZ1bmN0aW9uIChvKXtcblxuICAgIHRlcm1pbmFsc1tvLmlkXS53cml0ZShvLnBhY2tldCk7XG5cbiAgfSk7XG5cbiAgdmFyIHJlcXVlc3RJZCA9IDA7XG5cbiAgYXBwLmxheW91dC5vbigncmVzaXplJywgZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpe1xuXG4gICAgJGVsZW1lbnQuY3NzKHtcbiAgICAgICdtaW4td2lkdGgnIDogY29udGVudFZpZXcuc2l6ZSgpLnggKyAncHgnLFxuICAgICAgJ21pbi1oZWlnaHQnIDogY29udGVudFZpZXcuc2l6ZSgpLnkgKyAncHgnLFxuICAgIH0pO1xuXG4gIH0pO1xuXG5cbiAgdmFyIGVtaXR0ZXIgPSB7fTtcblxuICBlbWl0dGVyLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZVRlcm1pbmFsU2Vzc2lvbiAoZW50aXR5LCBjYWxsYmFjayl7XG5cbiAgICB2YXIgc2Vzc2lvbiA9IHRlcm1pbmFsU2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdID0ge1xuICAgICAgZW50aXR5IDogZW50aXR5XG4gICAgfVxuXG4gICAgdmFyIHNpemVzID0gdGVzdFNpemVzKCk7XG5cbiAgICBhcHAub25jZSgndGVybWluYWwtY3JlYXRlZCcsIGZ1bmN0aW9uIChtc2cpe1xuXG4gICAgICB2YXIgdGVybSA9IG5ldyBUZXJtaW5hbCh7XG4gICAgICAgIGNvbHMgOiBzaXplcy5jb2xzLFxuICAgICAgICByb3dzIDogc2l6ZXMucm93cyxcbiAgICAgICAgc2NyZWVuS2V5cyA6IHRydWVcbiAgICAgIH0pO1xuXG5cbiAgICAgIC8vIGZvciBkaXJlY3QgY29tbXVuaWNhdGlvbnMgZnJvbSB0aGUgc2VydmVyLi4uXG4gICAgICB0ZXJtaW5hbHNbbXNnLmlkXSA9IHRlcm07XG5cbiAgICAgIHRlcm0ub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGFwcC5yZW1vdGVTZW5kKCd0ZXJtJywge1xuICAgICAgICAgIGlkIDogbXNnLmlkLFxuICAgICAgICAgIHBhY2tldCA6IGRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgICAgXG5cbiAgICAgIHZhciAkdGVybSA9IGRvbSgnPGRpdj48L2Rpdj4nKTtcbiAgICAgICRlbGVtZW50LmFwcGVuZCgkdGVybSk7XG4gICAgICB0ZXJtLm9wZW4oJHRlcm0uZWxzWzBdKTtcblxuICAgICAgJHRlcm0uY3NzKHtcbiAgICAgICAgZGlzcGxheSA6ICdub25lJ1xuICAgICAgfSk7XG5cbiAgICAgIC8vIGZvciB0aGUgc2Vzc2lvbi4uLlxuICAgICAgc2Vzc2lvbi50ZXJtSWQgPSBtc2cuaWRcbiAgICAgIHNlc3Npb24udGVybWluYWwgPSB0ZXJtO1xuICAgICAgc2Vzc2lvbi4kdGVybSA9ICR0ZXJtO1xuXG4gICAgICBhcHAuZW1pdCgnc2Vzc2lvbi1zeW5jaHJvbmlzZWQnLCBlbnRpdHkuX3Nlc3Npb25JZCk7XG5cbiAgICAgIGNhbGxiYWNrKHRydWUpO1xuXG4gICAgfSk7XG5cbiAgICBhcHAucmVtb3RlU2VuZCgnY3JlYXRlLXRlcm0nLCB7XG4gICAgICBpZCA6IGVudGl0eS5fc2Vzc2lvbklkLFxuICAgICAgcm93cyA6IHNpemVzLnJvd3MsXG4gICAgICBjb2xzIDogc2l6ZXMuY29sc1xuICAgIH0pO1xuXG4gIH1cblxuICBlbWl0dGVyLnBhdXNlID0gZnVuY3Rpb24gcGF1c2VUZXJtaW5hbFNlc3Npb24gKGVudGl0eSl7XG5cbiAgICB2YXIgc2Vzc2lvbiA9IHRlcm1pbmFsU2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdO1xuXG4gICAgc2Vzc2lvbi4kdGVybS5jc3Moe1xuICAgICAgZGlzcGxheSA6ICdub25lJ1xuICAgIH0pO1xuXG4gICAgLy8gaGlkZXMgdGhlIG1haW4gdGVybWluYWxzIGVkaXRvci4uXG4gICAgJGVsZW1lbnQuY3NzKHtcbiAgICAgIGRpc3BsYXkgOiAnbm9uZScsXG4gICAgfSk7XG5cblxuICB9XG5cbiAgZW1pdHRlci5yZXN1bWUgPSBmdW5jdGlvbiByZXN1bWVUZXJtaW5hbFNlc3Npb24gKGVudGl0eSl7XG5cbiAgICB2YXIgc2Vzc2lvbiA9IHRlcm1pbmFsU2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdO1xuXG4gICAgc2Vzc2lvbi4kdGVybS5jc3Moe1xuICAgICAgZGlzcGxheSA6ICcnXG4gICAgfSk7XG5cbiAgICAkZWxlbWVudC5jc3Moe1xuICAgICAgZGlzcGxheSA6ICcnXG4gICAgfSk7XG5cbiAgfVxuXG4gIGVtaXR0ZXIuZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3lUZXJtaW5hbFNlc3Npb24gKGVudGl0eSwgY2FsbGJhY2spe1xuXG4gICAgdmFyIHNlc3Npb24gPSB0ZXJtaW5hbFNlc3Npb25zW2VudGl0eS5fc2Vzc2lvbklkXTtcblxuICAgIHNlc3Npb24udGVybWluYWwuZGVzdHJveSgpO1xuICAgIHNlc3Npb24uJHRlcm0ucmVtb3ZlKCk7XG5cbiAgICBhcHAucmVtb3RlU2VuZCgna2lsbC10ZXJtJywgc2Vzc2lvbi50ZXJtSWQpO1xuXG4gICAgdGVybWluYWxzW3Nlc3Npb24udGVybUlkXSA9IG51bGw7XG4gICAgdGVybWluYWxTZXNzaW9uc1tlbnRpdHkuX3Nlc3Npb25JZF0gPSBudWxsO1xuXG4gICAgZGVsZXRlIHRlcm1pbmFsU2Vzc2lvbnNbZW50aXR5Ll9zZXNzaW9uSWRdO1xuICAgIGRlbGV0ZSB0ZXJtaW5hbHNbc2Vzc2lvbi50ZXJtSWRdO1xuXG4gICAgJGVsZW1lbnQuY3NzKHtcbiAgICAgIGRpc3BsYXkgOiAnbm9uZScsXG4gICAgfSk7XG4gICAgLy8gY2FsbGJhY2sgdHJ1ZSA9IG9rYXkgdG8gZGVzdHJveSB0aGlzIHNlc3Npb24uLi5cbiAgICBjYWxsYmFjayh0cnVlKTtcblxuICB9XG5cblxuICBmdW5jdGlvbiB0ZXN0U2l6ZXMgKCl7XG5cbiAgICAgICRlbGVtZW50LmNzcyh7ZGlzcGxheSA6ICcnfSk7XG5cbiAgICAgIHZhciAkdGVzdGVyID0gZG9tKCc8ZGl2PjA8L2Rpdj4nKTtcbiAgICAgICR0ZXN0ZXIuY3NzKHtcbiAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaydcbiAgICAgIH0pXG4gICAgICAkZWxlbWVudC5hcHBlbmQoJHRlc3Rlcik7XG4gICAgICAgIC8vdmFyICRlbFxuXG4gICAgICB2YXIgY2hhcldpZHRoID0gJHRlc3Rlci5lbHNbMF0uY2xpZW50V2lkdGg7XG4gICAgICB2YXIgY2hhckhlaWdodCA9ICR0ZXN0ZXIuZWxzWzBdLmNsaWVudEhlaWdodDtcblxuICAgICAgJGVsZW1lbnQuY3NzKHtkaXNwbGF5IDogJ25vbmUnfSk7XG4gICAgICAkdGVzdGVyLnJlbW92ZSgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2xzIDogTWF0aC5mbG9vciggKChjb250ZW50Vmlldy5zaXplKCkueCAvIGNoYXJXaWR0aCkgLyAxMCkgKSAqIDEwLFxuICAgICAgICByb3dzIDogTWF0aC5mbG9vcihjb250ZW50Vmlldy5zaXplKCkueSAvIGNoYXJIZWlnaHQpXG4gICAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBlbWl0dGVyO1xuXG59IiwidmFyIGRvbWlmeSA9IHJlcXVpcmUoJ2RvbWlmeScpO1xudmFyIGRvbSA9IHJlcXVpcmUoJ2dyZWVuLW1lc2EtZG9tJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCwgYm94KXtcblxuICB2YXIgZmlsZXMgPSBkb21pZnkoJzx1bD48L3VsPicpXG4gIGZpbGVzLmNsYXNzTmFtZSA9IFwiYm94LWlubmVyIGZpbGVzXCI7XG4gIGJveC5hZGRFbGVtZW50KGZpbGVzKTtcblxuICB2YXIgY3VycmVudFRyZWUgPSBmYWxzZTtcblxuICAvLyB0aGlzIGV2ZW50IGdldHMgdHJpZ2dlcmVkIHdoZW5ldmVyIHRoZSB2aXJ0dWFsIGZpbGUgc3lzdGVtIGhhcyBmaW5pc2hlZCBzeW5jaHJvbmlzaW5nIHdpdGggdGhlIHNlcnZlclxuICBhcHAub24oJ3N5bmMnLCBmdW5jdGlvbiAocGF0aCl7XG5cbiAgICBhcHAudmZzLmdldEFsbChyZWZyZXNoVHJlZSk7XG5cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGRyZW4gKG5vZGUpe1xuICAgIHZhciBmbiA9IGZ1bmN0aW9uICgpeyB0aGlzLnJlbW92ZSgpOyB0aGlzLm9uY2xpY2sgPSBudWxsOyB9O1xuICAgIHZhciBmbnMgPSBbXTtcbiAgICBmb3JFYWNoLmNhbGwoIG5vZGUuY2hpbGROb2RlcyAsIGZ1bmN0aW9uIChub2RlKXsgXG4gICAgICBmbnMucHVzaChmbi5iaW5kKG5vZGUpKVxuICAgIH0pO1xuICAgIGZvckVhY2guY2FsbChmbnMsIGZ1bmN0aW9uKGZuKXtmbigpfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmaWxlVCAobyl7XG4gICAgcmV0dXJuICc8bGkgY2xhc3M9XCJmaWxlXCI+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cInR5cGNuIHR5cGNuLWRvY3VtZW50LXRleHRcIj48L3NwYW4+JyArXG4gICAgICAgICc8YSBocmVmPVwiI1wiPicgKyBcbiAgICAgICAgICBvLm5hbWUgK1xuICAgICAgICAnPC9hPicgK1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJ0eXBjbiB0eXBjbi1ob3ZlciB0eXBjbi1leWUtb3V0bGluZVwiPjwvc3Bhbj4nICsgXG4gICAgICAgICc8c3BhbiBjbGFzcz1cInR5cGNuIHR5cGNuLWhvdmVyIHR5cGNuLWluZm8tbGFyZ2VcIj48L3NwYW4+JyArIFxuICAgICAgJzwvbGk+JztcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvbGRlclQgKG8pe1xuICAgIHJldHVybiAnPGxpPicgK1xuICAgICAgICAnPHNwYW4gY2xhc3M9XCJ0eXBjbiB0eXBjbi1mb2xkZXJcIj48L3NwYW4+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cInR5cGNuIHR5cGNuLWZvbGRlci1vcGVuXCI+PC9zcGFuPicgK1xuICAgICAgICAnPGEgaHJlZj1cIiNcIj4nICsgXG4gICAgICAgICAgby5uYW1lICsgXG4gICAgICAgICc8L2E+JyArXG4gICAgICAgICc8c3BhbiBjbGFzcz1cInR5cGNuIHR5cGNuLWhvdmVyIHR5cGNuLWRvY3VtZW50LWFkZFwiPjwvc3Bhbj4nICtcbiAgICAgICAgJzxzcGFuIGNsYXNzPVwidHlwY24gdHlwY24taG92ZXIgdHlwY24tZm9sZGVyLWFkZFwiPjwvc3Bhbj4nICsgXG4gICAgICAgICc8c3BhbiBjbGFzcz1cInR5cGNuIHR5cGNuLWhvdmVyIHR5cGNuLWluZm8tbGFyZ2VcIj48L3NwYW4+JyArIFxuICAgICAgJzwvbGk+JztcblxuICB9XG5cbiAgZnVuY3Rpb24gcmVmcmVzaFRyZWUgKHRyZWUpe1xuXG4gICAgLy9kZWxldGVDaGlsZHJlbihmaWxlcyk7XG5cbiAgICBjdXJyZW50VHJlZSA9IHRyZWU7XG5cbiAgICBkb20oJ2xpJywgZmlsZXMpLnJlbW92ZSgpO1xuICAgIHZhciAkZmlsZXMgPSBkb20oZmlsZXMpO1xuXG4gICAgZnVuY3Rpb24gc2hvd0NvbnRlbnRzICh0cmVlLCAkcGFyZW50LCBsZXZlbCl7XG5cbiAgICAgIC8vdmFyIGVsID0gZG9taWZ5KG5ld0ZvbGRlcigpKTtcbiAgICAvLyAgJG5ld0ZvbGRlciA9IGRvbSgnYScsIGVsKTtcbiAgICAgLy8gJHBhcmVudC5hcHBlbmQoZWwpO1xuXG4gICAgICB0cmVlLmZvckVhY2goZnVuY3Rpb24gKGVudGl0eSl7XG5cbiAgICAgICAgdmFyIGVsLCAkYSwgJHVsID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKGVudGl0eS50eXBlID09PSBcImZpbGVcIil7XG5cbiAgICAgICAgICBlbCA9IGRvbWlmeShmaWxlVChlbnRpdHkpKTtcbiAgICAgICAgICAkYSA9IGRvbSgnYScsIGVsKTtcblxuICAgICAgICAgICRwcmV2aWV3ID0gZG9tKCdzcGFuLnR5cGNuLWV5ZS1vdXRsaW5lJywgZWwpO1xuICAgICAgICAgICRpbmZvID0gZG9tKCdzcGFuLnR5cGNuLWluZm8tbGFyZ2UnLCBlbCk7XG5cbiAgICAgICAgICAkYS5vbignbW91c2V1cCcsIChmdW5jdGlvbiAoZW50aXR5LCAkZWwsIGV2ZW50KXtcblxuICAgICAgICAgICAgaWYgKGV2ZW50LndoaWNoID09PSAxKXtcblxuICAgICAgICAgICAgICBhcHAuZW1pdCgnZWRpdC1lbnRpdHknLCBlbnRpdHkpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LndoaWNoID09PSAzKXtcblxuICAgICAgICAgICAgICBmaWxlQ29udGV4dE1lbnUoZW50aXR5LCAkZWwpO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9KS5iaW5kKHt9LCBlbnRpdHksIGRvbShlbCkpKVxuXG4gICAgICAgICAgJHByZXZpZXcub24oJ2NsaWNrJywgKGZ1bmN0aW9uIChlbnRpdHksIGV2ZW50KXtcblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgYXBwLmVtaXQoJ3ByZXZpZXctZW50aXR5JywgZW50aXR5KTtcblxuICAgICAgICAgIH0pLmJpbmQoe30sIGVudGl0eSkpO1xuXG4gICAgICAgICAgJGluZm8ub24oJ2NsaWNrJywgKGZ1bmN0aW9uIChlbnRpdHksIGV2ZW50KXtcblxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgYXBwLmVtaXQoJ2VkaXQtZW50aXR5LWluZm8nLCBlbnRpdHksICdmaWxlJyk7XG5cbiAgICAgICAgICB9KS5iaW5kKHt9LCBlbnRpdHkpKTtcblxuXG4gICAgICAgIH0gZWxzZSBpZiAoZW50aXR5LnR5cGUgPT09IFwiZm9sZGVyXCIpe1xuXG4gICAgICAgICAgZWwgPSBkb21pZnkoZm9sZGVyVChlbnRpdHkpKTtcbiAgICAgICAgICAkYSA9IGRvbSgnYScsIGVsKTtcblxuICAgICAgICAgICRpbmZvID0gZG9tKCdzcGFuLnR5cGNuLWluZm8tbGFyZ2UnLCBlbCk7XG4gICAgICAgICAgJG5ld0ZvbGRlciA9IGRvbSgnc3Bhbi50eXBjbi1mb2xkZXItYWRkJywgZWwpO1xuICAgICAgICAgICRuZXdGaWxlID0gZG9tKCdzcGFuLnR5cGNuLWRvY3VtZW50LWFkZCcsIGVsKTtcblxuICAgICAgICAgIGlmIChlbnRpdHkucGF0aCA9PT0gXCIvXCIpe1xuICAgICAgICAgICAgJGluZm8uY3NzKHsgZGlzcGxheTogJ25vbmUnfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgJHVsID0gZG9tKCc8dWwgY2xhc3M9XCJsZXZlbC0nICsgKGxldmVsICsgMSkrICdcIj48L3VsPicpO1xuXG4gICAgICAgICAgLy8kZWwuYWRkQ2xhc3MoJ29wZW4nKTtcbiAgICAgICAgICAkdWwuYWRkQ2xhc3MoJ29wZW4nKTtcbiAgICAgICAgICBkb20oZWwpLmFkZENsYXNzKCdvcGVuJyk7XG5cbiAgICAgICAgICAkYS5vbignbW91c2V1cCcsIChmdW5jdGlvbihlbnRpdHksICRlbCwgJHVsLCBldmVudCl7XG5cbiAgICAgICAgICAgIGlmIChldmVudC53aGljaCA9PT0gMSl7XG4gICAgICAgICAgICAgICRlbC50b2dnbGVDbGFzcygnb3BlbicpO1xuICAgICAgICAgICAgICAkdWwudG9nZ2xlQ2xhc3MoJ29wZW4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0pLmJpbmQoe30sIGVudGl0eSwgZG9tKGVsKSwgJHVsKSk7XG5cbiAgICAgICAgICAkbmV3Rm9sZGVyLm9uKCdjbGljaycsIChmdW5jdGlvbiAoZW50aXR5LCBldmVudCl7XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGFwcC5lbWl0KCdiZWdpbi1uZXctZm9sZGVyLXNlc3Npb24nLCBlbnRpdHkpO1xuXG4gICAgICAgICAgfSkuYmluZCh7fSwgZW50aXR5KSk7XG5cbiAgICAgICAgICAkbmV3RmlsZS5vbignY2xpY2snLCAoZnVuY3Rpb24gKGVudGl0eSwgZXZlbnQpe1xuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBhcHAuZW1pdCgnYmVnaW4tbmV3LWRvY3VtZW50LXNlc3Npb24nLCBlbnRpdHkpO1xuXG4gICAgICAgICAgfSkuYmluZCh7fSwgZW50aXR5KSk7XG5cbiAgICAgICAgICAkaW5mby5vbignY2xpY2snLCAoZnVuY3Rpb24gKGVudGl0eSwgZXZlbnQpe1xuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBhcHAuZW1pdCgnZWRpdC1lbnRpdHktaW5mbycsIGVudGl0eSwgJ2ZvbGRlcicpO1xuXG4gICAgICAgICAgfSkuYmluZCh7fSwgZW50aXR5KSk7XG5cbiAgICAgICAgICBzaG93Q29udGVudHMoZW50aXR5LmNvbnRlbnRzLCAkdWwsIGxldmVsICsgMSk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgICRwYXJlbnQuYXBwZW5kKGVsKTtcbiAgICAgICAgaWYgKCR1bCl7XG4gICAgICAgICAgJHBhcmVudC5hcHBlbmQoJHVsKTtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgIH1cblxuICAgIHNob3dDb250ZW50cyh0cmVlLCAkZmlsZXMsIDApO1xuXG4gICAgZG9tKCd1bC5maWxlcyAgPiBsaScsIGJveC5lbGVtZW50KS5hZGRDbGFzcygnb3BlbicpO1xuICAgIGRvbSgndWwuZmlsZXMgPiB1bC5sZXZlbC0xJywgYm94LmVsZW1lbnQpLmFkZENsYXNzKCdvcGVuJyk7XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbGVDb250ZXh0TWVudShlbnRpdHksICRlbCl7XG5cbiAgICBjb25zb2xlLmxvZygnQ29udGVudCBtZW51IG5vdCBpbXBsZW1lbnRlZCcpO1xuXG4gIH1cblxufTsiLCJ2YXIgJCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IuYmluZChkb2N1bWVudCk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoJy4vY29uc29sZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNjcmVlbkluaXRpYWxpc2VyICgpe1xuXG4gIC8qXG4gICAgICAtLXRvcCBtZW51LS0tLS0tLS0tLS0tLVxuICAgICAgLW4tLS10YWJzLS0tLS0tLS0tLS0tLS1cbiAgICAgIC1hLS0gICAgICAgICAgICAgICAgICAtXG4gICAgICAtdi0tIGVkaXQgd2luZG93ICAgICAgLVxuICAgICAgLSAtLSAgICAgICAgICAgICAgICAgIC1cbiAgICAgIC0tZm9vdGVyLS0tLS0tLS0tLS0tLS0tXG4gICovXG5cbiAgdmFyIGVtaXR0ZXIgPSBuZXcgKHJlcXVpcmUoJ2V2ZW50cycpKS5FdmVudEVtaXR0ZXI7XG5cbiAgLy8gaGVpZ2h0cyBjb25maWcuLiBcbiAgdmFyIHRvcE1lbnVIZWlnaHQgPSAzMDtcbiAgdmFyIGZpbGVOYXZpZ2F0aW9uV2lkdGggPSA0MDA7XG4gIHZhciBlZGl0b3JUYWJIZWlnaHQgPSAyNTtcbiAgdmFyIGNvbnNvbGVIZWlnaHQgPSAxMDA7XG5cbiAgLy8gc29tZSBjc3MgY2xhc3NlcyBjb25maWcuLi4gXG4gIHZhciBmaWxlTmF2aWdhdGlvbkNsYXNzID0gJ2ZpbGUtbmF2JztcbiAgdmFyIHBhZ2VDbGFzcyA9ICdwYWdlJztcbiAgdmFyIHRvcE1lbnVDbGFzcyA9ICd0b3AtbWVudSc7XG4gIHZhciBlZGl0b3JXcmFwcGVyQ2xhc3MgPSAnY29udGVudC12aWV3JztcbiAgdmFyIGVkaXRvclRhYnNDbGFzcyA9ICd0YWJzJztcbiAgdmFyIGVkaXRvclZpZXdDbGFzcyA9ICdlZGl0b3InO1xuICB2YXIgY29uc29sZUNsYXNzID0gJ2NvbnNvbGUnO1xuXG4gIC8vIGNyZWF0ZSBhbiBvdXRlciB3cmFwcGVyLi5cbiAgdmFyIHBhZ2UgPSBjcmVhdGVCb3gocGFnZUNsYXNzKTtcbiAgcGFnZS5lbGVtZW50LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcblxuICB2YXIgdG9wTWVudSA9IGNyZWF0ZUJveCh0b3BNZW51Q2xhc3MpO1xuICBwYWdlLmFkZEJveCh0b3BNZW51KTtcblxuICB2YXIgZmlsZU5hdmlnYXRpb24gPSBjcmVhdGVCb3goZmlsZU5hdmlnYXRpb25DbGFzcyk7XG4gIHBhZ2UuYWRkQm94KGZpbGVOYXZpZ2F0aW9uKTtcblxuICB2YXIgZWRpdG9yV3JhcHBlciA9IGNyZWF0ZUJveChlZGl0b3JXcmFwcGVyQ2xhc3MpO1xuICBwYWdlLmFkZEJveChlZGl0b3JXcmFwcGVyKTtcblxuICB2YXIgZWRpdG9yVGFicyA9IGNyZWF0ZUJveChlZGl0b3JUYWJzQ2xhc3MpO1xuICBlZGl0b3JXcmFwcGVyLmFkZEJveChlZGl0b3JUYWJzKTtcblxuICB2YXIgZWRpdG9yVmlldyA9IGNyZWF0ZUJveChlZGl0b3JWaWV3Q2xhc3MpO1xuICBlZGl0b3JXcmFwcGVyLmFkZEJveChlZGl0b3JWaWV3KTtcblxuICB2YXIgY29uc29sZVZpZXcgPSBjcmVhdGVCb3goY29uc29sZUNsYXNzKTtcbiAgcGFnZS5hZGRCb3goY29uc29sZVZpZXcpO1xuXG4gIHJlcXVpcmUoJy4vY29uc29sZS5qcycpLmFwcGVuZFRvKGNvbnNvbGVWaWV3LmVsZW1lbnQpO1xuXG4gIC8vY29uc29sZVZpZXcuYWRkRWxlbWVudChjb25zb2xlLmVsZW1lbnQpO1xuXG4gIC8vIG5vdyBhcHBlbmQgdG8gdGhlIGFjdHVhbCBib2R5Li4uXG4gIHBhZ2UuYXBwZW5kVG9FbGVtZW50KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKSk7XG5cbiAgdmFyIGdyID0gKDEgKyBNYXRoLnNxcnQoNSkpIC8gMjtcbiAgLy8gbWFrZSBzdXJlIHdlIGhhdmUgYSBoYW5kbGVyLi4uXG4gIGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZSAoZSl7XG5cbiAgICB2YXIgaW5uZXJXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIHZhciBpbm5lckhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgIC8vZmlsZU5hdmlnYXRpb25XaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIC0gKHdpbmRvdy5pbm5lcldpZHRoIC8gZ3IpO1xuXG4gICAgcGFnZS5zaXplKGlubmVyV2lkdGgsIGlubmVySGVpZ2h0KTtcbiAgICBwYWdlLnBvc2l0aW9uKDAsIDApO1xuXG4gICAgdG9wTWVudS5zaXplKGlubmVyV2lkdGgsIHRvcE1lbnVIZWlnaHQpO1xuICAgIHRvcE1lbnUucG9zaXRpb24oMCwgMCk7XG5cbiAgICBjb25zb2xlVmlldy5zaXplKGlubmVyV2lkdGgsIGNvbnNvbGVIZWlnaHQpO1xuICAgIGNvbnNvbGVWaWV3LnBvc2l0aW9uKDAsIGlubmVySGVpZ2h0IC0gY29uc29sZUhlaWdodCk7XG5cbiAgICBmaWxlTmF2aWdhdGlvbi5zaXplKGZpbGVOYXZpZ2F0aW9uV2lkdGggLSAxMCwgaW5uZXJIZWlnaHQgLSB0b3BNZW51LnNpemUoKS55IC0gY29uc29sZVZpZXcuc2l6ZSgpLnkgLSAxMCk7XG4gICAgZmlsZU5hdmlnYXRpb24ucG9zaXRpb24oMCwgKHRvcE1lbnUuc2l6ZSgpLnkpKTtcblxuICAgIGVkaXRvcldyYXBwZXIuc2l6ZShpbm5lcldpZHRoIC0gKGZpbGVOYXZpZ2F0aW9uV2lkdGggKyAxKSwgaW5uZXJIZWlnaHQgLSB0b3BNZW51LnNpemUoKS55IC0gY29uc29sZVZpZXcuc2l6ZSgpLnkpO1xuICAgIGVkaXRvcldyYXBwZXIucG9zaXRpb24oZmlsZU5hdmlnYXRpb25XaWR0aCArIDEsKHRvcE1lbnUuc2l6ZSgpLnkpKTtcblxuICAgIGVkaXRvclRhYnMuc2l6ZShlZGl0b3JXcmFwcGVyLnNpemUoKS54LCBlZGl0b3JUYWJIZWlnaHQpO1xuICAgIGVkaXRvclRhYnMucG9zaXRpb24oMCwgMCk7XG5cbiAgICBlZGl0b3JWaWV3LnNpemUoZWRpdG9yV3JhcHBlci5zaXplKCkueCwgZWRpdG9yV3JhcHBlci5zaXplKCkueSAtIGVkaXRvclRhYkhlaWdodCk7XG4gICAgZWRpdG9yVmlldy5wb3NpdGlvbigwLCBlZGl0b3JUYWJIZWlnaHQpO1xuXG4gICAgZW1pdHRlci5lbWl0KCdyZXNpemUnLCBpbm5lcldpZHRoLCBpbm5lckhlaWdodCk7XG5cbiAgfVxuXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVSZXNpemUsIGZhbHNlKTtcblxuICBlbWl0dGVyLnBhZ2UgPSBwYWdlO1xuICBlbWl0dGVyLm1lbnUgPSB0b3BNZW51O1xuICBlbWl0dGVyLm5hdiA9IGZpbGVOYXZpZ2F0aW9uO1xuICBlbWl0dGVyLnRhYnMgPSBlZGl0b3JUYWJzO1xuICBlbWl0dGVyLmVkaXRvciA9IGVkaXRvclZpZXc7XG4gIGVtaXR0ZXIuY29uc29sZSA9IGNvbnNvbGVWaWV3O1xuXG4gIC8vIHRyaWdnZXIgYSByZXNpemUgbWFudWFsbHkgdG8gZ2V0IGluaXRpYWwgcG9zaXRpb25zIGFuZCBzaXplcy4uLiBcbiAgaGFuZGxlUmVzaXplKCk7XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlQm94IChjbGFzc05hbWUpe1xuXG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcbiAgZWwuY2xhc3NOYW1lID0gXCJib3ggXCIgKyBjbGFzc05hbWUgO1xuICBzdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gIHN0eWxlLndpZHRoID0gXCIwcHhcIjtcbiAgc3R5bGUuaGVpZ2h0ID0gXCIwcHhcIjtcblxuICByZXR1cm4ge1xuICAgIGVsZW1lbnQgOiBlbCxcbiAgICBwb3NpdGlvbiA6IGZ1bmN0aW9uICh4LCB5KXtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCl7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeCA6IHBhcnNlSW50KHN0eWxlLmxlZnQsIDEwKSxcbiAgICAgICAgICB5IDogcGFyc2VJbnQoc3R5bGUudG9wLCAxMClcbiAgICAgICAgfVxuICAgICAgfSBcbiAgICAgIHN0eWxlLnRvcCA9IHkgKyBcInB4XCI7XG4gICAgICBzdHlsZS5sZWZ0ID0geCArIFwicHhcIjtcbiAgICB9LFxuICAgIHNpemUgOiBmdW5jdGlvbiAoeCwgeSl7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHggOiBwYXJzZUludChzdHlsZS53aWR0aCwgMTApLFxuICAgICAgICAgIHkgOiBwYXJzZUludChzdHlsZS5oZWlnaHQsIDEwKVxuICAgICAgICB9XG4gICAgICB9IFxuICAgICAgc3R5bGUuaGVpZ2h0ID0geSArIFwicHhcIjtcbiAgICAgIHN0eWxlLndpZHRoID0geCArIFwicHhcIjtcbiAgICB9LFxuICAgIGFkZEJveCA6IGZ1bmN0aW9uIChib3gpe1xuICAgICAgYm94LmFwcGVuZFRvRWxlbWVudChlbCk7XG4gICAgfSxcbiAgICBhZGRFbGVtZW50IDogZnVuY3Rpb24gKGVsZW1lbnQpe1xuICAgICAgZWwuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfSxcbiAgICBhcHBlbmRUb0VsZW1lbnQgOiBmdW5jdGlvbiAoZWxlbWVudCl7XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gIH1cblxufSIsInZhciBkb20gPSByZXF1aXJlKCdncmVlbi1tZXNhLWRvbScpO1xudmFyIGVhY2ggPSByZXF1aXJlKCdmb3JlYWNoJyk7XG5cbnZhciBiYWNrZHJvcCA9ICc8ZGl2IGNsYXNzPVwibW9kYWwtYmFja2Ryb3AgZmFkZVwiPjwvZGl2Pic7XG52YXIgYnV0dG9uID0gZnVuY3Rpb24gKG8peyByZXR1cm4gJzxidXR0b24gY2xhc3M9XCJidG4gYnRuLW1pbmkgJyArIG8uY2xhc3NlcyArJ1wiPicgKyBvLm9wdGlvbiArJzwvYnV0dG9uPic7IH07XG5cbnZhciBtb2RhbCA9IGZ1bmN0aW9uIChvKXsgcmV0dXJuICcnICsgXG4gICc8ZGl2IGNsYXNzPVwibW9kYWwgZmFkZVwiPicgK1xuICAnIDxkaXYgY2xhc3M9XCJtb2RhbC1oZWFkZXJcIj4nICtcbiAgJyAgIDxoMz4nKyBvLmhlYWRlciArICc8L2gzPicgK1xuICAnIDwvZGl2PicgKyBcbiAgJyA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPicgK1xuICAnICAgPGRpdj4nICsgby5tZXNzYWdlICsgJzwvZGl2PicgK1xuICAnIDwvZGl2PicgK1xuICAnIDxkaXYgY2xhc3M9XCJtb2RhbC1mb290ZXJcIj4nICtcbiAgJyAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXBcIj4nICtcbiAgJyAgIDwvZGl2PicgK1xuICAnPC9kaXY+JyArXG4gICc8L2Rpdj4nXG59O1xuXG52YXIgbG9hZGluZyA9ICcnICtcbic8ZGl2IGNsYXNzPVwibW9kYWwgZmFkZVwiPicgK1xuJyA8ZGl2IGNsYXNzPVwibW9kYWwtaGVhZGVyXCI+TG9hZGluZy4uLiBwbGVhc2Ugd2FpdDwvZGl2PicgK1xuJyA8ZGl2IGNsYXNzPVwibW9kYWwtZm9vdGVyXCI+PC9kaXY+JyArXG4nPC9kaXY+JztcblxuZnVuY3Rpb24gUG9wdXBzICgpe1xuXG4gIHRoaXMuYmFja2Ryb3AgPSBkb20oYmFja2Ryb3ApO1xuICB0aGlzLmxvYWRlciA9IGRvbShsb2FkaW5nKTtcblxuICByZXR1cm4gdGhpcztcblxufVxuXG5Qb3B1cHMucHJvdG90eXBlID0ge1xuICBsb2FkaW5nIDogZnVuY3Rpb24gKCl7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcblxuICAgIGRvbSgnYm9keScpLmFwcGVuZCh0aGlzLmJhY2tkcm9wKTtcbiAgICBkb20oJ2JvZHknKS5hcHBlbmQodGhpcy5sb2FkZXIpO1xuXG4gICAgdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCgoZnVuY3Rpb24gKCl7XG5cbiAgICAgIHRoaXMuYmFja2Ryb3AuYWRkQ2xhc3MoJ2luJyk7XG4gICAgICB0aGlzLmxvYWRlci5hZGRDbGFzcygnaW4nKTtcblxuICAgIH0pLmJpbmQodGhpcyksIDEwMCk7XG4gIH0sXG4gIG5vdExvYWRpbmcgOiBmdW5jdGlvbiAoKXtcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuXG4gICAgdGhpcy5iYWNrZHJvcC5yZW1vdmVDbGFzcygnaW4nKTtcbiAgICB0aGlzLmxvYWRlci5yZW1vdmVDbGFzcygnaW4nKTtcblxuICAgIHRoaXMuYmFja2Ryb3AucmVtb3ZlKCk7XG4gICAgdGhpcy5sb2FkZXIucmVtb3ZlKCk7XG5cbiAgfSxcbiAgbWVzc2FnZSA6IGZ1bmN0aW9uIChoZWFkZXIsIG1lc3NhZ2UsIGZuKXtcblxuICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgIGZuKCk7XG5cbiAgfSxcbiAgY29uZmlybSA6IGZ1bmN0aW9uIChoZWFkZXIsIG1lc3NhZ2UsIG9wdGlvbnMpe1xuXG4gICAgdmFyIGNvbmZpcm1Cb3ggPSBkb20obW9kYWwoeyBoZWFkZXIgOiBoZWFkZXIsIG1lc3NhZ2U6IG1lc3NhZ2UgfSkpO1xuXG4gICAgdmFyIGJ0bkdyb3VwID0gZG9tKGNvbmZpcm1Cb3gpLmZpbmQoJy5idG4tZ3JvdXAnKTtcblxuICAgIGRvbSgnYm9keScpLmFwcGVuZCh0aGlzLmJhY2tkcm9wKTtcbiAgICBkb20oJ2JvZHknKS5hcHBlbmQoY29uZmlybUJveCk7XG5cbiAgICB0aGlzLmJhY2tkcm9wLmNzcyh7XG4gICAgICBoZWlnaHQgOiB3aW5kb3cuaW5uZXJIZWlnaHQgKyBcInB4XCJcbiAgICB9KVxuXG4gICAgZWFjaChvcHRpb25zLCBmdW5jdGlvbiAob3B0aW9uKXtcblxuICAgICAgdmFyIGJ0biA9IGRvbShidXR0b24oe29wdGlvbiA6IG9wdGlvbi50ZXh0LCBjbGFzc2VzOiBvcHRpb24uY2xhc3NlcyA/IG9wdGlvbi5jbGFzc2VzIDogXCJcIn0pKTtcblxuICAgICAgYnRuR3JvdXAuYXBwZW5kKGJ0bik7XG5cbiAgICAgIGJ0bi5vbignY2xpY2snLCAoZnVuY3Rpb24gKGUpe1xuXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB0aGlzLmJhY2tkcm9wLnJlbW92ZSgpO1xuICAgICAgICBjb25maXJtQm94LnJlbW92ZSgpO1xuXG4gICAgICAgIG9wdGlvbi5jYWxsYmFjaygpO1xuXG4gICAgICB9KS5iaW5kKHRoaXMpKTtcblxuICAgIH0sIHRoaXMpO1xuXG4gICAgc2V0VGltZW91dCgoZnVuY3Rpb24gKCl7IFxuICAgICAgY29uZmlybUJveC5hZGRDbGFzcygnaW4nKTtcbiAgICAgIHRoaXMuYmFja2Ryb3AuYWRkQ2xhc3MoJ2luJyk7XG4gICAgfSkuYmluZCh0aGlzKSwxMCk7XG5cbiAgfVxuXG59O1xuXG52YXIgcG9wdXBzID0gbmV3IFBvcHVwcygpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvcHVwczsiLCJ2YXIgY29uc29sZSA9IHJlcXVpcmUoJy4vY29uc29sZS5qcycpO1xudmFyIGRvbWlmeSA9IHJlcXVpcmUoJ2RvbWlmeScpO1xudmFyIGRvbSA9IHJlcXVpcmUoJ2dyZWVuLW1lc2EtZG9tJyk7XG52YXIgcG9wdXBzID0gcmVxdWlyZSgnLi9tb2RhbC5qcycpO1xudmFyIGZpbGVzaXplID0gcmVxdWlyZSgnZmlsZXNpemUnKTtcbnZhciBEaWZmTWF0Y2hQYXRjaCA9IHJlcXVpcmUoJ2RpZmYtbWF0Y2gtcGF0Y2gnKTtcbnZhciBkbXAgPSBuZXcgRGlmZk1hdGNoUGF0Y2goKTtcbnZhciBjbG9uZURlZXAgPSByZXF1aXJlKCdjbG9uZS1kZWVwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFwcCwgc2Vzc2lvbkhhbmRsZXJzLCBib3gpe1xuXG4gIC8vIFJpZ2h0LCBsZXQncyBrZWVwIHRoaXMgc2ltcGxlLlxuICAvLyBTZXNzaW9uIEhhbmRsZXJzIHNob3VsZCBoYXZlIGEgY29uc2lzdGVudCBBUElcbiAgLy8gYmVjYXVzZSB3ZSdyZSBub3QgYXQgYWxsIERSWSBoZXJlIGF0bS5cbiAgLy8gXG4gIC8vIFdlIGFsc28gd2FudCB0byByZW1vdmUgYWxsIHRoZSBkZWFsaW5nIHdpdGggXG4gIC8vIGVudGl0eSBjaGFuZ2VzIGhlcmUuIEFsbCB0aGF0IHNlc3Npb25zIHNob3VsZCBcbiAgLy8gZGVhbCB3aXRoIGlzIGNyZWF0aW5nLCBwYXVzaW5nLCByZXN1bWluZyBhbmQgZGVzdHJveWluZ1xuICAvLyBzZXNzaW9ucywgbG9va2luZyBhZnRlciB0aGUgdGFicy5cblxuICB2YXIgdWwgPSBkb21pZnkoJzx1bCBjbGFzcz1cInRhYnNcIj48L3VsPicpO1xuICBib3guYWRkRWxlbWVudCh1bCk7XG4gICR1bCA9IGRvbSh1bCk7XG5cbiAgLy8gd2UgdXNlIGFuIGFycmF5IGJlY2F1c2Ugb3JkZXJpbmcgaXMgdXNlZnVsIGhlcmUuXG4gIHZhciBzZXNzaW9ucyA9IFtdO1xuXG4gIC8vIGNvdW50ZXJzL2lkc1xuICB2YXIgc2Vzc2lvbklkID0gMDtcbiAgdmFyIHRlcm1pbmFsU2Vzc2lvbkNvdW50ID0gMDtcbiAgdmFyIGNvbW1hbmRTZXNzaW9uQ291bnQgPSAwO1xuICB2YXIgY29tbWl0U2Vzc2lvbkNvdW50ID0gMDtcblxuICBmdW5jdGlvbiBnZXRFZGl0b3IgKGVkaXRvcil7XG5cbiAgICBpZiAoZWRpdG9yID09PSBcImFjZVwiKXtcbiAgICAgIHJldHVybiBzZXNzaW9uSGFuZGxlcnMuYWNlO1xuICAgIH0gZWxzZSBpZiAoZWRpdG9yID09PSBcImluZm9cIil7XG4gICAgICByZXR1cm4gc2Vzc2lvbkhhbmRsZXJzLmluZm87XG4gICAgfSBlbHNlIGlmIChlZGl0b3IgPT09IFwicHJldmlld1wiKXtcbiAgICAgIHJldHVybiBzZXNzaW9uSGFuZGxlcnMucHJldmlldztcbiAgICB9IGVsc2UgaWYgKGVkaXRvciA9PT0gXCJ0ZXJtaW5hbFwiKXtcbiAgICAgIHJldHVybiBzZXNzaW9uSGFuZGxlcnMudGVybWluYWxzO1xuICAgIH0gZWxzZSBpZiAoZWRpdG9yID09PSBcIm5ldy1kb2N1bWVudFwiKXtcbiAgICAgIHJldHVybiBzZXNzaW9uSGFuZGxlcnMubmV3RG9jdW1lbnQ7XG4gICAgfSBlbHNlIGlmIChlZGl0b3IgPT09IFwibmV3LWZvbGRlclwiKXtcbiAgICAgIHJldHVybiBzZXNzaW9uSGFuZGxlcnMubmV3Rm9sZGVyO1xuICAgIH0gZWxzZSBpZiAoZWRpdG9yID09PSBcImNvbW1hbmRcIil7XG4gICAgICByZXR1cm4gc2Vzc2lvbkhhbmRsZXJzLmNvbW1hbmRzO1xuICAgIH0gZWxzZSBpZiAoZWRpdG9yID09PSBcImNvbW1pdFwiKXtcbiAgICAgIHJldHVybiBzZXNzaW9uSGFuZGxlcnMuY29tbWl0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpc2VTZXNzaW9uIChlbnRpdHksIHRpdGxlLCBlZGl0b3IsIGNhbGxiYWNrKXtcblxuICAgIGVudGl0eSA9IGNsb25lRGVlcChlbnRpdHkpO1xuXG4gICAgdmFyIHNlc3Npb24gPSB7XG4gICAgICBlZGl0b3IgOiBnZXRFZGl0b3IoZWRpdG9yKSxcbiAgICAgIHR5cGUgOiBlZGl0b3IsXG4gICAgICBlbnRpdHkgOiBlbnRpdHksXG4gICAgICBzZXNzaW9uSWQgOiArK3Nlc3Npb25JZCxcbiAgICAgIHRpdGxlIDogdGl0bGUsXG4gICAgICBwYXRoIDogZW50aXR5LnBhdGgsXG4gICAgICAkdGFiIDogZG9tKCc8bGkgY2xhc3M9XCInICsgZWRpdG9yICsnXCI+PGEgaHJlZj1cIiNcIj4nICsgdGl0bGUgKyc8L2E+PHNwYW4gY2xhc3M9XCJ0eXBjbiB0eXBjbi1wb3dlclwiPjwvc3Bhbj48c3BhbiBjbGFzcz1cInR5cGNuIHR5cGNuLW1lZGlhLXJlY29yZFwiPjwvc3Bhbj48c3BhbiBjbGFzcz1cInR5cGNuIHR5cGNuLWFycm93LXN5bmNcIj48L3NwYW4+PC9saT4nKVxuICAgIH1cblxuXG4gICAgc2Vzc2lvbi4kdGFiLmFkZENsYXNzKCdzeW5jaHJvbmlzaW5nJyk7XG5cbiAgICBzZXNzaW9uLmVudGl0eS5fc2Vzc2lvbklkID0gc2Vzc2lvbi5zZXNzaW9uSWQ7XG5cbiAgICAkdWwuYXBwZW5kKHNlc3Npb24uJHRhYik7XG5cbiAgICBkb20oJ2EnLCBzZXNzaW9uLiR0YWIpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKXtcblxuICAgICAgcmVzdW1lU2Vzc2lvbihzZXNzaW9uKTtcblxuICAgIH0pO1xuXG4gICAgZG9tKCdzcGFuJywgc2Vzc2lvbi4kdGFiKS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSl7XG5cbiAgICAgIGRlc3Ryb3lTZXNzaW9uKHNlc3Npb24pO1xuXG4gICAgfSk7XG5cbiAgICBzZXNzaW9ucy5wdXNoKHNlc3Npb24pO1xuXG4gICAgc2Vzc2lvbi5lZGl0b3IuY3JlYXRlKHNlc3Npb24uZW50aXR5LCBmdW5jdGlvbiAoY3JlYXRlZE9rYXkpe1xuXG4gICAgICBpZiAoY3JlYXRlZE9rYXkpe1xuICAgICAgICBjYWxsYmFjayhzZXNzaW9uKTtcbiAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlc3Npb247XG5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3VtZVNlc3Npb24gKHNlc3Npb24pe1xuXG4gICAgLy8gd2hlbiB3ZSByZXN1bWUgYSBzZXNzaW9uIHdlIG5lZWQgdG8gcGF1c2UgdGhlIGV4aXN0aW5nIHNlc3Npb25cbiAgICBpZiAoc2Vzc2lvbnNbMF0uYWN0aXZlICYmIHNlc3Npb25zWzBdLnNlc3Npb25JZCAhPT0gc2Vzc2lvbi5zZXNzaW9uSWQpe1xuICAgICAgcGF1c2VTZXNzaW9uKHNlc3Npb25zWzBdKTtcbiAgICB9XG5cbiAgICBzZXNzaW9ucy51bnNoaWZ0KHNlc3Npb25zLnNwbGljZShzZXNzaW9ucy5pbmRleE9mKHNlc3Npb24pLCAxKVswXSk7XG4gICAgc2Vzc2lvbi5lZGl0b3IucmVzdW1lKHNlc3Npb24uZW50aXR5KTtcbiAgICBzZXNzaW9uLiR0YWIuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuICAgIHNlc3Npb24uYWN0aXZlID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdXNlU2Vzc2lvbiAoc2Vzc2lvbil7XG5cbiAgICBzZXNzaW9uLmVkaXRvci5wYXVzZShzZXNzaW9uLmVudGl0eSk7XG4gICAgc2Vzc2lvbi4kdGFiLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcbiAgICBzZXNzaW9uLmFjdGl2ZSA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveVNlc3Npb24gKHNlc3Npb24pe1xuXG4gICAgLy8gYXN5bmMuLiBjb3VsZCByZXF1aXJlIHVzZXIgaW5wdXQgYmVmb3JlIGNsb3NpbmcuLi4gXG4gICAgc2Vzc2lvbi5lZGl0b3IuZGVzdHJveShzZXNzaW9uLmVudGl0eSwgZnVuY3Rpb24gKG9rYXlUb0Nsb3NlKXtcbiAgICAgIGlmIChva2F5VG9DbG9zZSl7XG4gICAgICAgIHNlc3Npb24uJHRhYi5yZW1vdmUoKTtcbiAgICAgICAgc2Vzc2lvbi4kdGFiID0gbnVsbDtcbiAgICAgICAgc2Vzc2lvbi5lZGl0b3IgPSBudWxsO1xuICAgICAgfVxuICAgICAgc2Vzc2lvbnMuc3BsaWNlKHNlc3Npb25zLmluZGV4T2Yoc2Vzc2lvbiksIDEpO1xuXG4gICAgICBpZiAoc2Vzc2lvbnNbMF0pe1xuICAgICAgICByZXN1bWVTZXNzaW9uKHNlc3Npb25zWzBdKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFNlc3Npb24gKGVudGl0eSwgdHlwZSl7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlc3Npb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmIChzZXNzaW9uc1tpXS50eXBlID09PSB0eXBlICYmIHNlc3Npb25zW2ldLnBhdGggPT09IGVudGl0eS5wYXRoKXtcbiAgICAgICAgcmV0dXJuIHNlc3Npb25zW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcblxuICB9XG5cbiAgZnVuY3Rpb24gZmluZFNlc3Npb25CeUlkIChpZCl7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXNzaW9ucy5sZW5ndGg7IGkrKyl7XG4gICAgICBpZiAoc2Vzc2lvbnNbaV0uc2Vzc2lvbklkID09PSBpZCkgcmV0dXJuIHNlc3Npb25zW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyB0aGlzIG9ubHkgZmlyZSBvbmNlLlxuICBhcHAub24oJ2VkaXQtZW50aXR5JywgZnVuY3Rpb24gKGVudGl0eSl7XG5cbiAgICB2YXIgc2Vzc2lvbiA9IGZpbmRTZXNzaW9uIChlbnRpdHksICdhY2UnKTtcblxuICAgIGlmICghc2Vzc2lvbil7XG5cbiAgICAgIGlmIChlbnRpdHkubWltZSAhPT0gXCJhcHBsaWNhdGlvbi9qc29uXCIgJiYgZW50aXR5Lm1pbWUgIT09IFwidGV4dC94LW1hcmtkb3duXCIgJiYgZW50aXR5Lm1pbWUgIT09IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiKXtcblxuICAgICAgICBpbml0aWFsaXNlU2Vzc2lvbihlbnRpdHksIGVudGl0eS5uYW1lLCAncHJldmlldycsIGZ1bmN0aW9uIChzZXNzaW9uKXtcblxuICAgICAgICAgIHJlc3VtZVNlc3Npb24oc2Vzc2lvbik7XG5cbiAgICAgICAgfSlcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpbml0aWFsaXNlU2Vzc2lvbihlbnRpdHksIGVudGl0eS5uYW1lLCAnYWNlJywgZnVuY3Rpb24gKHNlc3Npb24pe1xuXG4gICAgICAgICAgcmVzdW1lU2Vzc2lvbihzZXNzaW9uKTtcblxuICAgICAgICB9KTtcblxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgcmVzdW1lU2Vzc2lvbihzZXNzaW9uKTtcblxuICAgIH1cblxuXG4gIH0pO1xuXG4gIGFwcC5vbignYmVnaW4tbmV3LWRvY3VtZW50LXNlc3Npb24nLCBmdW5jdGlvbiAoZW50aXR5KXtcblxuICAgIHZhciBzZXNzaW9uID0gZmluZFNlc3Npb24gKGVudGl0eSwgJ25ldy1kb2N1bWVudCcpO1xuXG4gICAgaWYgKCFzZXNzaW9uKXtcblxuICAgICAgaW5pdGlhbGlzZVNlc3Npb24oZW50aXR5LCBlbnRpdHkubmFtZSwgJ25ldy1kb2N1bWVudCcsIGZ1bmN0aW9uIChzZXNzaW9uKXtcbiAgICAgICAgcmVzdW1lU2Vzc2lvbihzZXNzaW9uKTtcbiAgICAgIH0pO1xuXG4gICAgfVxuXG4gIH0pO1xuXG5cbiAgYXBwLm9uKCdiZWdpbi1uZXctZm9sZGVyLXNlc3Npb24nLCBmdW5jdGlvbiAoZW50aXR5KXtcblxuICAgIHZhciBzZXNzaW9uID0gZmluZFNlc3Npb24gKGVudGl0eSwgJ25ldy1mb2xkZXInKTtcblxuICAgIGlmICghc2Vzc2lvbil7XG5cbiAgICAgIGluaXRpYWxpc2VTZXNzaW9uKGVudGl0eSwgZW50aXR5Lm5hbWUsICduZXctZm9sZGVyJywgZnVuY3Rpb24gKHNlc3Npb24pe1xuICAgICAgICByZXN1bWVTZXNzaW9uKHNlc3Npb24pO1xuICAgICAgfSk7XG5cbiAgICB9XG5cbiAgfSk7XG5cbiAgYXBwLm9uKCdwcmV2aWV3LWVudGl0eScsIGZ1bmN0aW9uIChlbnRpdHkpe1xuXG4gICAgdmFyIHNlc3Npb24gPSBmaW5kU2Vzc2lvbiAoZW50aXR5LCAncHJldmlldycpO1xuXG4gICAgaWYgKCFzZXNzaW9uKXtcblxuICAgICAgaW5pdGlhbGlzZVNlc3Npb24oZW50aXR5LCBlbnRpdHkubmFtZSwgJ3ByZXZpZXcnLCBmdW5jdGlvbiAoc2Vzc2lvbil7XG5cbiAgICAgICAgcmVzdW1lU2Vzc2lvbihzZXNzaW9uKTtcblxuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICByZXN1bWVTZXNzaW9uKHNlc3Npb24pO1xuXG4gICAgfVxuXG5cbiAgfSk7XG5cbiAgYXBwLm9uKCdlZGl0LWVudGl0eS1pbmZvJywgZnVuY3Rpb24gKGVudGl0eSl7XG5cbiAgICB2YXIgc2Vzc2lvbiA9IGZpbmRTZXNzaW9uIChlbnRpdHksICdpbmZvJyk7XG5cbiAgICBpZiAoIXNlc3Npb24pe1xuXG4gICAgICBpbml0aWFsaXNlU2Vzc2lvbihlbnRpdHksIGVudGl0eS5uYW1lLCAnaW5mbycsIGZ1bmN0aW9uIChzZXNzaW9uKXtcblxuICAgICAgICByZXN1bWVTZXNzaW9uKHNlc3Npb24pO1xuXG4gICAgICB9KTtcblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHJlc3VtZVNlc3Npb24oc2Vzc2lvbik7XG5cbiAgICB9XG5cblxuICB9KTtcblxuICBhcHAub24oJ25ldy1jb21tYW5kLXNlc3Npb24nLCBmdW5jdGlvbiAoKXtcblxuICAgIHZhciBjb21tYW5kSWQgPSAnY29tbWFuZC0nICsgKCsrY29tbWFuZFNlc3Npb25Db3VudCk7XG5cbiAgICB2YXIgc2Vzc2lvbiA9IGluaXRpYWxpc2VTZXNzaW9uKHsgcGF0aCA6IGNvbW1hbmRJZH0sIGNvbW1hbmRJZCwgJ2NvbW1hbmQnLCBmdW5jdGlvbiAoc2Vzc2lvbil7XG5cbiAgICAgIHJlc3VtZVNlc3Npb24oc2Vzc2lvbik7XG5cbiAgICB9KTtcblxuICB9KTtcblxuICBhcHAub24oJ25ldy1jb21taXQtc2Vzc2lvbicsIGZ1bmN0aW9uICgpe1xuXG4gICAgdmFyIGNvbW1pdElkID0gJ2NvbW1pdC0nICsgKCsrY29tbWl0U2Vzc2lvbkNvdW50KTtcblxuICAgIHZhciBzZXNzaW9uID0gaW5pdGlhbGlzZVNlc3Npb24oeyBwYXRoIDogY29tbWl0SWR9LCBjb21taXRJZCwgJ2NvbW1pdCcsIGZ1bmN0aW9uIChzZXNzaW9uKXtcblxuICAgICAgcmVzdW1lU2Vzc2lvbihzZXNzaW9uKTtcblxuICAgIH0pO1xuXG4gIH0pO1xuXG4gIGFwcC5vbignbmV3LXRlcm1pbmFsLXNlc3Npb24nLCBmdW5jdGlvbiAoKXtcblxuICAgIHZhciB0ZXJtSWQgPSAndGVybWluYWwtJyArICgrK3Rlcm1pbmFsU2Vzc2lvbkNvdW50KTtcblxuICAgIHZhciBzZXNzaW9uID0gaW5pdGlhbGlzZVNlc3Npb24oeyBwYXRoIDogdGVybUlkIH0sIHRlcm1JZCwgJ3Rlcm1pbmFsJywgZnVuY3Rpb24gKCl7XG5cbiAgICAgIHJlc3VtZVNlc3Npb24oc2Vzc2lvbik7XG5cbiAgICB9KTtcblxuICB9KTtcblxuICBhcHAub24oJ3JlcXVlc3QtdGVybWluYXRlLXNlc3Npb24nLCBmdW5jdGlvbiAoc2Vzc2lvbklkKXtcblxuICAgIHZhciBzZXNzaW9uID0gZmluZFNlc3Npb25CeUlkKHNlc3Npb25JZCk7XG4gICAgaWYgKHNlc3Npb24pe1xuICAgICAgZGVzdHJveVNlc3Npb24oc2Vzc2lvbik7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGFwcC5vbignc2Vzc2lvbi1kZXN5bmNocm9uaXNlZCcsIGZ1bmN0aW9uIChzZXNzaW9uSWQpe1xuXG4gICAgdmFyIHNlc3Npb24gPSBmaW5kU2Vzc2lvbkJ5SWQoc2Vzc2lvbklkKTtcbiAgICBpZiAoc2Vzc2lvbil7XG4gICAgICBzZXNzaW9uLiR0YWIuYWRkQ2xhc3MoJ2Rlc3luYycpO1xuICAgICAgc2Vzc2lvbi4kdGFiLnJlbW92ZUNsYXNzKCdzeW5jaHJvbmlzaW5nJyk7XG4gICAgfVxuXG4gIH0pO1xuXG4gIGFwcC5vbignc2Vzc2lvbi1zeW5jaHJvbmlzZWQnLCBmdW5jdGlvbiAoc2Vzc2lvbklkKXtcblxuICAgIHZhciBzZXNzaW9uID0gZmluZFNlc3Npb25CeUlkKHNlc3Npb25JZCk7XG4gICAgaWYgKHNlc3Npb24pe1xuICAgICAgc2Vzc2lvbi4kdGFiLnJlbW92ZUNsYXNzKCdkZXN5bmMnKTtcbiAgICAgIHNlc3Npb24uJHRhYi5yZW1vdmVDbGFzcygnc3luY2hyb25pc2luZycpO1xuICAgIH1cblxuICB9KTtcblxuICBhcHAub24oJ3Nlc3Npb24tc3luY3Job25pc2luZycsIGZ1bmN0aW9uIChzZXNzaW9uSWQpe1xuXG4gICAgdmFyIHNlc3Npb24gPSBmaW5kU2Vzc2lvbkJ5SWQoc2Vzc2lvbklkKTtcbiAgICBpZiAoc2Vzc2lvbil7XG4gICAgICBzZXNzaW9uLiR0YWIucmVtb3ZlQ2xhc3MoJ2Rlc3luYycpO1xuICAgICAgc2Vzc2lvbi4kdGFiLmFkZENsYXNzKCdzeW5jaHJvbmlzaW5nJyk7XG4gICAgfVxuXG4gIH0pO1xuXG59OyIsInZhciBkb20gPSByZXF1aXJlKCdncmVlbi1tZXNhLWRvbScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHAsIGJveCl7XG5cbiAgdmFyICRtZW51ID0gZG9tKCcnICsgXG4gICAgJzx1bCBjbGFzcz1cImJveC1pbm5lciBtZW51LWNvbnRlbnRcIj4nICtcbiAgICAnPGxpPjxzcGFuIGNsYXNzPVwidHlwY24gdHlwY24tdGgtbWVudVwiPjwvc3Bhbj4nICsgXG4gICAgICAnPHVsPicgKyBcbiAgICAgICAgJzxsaT48YSBocmVmPVwiI1wiIHJlbD1cInJlbHMvc2F2ZS1maWxlXCI+PHNwYW4gY2xhc3M9XCJ0eXBjbiB0eXBjbi1hcnJvdy1zeW5jXCI+PC9zcGFuPlNhdmUgYWxsPC9hPjwvbGk+JyArIFxuICAgICAgICAnPGxpPjxhIGhyZWY9XCIjXCIgcmVsPVwicmVscy9jb21taXQtc2Vzc2lvblwiPjxzcGFuIGNsYXNzPVwidHlwY24gdHlwY24tYXJyb3ctc3luY1wiPjwvc3Bhbj5Db21taXQ8L2E+PC9saT4nICsgXG4gICAgICAgICc8bGk+PGEgaHJlZj1cIiNcIiByZWw9XCJyZWxzL25ldy10ZXJtaW5hbFwiPjxzcGFuIGNsYXNzPVwidHlwY24gdHlwY24tZGV2aWNlLWRlc2t0b3BcIj48L3NwYW4+TmV3IFRlcm1pbmFsPC9hPjwvbGk+JyArIFxuICAgICAgICAnPGxpPjxhIGhyZWY9XCIjXCIgcmVsPVwicmVscy9uZXctY29tbWFuZFwiPjxzcGFuIGNsYXNzPVwidHlwY24gdHlwY24tc3Bhbm5lclwiPjwvc3Bhbj5SdW4gY29tbWFuZDwvYT48L2xpPicgKyBcbiAgICAgICc8L3VsPicgKyBcbiAgICAnPC9saT4nICtcbiAgJzwvdWw+Jyk7XG5cbiAgJG1lbnUuYXBwZW5kVG8oYm94LmVsZW1lbnQpO1xuXG4gIGRvbSgnYVtyZWw9XCJyZWxzL3NhdmUtZmlsZVwiXScsICRtZW51KS5vbignY2xpY2snLCBmdW5jdGlvbiAoZSl7XG5cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgYXBwLmVtaXQoJ3NhdmUtZW50aXR5Jyk7XG5cbiAgfSk7XG5cbiAgZG9tKCdhW3JlbD1cInJlbHMvY29tbWl0LXNlc3Npb25cIl0nLCAkbWVudSkub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpe1xuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGFwcC5lbWl0KCduZXctY29tbWl0LXNlc3Npb24nKTtcblxuICB9KTtcblxuICBkb20oJ2FbcmVsPVwicmVscy9uZXctdGVybWluYWxcIl0nLCAkbWVudSkub24oJ2NsaWNrJywgZnVuY3Rpb24gKGUpe1xuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGFwcC5lbWl0KCduZXctdGVybWluYWwtc2Vzc2lvbicpO1xuXG4gIH0pO1xuXG4gIGRvbSgnYVtyZWw9XCJyZWxzL25ldy1jb21tYW5kXCJdJywgJG1lbnUpLm9uKCdjbGljaycsIGZ1bmN0aW9uIChlKXtcblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBhcHAuZW1pdCgnbmV3LWNvbW1hbmQtc2Vzc2lvbicpO1xuXG4gIH0pO1xuXG59IiwiLy8gcHJvYmFibHkgd2FudCB0byBtb3ZlIHRoaXMgdG8gYSBjb25maWcgZmlsZSBhdCBzb21lIHBvaW50Li5cbnZhciB2ZnNSb290ID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QgKyBcIi92ZnNcIjtcbnZhciBzb2NrUm9vdCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0ICsgXCIvY29tbXNcIlxuXG4vLyBhcHBsaWNhdGlvbiBsZXZlbCBicm9rZXIuLi4gXG52YXIgYXBwID0gbmV3IChyZXF1aXJlKCdldmVudHMnKSkuRXZlbnRFbWl0dGVyKCk7XG5cbi8vIGxheW91dCBtYW5hZ2VzIHRoZSBzY3JlZW5cbnZhciBsYXlvdXQgPSBhcHAubGF5b3V0ID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL2xheW91dC5qcycpKCk7XG5cbi8vIHNldCB1cCB0aGUgc29ja2V0IGNvbW11bmljYXRpb25zIHdpdGggdGhlIHNlcnZlciBmb3IgdGVybWluYWxzL2ZpbGUgdXBkYXRlc1xudmFyIHJlbW90ZSA9IHJlcXVpcmUoJy4vbGliL3JlbW90ZS5qcycpKGFwcCwgc29ja1Jvb3QpO1xuLy8gZ2V0IHRoZSB2aXJ0dWFsIGZpbGUgc3lzdGVtIHdvcmtpbmcuLi5cbmFwcC52ZnMgPSByZXF1aXJlKCcuL2xpYi9maWxlLXN5c3RlbScpLmluaXRpYWxpc2VGaWxlU3lzdGVtKGFwcCwgdmZzUm9vdCk7XG4vLyBpbml0aWFsaXNlIHRoZSBlbnRpdHkgc2VsZWN0b3IuIFRoaXMgTVVTVCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB2ZnM6c3luYyBldmVudC5cbnZhciBlbnRpdHlTZWxlY3RvciA9IHJlcXVpcmUoJy4vY29tcG9uZW50cy9lbnRpdHktc2VsZWN0b3IuanMnKShhcHAsIGxheW91dC5uYXYpO1xuXG5cbnZhciB0b3BNZW51ID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL3RvcC1tZW51LmpzJykoYXBwLCBsYXlvdXQubWVudSk7XG5cbnZhciBzZXNzaW9uSGFuZGxlcnMgPSB7XG4gIGFjZSA6IHJlcXVpcmUoJy4vY29tcG9uZW50cy9lZGl0b3JzL2FjZS5qcycpKGFwcCwgbGF5b3V0LmVkaXRvciksXG4gIGluZm8gOiByZXF1aXJlKCcuL2NvbXBvbmVudHMvZWRpdG9ycy9pbmZvLmpzJykoYXBwLCBsYXlvdXQuZWRpdG9yKSxcbiAgcHJldmlldyA6IHJlcXVpcmUoJy4vY29tcG9uZW50cy9lZGl0b3JzL3ByZXZpZXdlci5qcycpKGFwcCwgbGF5b3V0LmVkaXRvciksXG4gIHRlcm1pbmFscyA6IHJlcXVpcmUoJy4vY29tcG9uZW50cy9lZGl0b3JzL3Rlcm1pbmFscy5qcycpKGFwcCwgbGF5b3V0LmVkaXRvciksXG4gIG5ld0ZvbGRlciA6IHJlcXVpcmUoJy4vY29tcG9uZW50cy9lZGl0b3JzL25ldy1mb2xkZXIuanMnKShhcHAsIGxheW91dC5lZGl0b3IpLFxuICBuZXdEb2N1bWVudCA6IHJlcXVpcmUoJy4vY29tcG9uZW50cy9lZGl0b3JzL25ldy1kb2N1bWVudC5qcycpKGFwcCwgbGF5b3V0LmVkaXRvciksXG4gIGNvbW1hbmRzIDogcmVxdWlyZSgnLi9jb21wb25lbnRzL2VkaXRvcnMvY29tbWFuZC5qcycpKGFwcCwgbGF5b3V0LmVkaXRvciksXG4gIGNvbW1pdCA6IHJlcXVpcmUoJy4vY29tcG9uZW50cy9lZGl0b3JzL2NvbW1pdC5qcycpKGFwcCwgbGF5b3V0LmVkaXRvcilcbn1cblxudmFyIHNlc3Npb25zID0gcmVxdWlyZSgnLi9jb21wb25lbnRzL3Nlc3Npb25zLmpzJykoYXBwLCBzZXNzaW9uSGFuZGxlcnMsIGxheW91dC50YWJzKTtcblxuLy8gc3lzdGVtIHdpZGUgc2F2ZSBldmVudFxud2luZG93Lm9ua2V5ZG93biA9IGZ1bmN0aW9uIChlKXtcbiAgaWYoKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpKXtcbiAgICBpZiAoZS53aGljaCA9PSA4Mykge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgYXBwLmVtaXQoJ3NhdmUtZW50aXR5Jyk7XG4gICAgfVxuICB9XG59XG5cblxuXG4vLyB0aGUgZW50aXR5IHNlbGVjdG9yIChvciAnZmlsZSBuYXZpZ2F0aW9uIHRoaW5nJyB0byB5b3UgYW5kIEksIGJ1dCB3ZSBjYW4ndCBjYWxsIGl0IHRoYXQpXG5cblxuXG4vKlxuXG52YXIgJCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IuYmluZChkb2N1bWVudCk7XG5cbiQoJ2JvZHknKS5vbmNvbnRleHRtZW51ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cblxudmFyIFNvY2tzSlMgPSByZXF1aXJlKCcuL2xpYi9zb2Nrcy5qcycpO1xuXG5cblxuXG5cbnZhciBhY2UgPSByZXF1aXJlKCdicmFjZScpO1xucmVxdWlyZSgnYnJhY2UvbW9kZS9qc29uJyk7XG5yZXF1aXJlKCdicmFjZS9tb2RlL21hcmtkb3duJyk7XG5yZXF1aXJlKCdicmFjZS90aGVtZS9tb25va2FpJyk7XG5cbnZhciBmaWxlU3lzdGVtID0ge1xuICBjaGlsZHJlbiA6IHtcbiAgICByb290IDoge1xuICAgICAgZW50aXRpZXMgOiBbXSxcbiAgICAgIG5hbWUgOiBcIi9cIixcbiAgICAgIGhyZWYgOiB2ZnNSb290ICsgXCIvXCIsXG4gICAgICBjaGlsZHJlbiA6IHt9LFxuICAgICAgcGFyZW50IDogZmFsc2VcbiAgICB9XG4gIH1cbn07XG5cbnZhciBzb2NrZXQgPSBuZXcgU29ja3NKUyhzb2NrUm9vdCk7XG5cbnNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbiAoKXtcbiAgY29uc29sZS5sb2coJ3NvY2tldCBvcGVuIScpO1xufVxuc29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKXtcblxuICB2YXIgbXNnID0gSlNPTi5wYXJzZShlLmRhdGEpO1xuXG4gIGZvciAodmFyIGkgaW4gbXNnKXtcblxuICAgIGNvbnNvbGUubG9nKG1zZ1tpXSwgaSlcblxuICB9XG5cbn1cblxudmFyIGVkaXRTZXNzaW9ucyA9IHt9O1xudmFyIGFjdGl2ZURpcmVjdG9yeSA9IGZhbHNlO1xudmFyIGFjdGl2ZVNlc3Npb24gPSBmYWxzZTtcbnZhciBkaXJlY3RvcnlDYWNoZSA9IHt9O1xuXG52YXIgZmlsZVN5c3RlbVZpZXdFbGVtZW50cyA9IHt9O1xudmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaDtcblxudmFyIHBhZ2UgPSBjcmVhdGVCb3goJ3BhZ2UnKTtcbnBhZ2UucG9zaXRpb24oMCwwKTtcbnBhZ2Uuc2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbnBhZ2UuYXBwZW5kVG9FbGVtZW50KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKSk7XG5cbnZhciB0b3BNZW51ID0gY3JlYXRlQm94KCd0b3AtbWVudScpO1xudG9wTWVudS5wb3NpdGlvbigwLDApO1xudG9wTWVudS5zaXplKHdpbmRvdy5pbm5lcldpZHRoLCAzMCk7XG5cbnZhciB0b3BNZW51Q29udGVudCA9IGRvbWlmeShbXG4gICc8dWwgY2xhc3M9XCJib3gtaW5uZXIgbWVudS1jb250ZW50XCI+JyxcbiAgJzxsaT48c3Bhbj5GaWxlPC9zcGFuPjx1bD48bGk+PGEgaHJlZj1cIiNcIiByZWw9XCJyZWxzL25ldy1maWxlXCI+TmV3IGZpbGU8L2E+PC9saT48bGk+PGEgaHJlZj1cIiNcIiByZWw9XCJyZWxzL25ldy1mb2xkZXJcIj5OZXcgZm9sZGVyPC9hPjwvbGk+PC91bD48L2xpPicsXG4gICc8L3VsPidcbl0uam9pbignXFxuJykpO1xuXG50b3BNZW51LmFkZEVsZW1lbnQodG9wTWVudUNvbnRlbnQpO1xuXG52YXIgZmlsZU5hdmlnYXRpb24gPSBjcmVhdGVCb3goJ2ZpbGUtbmF2Jyk7XG5maWxlTmF2aWdhdGlvbi5wb3NpdGlvbigwLCh0b3BNZW51LnNpemUoKS55KSk7XG5maWxlTmF2aWdhdGlvbi5zaXplKDMwMSwgd2luZG93LmlubmVySGVpZ2h0IC0gdG9wTWVudS5zaXplKCkueSk7XG5wYWdlLmFkZEJveChmaWxlTmF2aWdhdGlvbik7XG5cbnZhciBmaWxlcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG5maWxlcy5jbGFzc05hbWUgPSBcImJveC1pbm5lciBmaWxlc1wiO1xuZmlsZU5hdmlnYXRpb24uYWRkRWxlbWVudChmaWxlcyk7XG5cblxudmFyIGNvbnRlbnRWaWV3ID0gY3JlYXRlQm94KCdjb250ZW50LXZpZXcnKTtcbmNvbnRlbnRWaWV3LnBvc2l0aW9uKDMwMSwodG9wTWVudS5zaXplKCkueSkpO1xuY29udGVudFZpZXcuc2l6ZSh3aW5kb3cuaW5uZXJXaWR0aCAtIDMwMiwgd2luZG93LmlubmVySGVpZ2h0IC0gdG9wTWVudS5zaXplKCkueSk7XG5wYWdlLmFkZEJveChjb250ZW50Vmlldyk7XG5cbnZhciBjb250ZW50ID0gZG9taWZ5KFtcbiAgJzxkaXYgY2xhc3M9XCJib3gtaW5uZXIgY29udGVudFwiPicsXG4gICc8dWwgY2xhc3M9XCJ0YWJzXCI+PC91bD4nLFxuICAnPHVsIGNsYXNzPVwidGFiLWJvZGllc1wiPjwvdWw+JyxcbiAgJzwvZGl2Pidcbl0uam9pbignXFxuJykpO1xuXG5cbiAgXG4gIC8vIGRvZXNuJ3QgYmVsb25nIGhlcmUuLi5cbiAgdmFyIHRvcE1lbnVDb250ZW50ID0gZG9taWZ5KFtcbiAgICAnPHVsIGNsYXNzPVwiYm94LWlubmVyIG1lbnUtY29udGVudFwiPicsXG4gICAgJzxsaT48c3Bhbj5GaWxlPC9zcGFuPjx1bD48bGk+PGEgaHJlZj1cIiNcIiByZWw9XCJyZWxzL25ldy1maWxlXCI+TmV3IGZpbGU8L2E+PC9saT48bGk+PGEgaHJlZj1cIiNcIiByZWw9XCJyZWxzL25ldy1mb2xkZXJcIj5OZXcgZm9sZGVyPC9hPjwvbGk+PC91bD48L2xpPicsXG4gICAgJzwvdWw+J1xuICBdLmpvaW4oJ1xcbicpKTtcblxuICB0b3BNZW51LmFkZEVsZW1lbnQodG9wTWVudUNvbnRlbnQpO1xuICBcblxuY29udGVudFZpZXcuYWRkRWxlbWVudChjb250ZW50KTtcblxucGFnZS5hZGRCb3godG9wTWVudSk7XG5cbnZhciBkZWxlZ2F0ZSA9IG5ldyBEZWxlZ2F0ZShkb2N1bWVudC5ib2R5KTtcblxuZGVsZWdhdGUub24oJ2NsaWNrJywgJ3VsLm1lbnUtY29udGVudCBsaSB1bCBsaSBhJywgZnVuY3Rpb24gKGUpe1xuXG4gIHZhciByZWwgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3JlbCcpO1xuXG4gIHN3aXRjaCAocmVsKXtcblxuICAgIGNhc2UgXCJyZWxzL25ldy1mb2xkZXJcIjogXG5cbiAgICAgIGNyZWF0ZUZvbGRlcihhY3RpdmVEaXJlY3RvcnkpO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJyZWxzL25ldy1maWxlXCI6XG5cbiAgICAgIGNyZWF0ZUZpbGUoYWN0aXZlRGlyZWN0b3J5KTtcblxuICAgICAgYnJlYWs7XG5cbiAgfVxuXG59KTtcblxuXG5mdW5jdGlvbiBnZXRDb250ZW50Vmlld1NpemUgKCl7XG4gIHZhciBoZWFkZXJIZWlnaHQgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ3VsLnRhYnMnKS5vZmZzZXRIZWlnaHQ7XG4gIHZhciBwYWdlU2l6ZSA9IGNvbnRlbnRWaWV3LnNpemUoKTtcbiAgcmV0dXJuIHtcbiAgICB4IDogcGFnZVNpemUueCxcbiAgICB5IDogcGFnZVNpemUueSxcbiAgICBoZWFkZXJIZWlnaHQgOiBoZWFkZXJIZWlnaHRcbiAgfVxuXG59O1xuXG53aW5kb3cub25yZXNpemUgPSBmdW5jdGlvbiAoZXZlbnQpe1xuICBwYWdlLnNpemUod2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gIGZpbGVOYXZpZ2F0aW9uLnNpemUoMzAwLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICBjb250ZW50Vmlldy5zaXplKHdpbmRvdy5pbm5lcldpZHRoIC0gMzAxLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xufVxuXG53aW5kb3cub25rZXlkb3duID0gZnVuY3Rpb24gKGUpe1xuICBpZigoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkgJiYgZS53aGljaCA9PSA4Mykge1xuICAgICAgLy8gU2F2ZSBGdW5jdGlvblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgc2F2ZVNlc3Npb24oKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cblxuXG5cbmZ1bmN0aW9uIHNhdmVTZXNzaW9uICgpe1xuXG4gIHZhciB2YWwgPSBhY3RpdmVTZXNzaW9uLmVkaXRvci5nZXRTZXNzaW9uKCkuZ2V0VmFsdWUoKTtcblxuICBpZiAodmFsICE9PSBhY3RpdmVTZXNzaW9uLm9yaWdpbmFsVmFsdWUpe1xuICBcbiAgICB2YXIgYmVpbmdTYXZlZCA9IGFjdGl2ZVNlc3Npb247XG5cbiAgICBzYXZlRmlsZShhY3RpdmVTZXNzaW9uLnBhdGgsIHZhbCwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2Upe1xuXG4gICAgICBpZiAoIWVycil7XG5cbiAgICAgICAgdmFyIGN1cnJlbnRWYWwgPSBiZWluZ1NhdmVkLmVkaXRvci5nZXRTZXNzaW9uKCkuZ2V0VmFsdWUoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWwgPT09IHZhbCl7XG4gICAgICAgICAgYmVpbmdTYXZlZC50YWJIZWFkZXIucXVlcnlTZWxlY3RvcignYScpLmlubmVyVGV4dCA9IGJlaW5nU2F2ZWQuZW50aXR5Lm5hbWVcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGVydChlcnIpO1xuICAgICAgfVxuXG4gICAgfSlcblxuICB9XG5cbn1cblxuZnVuY3Rpb24gZW5kU2Vzc2lvbiAoZW50aXR5KXtcblxuICB2YXIgc2Vzc2lvbiA9IGVkaXRTZXNzaW9uc1tlbnRpdHkuaHJlZl07XG5cbiAgdmFyIHZhbCA9IHNlc3Npb24uZWRpdG9yLmdldFNlc3Npb24oKS5nZXRWYWx1ZSgpO1xuXG4gIGlmICh2YWwgIT09IHNlc3Npb24ub3JpZ2luYWxWYWx1ZSl7XG4gICAgaWYoIWNvbmZpcm0oJ1lvdSB3aWxsIGxvc2UgY2hhbmdlcy4gQXJlIHlvdSBzdXJlIHlvdSB3aXNoIHRvIHF1aXQ/Jykpe1xuICAgICAgcmV0dXJuO1xuXG4gICAgfVxuICB9XG5cbiAgc2Vzc2lvbi5lZGl0b3IuZGVzdHJveSgpO1xuICBzZXNzaW9uLnRhYkhlYWRlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNlc3Npb24udGFiSGVhZGVyKTtcbiAgc2Vzc2lvbi50YWIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZXNzaW9uLnRhYik7XG4gIHNlc3Npb24udGFiID0gbnVsbDtcbiAgc2Vzc2lvbi50YWJIZWFkZXIucXVlcnlTZWxlY3RvcignYScpLm9uY2xpY2sgPSBudWxsO1xuICBzZXNzaW9uLnRhYkhlYWRlci5xdWVyeVNlbGVjdG9yKCdzcGFuLnR5cGNuLWRlbGV0ZScpLm9uY2xpY2sgPSBudWxsO1xuICBzZXNzaW9uLnRhYkhlYWRlciA9IG51bGw7XG4gIGRlbGV0ZSBlZGl0U2Vzc2lvbnNbZW50aXR5LmhyZWZdO1xuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJveCAoY2xhc3NOYW1lKXtcblxuICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmFyIHN0eWxlID0gZWwuc3R5bGU7XG4gIGVsLmNsYXNzTmFtZSA9IFwiYm94IFwiICsgY2xhc3NOYW1lIDtcbiAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gIHN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gIHN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICBzdHlsZS53aWR0aCA9IFwiMHB4XCI7XG4gIHN0eWxlLmhlaWdodCA9IFwiMHB4XCI7XG5cbiAgcmV0dXJuIHtcbiAgICBlbGVtZW50IDogZWwsXG4gICAgcG9zaXRpb24gOiBmdW5jdGlvbiAoeCwgeSl7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHggOiBwYXJzZUludChzdHlsZS5sZWZ0LCAxMCksXG4gICAgICAgICAgeSA6IHBhcnNlSW50KHN0eWxlLnRvcCwgMTApXG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgICBzdHlsZS50b3AgPSB5ICsgXCJweFwiO1xuICAgICAgc3R5bGUubGVmdCA9IHggKyBcInB4XCI7XG4gICAgfSxcbiAgICBzaXplIDogZnVuY3Rpb24gKHgsIHkpe1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4IDogcGFyc2VJbnQoc3R5bGUud2lkdGgsIDEwKSxcbiAgICAgICAgICB5IDogcGFyc2VJbnQoc3R5bGUuaGVpZ2h0LCAxMClcbiAgICAgICAgfVxuICAgICAgfSBcbiAgICAgIHN0eWxlLmhlaWdodCA9IHkgKyBcInB4XCI7XG4gICAgICBzdHlsZS53aWR0aCA9IHggKyBcInB4XCI7XG4gICAgfSxcbiAgICBhZGRCb3ggOiBmdW5jdGlvbiAoYm94KXtcbiAgICAgIGJveC5hcHBlbmRUb0VsZW1lbnQoZWwpO1xuICAgIH0sXG4gICAgYWRkRWxlbWVudCA6IGZ1bmN0aW9uIChlbGVtZW50KXtcbiAgICAgIGVsLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIH0sXG4gICAgYXBwZW5kVG9FbGVtZW50IDogZnVuY3Rpb24gKGVsZW1lbnQpe1xuICAgICAgZWxlbWVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxuICB9XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlQWNlSW5zdGFuY2UgKGVsZW1lbnQpe1xuICB2YXIgZWRpdG9yID0gYWNlLmVkaXQoZWxlbWVudCk7XG4gIGVkaXRvci5nZXRTZXNzaW9uKCkuc2V0TW9kZSgnYWNlL21vZGUvbWFya2Rvd24nKTtcbiAgZWRpdG9yLnNldFRoZW1lKCdhY2UvdGhlbWUvbW9ub2thaScpO1xuICBlZGl0b3Iuc2V0U2hvd1ByaW50TWFyZ2luKGZhbHNlKTtcbiAgcmV0dXJuIGVkaXRvcjtcbn1cblxuXG5cbmZ1bmN0aW9uIGluc2VydFRleHQgKG5vZGUsIHRleHQpe1xuICBub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpKTtcbn1cblxuZnVuY3Rpb24gbWFrZUVkaXRTZXNzaW9uQWN0aXZlIChlbnRpdHkpe1xuXG4gIHZhciBzZXNzaW9uO1xuXG4gIHNlc3Npb24gPSBlZGl0U2Vzc2lvbnNbZW50aXR5LmhyZWZdO1xuXG4gIGZvckVhY2guY2FsbChjb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3VsLnRhYi1ib2RpZXMgbGknKSwgZnVuY3Rpb24gKGxpKXtcbiAgICBsaS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9KTtcblxuICBmb3JFYWNoLmNhbGwoY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCd1bC50YWJzIGxpLmFjdGl2ZScpLCBmdW5jdGlvbiAobGkpe1xuICAgIGxpLmNsYXNzTmFtZSA9IGxpLmNsYXNzTmFtZS5yZXBsYWNlKCdhY3RpdmUnLCAnJyk7XG4gIH0pO1xuXG4gIHNlc3Npb24udGFiLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICBzZXNzaW9uLnRhYkhlYWRlci5jbGFzc05hbWUgKz0gXCJhY3RpdmVcIjtcblxuICBhY3RpdmVTZXNzaW9uID0gc2Vzc2lvbjtcblxufVxuXG5mdW5jdGlvbiBlZGl0RmlsZSAoZW50aXR5LCBlbGVtZW50LCBldmVudCl7XG5cbiAgaWYgKCFldmVudCB8fCAoZXZlbnQud2hpY2ggPT09IDEgJiYgZXZlbnQudGFyZ2V0LnRhZ05hbWUgIT09IFwiSU5QVVRcIikpe1xuXG4gICAgdmFyIHNlc3Npb247XG5cbiAgICBpZiAoIWVkaXRTZXNzaW9uc1tlbnRpdHkuaHJlZl0pe1xuICAgICAgc2Vzc2lvbiA9IGNyZWF0ZUVkaXRTZXNzaW9uKGVudGl0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlc3Npb24gPSBlZGl0U2Vzc2lvbnNbZW50aXR5LmhyZWZdO1xuICAgIH1cblxuICAgIGxvYWRGaWxlKGVudGl0eS5ocmVmLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSl7XG5cbiAgICAgIHZhciBvcmlnaW5hbFZhbHVlID0gcmVzcG9uc2U7IFxuICAgICAgc2Vzc2lvbi5vcmlnaW5hbFZhbHVlID0gb3JpZ2luYWxWYWx1ZTtcbiAgICAgIHNlc3Npb24uZWRpdG9yLnNldFZhbHVlKG9yaWdpbmFsVmFsdWUpO1xuXG4gICAgICBzZXNzaW9uLmVkaXRvci5nZXRTZXNzaW9uKCkub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChlKXtcbiAgICAgICAgdmFyIGN1cnJlbnRWYWx1ZSA9IHNlc3Npb24uZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgIGlmIChjdXJyZW50VmFsdWUgIT09IG9yaWdpbmFsVmFsdWUpe1xuICAgICAgICAgIHNlc3Npb24udGFiSGVhZGVyLnF1ZXJ5U2VsZWN0b3IoJ2EnKS5pbm5lclRleHQgPSBzZXNzaW9uLmVudGl0eS5uYW1lICsgXCIgKiBcIiBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXNzaW9uLnRhYkhlYWRlci5xdWVyeVNlbGVjdG9yKCdhJykuaW5uZXJUZXh0ID0gc2Vzc2lvbi5lbnRpdHkubmFtZVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBmb3JFYWNoLmNhbGwoY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCd1bC50YWItYm9kaWVzIGxpJyksIGZ1bmN0aW9uIChsaSl7XG4gICAgICAgIGxpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9KTtcblxuICAgICAgZm9yRWFjaC5jYWxsKGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgndWwudGFicyBsaS5hY3RpdmUnKSwgZnVuY3Rpb24gKGxpKXtcbiAgICAgICAgbGkuY2xhc3NOYW1lID0gbGkuY2xhc3NOYW1lLnJlcGxhY2UoJ2FjdGl2ZScsICcnKTtcbiAgICAgIH0pO1xuXG4gICAgICBzZXNzaW9uLnRhYi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIHNlc3Npb24udGFiSGVhZGVyLmNsYXNzTmFtZSArPSBcImFjdGl2ZVwiO1xuXG4gICAgICBhY3RpdmVTZXNzaW9uID0gc2Vzc2lvbjtcblxuICAgIH0pO1xuXG4gIH0gZWxzZSBpZiAoZXZlbnQud2hpY2ggPT09IDMpe1xuXG4gICAgdmFyIGNsaWNrU2hpZWxkID0gZG9taWZ5KCc8ZGl2PjwvZGl2PicpO1xuICAgIGNsaWNrU2hpZWxkLnN0eWxlLndpZHRoID0gd2luZG93LmlubmVyV2lkdGggKyBcInB4XCI7XG4gICAgY2xpY2tTaGllbGQuc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ICsgXCJweFwiO1xuICAgIGNsaWNrU2hpZWxkLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGNsaWNrU2hpZWxkLnN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gICAgY2xpY2tTaGllbGQuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG5cbiAgICAkKCdib2R5JykuYXBwZW5kQ2hpbGQoY2xpY2tTaGllbGQpO1xuXG4gICAgdmFyIHJlc2V0ID0gZnVuY3Rpb24gcmVzZXQoKXtcbiAgICAgIGNsaWNrU2hpZWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgcmVzZXQpO1xuICAgICAgJCgnYm9keScpLnJlbW92ZUNoaWxkKGNsaWNrU2hpZWxkKTtcbiAgICAgICQoJ2JvZHknKS5yZW1vdmVDaGlsZChjb250ZXh0TWVudSlcbiAgICB9XG5cbiAgICBjbGlja1NoaWVsZC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHJlc2V0KTtcblxuICAgIC8vIHJpZ2h0Li4uXG4gICAgdmFyIGNvbnRleHRNZW51ID0gZG9taWZ5KCc8dWwgY2xhc3M9XCJjb250ZXh0LW1lbnVcIj4nICtcbiAgICAgICc8bGk+PGEgaHJlZj1cIiNcIiByZWw9XCJyZWxzL3JlbmFtZS1maWxlXCI+UmVuYW1lPC9hPjwvbGk+JyArXG4gICAgICAnPGxpPjxhIGhyZWY9XCIjXCIgcmVsPVwicmVscy9kZWxldGUtZmlsZVwiPkRlbGV0ZTwvYT48L2xpPicgK1xuICAgICAgJzwvdWw+JylcblxuICAgICQoJ2JvZHknKS5hcHBlbmRDaGlsZChjb250ZXh0TWVudSk7XG5cbiAgICBjb250ZXh0TWVudS5zdHlsZS50b3AgPSBldmVudC5jbGllbnRZICsgXCJweFwiO1xuICAgIGNvbnRleHRNZW51LnN0eWxlLmxlZnQgPSBldmVudC5jbGllbnRYICsgXCJweFwiO1xuXG4gICAgdmFyIGRlbCA9IG5ldyBEZWxlZ2F0ZShjb250ZXh0TWVudSk7XG4gICAgZGVsLm9uKCdjbGljaycsICdhJywgZnVuY3Rpb24gKGUpe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIC8vYWxlcnQoZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdyZWwnKSlcbiAgICAgIHN3aXRjaCAoZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdyZWwnKSl7XG5cbiAgICAgICAgY2FzZSBcInJlbHMvb3Blbi1maWxlXCIgOlxuICAgICAgICAgIGVkaXRGaWxlKGVudGl0eSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZWxzL3JlbmFtZS1maWxlXCIgOiBcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpXG4gICAgICAgICAgZWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGlucHV0KTtcbiAgICAgICAgICBpbnB1dC52YWx1ZSA9IGVudGl0eS5uYW1lO1xuICAgICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgaW5wdXQub25rZXlkb3duID0gZnVuY3Rpb24gKGUpe1xuICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDEzICYmIGlucHV0LnZhbHVlICE9PSBcIlwiKXtcbiAgICAgICAgICAgICAgcmVuYW1lRmlsZSAoZW50aXR5LCBpbnB1dC52YWx1ZSk7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbnB1dCk7XG4gICAgICAgICAgICAgIGlucHV0Lm9ua2V5ZG93biA9IG51bGw7XG4gICAgICAgICAgICAgIGlucHV0Lm9uY2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaW5wdXQgPSBudWxsO1xuXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQub25jbGljayA9IGZ1bmN0aW9uIChlKXtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicmVscy9kZWxldGUtZmlsZVwiOlxuICAgICAgICAgIGRlbGV0ZUZpbGUoZW50aXR5KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cblxufVxuXG5mdW5jdGlvbiByZW5hbWVGaWxlIChlbnRpdHksIG5ld05hbWUpe1xuXG4gIHZhciB1cmkgPSBlbnRpdHkuaHJlZi5yZXBsYWNlKGVudGl0eS5uYW1lLCBuZXdOYW1lKTtcblxuICB2YXIgb2xkVXJpID0gZW50aXR5LmhyZWYucmVwbGFjZSh2ZnNSb290LCAnJyk7XG5cbiAgdmFyIHNlc3Npb24gPSBmYWxzZTtcblxuICBpZiAoZWRpdFNlc3Npb25zW2VudGl0eS5ocmVmXSl7XG4gICAgc2Vzc2lvbiA9IGVkaXRTZXNzaW9uc1tlbnRpdHkuaHJlZl07XG4gIH1cblxuICByZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIHVybCA6IHVyaSwganNvbiA6IHsgcmVuYW1lRnJvbSA6IG9sZFVyaSB9fSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UsIGJvZHkpe1xuICAgIGxvYWREaXJlY3RvcnkoYWN0aXZlRGlyZWN0b3J5KTtcbiAgICBpZiAoc2Vzc2lvbil7XG4gICAgICBlZGl0U2Vzc2lvbnNbdXJpXSA9IHNlc3Npb247XG4gICAgICBlZGl0U2Vzc2lvbnNbdXJpXS5wYXRoID0gdXJpO1xuICAgICAgZWRpdFNlc3Npb25zW2VudGl0eS5ocmVmXSA9IG51bGw7XG4gICAgICBlZGl0U2Vzc2lvbnNbdXJpXS50YWJIZWFkZXIucXVlcnlTZWxlY3RvcignYScpLmlubmVyVGV4dCA9IG5ld05hbWU7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVuYW1lRm9sZGVyIChjdXJyZW50UGF0aCwgb2xkRm9sZGVyTmFtZSwgbmV3Rm9sZGVyTmFtZSl7XG5cbiAgdmFyIHVyaSA9IGN1cnJlbnRQYXRoLnJlcGxhY2Uob2xkRm9sZGVyTmFtZSwgbmV3Rm9sZGVyTmFtZSk7XG5cbiAgdmFyIG9sZFVyaSA9IGN1cnJlbnRQYXRoLnJlcGxhY2UodmZzUm9vdCwgJycpO1xuXG4gIHJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgdXJsOiB1cmksIGpzb24gOiB7IHJlbmFtZUZyb20gOiBvbGRVcml9fSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UsIGJvZHkpe1xuICAgIGxvYWREaXJlY3RvcnkoYWN0aXZlRGlyZWN0b3J5KTtcbiAgfSk7XG5cblxufVxuXG5mdW5jdGlvbiBkZWxldGVGaWxlIChlbnRpdHkpe1xuICBhbGVydCgnZGVsZXRlIGZpbGUnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRm9sZGVyIChwYXRoKXtcbiAgcmVxdWVzdCh7IG1ldGhvZCA6ICdQVVQnLCB1cmwgOiBwYXRoICsgXCJOZXcgZm9sZGVyL1wifSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UsIGJvZHkpe1xuICAgIGlmICghZXJyKXtcbiAgICAgIGxvYWREaXJlY3RvcnkoYWN0aXZlRGlyZWN0b3J5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWxlcnQoZXJyKTtcbiAgICB9XG5cbiAgfSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmlsZSAocGF0aCl7XG4gIHJlcXVlc3QoeyBtZXRob2QgOiAnUFVUJywgdXJsIDogcGF0aCArICdVbnRpdGxlZC5tZCcsIGJvZHkgOiAnJ30sIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlLCBib2R5KXtcbiAgICBpZiAoIWVycil7XG4gICAgICBsb2FkRGlyZWN0b3J5KGFjdGl2ZURpcmVjdG9yeSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgYWxlcnQoZXJyKTtcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVkaXRTZXNzaW9uIChlbnRpdHkpe1xuXG4gIHZhciBwYXRoID0gZW50aXR5LmhyZWY7XG5cbiAgdmFyIGNvbnRhaW5lciA9IGRvbWlmeSgnPGxpPjwvbGk+Jyk7XG4gIHZhciB0YWJIZWFkZXIgPSBkb21pZnkoJzxsaT48YSBocmVmPVwiI1wiPicgKyBlbnRpdHkubmFtZSArJzwvYT48c3BhbiBjbGFzcz1cInR5cGNuIHR5cGNuLWRlbGV0ZVwiPjxzcGFuPjwvbGk+Jyk7XG4gIHRhYkhlYWRlci5xdWVyeVNlbGVjdG9yKCdhJykub25jbGljayA9IG1ha2VFZGl0U2Vzc2lvbkFjdGl2ZS5iaW5kKHt9LCBlbnRpdHkpO1xuICBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ3VsLnRhYnMnKS5hcHBlbmRDaGlsZCh0YWJIZWFkZXIpO1xuXG4gIHZhciBzaXplID0gZ2V0Q29udGVudFZpZXdTaXplKCk7XG5cbiAgdmFyIHRhYkJvZHkgPSBjcmVhdGVCb3goJ2VkaXQtd2luZG93Jyk7XG4gIHRhYkJvZHkuc2l6ZShzaXplLngsIHNpemUueSAtIHNpemUuaGVhZGVySGVpZ2h0KTtcbiAgdGFiQm9keS5wb3NpdGlvbigwLCBzaXplLmhlYWRlckhlaWdodCk7XG4gIHRhYkJvZHkuYXBwZW5kVG9FbGVtZW50KGNvbnRhaW5lcik7XG4gIGNvbnRlbnQucXVlcnlTZWxlY3RvcigndWwudGFiLWJvZGllcycpLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgdmFyIGVkaXRvciA9IGFjZS5lZGl0KHRhYkJvZHkuZWxlbWVudCk7XG4gIGlmIChlbnRpdHkubmFtZS5tYXRjaCgvXFwubWQkLykpe1xuICBlZGl0b3IuZ2V0U2Vzc2lvbigpLnNldE1vZGUoJ2FjZS9tb2RlL21hcmtkb3duJyk7XG4gIH0gZWxzZSB7XG4gICAgZWRpdG9yLmdldFNlc3Npb24oKS5zZXRNb2RlKCdhY2UvbW9kZS9qc29uJyk7XG4gIH1cbiAgZWRpdG9yLnNldFRoZW1lKCdhY2UvdGhlbWUvbW9ub2thaScpO1xuICBlZGl0b3Iuc2V0U2hvd1ByaW50TWFyZ2luKGZhbHNlKTtcblxuICBlZGl0U2Vzc2lvbnNbcGF0aF0gPSB7XG4gICAgZWRpdG9yIDogZWRpdG9yLFxuICAgIHBhdGggOiBwYXRoLFxuICAgIGJveCA6IHRhYkJvZHksXG4gICAgdGFiIDogY29udGFpbmVyLFxuICAgIGVudGl0eSA6IGVudGl0eSxcbiAgICB0YWJIZWFkZXIgOiB0YWJIZWFkZXJcbiAgfVxuXG4gIHRhYkhlYWRlci5xdWVyeVNlbGVjdG9yKCdzcGFuLnR5cGNuLWRlbGV0ZScpLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSl7XG5cbiAgICBlbmRTZXNzaW9uKGVudGl0eSk7XG5cbiAgfTtcblxuICBlZGl0b3Iub24oJ2NoYW5nZScsIGZ1bmN0aW9uICgpe1xuXG4gICAgdmFyIGN1cnJsaW5lID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkuc3RhcnQucm93O1xuICAgIHZhciB3aG9sZWxpbmV0ZXh0ID0gZWRpdG9yLnNlc3Npb24uZ2V0TGluZShjdXJybGluZSk7XG4gICAgdmFyIGN1cnJjaGFyID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCkuc3RhcnQuY29sdW1uO1xuXG4gICAgdmFyIGRvU2VhcmNoID0gZmFsc2U7XG4gICAgdmFyIHVyaSA9IGZhbHNlO1xuICAgIHZhciBtb2RlID0gZmFsc2U7XG5cbiAgICBpZiAoY3VycmNoYXIgPT09ICh3aG9sZWxpbmV0ZXh0Lmxlbmd0aCAtIDEpICYmICgvcmVjb21tZW5kYXRpb25zOiQvLnRlc3Qod2hvbGVsaW5ldGV4dCkpKXtcblxuICAgICAgZG9TZWFyY2ggPSB0cnVlO1xuICAgICAgdXJpID0gXCJzb21ldGhpbmdcIjtcbiAgICAgIG1vZGUgPSBcInJlY29tbWVuZGF0aW9uc1wiO1xuXG4gICAgfSBlbHNlIGlmIChjdXJyY2hhciA9PT0gKHdob2xlbGluZXRleHQubGVuZ3RoIC0gMSkgJiYgKC9xdWFsaXR5c3RhdGVtZW50czokLy50ZXN0KHdob2xlbGluZXRleHQpKSl7XG5cbiAgICAgIGRvU2VhcmNoID0gdHJ1ZTtcbiAgICAgIHVyaSA9IFwic29tZXRoaW5nZWxzZVwiO1xuICAgICAgbW9kZSA9IFwiUXVhbGl0eSBzdGF0ZW1lbnRzXCI7XG5cbiAgICB9XG5cbiAgICBpZiAoZG9TZWFyY2gpe1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gZWRpdG9yLnJlbmRlcmVyLnNjcm9sbGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHBhZGRpbmcgPSBlZGl0b3IucmVuZGVyZXIuJHBhZGRpbmc7XG4gICAgICB2YXIgY3VyID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG5cbiAgICAgIC8vIGdldCB0aGUgeCBhbmQgeSBwb3NpdGlvbiBvZiBcbiAgICAgIHZhciB4ID0gTWF0aC5jZWlsKChjdXIuY29sdW1uICsgMSkgKiBlZGl0b3IucmVuZGVyZXIuY2hhcmFjdGVyV2lkdGgpICsgb2Zmc2V0LmxlZnQgKyBwYWRkaW5nO1xuICAgICAgdmFyIHkgPSBNYXRoLmNlaWwoY3VyLnJvdyAqIGVkaXRvci5yZW5kZXJlci5saW5lSGVpZ2h0KSArIG9mZnNldC50b3A7XG5cbiAgICAgIHZhciBpbnB1dCA9IGRvbWlmeSgnPGlucHV0IHBsYWNlaG9sZGVyPVwiU2VhcmNoIGZvciBjb25jZXB0c1wiIGNsYXNzPVwiYXV0b2NvbXBsZXRlLWlucHV0XCIgdHlwZT1cInRleHRcIj48L2lucHV0PicpO1xuICAgICAgLy9pbnB1dC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIC8vaW5wdXQuc3R5bGUuekluZGV4ID0gMTtcbiAgICAgIGlucHV0LnN0eWxlLmxlZnQgPSB4ICsgXCJweFwiO1xuICAgICAgaW5wdXQuc3R5bGUudG9wID0geSArIFwicHhcIjtcblxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpbnB1dCk7XG5cbiAgICAgIGlucHV0LmZvY3VzKCk7XG5cbiAgICAgIHZhciBsYXN0VmFsID0gXCJcIjtcbiAgICAgIHZhciByZXF1ZXN0SW5Qcm9ncmVzcyA9IGZhbHNlO1xuXG4gICAgICB2YXIgY29udGFpbmVyO1xuXG4gICAgICBmdW5jdGlvbiBnZXRSZXN1bHRzICh0ZXJtKXtcbiAgICAgICAgICByZXF1ZXN0KCcvbGQvY29uY2VwdHMvJyArIHRlcm0sIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlLCBib2R5KXtcbiAgICAgICAgICAgIHJlcXVlc3RJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICAgcHJvY2Vzc1Jlc3VsdHMoZXJyLCBKU09OLnBhcnNlKGJvZHkpKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIHByb2Nlc3NSZXN1bHRzIChlcnIsIGJvZHkpe1xuICAgICAgICByZXF1ZXN0SW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICBpZiAobGFzdFZhbCAhPT0gaW5wdXQudmFsdWUpe1xuICAgICAgICAgIGxhc3RWYWwgPSBpbnB1dC52YWx1ZTtcbiAgICAgICAgICBnZXRSZXN1bHRzKGxhc3RWYWwpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZWN0ID0gaW5wdXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgaWYgKGNvbnRhaW5lcil7XG4gICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjb250YWluZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVyID0gZG9taWZ5KCc8dWwgY2xhc3M9XCJhdXRvY29tcGxldGUtcG9wdXBcIj48L3VsPicpO1xuICAgICAgICBjb250YWluZXIuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS50b3AgPSByZWN0LmJvdHRvbSArIFwicHhcIjtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgKyBcInB4XCI7XG5cbiAgICAgICAgYm9keS5mb3JFYWNoKGZ1bmN0aW9uIChjb25jZXB0LCBpbmRleCl7XG5cbiAgICAgICAgICB2YXIgbGkgPSBkb21pZnkoJzxsaT4nICsgY29uY2VwdC52YWx1ZS5vYmplY3QgKyc8L2xpPicpO1xuICAgICAgICAgIGxpLm9uY2xpY2sgPSBmdW5jdGlvbiAoZSl7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIC8vIHJlbW92ZSBldmVudCBoYW5kbGVycyBmcm9tIG90aGVyIGxpcy4uXG4gICAgICAgICAgICB2YXIgZm5zID0gW107XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdsaScpLCBmdW5jdGlvbiAobGkpe1xuICAgICAgICAgICAgICAvL2lucHV0LnZhbHVlID0gY29uY2VwdC52YWx1ZS5vYmplY3Q7XG4gICAgICAgICAgICAgIGN1cnJlbnRWYWwgPSBsYXN0VmFsID0gaW5wdXQudmFsdWUgPSBjb25jZXB0LnZhbHVlLm9iamVjdDtcbiAgICAgICAgICAgICAgbGkub25jbGljayA9IGZhbHNlO1xuICAgICAgICAgICAgICBmbnMucHVzaChmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQobGkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKXsgZm4oKTsgfSk7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW5wdXQpO1xuXG4gICAgICAgICAgICB2YXIgbG9hZGluZyA9IGRvbWlmeSgnPGxpIGNsYXNzPVwibG9hZGluZ1wiPlNlYXJjaGluZyBmb3IgJyArIG1vZGUgKyAnIGZvciAnICsgY29uY2VwdC52YWx1ZS5vYmplY3QgKyc8L2xpPicpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxvYWRpbmcpO1xuXG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUudG9wID0gcmVjdC50b3AgKyBcInB4XCI7XG5cbiAgICAgICAgICAgIHNlYXJjaEZvclRoaW5ncyhjb25jZXB0LnZhbHVlLm9iamVjdCk7XG5cblxuICAgICAgICAgICAgLy9kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgICAgICAvL2VkaXRvci5mb2N1cygpO1xuICAgICAgICAgICAgLy9lZGl0b3IuaW5zZXJ0KGNvbmNlcHQudmFsdWUuc3ViamVjdCk7XG4gICAgICAgICAgICAvL2RvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQobGkpO1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcblxuICAgICAgICAvL2NvbnNvbGUubG9nKGlucHV0LmNhbGN1bGF0ZUJvdW5kaW5nUmVjdCgpKVxuICAgICAgICAvL2NvbnNvbGUubG9nKGJvZHkpO1xuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gc2VhcmNoRm9yVGhpbmdzICh0YWcpe1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJyZWNvbW1lbmRhdGlvbnNcIil7XG4gICAgICAgICAgcmVxdWVzdCgnL2xkL3JlY29tbWVuZGF0aW9ucy8nICsgdGFnLCBmdW5jdGlvbiAoZXJyLCByZXMpe1xuICAgICAgICAgICAgdmFyIHRyaXBsZXMgPSBKU09OLnBhcnNlKHJlcy5ib2R5KTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRyaXBsZXMpO1xuICAgICAgICAgICAgdmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gZG9taWZ5KCc8ZGl2IGNsYXNzPVwibGQtcmVzdWx0XCI+PGgzPlJlY29tbWVuZGF0aW9uczwvaDM+PHVsPjwvdWw+PC9kaXY+Jyk7XG4gICAgICAgICAgICB2YXIgdWwgPSByZXN1bHRzLnF1ZXJ5U2VsZWN0b3IoJ3VsJyk7XG5cbiAgICAgICAgICAgIHJlc3VsdHMuc3R5bGUudG9wID0gcmVjdC50b3AgKyBcInB4XCI7XG4gICAgICAgICAgICByZXN1bHRzLnN0eWxlLmxlZnQgPSByZWN0LmxlZnQgKyBcInB4XCI7XG4gICAgICAgICAgICByZXN1bHRzLnN0eWxlLm1heEhlaWdodCA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSByZWN0LnRvcCAtIDIwMCkgKyAncHgnXG5cbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnRhaW5lciA9IFwiXCI7XG5cbiAgICAgICAgICAgIHRyaXBsZXMuZm9yRWFjaChmdW5jdGlvbiAodHJpcGxlKXtcblxuICAgICAgICAgICAgICB2YXIgbGkgPSBkb21pZnkoJzxsaT48L2xpPicpO1xuICAgICAgICAgICAgICB2YXIgaWQgPSBkb21pZnkoJzxwIGNsYXNzPVwiaWRcIj4nICsgdHJpcGxlLnN1YmplY3QgKyAnPC9wPicpO1xuICAgICAgICAgICAgICB2YXIgdGV4dCA9IGRvbWlmeSgnPGRpdj4nICsgbWFya2VkKHRyaXBsZS5vYmplY3QucmVwbGFjZSgvXFxuXFw/XFxzL2csICdcXG4tICcpKSArICc8L2Rpdj4nKTtcbiAgICAgICAgICAgICAgdmFyIGluc2VydCA9IGRvbWlmeSgnPGEgaHJlZj1cIiNcIj5JbnNlcnQgYSBsaW5rIHRvIHRoaXMgcmVjb21tZW5kYXRpb248L2E+Jyk7XG5cbiAgICAgICAgICAgICAgaW5zZXJ0Lm9uY2xpY2sgPSBmdW5jdGlvbiAoZSl7XG5cbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgZWRpdG9yLmluc2VydCh0cmlwbGUuc3ViamVjdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKHJlc3VsdHMucXVlcnlTZWxlY3RvckFsbCgnYScpLCBmdW5jdGlvbiAoYSl7XG4gICAgICAgICAgICAgICAgICBhLm9uY2xpY2sgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChyZXN1bHRzKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gbnVsbDtcblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQoaWQpO1xuICAgICAgICAgICAgICBsaS5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICAgICAgICAgICAgbGkuYXBwZW5kQ2hpbGQoaW5zZXJ0KTtcblxuICAgICAgICAgICAgICB1bC5hcHBlbmRDaGlsZChsaSk7XG5cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJlc3VsdHMpO1xuXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnB1dC5vbmtleXVwID0gZnVuY3Rpb24gKGUpe1xuXG4gICAgICAgIHZhciBjdXJyZW50VmFsID0gaW5wdXQudmFsdWUudHJpbSgpO1xuXG4gICAgICAgIGlmIChjdXJyZW50VmFsICE9PSBcIlwiKXtcblxuICAgICAgICAgIC8vIGdldCB0aGUgb3B0aW9uc1xuXG4gICAgICAgICAgaWYgKGxhc3RWYWwgIT09IGN1cnJlbnRWYWwgJiYgIXJlcXVlc3RJblByb2dyZXNzKXtcbiAgICAgICAgICAgIHJlcXVlc3RJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgIGxhc3RWYWwgPSBjdXJyZW50VmFsO1xuICAgICAgICAgICAgZ2V0UmVzdWx0cyhsYXN0VmFsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIGNsZWFyIHRoZSBvcHRpb25zLi4uXG5cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICBcbiAgICAgIC8vIGxvb2tpbmcgZm9yIHJlY29tbWVuZGF0aW9uc1xuXG5cbiAgICAgIC8vIGNvbWVkeSBwcm9vZiBvZiBjb25jZXB0Li4uXG5cbiAgICAgIC8vc2V0VGltZW91dChmdW5jdGlvbiAoKXtcblxuICAgICAgLy8gIGVkaXRvci5mb2N1cygpO1xuICAgICAgLy8gIGVkaXRvci5pbnNlcnQoaW5wdXQudmFsdWUpO1xuICAgICAgIC8vIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaW5wdXQpO1xuXG4gICAgIC8vIH0sIDEwMDAwKVxuXG5cbiAgICB9XG5cblxuICB9KTtcblxuICByZXR1cm4gZWRpdFNlc3Npb25zW3BhdGhdO1xuXG59XG5cbmZ1bmN0aW9uIHNhdmVGaWxlKHBhdGgsIGJvZHksIGNhbGxiYWNrKXtcbiAgcmVxdWVzdC5wdXQoeyB1cmkgOiBwYXRoLCBib2R5IDogYm9keX0sIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlKXtcbiAgICBjYWxsYmFjayhlcnIsIHJlc3BvbnNlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGxvYWRGaWxlKHBhdGgsIGNhbGxiYWNrKXtcbiAgcmVxdWVzdChwYXRoLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSwgYm9keSl7XG4gICAgY2FsbGJhY2soZXJyLCBib2R5KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGxvYWREaXJlY3RvcnkocGF0aCwgb2JqLCBlbGVtZW50LCBldmVudCl7XG5cbiAgaWYgKGV2ZW50ICYmIGV2ZW50LndoaWNoID09PSAzKXtcblxuICAgIHZhciBjbGlja1NoaWVsZCA9IGRvbWlmeSgnPGRpdj48L2Rpdj4nKTtcbiAgICBjbGlja1NoaWVsZC5zdHlsZS53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoICsgXCJweFwiO1xuICAgIGNsaWNrU2hpZWxkLnN0eWxlLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCArIFwicHhcIjtcbiAgICBjbGlja1NoaWVsZC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICBjbGlja1NoaWVsZC5zdHlsZS50b3AgPSBcIjBweFwiO1xuICAgIGNsaWNrU2hpZWxkLnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuXG4gICAgJCgnYm9keScpLmFwcGVuZENoaWxkKGNsaWNrU2hpZWxkKTtcblxuICAgIHZhciByZXNldCA9IGZ1bmN0aW9uIHJlc2V0KCl7XG4gICAgICBjbGlja1NoaWVsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHJlc2V0KTtcbiAgICAgICQoJ2JvZHknKS5yZW1vdmVDaGlsZChjbGlja1NoaWVsZCk7XG4gICAgICAkKCdib2R5JykucmVtb3ZlQ2hpbGQoY29udGV4dE1lbnUpXG4gICAgfVxuXG4gICAgY2xpY2tTaGllbGQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCByZXNldCk7XG5cbiAgICAvLyByaWdodC4uLlxuICAgIHZhciBjb250ZXh0TWVudSA9IGRvbWlmeSgnPHVsIGNsYXNzPVwiY29udGV4dC1tZW51XCI+JyArXG4gICAgICAnPGxpPjxhIGhyZWY9XCIjXCIgcmVsPVwicmVscy9yZW5hbWUtZm9sZGVyXCI+UmVuYW1lPC9hPjwvbGk+JyArXG4gICAgICAnPGxpPjxhIGhyZWY9XCIjXCIgcmVsPVwicmVscy9kZWxldGUtZmlsZVwiPkRlbGV0ZTwvYT48L2xpPicgK1xuICAgICAgJzwvdWw+JylcblxuICAgICQoJ2JvZHknKS5hcHBlbmRDaGlsZChjb250ZXh0TWVudSk7XG5cbiAgICBjb250ZXh0TWVudS5zdHlsZS50b3AgPSBldmVudC5jbGllbnRZICsgXCJweFwiO1xuICAgIGNvbnRleHRNZW51LnN0eWxlLmxlZnQgPSBldmVudC5jbGllbnRYICsgXCJweFwiO1xuXG4gICAgdmFyIGRlbCA9IG5ldyBEZWxlZ2F0ZShjb250ZXh0TWVudSk7XG4gICAgZGVsLm9uKCdjbGljaycsICdhJywgZnVuY3Rpb24gKGUpe1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICByZXNldCgpO1xuXG4gICAgICB2YXIgcmVsID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKCdyZWwnKTtcblxuICAgICAgc3dpdGNoIChyZWwpe1xuICAgICAgICBjYXNlIFwicmVscy9yZW5hbWUtZm9sZGVyXCIgOlxuICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0JylcbiAgICAgICAgICBlbGVtZW50LnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuICAgICAgICAgIGlucHV0LnZhbHVlID0gb2JqLm5hbWU7XG4gICAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICBpbnB1dC5vbmtleWRvd24gPSBmdW5jdGlvbiAoZSl7XG4gICAgICAgICAgICBpZiAoZS53aGljaCA9PT0gMTMgJiYgaW5wdXQudmFsdWUgIT09IFwiXCIpe1xuICAgICAgICAgICAgICByZW5hbWVGb2xkZXIgKHBhdGgsIG9iai5uYW1lLCBpbnB1dC52YWx1ZSk7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbnB1dCk7XG4gICAgICAgICAgICAgIGlucHV0Lm9ua2V5ZG93biA9IG51bGw7XG4gICAgICAgICAgICAgIGlucHV0Lm9uY2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgaW5wdXQgPSBudWxsO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9IGVsc2UgaWYgKCFldmVudCB8fCAoZXZlbnQud2hpY2ggPT09IDEgJiYgZXZlbnQudGFyZ2V0LnRhZ05hbWUgIT09IFwiSU5QVVRcIikpIHtcblxuICAgIGFjdGl2ZURpcmVjdG9yeSA9IHBhdGg7XG5cbiAgICByZXF1ZXN0KHBhdGgsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlLCBib2R5KXtcblxuICAgICAgaWYgKCFlcnIpe1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UWXBlJykgPT09IFwiYXBwbGljYXRpb24vanNvblwiKXtcbiAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpcmVjdG9yeUNhY2hlW2FjdGl2ZURpcmVjdG9yeV0gPSBib2R5O1xuXG4gICAgICAgIHZhciByZWZlcmVuY2UgPSBnZXREaXJlY3RvcnlSZWZlcmVuY2UocGF0aCk7XG4gICAgICAgIHVwZGF0ZUZpbGVTeXN0ZW0ocGF0aCwgYm9keSk7XG4gICAgICAgIHJlbmRlckN1cnJlbnREaXJlY3RvcnkocmVmZXJlbmNlKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWxlcnQoZXJyKTtcbiAgICAgIH1cblxuICAgIH0pO1xuXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGlyZWN0b3J5UmVmZXJlbmNlKHBhdGgpe1xuICAgIC8vIHBvcCBvZmYgdGhlIGZpcnN0IGFuZCBsYXN0XG5cbiAgcGF0aCA9IHBhdGgucmVwbGFjZSh2ZnNSb290LCAnJyk7XG5cbiAgdmFyIHBhdGhDaHVua3MgPSBwYXRoLnNwbGl0KCcvJyk7XG4gIHZhciBwb2ludGVyID0gZmlsZVN5c3RlbTtcblxuICBwYXRoQ2h1bmtzLnNoaWZ0KCk7IFxuICBwYXRoQ2h1bmtzLnBvcCgpO1xuICBwYXRoQ2h1bmtzLnVuc2hpZnQoJ3Jvb3QnKTtcblxuICBwYXRoQ2h1bmtzLmZvckVhY2goZnVuY3Rpb24gKGNodW5rKXtcbiAgICBpZiAocG9pbnRlci5jaGlsZHJlbltjaHVua10pe1xuICAgICAgcG9pbnRlci5jaGlsZHJlbltjaHVua10ucGFyZW50ID0gcG9pbnRlcjtcbiAgICAgIHBvaW50ZXIgPSBwb2ludGVyLmNoaWxkcmVuW2NodW5rXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbWcnKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwb2ludGVyO1xuXG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZpbGVTeXN0ZW0ocGF0aCwgZW50aXRpZXMpe1xuXG4gIHZhciBwb2ludGVyID0gZ2V0RGlyZWN0b3J5UmVmZXJlbmNlKHBhdGgpO1xuXG4gIHBvaW50ZXIuZW50aXRpZXMuc3BsaWNlKDAsIHBvaW50ZXIuZW50aXRpZXMubGVuZ3RoKTtcblxuICBlbnRpdGllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRpdHkpe1xuICAgIGlmIChlbnRpdHkubWltZSA9PT0gXCJpbm9kZS9kaXJlY3RvcnlcIil7XG4gICAgICBpZiAoIXBvaW50ZXIuY2hpbGRyZW5bZW50aXR5Lm5hbWVdKXtcbiAgICAgICAgcG9pbnRlci5jaGlsZHJlbltlbnRpdHkubmFtZV0gPSB7XG4gICAgICAgICAgbmFtZSA6IGVudGl0eS5uYW1lLFxuICAgICAgICAgIGhyZWYgOiBlbnRpdHkuaHJlZixcbiAgICAgICAgICBlbnRpdGllcyA6IFtdLFxuICAgICAgICAgIGNoaWxkcmVuIDoge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhZGQgaXQgYXMgYW4gZW50aXR5Li4uXG4gICAgICBwb2ludGVyLmVudGl0aWVzLnB1c2goZW50aXR5KTtcblxuICAgIH1cbiAgICBcbiAgfSk7XG5cbiAgZm9yICh2YXIgY2hpbGQgaW4gcG9pbnRlci5jaGlsZHJlbil7XG4gICAgaWYgKHBvaW50ZXIuY2hpbGRyZW4uaGFzT3duUHJvcGVydHkoY2hpbGQpKXtcbiAgICAgIHZhciBleGlzdHMgPSBmYWxzZTtcbiAgICAgIGVudGl0aWVzLmZvckVhY2goZnVuY3Rpb24gKGVudGl0eSl7XG4gICAgICAgIGlmIChlbnRpdHkubmFtZSA9PT0gY2hpbGQpe1xuICAgICAgICAgIGV4aXN0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKCFleGlzdHMpe1xuICAgICAgICBkZWxldGUgcG9pbnRlci5jaGlsZHJlbltjaGlsZF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuXG5sb2FkRGlyZWN0b3J5KGZpbGVTeXN0ZW0uY2hpbGRyZW4ucm9vdC5ocmVmKTtcbiovIiwidmFyIHJlcXVlc3QgPSByZXF1aXJlKCdicm93c2VyLXJlcXVlc3QnKTtcbnZhciBHYXRoZXIgPSByZXF1aXJlKCdnbS1nYXRoZXInKTtcbnZhciBjbG9uZURlZXAgPSByZXF1aXJlKCdjbG9uZS1kZWVwJyk7XG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuXG52YXIgY29uc29sZSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvY29uc29sZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cy5pbml0aWFsaXNlRmlsZVN5c3RlbSA9IGZ1bmN0aW9uIGluaXRpYWxpc2VGaWxlU3lzdGVtIChhcHAsIHZmc1Jvb3Qpe1xuXG4gIHZhciBzeXN0ZW0gPSBuZXcgKHJlcXVpcmUoJ2V2ZW50cycpKS5FdmVudEVtaXR0ZXI7XG5cbiAgLy8gZ2xvYmFsIGFwcGxpY2F0aW9uIGV2ZW50cy4uLiBcbiAgYXBwLm9uKCdyZW1vdGUtZW50aXR5LXVwZGF0ZScsIGZ1bmN0aW9uIChtc2cpe1xuXG4gICAgYXBwLmVtaXQoJ2VudGl0eS11cGRhdGVkJywgJ3VwZGF0ZScsIG1zZy5wYXRoKTtcblxuICAgIGxvYWRGaWxlU3lzdGVtKGRhdGEuY2hpbGRyZW4ucm9vdC5ocmVmLCBmdW5jdGlvbiAoZXJyKXtcblxuICAgICAgaWYgKCFlcnIpe1xuXG4gICAgICAgIGNvbnNvbGUubG9nKCdSZW1vdGUgZmlsZSBzeXN0ZW0gc3luY2hyb25pc2VkJyk7XG5cbiAgICAgICAgYXBwLmVtaXQoJ3N5bmMnLCBkYXRhLmNoaWxkcmVuLnJvb3QucmVsUGF0aCk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgYXBwLmVtaXQoJ3N5bmMtZXJyb3InLCAnVW5hYmxlIHRvIHN5bmNocm9uaXNlIHdpdGggcmVtb3RlIGZpbGUgc3lzdGVtJywgZXJyKTtcblxuICAgICAgfVxuXG4gICAgfSk7XG5cbiAgfSk7XG5cbiAgYXBwLm9uKCdyZW1vdGUtZW50aXR5LXJlbmFtZScsIGZ1bmN0aW9uIChtc2cpe1xuXG4gICAgYXBwLmVtaXQoJ2VudGl0eS1yZW5hbWVkJywgJ3JlbmFtZScsIG1zZy5wYXRoLCBtc2cub2xkUGF0aCk7XG5cbiAgICBsb2FkRmlsZVN5c3RlbShkYXRhLmNoaWxkcmVuLnJvb3QuaHJlZiwgZnVuY3Rpb24gKGVycil7XG5cbiAgICAgIGlmICghZXJyKXtcblxuICAgICAgICBjb25zb2xlLmxvZygnUmVtb3RlIGZpbGUgc3lzdGVtIHN5bmNocm9uaXNlZCcpO1xuXG4gICAgICAgIGFwcC5lbWl0KCdzeW5jJywgZGF0YS5jaGlsZHJlbi5yb290LnJlbFBhdGgpO1xuXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGFwcC5lbWl0KCdzeW5jLWVycm9yJywgJ1VuYWJsZSB0byBzeW5jaHJvbmlzZSB3aXRoIHJlbW90ZSBmaWxlIHN5c3RlbScsIGVycik7XG5cbiAgICAgIH1cblxuICAgIH0pO1xuXG5cbiAgfSlcblxuICBhcHAub24oJ3JlbW90ZS1lbnRpdHktY3JlYXRlJywgZnVuY3Rpb24gKG1zZyl7XG5cbiAgICBhcHAuZW1pdCgnZW50aXR5LXVwZGF0ZWQnLCAnY3JlYXRlJywgbXNnLnBhdGgpO1xuXG4gICAgLy8geW91IGtub3csIFxuXG4gICAgbG9hZEZpbGVTeXN0ZW0oZGF0YS5jaGlsZHJlbi5yb290LmhyZWYsIGZ1bmN0aW9uIChlcnIpe1xuXG4gICAgICBpZiAoIWVycil7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1JlbW90ZSBmaWxlIHN5c3RlbSBzeW5jaHJvbmlzZWQnKTtcblxuICAgICAgICBhcHAuZW1pdCgnc3luYycsIGRhdGEuY2hpbGRyZW4ucm9vdC5yZWxQYXRoKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBhcHAuZW1pdCgnc3luYy1lcnJvcicsICdVbmFibGUgdG8gc3luY2hyb25pc2Ugd2l0aCByZW1vdGUgZmlsZSBzeXN0ZW0nLCBlcnIpO1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9KTtcblxuICBhcHAub24oJ3JlbW90ZS1lbnRpdHktZGVsZXRlJywgZnVuY3Rpb24gKG1zZyl7XG5cbiAgICBhcHAuZW1pdCgnZW50aXR5LXVwZGF0ZWQnLCAnZGVsZXRlJywgbXNnLnBhdGgpO1xuXG4gICAgbG9hZEZpbGVTeXN0ZW0oZGF0YS5jaGlsZHJlbi5yb290LmhyZWYsIGZ1bmN0aW9uIChlcnIpe1xuXG4gICAgICBpZiAoIWVycil7XG5cbiAgICAgICAgY29uc29sZS5sb2coJ1JlbW90ZSBmaWxlIHN5c3RlbSBzeW5jaHJvbmlzZWQnKTtcblxuICAgICAgICBhcHAuZW1pdCgnc3luYycsIGRhdGEuY2hpbGRyZW4ucm9vdC5yZWxQYXRoKTtcblxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBhcHAuZW1pdCgnc3luYy1lcnJvcicsICdVbmFibGUgdG8gc3luY2hyb25pc2Ugd2l0aCByZW1vdGUgZmlsZSBzeXN0ZW0nLCBlcnIpO1xuXG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9KTtcblxuXG4gIC8vIG91ciBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZS4uLlxuICB2YXIgZGF0YSA9IHtcbiAgICBlbnRpdGllcyA6IFtdLFxuICAgIGNoaWxkcmVuIDoge1xuICAgICAgcm9vdCA6IHtcbiAgICAgICAgZW50aXRpZXMgOiBbXSxcbiAgICAgICAgbmFtZSA6IFwiUHJvamVjdCByb290XCIsXG4gICAgICAgIHJlbFBhdGggOiBcIi9cIixcbiAgICAgICAgaHJlZiA6IHZmc1Jvb3QgKyBcIi9cIixcbiAgICAgICAgY2hpbGRyZW4gOiB7fSxcbiAgICAgICAgcGFyZW50IDogZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGVudGl0eUxvb2t1cCA9IHt9O1xuXG4gIHN5c3RlbS5nZXRVUkkgPSBmdW5jdGlvbiBnZXRVUkkgKHBhdGhOYW1lKXtcblxuICAgIHJldHVybiB2ZnNSb290ICsgcGF0aE5hbWU7XG5cbiAgfSBcblxuICBzeXN0ZW0ucmVhZEZpbGUgPSBmdW5jdGlvbiByZWFkRmlsZSAocGF0aE5hbWUsIGZuKXtcblxuICAgIHZhciBlbnRpdHkgPSBlbnRpdHlMb29rdXBbcGF0aE5hbWVdO1xuXG4gICAgLy8gdGVjaG5pY2FsbHkgaWYgdGhpcyBkb2Vzbid0IGV4aXN0Li4uXG5cbiAgICBpZiAoIWVudGl0eSl7IC8vIGRvZXNuJ3QgZXhpc3Q/XG4gICAgICB2YXIgcGFyZW50UGF0aCA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUocGF0aE5hbWUpLCAnLycpO1xuICAgICAgLy9wYXJlbnQgPSBlbnRpdHlMb29rdXBbcGFyZW50UGF0aF07XG5cbiAgICAgIGVudGl0eSA9IHtcbiAgICAgICAgcGFyZW50IDogcGFyZW50UGF0aCxcbiAgICAgICAgaHJlZiA6IHZmc1Jvb3QgKyBwYXRoTmFtZSxcbiAgICAgICAgbWltZSA6ICcnLFxuICAgICAgICBzaXplIDogMCxcbiAgICAgICAgbXRpbWUgOiAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVxdWVzdChlbnRpdHkuaHJlZiwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2Upe1xuXG4gICAgICAvL3ZhciBoZWFkZXJzID0gcmVzcG9uc2UuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCk7XG5cbiAgICAgIGlmICghZXJyKXtcblxuICAgICAgICB2YXIgYm9keSA9IHJlc3BvbnNlLmJvZHk7XG5cbiAgICAgICAgcmVxdWVzdCh2ZnNSb290ICsgZW50aXR5LnBhcmVudCwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2Upe1xuXG4gICAgICAgICAgaWYgKCFlcnIgJiYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA9PT0gMzA0KSl7XG4gICAgICAgICAgICB2YXIgbWV0YSA9IEpTT04ucGFyc2UocmVzcG9uc2UuYm9keSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGEubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICBpZiAobWV0YVtpXS5uYW1lID09PSBlbnRpdHkubmFtZSl7XG4gICAgICAgICAgICAgICAgZW50aXR5Lm1pbWUgPSBtZXRhW2ldLm1pbWU7XG4gICAgICAgICAgICAgICAgZW50aXR5LnNpemUgPSBtZXRhW2ldLnNpemU7XG4gICAgICAgICAgICAgICAgZW50aXR5Lm10aW1lID0gbWV0YVtpXS5tdGltZTtcbiAgICAgICAgICAgICAgICBmbiAoZmFsc2UsIGVudGl0eSwgYm9keSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm4gKGVyciwgZW50aXR5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuIChlcnIsIGVudGl0eSk7XG4gICAgICB9XG5cbiAgICB9KTtcblxuICB9O1xuXG4gIHN5c3RlbS5yZWFkRmlsZUFzQmFzZTY0ID0gZnVuY3Rpb24gcmVhZEZpbGVBc0Jhc2U2NCAocGF0aE5hbWUsIGZuKXtcblxuICAgIHZhciBlbnRpdHkgPSBlbnRpdHlMb29rdXBbcGF0aE5hbWVdO1xuXG4gICAgLy8gaGF2ZSB0byBnbyBncml6emx5IGZvciB0aGlzLi4uXG5cbiAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgeGhyLm9wZW4oJ0dFVCcsIGVudGl0eS5ocmVmLCB0cnVlKTtcbiAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKXtcblxuICAgICAgdmFyIGJsb2IgPSB4aHIucmVzcG9uc2U7XG4gICAgICB2YXIgYm9keSA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG5cbiAgICAgIHJlcXVlc3QodmZzUm9vdCArIGVudGl0eS5wYXJlbnQsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlKXtcblxuICAgICAgICBpZiAoIWVycil7XG4gICAgICAgICAgdmFyIG1ldGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlLmJvZHkpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBpZiAobWV0YVtpXS5uYW1lID09PSBlbnRpdHkubmFtZSl7XG4gICAgICAgICAgICAgIGVudGl0eS5taW1lID0gbWV0YVtpXS5taW1lO1xuICAgICAgICAgICAgICBlbnRpdHkuc2l6ZSA9IG1ldGFbaV0uc2l6ZTtcbiAgICAgICAgICAgICAgZW50aXR5Lm10aW1lID0gbWV0YVtpXS5tdGltZTtcbiAgICAgICAgICAgICAgZm4gKGZhbHNlLCBlbnRpdHksIGJvZHkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm4gKGVyciwgZW50aXR5KTtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgIH1cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpe1xuICAgICAgZm4gKHJlc3BvbnNlLnN0YXR1cywgZW50aXR5KTtcbiAgICB9XG5cbiAgICB4aHIuc2VuZCgpO1xuXG4gIH1cblxuXG5cbiAgc3lzdGVtLndyaXRlRmlsZSA9IGZ1bmN0aW9uIHdyaXRlRmlsZShwYXRoTmFtZSwgYm9keSwgZm4pe1xuXG4gICAgdmFyIGVudGl0eSA9IGVudGl0eUxvb2t1cFtwYXRoTmFtZV07XG5cbiAgICBpZiAoZW50aXR5KXtcblxuICAgICAgcmVxdWVzdC5wdXQoeyB1cmkgOiBlbnRpdHkuaHJlZiwgYm9keSA6IGJvZHl9LCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSl7XG4gICAgICAgIGlmICghZXJyKXtcbiAgICAgICAgICBmbiAoZmFsc2UsIGVudGl0eSk7XG4gICAgICAgICAgYXBwLmVtaXQoJ2VudGl0eS11cGRhdGVkJywgJ3VwZGF0ZScsIHBhdGhOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbiAoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB2YXIgZW50aXR5ID0ge1xuICAgICAgICBocmVmIDogdmZzUm9vdCArIHBhdGhOYW1lLFxuICAgICAgICBwYXJlbnQgOiBwYXRoLmRpcm5hbWUocGF0aE5hbWUpICsgXCIvXCJcbiAgICAgIH1cblxuICAgICAgcmVxdWVzdC5wdXQoeyB1cmkgOiB2ZnNSb290ICsgcGF0aE5hbWUsIGJvZHkgOiBib2R5fSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2Upe1xuICAgICAgICBpZiAoIWVycil7XG5cbiAgICAgICAgICB2YXIgcCA9IHBhdGhOYW1lLnNwbGl0KCcvJyk7IHZhciBuYW1lID0gcC5wb3AoKTsgcC5zaGlmdCgpOyBcbiAgICAgICAgICB2YXIgZm9sZGVyID0gXCIvXCIgKyBwLmpvaW4oJy8nKTtcblxuICAgICAgICAgIGlmICghL1xcLyQvLnRlc3QoZm9sZGVyKSl7XG4gICAgICAgICAgICBmb2xkZXIgKz0gXCIvXCI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVxdWVzdC5nZXQodmZzUm9vdCArIGZvbGRlciwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2Upe1xuXG4gICAgICAgICAgICB2YXIgcmVmID0gZ2V0RGlyZWN0b3J5UmVmZXJlbmNlKGZvbGRlcik7XG5cbiAgICAgICAgICAgIHZhciBib2R5ID0gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgaWYgKGJvZHlbaV0ubmFtZSA9PT0gbmFtZSl7XG4gICAgICAgICAgICAgICAgZW50aXR5Lm5hbWUgPSBib2R5W2ldLm5hbWU7XG4gICAgICAgICAgICAgICAgZW50aXR5LnNpemUgPSBib2R5W2ldLnNpemU7XG4gICAgICAgICAgICAgICAgZW50aXR5Lm1pbWUgPSBib2R5W2ldLm1pbWU7XG4gICAgICAgICAgICAgICAgZW50aXR5Lm10aW1lID0gYm9keVtpXS5tdGltZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbnRpdHlMb29rdXBbcGF0aE5hbWVdID0gZW50aXR5O1xuXG4gICAgICAgICAgICByZWYuZW50aXRpZXMucHVzaChlbnRpdHkpO1xuXG4gICAgICAgICAgICBmbiAoZmFsc2UsIGVudGl0eSk7XG4gICAgICAgICAgICBhcHAuZW1pdCgnc3luYycsIGRhdGEuY2hpbGRyZW4ucm9vdC5yZWxQYXRoKTtcbiAgICAgICAgICAgIGFwcC5lbWl0KCdlbnRpdHktdXBkYXRlZCcsICd1cGRhdGUnLCBwYXRoTmFtZSk7XG5cblxuICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbiAoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICB9KTtcblxuICAgIH1cblxuICB9O1xuXG4gIHN5c3RlbS5yZW5hbWVGaWxlID0gZnVuY3Rpb24gcmVuYW1lRmlsZSAocGF0aE5hbWUsIG5ld05hbWUsIGZuKXtcblxuICAgIHZhciBlbnRpdHkgPSBlbnRpdHlMb29rdXBbcGF0aE5hbWVdO1xuXG4gICAgdmFyIG9sZFBhdGggPSBlbnRpdHkucmVsUGF0aDtcbiAgICB2YXIgbmV3UGF0aCA9IGVudGl0eS5ocmVmLnJlcGxhY2UoZW50aXR5Lm5hbWUsIG5ld05hbWUpO1xuXG4gICAgcmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCB1cmwgOiBuZXdQYXRoLCBqc29uIDogeyByZW5hbWVGcm9tIDogb2xkUGF0aCB9fSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UsIGJvZHkpe1xuICAgICAgLy8gbG9hZCBuZXcgbWV0YWRhdGEuLi4gXG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApe1xuICAgICAgICB2YXIgbmV3RW50aXR5ID0gY2xvbmVEZWVwKGVudGl0eSk7XG4gICAgICAgIG5ld0VudGl0eS5yZWxQYXRoID0gbmV3UGF0aC5yZXBsYWNlKHZmc1Jvb3QsICcnKTtcbiAgICAgICAgbmV3RW50aXR5LmhyZWYgPSBuZXdQYXRoO1xuICAgICAgICBuZXdFbnRpdHkubmFtZSA9IG5ld05hbWU7XG5cbiAgICAgICAgZGVsZXRlIGVudGl0eUxvb2t1cFtwYXRoTmFtZV07XG5cbiAgICAgICAgZW50aXR5TG9va3VwW25ld0VudGl0eS5yZWxQYXRoXSA9IG5ld0VudGl0eTtcblxuICAgICAgICBmbiAoZmFsc2UsIG5ld0VudGl0eSwgZW50aXR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuIChlcnIpO1xuICAgICAgfVxuICAgICAgLy9mbihlcnIsIG5ld05hbWUsIGVudGl0eS5uYW1lICk7XG5cbiAgICB9KTtcbiAgfTtcblxuICBzeXN0ZW0uZGVsZXRlRmlsZSA9IGZ1bmN0aW9uIGRlbGV0ZUZpbGUgKHBhdGhOYW1lLCBmbil7XG5cbiAgICB2YXIgZW50aXR5ID0gZW50aXR5TG9va3VwW3BhdGhOYW1lXTtcblxuICAgIHJlcXVlc3QoeyBtZXRob2QgOiAnZGVsZXRlJywgdXJsIDogZW50aXR5LmhyZWZ9LCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSl7XG5cbiAgICAgIGZuKGVycik7XG5cbiAgICB9KVxuXG4gIH07XG5cbiAgc3lzdGVtLnJlYWRGb2xkZXIgPSBmdW5jdGlvbiByZWFkRm9sZGVyIChwYXRoTmFtZSwgZm4pe1xuXG4gIH07XG5cbiAgc3lzdGVtLndyaXRlRm9sZGVyID0gZnVuY3Rpb24gd3JpdGVGb2xkZXIgKHBhdGhOYW1lLCBuZXdGb2xkZXJOYW1lLCBmbil7XG5cbiAgICB2YXIgZW50aXR5ID0gZW50aXR5TG9va3VwW3BhdGhOYW1lXTtcblxuICAgIHZhciBuZXdQYXRoID0gZW50aXR5LmhyZWYgKyBcIi9cIiArIG5ld0ZvbGRlck5hbWUgKyBcIi9cIjtcblxuICAgIHJlcXVlc3QoeyBtZXRob2Q6ICdwdXQnLCB1cmwgOiBuZXdQYXRofSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2Upe1xuXG4gICAgICBmbiAoZXJyLCBuZXdGb2xkZXJOYW1lKTtcblxuICAgIH0pO1xuXG4gIH07XG5cbiAgc3lzdGVtLmNyZWF0ZUZpbGUgPSBmdW5jdGlvbiB3cml0ZUZvbGRlciAocGF0aE5hbWUsIG5ld0ZpbGVOYW1lLCBmbil7XG5cbiAgICB2YXIgZW50aXR5ID0gZW50aXR5TG9va3VwW3BhdGhOYW1lXTtcblxuICAgIHZhciBuZXdQYXRoID0gZW50aXR5LmhyZWYgKyBcIi9cIiArIG5ld0ZpbGVOYW1lO1xuXG4gICAgcmVxdWVzdCh7IG1ldGhvZDogJ3B1dCcsIHVybCA6IG5ld1BhdGh9LCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSl7XG5cbiAgICAgIGZuIChlcnIsIG5ld0ZpbGVOYW1lKTtcblxuICAgIH0pO1xuXG4gIH07XG5cbiAgc3lzdGVtLnJlbmFtZUZvbGRlciA9IGZ1bmN0aW9uIHJlbmFtZUZvbGRlciAocGF0aCwgbmV3TmFtZSwgZm4pe1xuXG4gICAgdmFyIGVudGl0eSA9IGVudGl0eUxvb2t1cFtwYXRoTmFtZV07XG5cbiAgICB2YXIgbmV3UGF0aCA9IGVudGl0eS5ocmVmLnJlcGxhY2UoZW50aXR5Lm5hbWUgKyBcIi9cIiwgbmV3TmFtZSk7XG4gICAgdmFyIG9sZFBhdGggPSBlbnRpdHkucmVsUGF0aDtcblxuICAgIHJlcXVlc3QoeyBtZXRob2QgOiAnUE9TVCcsIHVybCA6IG5ld1BhdGgsIGpzb24gOiB7cmVuYW1lRnJvbSA6IG9sZFBhdGh9fSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UsIGJvZHkpe1xuICAgICAgZm4gKGVyciwgbmV3TmFtZSwgZW50aXR5Lm5hbWUpO1xuICAgIH0pO1xuLypcbiAgdmFyIHVyaSA9IGN1cnJlbnRQYXRoLnJlcGxhY2Uob2xkRm9sZGVyTmFtZSwgbmV3Rm9sZGVyTmFtZSk7XG5cbiAgdmFyIG9sZFVyaSA9IGN1cnJlbnRQYXRoLnJlcGxhY2UodmZzUm9vdCwgJycpO1xuXG4gIHJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgdXJsOiB1cmksIGpzb24gOiB7IHJlbmFtZUZyb20gOiBvbGRVcml9fSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UsIGJvZHkpe1xuICAgIGxvYWREaXJlY3RvcnkoYWN0aXZlRGlyZWN0b3J5KTtcbiAgfSk7XG4qL1xuXG4gIH07XG5cbiAgc3lzdGVtLmRlbGV0ZUZvbGRlciA9IGZ1bmN0aW9uIGRlbGV0ZUZvbGRlciAocGF0aE5hbWUsIGZuKXtcblxuICAgIHZhciBlbnRpdHkgPSBlbnRpdHlMb29rdXBbcGF0aE5hbWVdO1xuXG4gICAgcmVxdWVzdCh7IG1ldGhvZCA6ICdkZWxldGUnLCB1cmwgOiBlbnRpdHkuaHJlZn0sIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlKXtcblxuICAgICAgZm4oZXJyKTtcblxuICAgIH0pO1xuXG4gIH07XG5cbiAgc3lzdGVtLmdldEFsbCA9IGZ1bmN0aW9uIGdldEFsbChmbil7XG5cbiAgICBmdW5jdGlvbiBnZXRDb250ZW50cyAobm9kZSwgY29udGVudHMpe1xuXG4gICAgICBmb3IgKHZhciBmb2xkZXIgaW4gbm9kZS5jaGlsZHJlbil7XG4gICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmhhc093blByb3BlcnR5KGZvbGRlcikpe1xuICAgICAgICAgIHZhciBmb2xkZXJPYmplY3QgPSB7XG4gICAgICAgICAgICB0eXBlIDogJ2ZvbGRlcicsXG4gICAgICAgICAgICBuYW1lIDogbm9kZS5jaGlsZHJlbltmb2xkZXJdLm5hbWUsXG4gICAgICAgICAgICBwYXRoIDogbm9kZS5jaGlsZHJlbltmb2xkZXJdLnJlbFBhdGgsXG4gICAgICAgICAgICBjb250ZW50cyA6IFtdXG4gICAgICAgICAgfSBcbiAgICAgICAgICBjb250ZW50cy5wdXNoKGZvbGRlck9iamVjdCk7XG4gICAgICAgICAgZ2V0Q29udGVudHMobm9kZS5jaGlsZHJlbltmb2xkZXJdLCBmb2xkZXJPYmplY3QuY29udGVudHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5lbnRpdGllcy5sZW5ndGg7IGkrKyl7XG5cbiAgICAgICAgY29udGVudHMucHVzaCh7XG4gICAgICAgICAgdHlwZSA6ICdmaWxlJyxcbiAgICAgICAgICBuYW1lIDogbm9kZS5lbnRpdGllc1tpXS5uYW1lLFxuICAgICAgICAgIHBhdGggOiBub2RlLmVudGl0aWVzW2ldLmhyZWYucmVwbGFjZSh2ZnNSb290LCAnJyksXG4gICAgICAgICAgbWltZSA6IG5vZGUuZW50aXRpZXNbaV0ubWltZSxcbiAgICAgICAgICBtdGltZSA6IG5vZGUuZW50aXRpZXNbaV0ubXRpbWUsXG4gICAgICAgICAgc2l6ZSA6IG5vZGUuZW50aXRpZXNbaV0uc2l6ZSxcbiAgICAgICAgICBwYXJlbnQgOiBub2RlLnJlbFBhdGhcbiAgICAgICAgfSk7XG5cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHZhciB0cmVlID0gW107XG5cbiAgICBnZXRDb250ZW50cyhkYXRhLCB0cmVlKTtcblxuICAgIGZuKHRyZWUpO1xuXG4gIH07XG5cbiAgLy8gaG93ZXZlciB3ZSdyZSBkb2luZyB0byBsb2FkIHRoZSBlbnRpcmUgZmlsZSBzeXN0ZW0gaW4gbm93LlxuXG4gIGZ1bmN0aW9uIGxvYWRGaWxlU3lzdGVtIChwYXRoTmFtZSwgZm4pe1xuXG4gICAgcmVxdWVzdChwYXRoTmFtZSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UsIGJvZHkpe1xuXG4gICAgICBpZiAoIWVycil7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpe1xuICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9kaXJlY3RvcnlDYWNoZVthY3RpdmVEaXJlY3RvcnldID0gYm9keTtcblxuICAgICAgICB1cGRhdGVGaWxlU3lzdGVtKHBhdGhOYW1lLCBib2R5KTtcbiAgXG4gICAgICAgIHZhciBwb2ludGVyID0gZ2V0RGlyZWN0b3J5UmVmZXJlbmNlKHBhdGhOYW1lKTtcblxuICAgICAgICB2YXIgZ2F0aGVyZXIgPSBuZXcgR2F0aGVyKCk7XG5cbiAgICAgICAgdmFyIGNoaWxkQ291bnQgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGNoaWxkIGluIHBvaW50ZXIuY2hpbGRyZW4pe1xuICAgICAgICAgIGlmIChwb2ludGVyLmNoaWxkcmVuLmhhc093blByb3BlcnR5KGNoaWxkKSl7XG4gICAgICAgICAgICBjaGlsZENvdW50ICsrO1xuICAgICAgICAgICAgZ2F0aGVyZXIudGFzaygoZnVuY3Rpb24gKGhyZWYpe1xuXG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZG9uZSwgZXJyb3Ipe1xuXG4gICAgICAgICAgICAgICAgbG9hZEZpbGVTeXN0ZW0oaHJlZiwgZnVuY3Rpb24gKGVycil7XG5cbiAgICAgICAgICAgICAgICAgIGlmICghZXJyKXtcblxuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG5cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoZXJyKTtcblxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgfSkocG9pbnRlci5jaGlsZHJlbltjaGlsZF0uaHJlZikpO1xuXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkQ291bnQgPiAwKXtcbiAgICAgICAgICBnYXRoZXJlci5ydW4oZnVuY3Rpb24gKGVycil7XG4gICAgICAgICAgICBpZiAoZXJyKXtcbiAgICAgICAgICAgICAgZm4oZXJyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZuKGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZuIChmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL3JlbmRlckN1cnJlbnREaXJlY3RvcnkocmVmZXJlbmNlKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm4gKGVycik7XG4gICAgICB9XG5cbiAgICB9KTtcbiAgfTtcblxuICBsb2FkRmlsZVN5c3RlbShkYXRhLmNoaWxkcmVuLnJvb3QuaHJlZiwgZnVuY3Rpb24gKGVycil7XG5cbiAgICBpZiAoIWVycil7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdSZW1vdGUgZmlsZSBzeXN0ZW0gc3luY2hyb25pc2VkJyk7XG5cbiAgICAgIGFwcC5lbWl0KCdzeW5jJywgZGF0YS5jaGlsZHJlbi5yb290LnJlbFBhdGgpO1xuXG4gICAgfSBlbHNlIHtcblxuICAgICAgYXBwLmVtaXQoJ3N5bmMtZXJyb3InLCAnVW5hYmxlIHRvIHN5bmNocm9uaXNlIHdpdGggcmVtb3RlIGZpbGUgc3lzdGVtJywgZXJyKTtcblxuICAgIH1cblxuICB9KTtcblxuICBmdW5jdGlvbiBnZXREaXJlY3RvcnlSZWZlcmVuY2UgKHBhdGhOYW1lKXtcbiAgICAgIC8vIHBvcCBvZmYgdGhlIGZpcnN0IGFuZCBsYXN0XG5cbiAgICBwYXRoTmFtZSA9IHBhdGhOYW1lLnJlcGxhY2UodmZzUm9vdCwgJycpO1xuXG4gICAgdmFyIHBhdGhDaHVua3MgPSBwYXRoTmFtZS5zcGxpdCgnLycpO1xuICAgIHZhciBwb2ludGVyID0gZGF0YTtcblxuICAgIHBhdGhDaHVua3Muc2hpZnQoKTsgXG4gICAgcGF0aENodW5rcy5wb3AoKTtcbiAgICBwYXRoQ2h1bmtzLnVuc2hpZnQoJ3Jvb3QnKTtcblxuICAgIHBhdGhDaHVua3MuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspe1xuICAgICAgaWYgKHBvaW50ZXIuY2hpbGRyZW5bY2h1bmtdKXtcbiAgICAgICAgcG9pbnRlci5jaGlsZHJlbltjaHVua10ucGFyZW50ID0gcG9pbnRlcjtcbiAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIuY2hpbGRyZW5bY2h1bmtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvbWcnKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBwb2ludGVyO1xuXG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGaWxlU3lzdGVtKHBhdGhOYW1lLCBlbnRpdGllcyl7XG5cbiAgICAvLyBPa2F5IHRoZSBvYmplY3RpdmUgaGVyZSBpcyB0byBnZXQgYWxsIHRoZSBjaGFuZ2VzLi4uXG5cbiAgICB2YXIgcG9pbnRlciA9IGdldERpcmVjdG9yeVJlZmVyZW5jZShwYXRoTmFtZSk7XG5cbiAgICB2YXIgY3VycmVudEVudGl0aWVzID0gcG9pbnRlci5lbnRpdGllcy5zcGxpY2UoMCwgcG9pbnRlci5lbnRpdGllcy5sZW5ndGgpO1xuXG4gICAgY3VycmVudEVudGl0aWVzLmZvckVhY2goZnVuY3Rpb24gKGVudGl0eSl7XG5cbiAgICAgIGRlbGV0ZSBlbnRpdHlMb29rdXBbZW50aXR5LnJlbFBhdGhdO1xuXG4gICAgfSk7XG5cbiAgICBlbnRpdGllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRpdHkpe1xuICAgICAgaWYgKGVudGl0eS5taW1lID09PSBcImlub2RlL2RpcmVjdG9yeVwiKXtcbiAgICAgICAgaWYgKCFwb2ludGVyLmNoaWxkcmVuW2VudGl0eS5uYW1lXSAmJiBlbnRpdHkubmFtZS5zdWJzdHIoMCwgMSkgIT09IFwiLlwiKXtcbiAgICAgICAgICBwb2ludGVyLmNoaWxkcmVuW2VudGl0eS5uYW1lXSA9IHtcbiAgICAgICAgICAgIG5hbWUgOiBlbnRpdHkubmFtZSxcbiAgICAgICAgICAgIGhyZWYgOiBlbnRpdHkuaHJlZixcbiAgICAgICAgICAgIHJlbFBhdGggOiBlbnRpdHkuaHJlZi5yZXBsYWNlKHZmc1Jvb3QsICcnKSxcbiAgICAgICAgICAgIGVudGl0aWVzIDogW10sXG4gICAgICAgICAgICBjaGlsZHJlbiA6IHt9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNyZWF0ZSBhIGxvb2t1cCBieSBwYXRoLi4uXG4gICAgICAgICAgZW50aXR5TG9va3VwW3BvaW50ZXIuY2hpbGRyZW5bZW50aXR5Lm5hbWVdLnJlbFBhdGhdID0gcG9pbnRlci5jaGlsZHJlbltlbnRpdHkubmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW50aXR5Lm5hbWUuc3Vic3RyKDAsMSkgIT09IFwiLlwiKSB7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgcmVscGF0aC4uXG4gICAgICAgIGVudGl0eS5yZWxQYXRoID0gZW50aXR5LmhyZWYucmVwbGFjZSh2ZnNSb290LCAnJyk7XG4gICAgICAgIGVudGl0eS5wYXJlbnQgPSBwYXRoTmFtZS5yZXBsYWNlKHZmc1Jvb3QsICcnKTtcbiAgICAgICAgLy8gY3JlYXRlIGEgbG9va3VwIGJ5IHJlbHBhdGguLiBcbiAgICAgICAgZW50aXR5TG9va3VwW2VudGl0eS5yZWxQYXRoXSA9IGVudGl0eTtcblxuICAgICAgICAvLyBhZGQgaXQgYXMgYW4gZW50aXR5XG4gICAgICAgIHBvaW50ZXIuZW50aXRpZXMucHVzaChlbnRpdHkpO1xuXG4gICAgICB9XG4gICAgICBcbiAgICB9KTtcblxuXG4gICAgLy8gY2hlY2sgZm9yIGFueSBmb2xkZXJzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuLlxuICAgIGZvciAodmFyIGNoaWxkIGluIHBvaW50ZXIuY2hpbGRyZW4pe1xuICAgICAgaWYgKHBvaW50ZXIuY2hpbGRyZW4uaGFzT3duUHJvcGVydHkoY2hpbGQpKXtcbiAgICAgICAgdmFyIGV4aXN0cyA9IGZhbHNlO1xuICAgICAgICBlbnRpdGllcy5mb3JFYWNoKGZ1bmN0aW9uIChlbnRpdHkpe1xuICAgICAgICAgIGlmIChlbnRpdHkubmFtZSA9PT0gY2hpbGQpe1xuICAgICAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWV4aXN0cyl7XG4gICAgICAgICAgZGVsZXRlIHBvaW50ZXIuY2hpbGRyZW5bY2hpbGRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZW50aXR5TG9va3VwWycvJ10gPSBkYXRhLmNoaWxkcmVuLnJvb3Q7XG4gIH1cblxuICByZXR1cm4gc3lzdGVtO1xuXG59XG5cblxuXG4vKlxuXG4gIC0gU3RhdHVzIG9uZTogTm90aGluZyBpcyBsb2FkZWQuXG4gIC0gU3RhdHVzIHR3bzogXG5cbiovIiwidmFyIFNvY2tzSlMgPSByZXF1aXJlKCcuL3NvY2tzLmpzJyk7XG52YXIgY29uc29sZSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvY29uc29sZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcHAsIHNvY2tSb290KXtcblxuICB2YXIgc29ja2V0ID0gbmV3IFNvY2tzSlMoc29ja1Jvb3QpO1xuXG4gIHNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbiAoKXtcbiAgICBjb25zb2xlLmxvZygnUmVtb3RlIGZpbGUgc2VydmVyIGlzIG9ubGluZS4nKTtcbiAgfVxuICBzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpe1xuXG4gICAgdmFyIG1zZyA9IEpTT04ucGFyc2UoZS5kYXRhKTtcblxuICAgIGZvciAodmFyIGkgaW4gbXNnKXtcbiAgICAgIGlmIChtc2cuaGFzT3duUHJvcGVydHkoaSkpIGFwcC5lbWl0KGksIG1zZ1tpXSk7XG4gICAgfVxuXG4gIH1cblxuICBhcHAucmVtb3RlU2VuZCA9IGZ1bmN0aW9uIChzaWduYWwsIG1zZyl7XG5cbiAgICB2YXIgbyA9IHt9O1xuICAgIG9bc2lnbmFsXSA9IG1zZztcblxuICAgIHNvY2tldC5zZW5kKEpTT04uc3RyaW5naWZ5KG8pKTtcblxuICB9O1xuXG59IiwiLyogU29ja0pTIGNsaWVudCwgdmVyc2lvbiAwLjMuNCwgaHR0cDovL3NvY2tqcy5vcmcsIE1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG4qL1xuXG4vLyAgICAgWypdIEluY2x1ZGluZyBsaWIvaW5kZXguanNcbi8vIFB1YmxpYyBvYmplY3RcblNvY2tKUyA9IChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICB2YXIgX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgICAgICAgIHZhciBfd2luZG93ID0gd2luZG93O1xuICAgICAgICAgICAgICB2YXIgdXRpbHMgPSB7fTtcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3JldmVudHRhcmdldC5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxuLyogU2ltcGxpZmllZCBpbXBsZW1lbnRhdGlvbiBvZiBET00yIEV2ZW50VGFyZ2V0LlxuICogICBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1FdmVudHMvZXZlbnRzLmh0bWwjRXZlbnRzLUV2ZW50VGFyZ2V0XG4gKi9cbnZhciBSRXZlbnRUYXJnZXQgPSBmdW5jdGlvbigpIHt9O1xuUkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZighdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICB9XG4gICAgaWYoIShldmVudFR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IFtdO1xuICAgIH1cbiAgICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gICAgaWYodXRpbHMuYXJySW5kZXhPZihhcnIsIGxpc3RlbmVyKSA9PT0gLTEpIHtcbiAgICAgICAgYXJyLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICByZXR1cm47XG59O1xuXG5SRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgIGlmKCEodGhpcy5fbGlzdGVuZXJzICYmIChldmVudFR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gICAgdmFyIGlkeCA9IHV0aWxzLmFyckluZGV4T2YoYXJyLCBsaXN0ZW5lcik7XG4gICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgaWYoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyLnNsaWNlKDAsIGlkeCkuY29uY2F0KCBhcnIuc2xpY2UoaWR4KzEpICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm47XG59O1xuXG5SRXZlbnRUYXJnZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgdCA9IGV2ZW50LnR5cGU7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgIGlmICh0aGlzWydvbicrdF0pIHtcbiAgICAgICAgdGhpc1snb24nK3RdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzICYmIHQgaW4gdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIDwgdGhpcy5fbGlzdGVuZXJzW3RdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbdF1baV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi9yZXZlbnR0YXJnZXQuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3NpbXBsZWV2ZW50LmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgU2ltcGxlRXZlbnQgPSBmdW5jdGlvbih0eXBlLCBvYmopIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIGlmICh0eXBlb2Ygb2JqICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBmb3IodmFyIGsgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrKSkgY29udGludWU7XG4gICAgICAgICAgICB0aGlzW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuU2ltcGxlRXZlbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSBbXTtcbiAgICBmb3IodmFyIGsgaW4gdGhpcykge1xuICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoaykpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgdiA9IHRoaXNba107XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJykgdiA9ICdbZnVuY3Rpb25dJztcbiAgICAgICAgci5wdXNoKGsgKyAnPScgKyB2KTtcbiAgICB9XG4gICAgcmV0dXJuICdTaW1wbGVFdmVudCgnICsgci5qb2luKCcsICcpICsgJyknO1xufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvc2ltcGxlZXZlbnQuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL2V2ZW50ZW1pdHRlci5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIEV2ZW50RW1pdHRlciA9IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0Ll9ldmVudHMgPSBldmVudHMgfHwgW107XG4gICAgdGhhdC5fbGlzdGVuZXJzID0ge307XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0Ll92ZXJpZnlUeXBlKHR5cGUpO1xuICAgIGlmICh0aGF0Ll9udWtlZCkgcmV0dXJuO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGlmICh0aGF0WydvbicrdHlwZV0pIHtcbiAgICAgICAgdGhhdFsnb24nK3R5cGVdLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgIH1cbiAgICBpZiAodHlwZSBpbiB0aGF0Ll9saXN0ZW5lcnMpIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoYXQuX2xpc3RlbmVyc1t0eXBlXS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhhdC5fbGlzdGVuZXJzW3R5cGVdW2ldLmFwcGx5KHRoYXQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQuX3ZlcmlmeVR5cGUodHlwZSk7XG4gICAgaWYgKHRoYXQuX251a2VkKSByZXR1cm47XG5cbiAgICBpZiAoISh0eXBlIGluIHRoYXQuX2xpc3RlbmVycykpIHtcbiAgICAgICAgdGhhdC5fbGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgfVxuICAgIHRoYXQuX2xpc3RlbmVyc1t0eXBlXS5wdXNoKGNhbGxiYWNrKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX3ZlcmlmeVR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh1dGlscy5hcnJJbmRleE9mKHRoYXQuX2V2ZW50cywgdHlwZSkgPT09IC0xKSB7XG4gICAgICAgIHV0aWxzLmxvZygnRXZlbnQgJyArIEpTT04uc3RyaW5naWZ5KHR5cGUpICtcbiAgICAgICAgICAgICAgICAgICcgbm90IGxpc3RlZCAnICsgSlNPTi5zdHJpbmdpZnkodGhhdC5fZXZlbnRzKSArXG4gICAgICAgICAgICAgICAgICAnIGluICcgKyB0aGF0KTtcbiAgICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm51a2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5fbnVrZWQgPSB0cnVlO1xuICAgIGZvcih2YXIgaT0wOyBpPHRoYXQuX2V2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWxldGUgdGhhdFt0aGF0Ll9ldmVudHNbaV1dO1xuICAgIH1cbiAgICB0aGF0Ll9saXN0ZW5lcnMgPSB7fTtcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL2V2ZW50ZW1pdHRlci5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdXRpbHMuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciByYW5kb21fc3RyaW5nX2NoYXJzID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OV8nO1xudXRpbHMucmFuZG9tX3N0cmluZyA9IGZ1bmN0aW9uKGxlbmd0aCwgbWF4KSB7XG4gICAgbWF4ID0gbWF4IHx8IHJhbmRvbV9zdHJpbmdfY2hhcnMubGVuZ3RoO1xuICAgIHZhciBpLCByZXQgPSBbXTtcbiAgICBmb3IoaT0wOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmV0LnB1c2goIHJhbmRvbV9zdHJpbmdfY2hhcnMuc3Vic3RyKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCksMSkgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbn07XG51dGlscy5yYW5kb21fbnVtYmVyID0gZnVuY3Rpb24obWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XG59O1xudXRpbHMucmFuZG9tX251bWJlcl9zdHJpbmcgPSBmdW5jdGlvbihtYXgpIHtcbiAgICB2YXIgdCA9ICgnJysobWF4IC0gMSkpLmxlbmd0aDtcbiAgICB2YXIgcCA9IEFycmF5KHQrMSkuam9pbignMCcpO1xuICAgIHJldHVybiAocCArIHV0aWxzLnJhbmRvbV9udW1iZXIobWF4KSkuc2xpY2UoLXQpO1xufTtcblxuLy8gQXNzdW1pbmcgdGhhdCB1cmwgbG9va3MgbGlrZTogaHR0cDovL2FzZGFzZDoxMTEvYXNkXG51dGlscy5nZXRPcmlnaW4gPSBmdW5jdGlvbih1cmwpIHtcbiAgICB1cmwgKz0gJy8nO1xuICAgIHZhciBwYXJ0cyA9IHVybC5zcGxpdCgnLycpLnNsaWNlKDAsIDMpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCcvJyk7XG59O1xuXG51dGlscy5pc1NhbWVPcmlnaW5VcmwgPSBmdW5jdGlvbih1cmxfYSwgdXJsX2IpIHtcbiAgICAvLyBsb2NhdGlvbi5vcmlnaW4gd291bGQgZG8sIGJ1dCBpdCdzIG5vdCBhbHdheXMgYXZhaWxhYmxlLlxuICAgIGlmICghdXJsX2IpIHVybF9iID0gX3dpbmRvdy5sb2NhdGlvbi5ocmVmO1xuXG4gICAgcmV0dXJuICh1cmxfYS5zcGxpdCgnLycpLnNsaWNlKDAsMykuam9pbignLycpXG4gICAgICAgICAgICAgICAgPT09XG4gICAgICAgICAgICB1cmxfYi5zcGxpdCgnLycpLnNsaWNlKDAsMykuam9pbignLycpKTtcbn07XG5cbnV0aWxzLmdldFBhcmVudERvbWFpbiA9IGZ1bmN0aW9uKHVybCkge1xuICAgIC8vIGlwdjQgaXAgYWRkcmVzc1xuICAgIGlmICgvXlswLTkuXSokLy50ZXN0KHVybCkpIHJldHVybiB1cmw7XG4gICAgLy8gaXB2NiBpcCBhZGRyZXNzXG4gICAgaWYgKC9eXFxbLy50ZXN0KHVybCkpIHJldHVybiB1cmw7XG4gICAgLy8gbm8gZG90c1xuICAgIGlmICghKC9bLl0vLnRlc3QodXJsKSkpIHJldHVybiB1cmw7XG5cbiAgICB2YXIgcGFydHMgPSB1cmwuc3BsaXQoJy4nKS5zbGljZSgxKTtcbiAgICByZXR1cm4gcGFydHMuam9pbignLicpO1xufTtcblxudXRpbHMub2JqZWN0RXh0ZW5kID0gZnVuY3Rpb24oZHN0LCBzcmMpIHtcbiAgICBmb3IodmFyIGsgaW4gc3JjKSB7XG4gICAgICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgIGRzdFtrXSA9IHNyY1trXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZHN0O1xufTtcblxudmFyIFdQcmVmaXggPSAnX2pwJztcblxudXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghKFdQcmVmaXggaW4gX3dpbmRvdykpIHtcbiAgICAgICAgX3dpbmRvd1tXUHJlZml4XSA9IHt9O1xuICAgIH1cbn07XG5cbnV0aWxzLmNsb3NlRnJhbWUgPSBmdW5jdGlvbiAoY29kZSwgcmVhc29uKSB7XG4gICAgcmV0dXJuICdjJytKU09OLnN0cmluZ2lmeShbY29kZSwgcmVhc29uXSk7XG59O1xuXG51dGlscy51c2VyU2V0Q29kZSA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09IDEwMDAgfHwgKGNvZGUgPj0gMzAwMCAmJiBjb2RlIDw9IDQ5OTkpO1xufTtcblxuLy8gU2VlOiBodHRwOi8vd3d3LmVyZy5hYmRuLmFjLnVrL35nZXJyaXQvZGNjcC9ub3Rlcy9jY2lkMi9ydG9fZXN0aW1hdG9yL1xuLy8gYW5kIFJGQyAyOTg4LlxudXRpbHMuY291bnRSVE8gPSBmdW5jdGlvbiAocnR0KSB7XG4gICAgdmFyIHJ0bztcbiAgICBpZiAocnR0ID4gMTAwKSB7XG4gICAgICAgIHJ0byA9IDMgKiBydHQ7IC8vIHJ0byA+IDMwMG1zZWNcbiAgICB9IGVsc2Uge1xuICAgICAgICBydG8gPSBydHQgKyAyMDA7IC8vIDIwMG1zZWMgPCBydG8gPD0gMzAwbXNlY1xuICAgIH1cbiAgICByZXR1cm4gcnRvO1xufVxuXG51dGlscy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoX3dpbmRvdy5jb25zb2xlICYmIGNvbnNvbGUubG9nICYmIGNvbnNvbGUubG9nLmFwcGx5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgfVxufTtcblxudXRpbHMuYmluZCA9IGZ1bmN0aW9uKGZ1biwgdGhhdCkge1xuICAgIGlmIChmdW4uYmluZCkge1xuICAgICAgICByZXR1cm4gZnVuLmJpbmQodGhhdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbn07XG5cbnV0aWxzLmZsYXRVcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICByZXR1cm4gdXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgJiYgdXJsLmluZGV4T2YoJyMnKSA9PT0gLTE7XG59O1xuXG51dGlscy5hbWVuZFVybCA9IGZ1bmN0aW9uKHVybCkge1xuICAgIHZhciBkbCA9IF9kb2N1bWVudC5sb2NhdGlvbjtcbiAgICBpZiAoIXVybCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIHVybCBmb3IgU29ja0pTJyk7XG4gICAgfVxuICAgIGlmICghdXRpbHMuZmxhdFVybCh1cmwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBiYXNpYyB1cmxzIGFyZSBzdXBwb3J0ZWQgaW4gU29ja0pTJyk7XG4gICAgfVxuXG4gICAgLy8gICcvL2FiYycgLS0+ICdodHRwOi8vYWJjJ1xuICAgIGlmICh1cmwuaW5kZXhPZignLy8nKSA9PT0gMCkge1xuICAgICAgICB1cmwgPSBkbC5wcm90b2NvbCArIHVybDtcbiAgICB9XG4gICAgLy8gJy9hYmMnIC0tPiAnaHR0cDovL2xvY2FsaG9zdDo4MC9hYmMnXG4gICAgaWYgKHVybC5pbmRleE9mKCcvJykgPT09IDApIHtcbiAgICAgICAgdXJsID0gZGwucHJvdG9jb2wgKyAnLy8nICsgZGwuaG9zdCArIHVybDtcbiAgICB9XG4gICAgLy8gc3RyaXAgdHJhaWxpbmcgc2xhc2hlc1xuICAgIHVybCA9IHVybC5yZXBsYWNlKC9bL10rJC8sJycpO1xuICAgIHJldHVybiB1cmw7XG59O1xuXG4vLyBJRSBkb2Vzbid0IHN1cHBvcnQgW10uaW5kZXhPZi5cbnV0aWxzLmFyckluZGV4T2YgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gICAgZm9yKHZhciBpPTA7IGkgPCBhcnIubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZihhcnJbaV0gPT09IG9iail7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59O1xuXG51dGlscy5hcnJTa2lwID0gZnVuY3Rpb24oYXJyLCBvYmopIHtcbiAgICB2YXIgaWR4ID0gdXRpbHMuYXJySW5kZXhPZihhcnIsIG9iaik7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGFyci5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkc3QgPSBhcnIuc2xpY2UoMCwgaWR4KTtcbiAgICAgICAgcmV0dXJuIGRzdC5jb25jYXQoYXJyLnNsaWNlKGlkeCsxKSk7XG4gICAgfVxufTtcblxuLy8gVmlhOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS8xMTMzMTIyLzIxMjFjNjAxYzU1NDkxNTU0ODNmNTBiZTNkYTUzMDVlODNiOGM1ZGZcbnV0aWxzLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwodmFsdWUpLmluZGV4T2YoJ0FycmF5JykgPj0gMFxufTtcblxudXRpbHMuZGVsYXkgPSBmdW5jdGlvbih0LCBmdW4pIHtcbiAgICBpZih0eXBlb2YgdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmdW4gPSB0O1xuICAgICAgICB0ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCB0KTtcbn07XG5cblxuLy8gQ2hhcnMgd29ydGggZXNjYXBpbmcsIGFzIGRlZmluZWQgYnkgRG91Z2xhcyBDcm9ja2ZvcmQ6XG4vLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3VnbGFzY3JvY2tmb3JkL0pTT04tanMvYmxvYi80N2E5ODgyY2RkZWIxZTg1MjllMDdhZjk3MzYyMTgwNzUzNzJiOGFjL2pzb24yLmpzI0wxOTZcbnZhciBqc29uX2VzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAganNvbl9sb29rdXAgPSB7XG5cIlxcdTAwMDBcIjpcIlxcXFx1MDAwMFwiLFwiXFx1MDAwMVwiOlwiXFxcXHUwMDAxXCIsXCJcXHUwMDAyXCI6XCJcXFxcdTAwMDJcIixcIlxcdTAwMDNcIjpcIlxcXFx1MDAwM1wiLFxuXCJcXHUwMDA0XCI6XCJcXFxcdTAwMDRcIixcIlxcdTAwMDVcIjpcIlxcXFx1MDAwNVwiLFwiXFx1MDAwNlwiOlwiXFxcXHUwMDA2XCIsXCJcXHUwMDA3XCI6XCJcXFxcdTAwMDdcIixcblwiXFxiXCI6XCJcXFxcYlwiLFwiXFx0XCI6XCJcXFxcdFwiLFwiXFxuXCI6XCJcXFxcblwiLFwiXFx1MDAwYlwiOlwiXFxcXHUwMDBiXCIsXCJcXGZcIjpcIlxcXFxmXCIsXCJcXHJcIjpcIlxcXFxyXCIsXG5cIlxcdTAwMGVcIjpcIlxcXFx1MDAwZVwiLFwiXFx1MDAwZlwiOlwiXFxcXHUwMDBmXCIsXCJcXHUwMDEwXCI6XCJcXFxcdTAwMTBcIixcIlxcdTAwMTFcIjpcIlxcXFx1MDAxMVwiLFxuXCJcXHUwMDEyXCI6XCJcXFxcdTAwMTJcIixcIlxcdTAwMTNcIjpcIlxcXFx1MDAxM1wiLFwiXFx1MDAxNFwiOlwiXFxcXHUwMDE0XCIsXCJcXHUwMDE1XCI6XCJcXFxcdTAwMTVcIixcblwiXFx1MDAxNlwiOlwiXFxcXHUwMDE2XCIsXCJcXHUwMDE3XCI6XCJcXFxcdTAwMTdcIixcIlxcdTAwMThcIjpcIlxcXFx1MDAxOFwiLFwiXFx1MDAxOVwiOlwiXFxcXHUwMDE5XCIsXG5cIlxcdTAwMWFcIjpcIlxcXFx1MDAxYVwiLFwiXFx1MDAxYlwiOlwiXFxcXHUwMDFiXCIsXCJcXHUwMDFjXCI6XCJcXFxcdTAwMWNcIixcIlxcdTAwMWRcIjpcIlxcXFx1MDAxZFwiLFxuXCJcXHUwMDFlXCI6XCJcXFxcdTAwMWVcIixcIlxcdTAwMWZcIjpcIlxcXFx1MDAxZlwiLFwiXFxcIlwiOlwiXFxcXFxcXCJcIixcIlxcXFxcIjpcIlxcXFxcXFxcXCIsXG5cIlxcdTAwN2ZcIjpcIlxcXFx1MDA3ZlwiLFwiXFx1MDA4MFwiOlwiXFxcXHUwMDgwXCIsXCJcXHUwMDgxXCI6XCJcXFxcdTAwODFcIixcIlxcdTAwODJcIjpcIlxcXFx1MDA4MlwiLFxuXCJcXHUwMDgzXCI6XCJcXFxcdTAwODNcIixcIlxcdTAwODRcIjpcIlxcXFx1MDA4NFwiLFwiXFx1MDA4NVwiOlwiXFxcXHUwMDg1XCIsXCJcXHUwMDg2XCI6XCJcXFxcdTAwODZcIixcblwiXFx1MDA4N1wiOlwiXFxcXHUwMDg3XCIsXCJcXHUwMDg4XCI6XCJcXFxcdTAwODhcIixcIlxcdTAwODlcIjpcIlxcXFx1MDA4OVwiLFwiXFx1MDA4YVwiOlwiXFxcXHUwMDhhXCIsXG5cIlxcdTAwOGJcIjpcIlxcXFx1MDA4YlwiLFwiXFx1MDA4Y1wiOlwiXFxcXHUwMDhjXCIsXCJcXHUwMDhkXCI6XCJcXFxcdTAwOGRcIixcIlxcdTAwOGVcIjpcIlxcXFx1MDA4ZVwiLFxuXCJcXHUwMDhmXCI6XCJcXFxcdTAwOGZcIixcIlxcdTAwOTBcIjpcIlxcXFx1MDA5MFwiLFwiXFx1MDA5MVwiOlwiXFxcXHUwMDkxXCIsXCJcXHUwMDkyXCI6XCJcXFxcdTAwOTJcIixcblwiXFx1MDA5M1wiOlwiXFxcXHUwMDkzXCIsXCJcXHUwMDk0XCI6XCJcXFxcdTAwOTRcIixcIlxcdTAwOTVcIjpcIlxcXFx1MDA5NVwiLFwiXFx1MDA5NlwiOlwiXFxcXHUwMDk2XCIsXG5cIlxcdTAwOTdcIjpcIlxcXFx1MDA5N1wiLFwiXFx1MDA5OFwiOlwiXFxcXHUwMDk4XCIsXCJcXHUwMDk5XCI6XCJcXFxcdTAwOTlcIixcIlxcdTAwOWFcIjpcIlxcXFx1MDA5YVwiLFxuXCJcXHUwMDliXCI6XCJcXFxcdTAwOWJcIixcIlxcdTAwOWNcIjpcIlxcXFx1MDA5Y1wiLFwiXFx1MDA5ZFwiOlwiXFxcXHUwMDlkXCIsXCJcXHUwMDllXCI6XCJcXFxcdTAwOWVcIixcblwiXFx1MDA5ZlwiOlwiXFxcXHUwMDlmXCIsXCJcXHUwMGFkXCI6XCJcXFxcdTAwYWRcIixcIlxcdTA2MDBcIjpcIlxcXFx1MDYwMFwiLFwiXFx1MDYwMVwiOlwiXFxcXHUwNjAxXCIsXG5cIlxcdTA2MDJcIjpcIlxcXFx1MDYwMlwiLFwiXFx1MDYwM1wiOlwiXFxcXHUwNjAzXCIsXCJcXHUwNjA0XCI6XCJcXFxcdTA2MDRcIixcIlxcdTA3MGZcIjpcIlxcXFx1MDcwZlwiLFxuXCJcXHUxN2I0XCI6XCJcXFxcdTE3YjRcIixcIlxcdTE3YjVcIjpcIlxcXFx1MTdiNVwiLFwiXFx1MjAwY1wiOlwiXFxcXHUyMDBjXCIsXCJcXHUyMDBkXCI6XCJcXFxcdTIwMGRcIixcblwiXFx1MjAwZVwiOlwiXFxcXHUyMDBlXCIsXCJcXHUyMDBmXCI6XCJcXFxcdTIwMGZcIixcIlxcdTIwMjhcIjpcIlxcXFx1MjAyOFwiLFwiXFx1MjAyOVwiOlwiXFxcXHUyMDI5XCIsXG5cIlxcdTIwMmFcIjpcIlxcXFx1MjAyYVwiLFwiXFx1MjAyYlwiOlwiXFxcXHUyMDJiXCIsXCJcXHUyMDJjXCI6XCJcXFxcdTIwMmNcIixcIlxcdTIwMmRcIjpcIlxcXFx1MjAyZFwiLFxuXCJcXHUyMDJlXCI6XCJcXFxcdTIwMmVcIixcIlxcdTIwMmZcIjpcIlxcXFx1MjAyZlwiLFwiXFx1MjA2MFwiOlwiXFxcXHUyMDYwXCIsXCJcXHUyMDYxXCI6XCJcXFxcdTIwNjFcIixcblwiXFx1MjA2MlwiOlwiXFxcXHUyMDYyXCIsXCJcXHUyMDYzXCI6XCJcXFxcdTIwNjNcIixcIlxcdTIwNjRcIjpcIlxcXFx1MjA2NFwiLFwiXFx1MjA2NVwiOlwiXFxcXHUyMDY1XCIsXG5cIlxcdTIwNjZcIjpcIlxcXFx1MjA2NlwiLFwiXFx1MjA2N1wiOlwiXFxcXHUyMDY3XCIsXCJcXHUyMDY4XCI6XCJcXFxcdTIwNjhcIixcIlxcdTIwNjlcIjpcIlxcXFx1MjA2OVwiLFxuXCJcXHUyMDZhXCI6XCJcXFxcdTIwNmFcIixcIlxcdTIwNmJcIjpcIlxcXFx1MjA2YlwiLFwiXFx1MjA2Y1wiOlwiXFxcXHUyMDZjXCIsXCJcXHUyMDZkXCI6XCJcXFxcdTIwNmRcIixcblwiXFx1MjA2ZVwiOlwiXFxcXHUyMDZlXCIsXCJcXHUyMDZmXCI6XCJcXFxcdTIwNmZcIixcIlxcdWZlZmZcIjpcIlxcXFx1ZmVmZlwiLFwiXFx1ZmZmMFwiOlwiXFxcXHVmZmYwXCIsXG5cIlxcdWZmZjFcIjpcIlxcXFx1ZmZmMVwiLFwiXFx1ZmZmMlwiOlwiXFxcXHVmZmYyXCIsXCJcXHVmZmYzXCI6XCJcXFxcdWZmZjNcIixcIlxcdWZmZjRcIjpcIlxcXFx1ZmZmNFwiLFxuXCJcXHVmZmY1XCI6XCJcXFxcdWZmZjVcIixcIlxcdWZmZjZcIjpcIlxcXFx1ZmZmNlwiLFwiXFx1ZmZmN1wiOlwiXFxcXHVmZmY3XCIsXCJcXHVmZmY4XCI6XCJcXFxcdWZmZjhcIixcblwiXFx1ZmZmOVwiOlwiXFxcXHVmZmY5XCIsXCJcXHVmZmZhXCI6XCJcXFxcdWZmZmFcIixcIlxcdWZmZmJcIjpcIlxcXFx1ZmZmYlwiLFwiXFx1ZmZmY1wiOlwiXFxcXHVmZmZjXCIsXG5cIlxcdWZmZmRcIjpcIlxcXFx1ZmZmZFwiLFwiXFx1ZmZmZVwiOlwiXFxcXHVmZmZlXCIsXCJcXHVmZmZmXCI6XCJcXFxcdWZmZmZcIn07XG5cbi8vIFNvbWUgZXh0cmEgY2hhcmFjdGVycyB0aGF0IENocm9tZSBnZXRzIHdyb25nLCBhbmQgc3Vic3RpdHV0ZXMgd2l0aFxuLy8gc29tZXRoaW5nIGVsc2Ugb24gdGhlIHdpcmUuXG52YXIgZXh0cmFfZXNjYXBhYmxlID0gL1tcXHgwMC1cXHgxZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXFx1MDMwMC1cXHUwMzMzXFx1MDMzZC1cXHUwMzQ2XFx1MDM0YS1cXHUwMzRjXFx1MDM1MC1cXHUwMzUyXFx1MDM1Ny1cXHUwMzU4XFx1MDM1Yy1cXHUwMzYyXFx1MDM3NFxcdTAzN2VcXHUwMzg3XFx1MDU5MS1cXHUwNWFmXFx1MDVjNFxcdTA2MTAtXFx1MDYxN1xcdTA2NTMtXFx1MDY1NFxcdTA2NTctXFx1MDY1YlxcdTA2NWQtXFx1MDY1ZVxcdTA2ZGYtXFx1MDZlMlxcdTA2ZWItXFx1MDZlY1xcdTA3MzBcXHUwNzMyLVxcdTA3MzNcXHUwNzM1LVxcdTA3MzZcXHUwNzNhXFx1MDczZFxcdTA3M2YtXFx1MDc0MVxcdTA3NDNcXHUwNzQ1XFx1MDc0N1xcdTA3ZWItXFx1MDdmMVxcdTA5NTFcXHUwOTU4LVxcdTA5NWZcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmXFx1MGEzM1xcdTBhMzZcXHUwYTU5LVxcdTBhNWJcXHUwYTVlXFx1MGI1Yy1cXHUwYjVkXFx1MGUzOC1cXHUwZTM5XFx1MGY0M1xcdTBmNGRcXHUwZjUyXFx1MGY1N1xcdTBmNWNcXHUwZjY5XFx1MGY3Mi1cXHUwZjc2XFx1MGY3OFxcdTBmODAtXFx1MGY4M1xcdTBmOTNcXHUwZjlkXFx1MGZhMlxcdTBmYTdcXHUwZmFjXFx1MGZiOVxcdTE5MzktXFx1MTkzYVxcdTFhMTdcXHUxYjZiXFx1MWNkYS1cXHUxY2RiXFx1MWRjMC1cXHUxZGNmXFx1MWRmY1xcdTFkZmVcXHUxZjcxXFx1MWY3M1xcdTFmNzVcXHUxZjc3XFx1MWY3OVxcdTFmN2JcXHUxZjdkXFx1MWZiYlxcdTFmYmVcXHUxZmM5XFx1MWZjYlxcdTFmZDNcXHUxZmRiXFx1MWZlM1xcdTFmZWJcXHUxZmVlLVxcdTFmZWZcXHUxZmY5XFx1MWZmYlxcdTFmZmRcXHUyMDAwLVxcdTIwMDFcXHUyMGQwLVxcdTIwZDFcXHUyMGQ0LVxcdTIwZDdcXHUyMGU3LVxcdTIwZTlcXHUyMTI2XFx1MjEyYS1cXHUyMTJiXFx1MjMyOS1cXHUyMzJhXFx1MmFkY1xcdTMwMmItXFx1MzAyY1xcdWFhYjItXFx1YWFiM1xcdWY5MDAtXFx1ZmEwZFxcdWZhMTBcXHVmYTEyXFx1ZmExNS1cXHVmYTFlXFx1ZmEyMFxcdWZhMjJcXHVmYTI1LVxcdWZhMjZcXHVmYTJhLVxcdWZhMmRcXHVmYTMwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjFkXFx1ZmIxZlxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiNGVcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZXh0cmFfbG9va3VwO1xuXG4vLyBKU09OIFF1b3RlIHN0cmluZy4gVXNlIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbiB3aGVuIHBvc3NpYmxlLlxudmFyIEpTT05RdW90ZSA9IChKU09OICYmIEpTT04uc3RyaW5naWZ5KSB8fCBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBqc29uX2VzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIGlmIChqc29uX2VzY2FwYWJsZS50ZXN0KHN0cmluZykpIHtcbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UoanNvbl9lc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgICAgIHJldHVybiBqc29uX2xvb2t1cFthXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAnXCInICsgc3RyaW5nICsgJ1wiJztcbn07XG5cbi8vIFRoaXMgbWF5IGJlIHF1aXRlIHNsb3csIHNvIGxldCdzIGRlbGF5IHVudGlsIHVzZXIgYWN0dWFsbHkgdXNlcyBiYWRcbi8vIGNoYXJhY3RlcnMuXG52YXIgdW5yb2xsX2xvb2t1cCA9IGZ1bmN0aW9uKGVzY2FwYWJsZSkge1xuICAgIHZhciBpO1xuICAgIHZhciB1bnJvbGxlZCA9IHt9XG4gICAgdmFyIGMgPSBbXVxuICAgIGZvcihpPTA7IGk8NjU1MzY7IGkrKykge1xuICAgICAgICBjLnB1c2goIFN0cmluZy5mcm9tQ2hhckNvZGUoaSkgKTtcbiAgICB9XG4gICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgYy5qb2luKCcnKS5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdW5yb2xsZWRbIGEgXSA9ICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSk7XG4gICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIHVucm9sbGVkO1xufTtcblxuLy8gUXVvdGUgc3RyaW5nLCBhbHNvIHRha2luZyBjYXJlIG9mIHVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IGJyb3dzZXJzXG4vLyBvZnRlbiBicmVhay4gRXNwZWNpYWxseSwgdGFrZSBjYXJlIG9mIHVuaWNvZGUgc3Vycm9nYXRlczpcbi8vICAgIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwcGluZ19vZl9Vbmljb2RlX2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xudXRpbHMucXVvdGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgcXVvdGVkID0gSlNPTlF1b3RlKHN0cmluZyk7XG5cbiAgICAvLyBJbiBtb3N0IGNhc2VzIHRoaXMgc2hvdWxkIGJlIHZlcnkgZmFzdCBhbmQgZ29vZCBlbm91Z2guXG4gICAgZXh0cmFfZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgaWYoIWV4dHJhX2VzY2FwYWJsZS50ZXN0KHF1b3RlZCkpIHtcbiAgICAgICAgcmV0dXJuIHF1b3RlZDtcbiAgICB9XG5cbiAgICBpZighZXh0cmFfbG9va3VwKSBleHRyYV9sb29rdXAgPSB1bnJvbGxfbG9va3VwKGV4dHJhX2VzY2FwYWJsZSk7XG5cbiAgICByZXR1cm4gcXVvdGVkLnJlcGxhY2UoZXh0cmFfZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBleHRyYV9sb29rdXBbYV07XG4gICAgfSk7XG59XG5cbnZhciBfYWxsX3Byb3RvY29scyA9IFsnd2Vic29ja2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAneGRyLXN0cmVhbWluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ3hoci1zdHJlYW1pbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdpZnJhbWUtZXZlbnRzb3VyY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICdpZnJhbWUtaHRtbGZpbGUnLFxuICAgICAgICAgICAgICAgICAgICAgICd4ZHItcG9sbGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ3hoci1wb2xsaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLXhoci1wb2xsaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAnanNvbnAtcG9sbGluZyddO1xuXG51dGlscy5wcm9iZVByb3RvY29scyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcm9iZWQgPSB7fTtcbiAgICBmb3IodmFyIGk9MDsgaTxfYWxsX3Byb3RvY29scy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvdG9jb2wgPSBfYWxsX3Byb3RvY29sc1tpXTtcbiAgICAgICAgLy8gVXNlciBjYW4gaGF2ZSBhIHR5cG8gaW4gcHJvdG9jb2wgbmFtZS5cbiAgICAgICAgcHJvYmVkW3Byb3RvY29sXSA9IFNvY2tKU1twcm90b2NvbF0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFNvY2tKU1twcm90b2NvbF0uZW5hYmxlZCgpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvYmVkO1xufTtcblxudXRpbHMuZGV0ZWN0UHJvdG9jb2xzID0gZnVuY3Rpb24ocHJvYmVkLCBwcm90b2NvbHNfd2hpdGVsaXN0LCBpbmZvKSB7XG4gICAgdmFyIHBlID0ge30sXG4gICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgIGlmICghcHJvdG9jb2xzX3doaXRlbGlzdCkgcHJvdG9jb2xzX3doaXRlbGlzdCA9IF9hbGxfcHJvdG9jb2xzO1xuICAgIGZvcih2YXIgaT0wOyBpPHByb3RvY29sc193aGl0ZWxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3RvY29sID0gcHJvdG9jb2xzX3doaXRlbGlzdFtpXTtcbiAgICAgICAgcGVbcHJvdG9jb2xdID0gcHJvYmVkW3Byb3RvY29sXTtcbiAgICB9XG4gICAgdmFyIG1heWJlX3B1c2ggPSBmdW5jdGlvbihwcm90b3MpIHtcbiAgICAgICAgdmFyIHByb3RvID0gcHJvdG9zLnNoaWZ0KCk7XG4gICAgICAgIGlmIChwZVtwcm90b10pIHtcbiAgICAgICAgICAgIHByb3RvY29scy5wdXNoKHByb3RvKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwcm90b3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1heWJlX3B1c2gocHJvdG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIDEuIFdlYnNvY2tldFxuICAgIGlmIChpbmZvLndlYnNvY2tldCAhPT0gZmFsc2UpIHtcbiAgICAgICAgbWF5YmVfcHVzaChbJ3dlYnNvY2tldCddKTtcbiAgICB9XG5cbiAgICAvLyAyLiBTdHJlYW1pbmdcbiAgICBpZiAocGVbJ3hoci1zdHJlYW1pbmcnXSAmJiAhaW5mby5udWxsX29yaWdpbikge1xuICAgICAgICBwcm90b2NvbHMucHVzaCgneGhyLXN0cmVhbWluZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwZVsneGRyLXN0cmVhbWluZyddICYmICFpbmZvLmNvb2tpZV9uZWVkZWQgJiYgIWluZm8ubnVsbF9vcmlnaW4pIHtcbiAgICAgICAgICAgIHByb3RvY29scy5wdXNoKCd4ZHItc3RyZWFtaW5nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXliZV9wdXNoKFsnaWZyYW1lLWV2ZW50c291cmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZnJhbWUtaHRtbGZpbGUnXSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBQb2xsaW5nXG4gICAgaWYgKHBlWyd4aHItcG9sbGluZyddICYmICFpbmZvLm51bGxfb3JpZ2luKSB7XG4gICAgICAgIHByb3RvY29scy5wdXNoKCd4aHItcG9sbGluZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwZVsneGRyLXBvbGxpbmcnXSAmJiAhaW5mby5jb29raWVfbmVlZGVkICYmICFpbmZvLm51bGxfb3JpZ2luKSB7XG4gICAgICAgICAgICBwcm90b2NvbHMucHVzaCgneGRyLXBvbGxpbmcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1heWJlX3B1c2goWydpZnJhbWUteGhyLXBvbGxpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2pzb25wLXBvbGxpbmcnXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3RvY29scztcbn1cbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdXRpbHMuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL2RvbS5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxuLy8gTWF5IGJlIHVzZWQgYnkgaHRtbGZpbGUganNvbnAgYW5kIHRyYW5zcG9ydHMuXG52YXIgTVByZWZpeCA9ICdfc29ja2pzX2dsb2JhbCc7XG51dGlscy5jcmVhdGVIb29rID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHdpbmRvd19pZCA9ICdhJyArIHV0aWxzLnJhbmRvbV9zdHJpbmcoOCk7XG4gICAgaWYgKCEoTVByZWZpeCBpbiBfd2luZG93KSkge1xuICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgIF93aW5kb3dbTVByZWZpeF0gPSBmdW5jdGlvbih3aW5kb3dfaWQpIHtcbiAgICAgICAgICAgIGlmICghKHdpbmRvd19pZCBpbiBtYXApKSB7XG4gICAgICAgICAgICAgICAgbWFwW3dpbmRvd19pZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB3aW5kb3dfaWQsXG4gICAgICAgICAgICAgICAgICAgIGRlbDogZnVuY3Rpb24oKSB7ZGVsZXRlIG1hcFt3aW5kb3dfaWRdO31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcFt3aW5kb3dfaWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfd2luZG93W01QcmVmaXhdKHdpbmRvd19pZCk7XG59O1xuXG5cblxudXRpbHMuYXR0YWNoTWVzc2FnZSA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgdXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG59O1xudXRpbHMuYXR0YWNoRXZlbnQgPSBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIF93aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgX3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElFIHF1aXJrcy5cbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvOiBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG4gICAgICAgIC8vIHRoZSBtZXNzYWdlIGdldHMgZGVsaXZlcmVkIG9ubHkgdG8gJ2RvY3VtZW50Jywgbm90ICd3aW5kb3cnLlxuICAgICAgICBfZG9jdW1lbnQuYXR0YWNoRXZlbnQoXCJvblwiICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgLy8gSSBnZXQgJ3dpbmRvdycgZm9yIGllOC5cbiAgICAgICAgX3dpbmRvdy5hdHRhY2hFdmVudChcIm9uXCIgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbn07XG5cbnV0aWxzLmRldGFjaE1lc3NhZ2UgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIHV0aWxzLmRldGFjaEV2ZW50KCdtZXNzYWdlJywgbGlzdGVuZXIpO1xufTtcbnV0aWxzLmRldGFjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBfd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF93aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBfZG9jdW1lbnQuZGV0YWNoRXZlbnQoXCJvblwiICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgX3dpbmRvdy5kZXRhY2hFdmVudChcIm9uXCIgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbn07XG5cblxudmFyIG9uX3VubG9hZCA9IHt9O1xuLy8gVGhpbmdzIHJlZ2lzdGVyZWQgYWZ0ZXIgYmVmb3JldW5sb2FkIGFyZSB0byBiZSBjYWxsZWQgaW1tZWRpYXRlbHkuXG52YXIgYWZ0ZXJfdW5sb2FkID0gZmFsc2U7XG5cbnZhciB0cmlnZ2VyX3VubG9hZF9jYWxsYmFja3MgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IodmFyIHJlZiBpbiBvbl91bmxvYWQpIHtcbiAgICAgICAgb25fdW5sb2FkW3JlZl0oKTtcbiAgICAgICAgZGVsZXRlIG9uX3VubG9hZFtyZWZdO1xuICAgIH07XG59O1xuXG52YXIgdW5sb2FkX3RyaWdnZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmKGFmdGVyX3VubG9hZCkgcmV0dXJuO1xuICAgIGFmdGVyX3VubG9hZCA9IHRydWU7XG4gICAgdHJpZ2dlcl91bmxvYWRfY2FsbGJhY2tzKCk7XG59O1xuXG4vLyAndW5sb2FkJyBhbG9uZSBpcyBub3QgcmVsaWFibGUgaW4gb3BlcmEgd2l0aGluIGFuIGlmcmFtZSwgYnV0IHdlXG4vLyBjYW4ndCB1c2UgYGJlZm9yZXVubG9hZGAgYXMgSUUgZmlyZXMgaXQgb24gamF2YXNjcmlwdDogbGlua3MuXG51dGlscy5hdHRhY2hFdmVudCgndW5sb2FkJywgdW5sb2FkX3RyaWdnZXJlZCk7XG5cbnV0aWxzLnVubG9hZF9hZGQgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIHZhciByZWYgPSB1dGlscy5yYW5kb21fc3RyaW5nKDgpO1xuICAgIG9uX3VubG9hZFtyZWZdID0gbGlzdGVuZXI7XG4gICAgaWYgKGFmdGVyX3VubG9hZCkge1xuICAgICAgICB1dGlscy5kZWxheSh0cmlnZ2VyX3VubG9hZF9jYWxsYmFja3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufTtcbnV0aWxzLnVubG9hZF9kZWwgPSBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAocmVmIGluIG9uX3VubG9hZClcbiAgICAgICAgZGVsZXRlIG9uX3VubG9hZFtyZWZdO1xufTtcblxuXG51dGlscy5jcmVhdGVJZnJhbWUgPSBmdW5jdGlvbiAoaWZyYW1lX3VybCwgZXJyb3JfY2FsbGJhY2spIHtcbiAgICB2YXIgaWZyYW1lID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRfcmVmO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAgIC8vIEV4cGxvcmVyIGhhZCBwcm9ibGVtcyB3aXRoIHRoYXQuXG4gICAgICAgIHRyeSB7aWZyYW1lLm9ubG9hZCA9IG51bGw7fSBjYXRjaCAoeCkge31cbiAgICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgICAgIC8vIFRoaXMgdGltZW91dCBtYWtlcyBjaHJvbWUgZmlyZSBvbmJlZm9yZXVubG9hZCBldmVudFxuICAgICAgICAgICAgLy8gd2l0aGluIGlmcmFtZS4gV2l0aG91dCB0aGUgdGltZW91dCBpdCBnb2VzIHN0cmFpZ2h0IHRvXG4gICAgICAgICAgICAvLyBvbnVubG9hZC5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYoaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHV0aWxzLnVubG9hZF9kZWwodW5sb2FkX3JlZik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikge1xuICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBlcnJvcl9jYWxsYmFjayhyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHgpIHt9O1xuICAgIH07XG5cbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lX3VybDtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKXtvbmVycm9yKCdvbmVycm9yJyk7fTtcbiAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGBvbmxvYWRgIGlzIHRyaWdnZXJlZCBiZWZvcmUgc2NyaXB0cyBvbiB0aGUgaWZyYW1lIGFyZVxuICAgICAgICAvLyBleGVjdXRlZC4gR2l2ZSBpdCBmZXcgc2Vjb25kcyB0byBhY3R1YWxseSBsb2FkIHN0dWZmLlxuICAgICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b25lcnJvcignb25sb2FkIHRpbWVvdXQnKTt9LCAyMDAwKTtcbiAgICB9O1xuICAgIF9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtvbmVycm9yKCd0aW1lb3V0Jyk7fSwgMTUwMDApO1xuICAgIHVubG9hZF9yZWYgPSB1dGlscy51bmxvYWRfYWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvc3Q6IHBvc3QsXG4gICAgICAgIGNsZWFudXA6IGNsZWFudXAsXG4gICAgICAgIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xufTtcblxudXRpbHMuY3JlYXRlSHRtbGZpbGUgPSBmdW5jdGlvbiAoaWZyYW1lX3VybCwgZXJyb3JfY2FsbGJhY2spIHtcbiAgICB2YXIgZG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZF9yZWY7XG4gICAgdmFyIGlmcmFtZTtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgICAgIHV0aWxzLnVubG9hZF9kZWwodW5sb2FkX3JlZik7XG4gICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgaWZyYW1lID0gZG9jID0gbnVsbDtcbiAgICAgICAgICAgIENvbGxlY3RHYXJiYWdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikgIHtcbiAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgZXJyb3JfY2FsbGJhY2socik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICh4KSB7fTtcbiAgICB9O1xuXG4gICAgZG9jLm9wZW4oKTtcbiAgICBkb2Mud3JpdGUoJzxodG1sPjxzJyArICdjcmlwdD4nICtcbiAgICAgICAgICAgICAgJ2RvY3VtZW50LmRvbWFpbj1cIicgKyBkb2N1bWVudC5kb21haW4gKyAnXCI7JyArXG4gICAgICAgICAgICAgICc8L3MnICsgJ2NyaXB0PjwvaHRtbD4nKTtcbiAgICBkb2MuY2xvc2UoKTtcbiAgICBkb2MucGFyZW50V2luZG93W1dQcmVmaXhdID0gX3dpbmRvd1tXUHJlZml4XTtcbiAgICB2YXIgYyA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgICBpZnJhbWUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgYy5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVfdXJsO1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b25lcnJvcigndGltZW91dCcpO30sIDE1MDAwKTtcbiAgICB1bmxvYWRfcmVmID0gdXRpbHMudW5sb2FkX2FkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3N0OiBwb3N0LFxuICAgICAgICBjbGVhbnVwOiBjbGVhbnVwLFxuICAgICAgICBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL2RvbS5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvZG9tMi5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIEFic3RyYWN0WEhST2JqZWN0ID0gZnVuY3Rpb24oKXt9O1xuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcihbJ2NodW5rJywgJ2ZpbmlzaCddKTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhhdC54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9IGNhdGNoKHgpIHt9O1xuXG4gICAgaWYgKCF0aGF0Lnhocikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhhdC54aHIgPSBuZXcgX3dpbmRvdy5BY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgICAgICB9IGNhdGNoKHgpIHt9O1xuICAgIH1cbiAgICBpZiAoX3dpbmRvdy5BY3RpdmVYT2JqZWN0IHx8IF93aW5kb3cuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgLy8gSUU4IGNhY2hlcyBldmVuIFBPU1RzXG4gICAgICAgIHVybCArPSAoKHVybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyAndD0nKygrbmV3IERhdGUpO1xuICAgIH1cblxuICAgIC8vIEV4cGxvcmVyIHRlbmRzIHRvIGtlZXAgY29ubmVjdGlvbiBvcGVuLCBldmVuIGFmdGVyIHRoZVxuICAgIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxuICAgIHRoYXQudW5sb2FkX3JlZiA9IHV0aWxzLnVubG9hZF9hZGQoZnVuY3Rpb24oKXt0aGF0Ll9jbGVhbnVwKHRydWUpO30pO1xuICAgIHRyeSB7XG4gICAgICAgIHRoYXQueGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvLyBJRSByYWlzZXMgYW4gZXhjZXB0aW9uIG9uIHdyb25nIHBvcnQuXG4gICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgICAgICB0aGF0Ll9jbGVhbnVwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuXG4gICAgaWYgKCFvcHRzIHx8ICFvcHRzLm5vX2NyZWRlbnRpYWxzKSB7XG4gICAgICAgIC8vIE1vemlsbGEgZG9jcyBzYXlzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1hNTEh0dHBSZXF1ZXN0IDpcbiAgICAgICAgLy8gXCJUaGlzIG5ldmVyIGFmZmVjdHMgc2FtZS1zaXRlIHJlcXVlc3RzLlwiXG4gICAgICAgIHRoYXQueGhyLndpdGhDcmVkZW50aWFscyA9ICd0cnVlJztcbiAgICB9XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5oZWFkZXJzKSB7XG4gICAgICAgIGZvcih2YXIga2V5IGluIG9wdHMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhhdC54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdHMuaGVhZGVyc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoYXQueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhhdC54aHIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGhhdC54aHI7XG4gICAgICAgICAgICBzd2l0Y2ggKHgucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIC8vIElFIGRvZXNuJ3QgbGlrZSBwZWVraW5nIGludG8gcmVzcG9uc2VUZXh0IG9yIHN0YXR1c1xuICAgICAgICAgICAgICAgIC8vIG9uIE1pY3Jvc29mdC5YTUxIVFRQIGFuZCByZWFkeXN0YXRlPTNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0geC5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge307XG4gICAgICAgICAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSBzdGF0dXMgPSAyMDQ7XG5cbiAgICAgICAgICAgICAgICAvLyBJRSBkb2VzIHJldHVybiByZWFkeXN0YXRlID09IDMgZm9yIDQwNCBhbnN3ZXJzLlxuICAgICAgICAgICAgICAgIGlmICh0ZXh0ICYmIHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmVtaXQoJ2NodW5rJywgc3RhdHVzLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICAgICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykgc3RhdHVzID0gMjA0O1xuXG4gICAgICAgICAgICAgICAgdGhhdC5lbWl0KCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB0aGF0Ll9jbGVhbnVwKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhhdC54aHIuc2VuZChwYXlsb2FkKTtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICghdGhhdC54aHIpIHJldHVybjtcbiAgICB1dGlscy51bmxvYWRfZGVsKHRoYXQudW5sb2FkX3JlZik7XG5cbiAgICAvLyBJRSBuZWVkcyB0aGlzIGZpZWxkIHRvIGJlIGEgZnVuY3Rpb25cbiAgICB0aGF0Lnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe307XG5cbiAgICBpZiAoYWJvcnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoYXQueGhyLmFib3J0KCk7XG4gICAgICAgIH0gY2F0Y2goeCkge307XG4gICAgfVxuICAgIHRoYXQudW5sb2FkX3JlZiA9IHRoYXQueGhyID0gbnVsbDtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0Lm51a2UoKTtcbiAgICB0aGF0Ll9jbGVhbnVwKHRydWUpO1xufTtcblxudmFyIFhIUkNvcnNPYmplY3QgPSB1dGlscy5YSFJDb3JzT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgIHV0aWxzLmRlbGF5KGZ1bmN0aW9uKCl7dGhhdC5fc3RhcnQuYXBwbHkodGhhdCwgYXJncyk7fSk7XG59O1xuWEhSQ29yc09iamVjdC5wcm90b3R5cGUgPSBuZXcgQWJzdHJhY3RYSFJPYmplY3QoKTtcblxudmFyIFhIUkxvY2FsT2JqZWN0ID0gdXRpbHMuWEhSTG9jYWxPYmplY3QgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB1dGlscy5kZWxheShmdW5jdGlvbigpe1xuICAgICAgICB0aGF0Ll9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCwge1xuICAgICAgICAgICAgbm9fY3JlZGVudGlhbHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuWEhSTG9jYWxPYmplY3QucHJvdG90eXBlID0gbmV3IEFic3RyYWN0WEhST2JqZWN0KCk7XG5cblxuXG4vLyBSZWZlcmVuY2VzOlxuLy8gICBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvMTAwLWxpbmUtYWpheC13cmFwcGVyXG4vLyAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzI4ODA2MCh2PVZTLjg1KS5hc3B4XG52YXIgWERST2JqZWN0ID0gdXRpbHMuWERST2JqZWN0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdXRpbHMuZGVsYXkoZnVuY3Rpb24oKXt0aGF0Ll9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCk7fSk7XG59O1xuWERST2JqZWN0LnByb3RvdHlwZSA9IG5ldyBFdmVudEVtaXR0ZXIoWydjaHVuaycsICdmaW5pc2gnXSk7XG5YRFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciB4ZHIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAvLyBJRSBjYWNoZXMgZXZlbiBQT1NUc1xuICAgIHVybCArPSAoKHVybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyAndD0nKygrbmV3IERhdGUpO1xuXG4gICAgdmFyIG9uZXJyb3IgPSB4ZHIub250aW1lb3V0ID0geGRyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgICAgIHRoYXQuX2NsZWFudXAoZmFsc2UpO1xuICAgIH07XG4gICAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5lbWl0KCdjaHVuaycsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgfTtcbiAgICB4ZHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgdGhhdC5fY2xlYW51cChmYWxzZSk7XG4gICAgfTtcbiAgICB0aGF0LnhkciA9IHhkcjtcbiAgICB0aGF0LnVubG9hZF9yZWYgPSB1dGlscy51bmxvYWRfYWRkKGZ1bmN0aW9uKCl7dGhhdC5fY2xlYW51cCh0cnVlKTt9KTtcbiAgICB0cnkge1xuICAgICAgICAvLyBGYWlscyB3aXRoIEFjY2Vzc0RlbmllZCBpZiBwb3J0IG51bWJlciBpcyBib2d1c1xuICAgICAgICB0aGF0Lnhkci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICAgICAgdGhhdC54ZHIuc2VuZChwYXlsb2FkKTtcbiAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgb25lcnJvcigpO1xuICAgIH1cbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAoIXRoYXQueGRyKSByZXR1cm47XG4gICAgdXRpbHMudW5sb2FkX2RlbCh0aGF0LnVubG9hZF9yZWYpO1xuXG4gICAgdGhhdC54ZHIub250aW1lb3V0ID0gdGhhdC54ZHIub25lcnJvciA9IHRoYXQueGRyLm9ucHJvZ3Jlc3MgPVxuICAgICAgICB0aGF0Lnhkci5vbmxvYWQgPSBudWxsO1xuICAgIGlmIChhYm9ydCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhhdC54ZHIuYWJvcnQoKTtcbiAgICAgICAgfSBjYXRjaCh4KSB7fTtcbiAgICB9XG4gICAgdGhhdC51bmxvYWRfcmVmID0gdGhhdC54ZHIgPSBudWxsO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0Lm51a2UoKTtcbiAgICB0aGF0Ll9jbGVhbnVwKHRydWUpO1xufTtcblxuLy8gMS4gSXMgbmF0aXZlbHkgdmlhIFhIUlxuLy8gMi4gSXMgbmF0aXZlbHkgdmlhIFhEUlxuLy8gMy4gTm9wZSwgYnV0IHBvc3RNZXNzYWdlIGlzIHRoZXJlIHNvIGl0IHNob3VsZCB3b3JrIHZpYSB0aGUgSWZyYW1lLlxuLy8gNC4gTm9wZSwgc29ycnkuXG51dGlscy5pc1hIUkNvcnNDYXBhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKF93aW5kb3cuWE1MSHR0cFJlcXVlc3QgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIC8vIFhEb21haW5SZXF1ZXN0IGRvZXNuJ3Qgd29yayBpZiBwYWdlIGlzIHNlcnZlZCBmcm9tIGZpbGU6Ly9cbiAgICBpZiAoX3dpbmRvdy5YRG9tYWluUmVxdWVzdCAmJiBfZG9jdW1lbnQuZG9tYWluKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBpZiAoSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgcmV0dXJuIDQ7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi9kb20yLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9zb2NranMuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBTb2NrSlMgPSBmdW5jdGlvbih1cmwsIGRlcF9wcm90b2NvbHNfd2hpdGVsaXN0LCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgPT09IF93aW5kb3cpIHtcbiAgICAgICAgLy8gbWFrZXMgYG5ld2Agb3B0aW9uYWxcbiAgICAgICAgcmV0dXJuIG5ldyBTb2NrSlModXJsLCBkZXBfcHJvdG9jb2xzX3doaXRlbGlzdCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIFxuICAgIHZhciB0aGF0ID0gdGhpcywgcHJvdG9jb2xzX3doaXRlbGlzdDtcbiAgICB0aGF0Ll9vcHRpb25zID0ge2RldmVsOiBmYWxzZSwgZGVidWc6IGZhbHNlLCBwcm90b2NvbHNfd2hpdGVsaXN0OiBbXSxcbiAgICAgICAgICAgICAgICAgICAgIGluZm86IHVuZGVmaW5lZCwgcnR0OiB1bmRlZmluZWR9O1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHV0aWxzLm9iamVjdEV4dGVuZCh0aGF0Ll9vcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhhdC5fYmFzZV91cmwgPSB1dGlscy5hbWVuZFVybCh1cmwpO1xuICAgIHRoYXQuX3NlcnZlciA9IHRoYXQuX29wdGlvbnMuc2VydmVyIHx8IHV0aWxzLnJhbmRvbV9udW1iZXJfc3RyaW5nKDEwMDApO1xuICAgIGlmICh0aGF0Ll9vcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QgJiZcbiAgICAgICAgdGhhdC5fb3B0aW9ucy5wcm90b2NvbHNfd2hpdGVsaXN0Lmxlbmd0aCkge1xuICAgICAgICBwcm90b2NvbHNfd2hpdGVsaXN0ID0gdGhhdC5fb3B0aW9ucy5wcm90b2NvbHNfd2hpdGVsaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERlcHJlY2F0ZWQgQVBJXG4gICAgICAgIGlmICh0eXBlb2YgZGVwX3Byb3RvY29sc193aGl0ZWxpc3QgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBkZXBfcHJvdG9jb2xzX3doaXRlbGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwcm90b2NvbHNfd2hpdGVsaXN0ID0gW2RlcF9wcm90b2NvbHNfd2hpdGVsaXN0XTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KGRlcF9wcm90b2NvbHNfd2hpdGVsaXN0KSkge1xuICAgICAgICAgICAgcHJvdG9jb2xzX3doaXRlbGlzdCA9IGRlcF9wcm90b2NvbHNfd2hpdGVsaXN0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm90b2NvbHNfd2hpdGVsaXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdG9jb2xzX3doaXRlbGlzdCkge1xuICAgICAgICAgICAgdGhhdC5fZGVidWcoJ0RlcHJlY2F0ZWQgQVBJOiBVc2UgXCJwcm90b2NvbHNfd2hpdGVsaXN0XCIgb3B0aW9uICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luc3RlYWQgb2Ygc3VwcGx5aW5nIHByb3RvY29sIGxpc3QgYXMgYSBzZWNvbmQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFyYW1ldGVyIHRvIFNvY2tKUyBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGF0Ll9wcm90b2NvbHMgPSBbXTtcbiAgICB0aGF0LnByb3RvY29sID0gbnVsbDtcbiAgICB0aGF0LnJlYWR5U3RhdGUgPSBTb2NrSlMuQ09OTkVDVElORztcbiAgICB0aGF0Ll9pciA9IGNyZWF0ZUluZm9SZWNlaXZlcih0aGF0Ll9iYXNlX3VybCk7XG4gICAgdGhhdC5faXIub25maW5pc2ggPSBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICAgICAgdGhhdC5faXIgPSBudWxsO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKHRoYXQuX29wdGlvbnMuaW5mbykge1xuICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlIGlmIHVzZXIgc3VwcGxpZXMgdGhlIG9wdGlvblxuICAgICAgICAgICAgICAgIGluZm8gPSB1dGlscy5vYmplY3RFeHRlbmQoaW5mbywgdGhhdC5fb3B0aW9ucy5pbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGF0Ll9vcHRpb25zLnJ0dCkge1xuICAgICAgICAgICAgICAgIHJ0dCA9IHRoYXQuX29wdGlvbnMucnR0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhhdC5fYXBwbHlJbmZvKGluZm8sIHJ0dCwgcHJvdG9jb2xzX3doaXRlbGlzdCk7XG4gICAgICAgICAgICB0aGF0Ll9kaWRDbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhhdC5fZGlkQ2xvc2UoMTAwMiwgJ0NhblxcJ3QgY29ubmVjdCB0byBzZXJ2ZXInLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLy8gSW5oZXJpdGFuY2VcblNvY2tKUy5wcm90b3R5cGUgPSBuZXcgUkV2ZW50VGFyZ2V0KCk7XG5cblNvY2tKUy52ZXJzaW9uID0gXCIwLjMuNFwiO1xuXG5Tb2NrSlMuQ09OTkVDVElORyA9IDA7XG5Tb2NrSlMuT1BFTiA9IDE7XG5Tb2NrSlMuQ0xPU0lORyA9IDI7XG5Tb2NrSlMuQ0xPU0VEID0gMztcblxuU29ja0pTLnByb3RvdHlwZS5fZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fb3B0aW9ucy5kZWJ1ZylcbiAgICAgICAgdXRpbHMubG9nLmFwcGx5KHV0aWxzLCBhcmd1bWVudHMpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fZGlzcGF0Y2hPcGVuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0LnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgICAgIGlmICh0aGF0Ll90cmFuc3BvcnRfdHJlZikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoYXQuX3RyYW5zcG9ydF90cmVmKTtcbiAgICAgICAgICAgIHRoYXQuX3RyYW5zcG9ydF90cmVmID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGF0LnJlYWR5U3RhdGUgPSBTb2NrSlMuT1BFTjtcbiAgICAgICAgdGhhdC5kaXNwYXRjaEV2ZW50KG5ldyBTaW1wbGVFdmVudChcIm9wZW5cIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBzZXJ2ZXIgbWlnaHQgaGF2ZSBiZWVuIHJlc3RhcnRlZCwgYW5kIGxvc3QgdHJhY2sgb2Ygb3VyXG4gICAgICAgIC8vIGNvbm5lY3Rpb24uXG4gICAgICAgIHRoYXQuX2RpZENsb3NlKDEwMDYsIFwiU2VydmVyIGxvc3Qgc2Vzc2lvblwiKTtcbiAgICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9kaXNwYXRjaE1lc3NhZ2UgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0LnJlYWR5U3RhdGUgIT09IFNvY2tKUy5PUEVOKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgIHRoYXQuZGlzcGF0Y2hFdmVudChuZXcgU2ltcGxlRXZlbnQoXCJtZXNzYWdlXCIsIHtkYXRhOiBkYXRhfSkpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fZGlzcGF0Y2hIZWFydGJlYXQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0LnJlYWR5U3RhdGUgIT09IFNvY2tKUy5PUEVOKVxuICAgICAgICByZXR1cm47XG4gICAgdGhhdC5kaXNwYXRjaEV2ZW50KG5ldyBTaW1wbGVFdmVudCgnaGVhcnRiZWF0Jywge30pKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2RpZENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uLCBmb3JjZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5yZWFkeVN0YXRlICE9PSBTb2NrSlMuQ09OTkVDVElORyAmJlxuICAgICAgICB0aGF0LnJlYWR5U3RhdGUgIT09IFNvY2tKUy5PUEVOICYmXG4gICAgICAgIHRoYXQucmVhZHlTdGF0ZSAhPT0gU29ja0pTLkNMT1NJTkcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lOVkFMSURfU1RBVEVfRVJSJyk7XG4gICAgaWYgKHRoYXQuX2lyKSB7XG4gICAgICAgIHRoYXQuX2lyLm51a2UoKTtcbiAgICAgICAgdGhhdC5faXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGF0Ll90cmFuc3BvcnQpIHtcbiAgICAgICAgdGhhdC5fdHJhbnNwb3J0LmRvQ2xlYW51cCgpO1xuICAgICAgICB0aGF0Ll90cmFuc3BvcnQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBjbG9zZV9ldmVudCA9IG5ldyBTaW1wbGVFdmVudChcImNsb3NlXCIsIHtcbiAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgIHdhc0NsZWFuOiB1dGlscy51c2VyU2V0Q29kZShjb2RlKX0pO1xuXG4gICAgaWYgKCF1dGlscy51c2VyU2V0Q29kZShjb2RlKSAmJlxuICAgICAgICB0aGF0LnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HICYmICFmb3JjZSkge1xuICAgICAgICBpZiAodGhhdC5fdHJ5X25leHRfcHJvdG9jb2woY2xvc2VfZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2VfZXZlbnQgPSBuZXcgU2ltcGxlRXZlbnQoXCJjbG9zZVwiLCB7Y29kZTogMjAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJBbGwgdHJhbnNwb3J0cyBmYWlsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhc0NsZWFuOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfZXZlbnQ6IGNsb3NlX2V2ZW50fSk7XG4gICAgfVxuICAgIHRoYXQucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TRUQ7XG5cbiAgICB1dGlscy5kZWxheShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQoY2xvc2VfZXZlbnQpO1xuICAgICAgICAgICAgICAgIH0pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fZGlkTWVzc2FnZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHR5cGUgPSBkYXRhLnNsaWNlKDAsIDEpO1xuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgY2FzZSAnbyc6XG4gICAgICAgIHRoYXQuX2Rpc3BhdGNoT3BlbigpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdhJzpcbiAgICAgICAgdmFyIHBheWxvYWQgPSBKU09OLnBhcnNlKGRhdGEuc2xpY2UoMSkgfHwgJ1tdJyk7XG4gICAgICAgIGZvcih2YXIgaT0wOyBpIDwgcGF5bG9hZC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB0aGF0Ll9kaXNwYXRjaE1lc3NhZ2UocGF5bG9hZFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbSc6XG4gICAgICAgIHZhciBwYXlsb2FkID0gSlNPTi5wYXJzZShkYXRhLnNsaWNlKDEpIHx8ICdudWxsJyk7XG4gICAgICAgIHRoYXQuX2Rpc3BhdGNoTWVzc2FnZShwYXlsb2FkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYyc6XG4gICAgICAgIHZhciBwYXlsb2FkID0gSlNPTi5wYXJzZShkYXRhLnNsaWNlKDEpIHx8ICdbXScpO1xuICAgICAgICB0aGF0Ll9kaWRDbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaCc6XG4gICAgICAgIHRoYXQuX2Rpc3BhdGNoSGVhcnRiZWF0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyeV9uZXh0X3Byb3RvY29sID0gZnVuY3Rpb24oY2xvc2VfZXZlbnQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQucHJvdG9jb2wpIHtcbiAgICAgICAgdGhhdC5fZGVidWcoJ0Nsb3NlZCB0cmFuc3BvcnQ6JywgdGhhdC5wcm90b2NvbCwgJycrY2xvc2VfZXZlbnQpO1xuICAgICAgICB0aGF0LnByb3RvY29sID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoYXQuX3RyYW5zcG9ydF90cmVmKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGF0Ll90cmFuc3BvcnRfdHJlZik7XG4gICAgICAgIHRoYXQuX3RyYW5zcG9ydF90cmVmID0gbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZSgxKSB7XG4gICAgICAgIHZhciBwcm90b2NvbCA9IHRoYXQucHJvdG9jb2wgPSB0aGF0Ll9wcm90b2NvbHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKCFwcm90b2NvbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNvbWUgcHJvdG9jb2xzIHJlcXVpcmUgYWNjZXNzIHRvIGBib2R5YCwgd2hhdCBpZiB3ZXJlIGluXG4gICAgICAgIC8vIHRoZSBgaGVhZGA/XG4gICAgICAgIGlmIChTb2NrSlNbcHJvdG9jb2xdICYmXG4gICAgICAgICAgICBTb2NrSlNbcHJvdG9jb2xdLm5lZWRfYm9keSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgKCFfZG9jdW1lbnQuYm9keSB8fFxuICAgICAgICAgICAgICh0eXBlb2YgX2RvY3VtZW50LnJlYWR5U3RhdGUgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICYmIF9kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSkpIHtcbiAgICAgICAgICAgIHRoYXQuX3Byb3RvY29scy51bnNoaWZ0KHByb3RvY29sKTtcbiAgICAgICAgICAgIHRoYXQucHJvdG9jb2wgPSAnd2FpdGluZy1mb3ItbG9hZCc7XG4gICAgICAgICAgICB1dGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdGhhdC5fdHJ5X25leHRfcHJvdG9jb2woKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIVNvY2tKU1twcm90b2NvbF0gfHxcbiAgICAgICAgICAgICAgIVNvY2tKU1twcm90b2NvbF0uZW5hYmxlZCh0aGF0Ll9vcHRpb25zKSkge1xuICAgICAgICAgICAgdGhhdC5fZGVidWcoJ1NraXBwaW5nIHRyYW5zcG9ydDonLCBwcm90b2NvbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcm91bmRUcmlwcyA9IFNvY2tKU1twcm90b2NvbF0ucm91bmRUcmlwcyB8fCAxO1xuICAgICAgICAgICAgdmFyIHRvID0gKCh0aGF0Ll9vcHRpb25zLnJ0byB8fCAwKSAqIHJvdW5kVHJpcHMpIHx8IDUwMDA7XG4gICAgICAgICAgICB0aGF0Ll90cmFuc3BvcnRfdHJlZiA9IHV0aWxzLmRlbGF5KHRvLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJIGNhbid0IHVuZGVyc3RhbmQgaG93IGl0IGlzIHBvc3NpYmxlIHRvIHJ1blxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHRpbWVyLCB3aGVuIHRoZSBzdGF0ZSBpcyBDTE9TRUQsIGJ1dFxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBhcmVudGx5IGluIElFIGV2ZXJ5dGhpbiBpcyBwb3NzaWJsZS5cbiAgICAgICAgICAgICAgICAgICAgdGhhdC5fZGlkQ2xvc2UoMjAwNywgXCJUcmFuc3BvcnQgdGltZW91dGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgY29ubmlkID0gdXRpbHMucmFuZG9tX3N0cmluZyg4KTtcbiAgICAgICAgICAgIHZhciB0cmFuc191cmwgPSB0aGF0Ll9iYXNlX3VybCArICcvJyArIHRoYXQuX3NlcnZlciArICcvJyArIGNvbm5pZDtcbiAgICAgICAgICAgIHRoYXQuX2RlYnVnKCdPcGVuaW5nIHRyYW5zcG9ydDonLCBwcm90b2NvbCwgJyB1cmw6Jyt0cmFuc191cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAnIFJUTzonK3RoYXQuX29wdGlvbnMucnRvKTtcbiAgICAgICAgICAgIHRoYXQuX3RyYW5zcG9ydCA9IG5ldyBTb2NrSlNbcHJvdG9jb2xdKHRoYXQsIHRyYW5zX3VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuX2Jhc2VfdXJsKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAoY29kZSAmJiAhdXRpbHMudXNlclNldENvZGUoY29kZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIklOVkFMSURfQUNDRVNTX0VSUlwiKTtcbiAgICBpZih0aGF0LnJlYWR5U3RhdGUgIT09IFNvY2tKUy5DT05ORUNUSU5HICYmXG4gICAgICAgdGhhdC5yZWFkeVN0YXRlICE9PSBTb2NrSlMuT1BFTikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoYXQucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TSU5HO1xuICAgIHRoYXQuX2RpZENsb3NlKGNvZGUgfHwgMTAwMCwgcmVhc29uIHx8IFwiTm9ybWFsIGNsb3N1cmVcIik7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0LnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lOVkFMSURfU1RBVEVfRVJSJyk7XG4gICAgaWYgKHRoYXQucmVhZHlTdGF0ZSA9PT0gU29ja0pTLk9QRU4pIHtcbiAgICAgICAgdGhhdC5fdHJhbnNwb3J0LmRvU2VuZCh1dGlscy5xdW90ZSgnJyArIGRhdGEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9hcHBseUluZm8gPSBmdW5jdGlvbihpbmZvLCBydHQsIHByb3RvY29sc193aGl0ZWxpc3QpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5fb3B0aW9ucy5pbmZvID0gaW5mbztcbiAgICB0aGF0Ll9vcHRpb25zLnJ0dCA9IHJ0dDtcbiAgICB0aGF0Ll9vcHRpb25zLnJ0byA9IHV0aWxzLmNvdW50UlRPKHJ0dCk7XG4gICAgdGhhdC5fb3B0aW9ucy5pbmZvLm51bGxfb3JpZ2luID0gIV9kb2N1bWVudC5kb21haW47XG4gICAgdmFyIHByb2JlZCA9IHV0aWxzLnByb2JlUHJvdG9jb2xzKCk7XG4gICAgdGhhdC5fcHJvdG9jb2xzID0gdXRpbHMuZGV0ZWN0UHJvdG9jb2xzKHByb2JlZCwgcHJvdG9jb2xzX3doaXRlbGlzdCwgaW5mbyk7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi9zb2NranMuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLXdlYnNvY2tldC5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIFdlYlNvY2tldFRyYW5zcG9ydCA9IFNvY2tKUy53ZWJzb2NrZXQgPSBmdW5jdGlvbihyaSwgdHJhbnNfdXJsKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciB1cmwgPSB0cmFuc191cmwgKyAnL3dlYnNvY2tldCc7XG4gICAgaWYgKHVybC5zbGljZSgwLCA1KSA9PT0gJ2h0dHBzJykge1xuICAgICAgICB1cmwgPSAnd3NzJyArIHVybC5zbGljZSg1KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB1cmwgPSAnd3MnICsgdXJsLnNsaWNlKDQpO1xuICAgIH1cbiAgICB0aGF0LnJpID0gcmk7XG4gICAgdGhhdC51cmwgPSB1cmw7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gX3dpbmRvdy5XZWJTb2NrZXQgfHwgX3dpbmRvdy5Nb3pXZWJTb2NrZXQ7XG5cbiAgICB0aGF0LndzID0gbmV3IENvbnN0cnVjdG9yKHRoYXQudXJsKTtcbiAgICB0aGF0LndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhhdC5yaS5fZGlkTWVzc2FnZShlLmRhdGEpO1xuICAgIH07XG4gICAgLy8gRmlyZWZveCBoYXMgYW4gaW50ZXJlc3RpbmcgYnVnLiBJZiBhIHdlYnNvY2tldCBjb25uZWN0aW9uIGlzXG4gICAgLy8gY3JlYXRlZCBhZnRlciBvbnVubG9hZCwgaXQgc3RheXMgYWxpdmUgZXZlbiB3aGVuIHVzZXJcbiAgICAvLyBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlLiBJbiBzdWNoIHNpdHVhdGlvbiBsZXQncyBsaWUgLVxuICAgIC8vIGxldCdzIG5vdCBvcGVuIHRoZSB3cyBjb25uZWN0aW9uIGF0IGFsbC4gU2VlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NranMvc29ja2pzLWNsaWVudC9pc3N1ZXMvMjhcbiAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTYwODVcbiAgICB0aGF0LnVubG9hZF9yZWYgPSB1dGlscy51bmxvYWRfYWRkKGZ1bmN0aW9uKCl7dGhhdC53cy5jbG9zZSgpfSk7XG4gICAgdGhhdC53cy5vbmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQucmkuX2RpZE1lc3NhZ2UodXRpbHMuY2xvc2VGcmFtZSgxMDA2LCBcIldlYlNvY2tldCBjb25uZWN0aW9uIGJyb2tlblwiKSk7XG4gICAgfTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuZG9TZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHRoaXMud3Muc2VuZCgnWycgKyBkYXRhICsgJ10nKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuZG9DbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciB3cyA9IHRoYXQud3M7XG4gICAgaWYgKHdzKSB7XG4gICAgICAgIHdzLm9ubWVzc2FnZSA9IHdzLm9uY2xvc2UgPSBudWxsO1xuICAgICAgICB3cy5jbG9zZSgpO1xuICAgICAgICB1dGlscy51bmxvYWRfZGVsKHRoYXQudW5sb2FkX3JlZik7XG4gICAgICAgIHRoYXQudW5sb2FkX3JlZiA9IHRoYXQucmkgPSB0aGF0LndzID0gbnVsbDtcbiAgICB9XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIShfd2luZG93LldlYlNvY2tldCB8fCBfd2luZG93Lk1veldlYlNvY2tldCk7XG59O1xuXG4vLyBJbiB0aGVvcnksIHdzIHNob3VsZCByZXF1aXJlIDEgcm91bmQgdHJpcC4gQnV0IGluIGNocm9tZSwgdGhpcyBpc1xuLy8gbm90IHZlcnkgc3RhYmxlIG92ZXIgU1NMLiBNb3N0IGxpa2VseSBhIHdzIGNvbm5lY3Rpb24gcmVxdWlyZXMgYVxuLy8gc2VwYXJhdGUgU1NMIGNvbm5lY3Rpb24sIGluIHdoaWNoIGNhc2UgMiByb3VuZCB0cmlwcyBhcmUgYW5cbi8vIGFic29sdXRlIG1pbnVtdW0uXG5XZWJTb2NrZXRUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLXdlYnNvY2tldC5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtc2VuZGVyLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgQnVmZmVyZWRTZW5kZXIgPSBmdW5jdGlvbigpIHt9O1xuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRfY29uc3RydWN0b3IgPSBmdW5jdGlvbihzZW5kZXIpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5zZW5kX2J1ZmZlciA9IFtdO1xuICAgIHRoYXQuc2VuZGVyID0gc2VuZGVyO1xufTtcbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5kb1NlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQuc2VuZF9idWZmZXIucHVzaChtZXNzYWdlKTtcbiAgICBpZiAoIXRoYXQuc2VuZF9zdG9wKSB7XG4gICAgICAgIHRoYXQuc2VuZF9zY2hlZHVsZSgpO1xuICAgIH1cbn07XG5cbi8vIEZvciBwb2xsaW5nIHRyYW5zcG9ydHMgaW4gYSBzaXR1YXRpb24gd2hlbiBpbiB0aGUgbWVzc2FnZSBjYWxsYmFjayxcbi8vIG5ldyBtZXNzYWdlIGlzIGJlaW5nIHNlbmQuIElmIHRoZSBzZW5kaW5nIGNvbm5lY3Rpb24gd2FzIHN0YXJ0ZWRcbi8vIGJlZm9yZSByZWNlaXZpbmcgb25lLCBpdCBpcyBwb3NzaWJsZSB0byBzYXR1cmF0ZSB0aGUgbmV0d29yayBhbmRcbi8vIHRpbWVvdXQgZHVlIHRvIHRoZSBsYWNrIG9mIHJlY2VpdmluZyBzb2NrZXQuIFRvIGF2b2lkIHRoYXQgd2UgZGVsYXlcbi8vIHNlbmRpbmcgbWVzc2FnZXMgYnkgc29tZSBzbWFsbCB0aW1lLCBpbiBvcmRlciB0byBsZXQgcmVjZWl2aW5nXG4vLyBjb25uZWN0aW9uIGJlIHN0YXJ0ZWQgYmVmb3JlaGFuZC4gVGhpcyBpcyBvbmx5IGEgaGFsZm1lYXN1cmUgYW5kXG4vLyBkb2VzIG5vdCBmaXggdGhlIGJpZyBwcm9ibGVtLCBidXQgaXQgZG9lcyBtYWtlIHRoZSB0ZXN0cyBnbyBtb3JlXG4vLyBzdGFibGUgb24gc2xvdyBuZXR3b3Jrcy5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kX3NjaGVkdWxlX3dhaXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHRyZWY7XG4gICAgdGhhdC5zZW5kX3N0b3AgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5zZW5kX3N0b3AgPSBudWxsO1xuICAgICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgfTtcbiAgICB0cmVmID0gdXRpbHMuZGVsYXkoMjUsIGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0LnNlbmRfc3RvcCA9IG51bGw7XG4gICAgICAgIHRoYXQuc2VuZF9zY2hlZHVsZSgpO1xuICAgIH0pO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRfc2NoZWR1bGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQuc2VuZF9idWZmZXIubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgcGF5bG9hZCA9ICdbJyArIHRoYXQuc2VuZF9idWZmZXIuam9pbignLCcpICsgJ10nO1xuICAgICAgICB0aGF0LnNlbmRfc3RvcCA9IHRoYXQuc2VuZGVyKHRoYXQudHJhbnNfdXJsLCBwYXlsb2FkLCBmdW5jdGlvbihzdWNjZXNzLCBhYm9ydF9yZWFzb24pIHtcbiAgICAgICAgICAgIHRoYXQuc2VuZF9zdG9wID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRoYXQucmkuX2RpZENsb3NlKDEwMDYsICdTZW5kaW5nIGVycm9yICcgKyBhYm9ydF9yZWFzb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGF0LnNlbmRfc2NoZWR1bGVfd2FpdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhhdC5zZW5kX2J1ZmZlciA9IFtdO1xuICAgIH1cbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kX2Rlc3RydWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQuX3NlbmRfc3RvcCkge1xuICAgICAgICB0aGF0Ll9zZW5kX3N0b3AoKTtcbiAgICB9XG4gICAgdGhhdC5fc2VuZF9zdG9wID0gbnVsbDtcbn07XG5cbnZhciBqc29uUEdlbmVyaWNTZW5kZXIgPSBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgaWYgKCEoJ19zZW5kX2Zvcm0nIGluIHRoYXQpKSB7XG4gICAgICAgIHZhciBmb3JtID0gdGhhdC5fc2VuZF9mb3JtID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICAgICAgdmFyIGFyZWEgPSB0aGF0Ll9zZW5kX2FyZWEgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgICAgICBmb3JtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICAgICAgZm9ybS5lbmN0eXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICAgIGZvcm0uYWNjZXB0Q2hhcnNldCA9IFwiVVRGLThcIjtcbiAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICAgICAgX2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gICAgfVxuICAgIHZhciBmb3JtID0gdGhhdC5fc2VuZF9mb3JtO1xuICAgIHZhciBhcmVhID0gdGhhdC5fc2VuZF9hcmVhO1xuICAgIHZhciBpZCA9ICdhJyArIHV0aWxzLnJhbmRvbV9zdHJpbmcoOCk7XG4gICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICBmb3JtLmFjdGlvbiA9IHVybCArICcvanNvbnBfc2VuZD9pPScgKyBpZDtcblxuICAgIHZhciBpZnJhbWU7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICAgIGlmcmFtZSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8aWZyYW1lIG5hbWU9XCInKyBpZCArJ1wiPicpO1xuICAgIH0gY2F0Y2goeCkge1xuICAgICAgICBpZnJhbWUgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIGlmcmFtZS5uYW1lID0gaWQ7XG4gICAgfVxuICAgIGlmcmFtZS5pZCA9IGlkO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIHRyeSB7XG4gICAgICAgIGFyZWEudmFsdWUgPSBwYXlsb2FkO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICB1dGlscy5sb2coJ1lvdXIgYnJvd3NlciBpcyBzZXJpb3VzbHkgYnJva2VuLiBHbyBob21lISAnICsgZS5tZXNzYWdlKTtcbiAgICB9XG4gICAgZm9ybS5zdWJtaXQoKTtcblxuICAgIHZhciBjb21wbGV0ZWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghaWZyYW1lLm9uZXJyb3IpIHJldHVybjtcbiAgICAgICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmVycm9yID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgICAgIC8vIE9wZXJhIG1pbmkgZG9lc24ndCBsaWtlIGlmIHdlIEdDIGlmcmFtZVxuICAgICAgICAvLyBpbW1lZGlhdGVseSwgdGh1cyB0aGlzIHRpbWVvdXQuXG4gICAgICAgIHV0aWxzLmRlbGF5KDUwMCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIGFyZWEudmFsdWUgPSAnJztcbiAgICAgICAgLy8gSXQgaXMgbm90IHBvc3NpYmxlIHRvIGRldGVjdCBpZiB0aGUgaWZyYW1lIHN1Y2NlZWRlZCBvclxuICAgICAgICAvLyBmYWlsZWQgdG8gc3VibWl0IG91ciBmb3JtLlxuICAgICAgICBjYWxsYmFjayh0cnVlKTtcbiAgICB9O1xuICAgIGlmcmFtZS5vbmVycm9yID0gaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlZDtcbiAgICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoaWZyYW1lLnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJykgY29tcGxldGVkKCk7XG4gICAgfTtcbiAgICByZXR1cm4gY29tcGxldGVkO1xufTtcblxudmFyIGNyZWF0ZUFqYXhTZW5kZXIgPSBmdW5jdGlvbihBamF4T2JqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCB1cmwgKyAnL3hocl9zZW5kJywgcGF5bG9hZCk7XG4gICAgICAgIHhvLm9uZmluaXNoID0gZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwNCxcbiAgICAgICAgICAgICAgICAgICAgICdodHRwIHN0YXR1cyAnICsgc3RhdHVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFib3J0X3JlYXNvbikge1xuICAgICAgICAgICAgY2FsbGJhY2soZmFsc2UsIGFib3J0X3JlYXNvbik7XG4gICAgICAgIH07XG4gICAgfTtcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLXNlbmRlci5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtanNvbnAtcmVjZWl2ZXIuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIFBhcnRzIGRlcml2ZWQgZnJvbSBTb2NrZXQuaW86XG4vLyAgICBodHRwczovL2dpdGh1Yi5jb20vTGVhcm5Cb29zdC9zb2NrZXQuaW8vYmxvYi8wLjYuMTcvbGliL3NvY2tldC5pby90cmFuc3BvcnRzL2pzb25wLXBvbGxpbmcuanNcbi8vIGFuZCBqUXVlcnktSlNPTlA6XG4vLyAgICBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2pxdWVyeS1qc29ucC9zb3VyY2UvYnJvd3NlL3RydW5rL2NvcmUvanF1ZXJ5Lmpzb25wLmpzXG52YXIganNvblBHZW5lcmljUmVjZWl2ZXIgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRyZWY7XG4gICAgdmFyIHNjcmlwdCA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICB2YXIgc2NyaXB0MjsgIC8vIE9wZXJhIHN5bmNocm9ub3VzIGxvYWQgdHJpY2suXG4gICAgdmFyIGNsb3NlX3NjcmlwdCA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICAgIGlmIChzY3JpcHQyKSB7XG4gICAgICAgICAgICBzY3JpcHQyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0Mik7XG4gICAgICAgICAgICBzY3JpcHQyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAgICAgICAvLyBVbmZvcnR1bmF0ZWx5LCB5b3UgY2FuJ3QgcmVhbGx5IGFib3J0IHNjcmlwdCBsb2FkaW5nIG9mXG4gICAgICAgICAgICAvLyB0aGUgc2NyaXB0LlxuICAgICAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBzY3JpcHQub25lcnJvciA9XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbmNsaWNrID0gbnVsbDtcbiAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICBjYWxsYmFjayhmcmFtZSk7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gSUU5IGZpcmVzICdlcnJvcicgZXZlbnQgYWZ0ZXIgb3JzYyBvciBiZWZvcmUsIGluIHJhbmRvbSBvcmRlci5cbiAgICB2YXIgbG9hZGVkX29rYXkgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3JfdGltZXIgPSBudWxsO1xuXG4gICAgc2NyaXB0LmlkID0gJ2EnICsgdXRpbHMucmFuZG9tX3N0cmluZyg4KTtcbiAgICBzY3JpcHQuc3JjID0gdXJsO1xuICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgc2NyaXB0LmNoYXJzZXQgPSAnVVRGLTgnO1xuICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIWVycm9yX3RpbWVyKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBmaXJpbmcgY2xvc2Vfc2NyaXB0LlxuICAgICAgICAgICAgZXJyb3JfdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICghbG9hZGVkX29rYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2Vfc2NyaXB0KHV0aWxzLmNsb3NlRnJhbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAxMDA2LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9uZXJyb3IpXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY2xvc2Vfc2NyaXB0KHV0aWxzLmNsb3NlRnJhbWUoMTAwNiwgXCJKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ubG9hZClcIikpO1xuICAgIH07XG5cbiAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoL2xvYWRlZHxjbG9zZWQvLnRlc3Qoc2NyaXB0LnJlYWR5U3RhdGUpKSB7XG4gICAgICAgICAgICBpZiAoc2NyaXB0ICYmIHNjcmlwdC5odG1sRm9yICYmIHNjcmlwdC5vbmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgbG9hZGVkX29rYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluIElFLCBhY3R1YWxseSBleGVjdXRlIHRoZSBzY3JpcHQuXG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdC5vbmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgICAgICBjbG9zZV9zY3JpcHQodXRpbHMuY2xvc2VGcmFtZSgxMDA2LCBcIkpTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25yZWFkeXN0YXRlY2hhbmdlKVwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIElFOiBldmVudC9odG1sRm9yL29uY2xpY2sgdHJpY2suXG4gICAgLy8gT25lIGNhbid0IHJlbHkgb24gcHJvcGVyIG9yZGVyIGZvciBvbnJlYWR5c3RhdGVjaGFuZ2UuIEluIG9yZGVyIHRvXG4gICAgLy8gbWFrZSBzdXJlLCBzZXQgYSAnaHRtbEZvcicgYW5kICdldmVudCcgcHJvcGVydGllcywgc28gdGhhdFxuICAgIC8vIHNjcmlwdCBjb2RlIHdpbGwgYmUgaW5zdGFsbGVkIGFzICdvbmNsaWNrJyBoYW5kbGVyIGZvciB0aGVcbiAgICAvLyBzY3JpcHQgb2JqZWN0LiBMYXRlciwgb25yZWFkeXN0YXRlY2hhbmdlLCBtYW51YWxseSBleGVjdXRlIHRoaXNcbiAgICAvLyBjb2RlLiBGRiBhbmQgQ2hyb21lIGRvZXNuJ3Qgd29yayB3aXRoICdldmVudCcgYW5kICdodG1sRm9yJ1xuICAgIC8vIHNldC4gRm9yIHJlZmVyZW5jZSBzZWU6XG4gICAgLy8gICBodHRwOi8vamF1Ym91cmcubmV0LzIwMTAvMDcvbG9hZGluZy1zY3JpcHQtYXMtb25jbGljay1oYW5kbGVyLW9mLmh0bWxcbiAgICAvLyBBbHNvLCByZWFkIG9uIHRoYXQgYWJvdXQgc2NyaXB0IG9yZGVyaW5nOlxuICAgIC8vICAgaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0R5bmFtaWNfU2NyaXB0X0V4ZWN1dGlvbl9PcmRlclxuICAgIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jID09PSAndW5kZWZpbmVkJyAmJiBfZG9jdW1lbnQuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgLy8gQWNjb3JkaW5nIHRvIG1vemlsbGEgZG9jcywgaW4gcmVjZW50IGJyb3dzZXJzIHNjcmlwdC5hc3luYyBkZWZhdWx0c1xuICAgICAgICAvLyB0byAndHJ1ZScsIHNvIHdlIG1heSB1c2UgaXQgdG8gZGV0ZWN0IGEgZ29vZCBicm93c2VyOlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9IVE1ML0VsZW1lbnQvc2NyaXB0XG4gICAgICAgIGlmICghL29wZXJhL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgLy8gTmFpdmVseSBhc3N1bWUgd2UncmUgaW4gSUVcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQ7XG4gICAgICAgICAgICAgICAgc2NyaXB0LmV2ZW50ID0gXCJvbmNsaWNrXCI7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9wZXJhLCBzZWNvbmQgc3luYyBzY3JpcHQgaGFja1xuICAgICAgICAgICAgc2NyaXB0MiA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHNjcmlwdDIudGV4dCA9IFwidHJ5e3ZhciBhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1wiK3NjcmlwdC5pZCtcIicpOyBpZihhKWEub25lcnJvcigpO31jYXRjaCh4KXt9O1wiO1xuICAgICAgICAgICAgc2NyaXB0LmFzeW5jID0gc2NyaXB0Mi5hc3luYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIG1vc3RseSBmb3IgS29ucXVlcm9yIC0gc3R1cGlkIHRpbWVyLCAzNSBzZWNvbmRzIHNoYWxsIGJlIHBsZW50eS5cbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2Vfc2NyaXB0KHV0aWxzLmNsb3NlRnJhbWUoMTAwNiwgXCJKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKHRpbWVvdXQpXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9LCAzNTAwMCk7XG5cbiAgICB2YXIgaGVhZCA9IF9kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbiAgICBpZiAoc2NyaXB0Mikge1xuICAgICAgICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQyLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2Vfc2NyaXB0O1xufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtanNvbnAtcmVjZWl2ZXIuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLWpzb25wLXBvbGxpbmcuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIFRoZSBzaW1wbGVzdCBhbmQgbW9zdCByb2J1c3QgdHJhbnNwb3J0LCB1c2luZyB0aGUgd2VsbC1rbm93IGNyb3NzXG4vLyBkb21haW4gaGFjayAtIEpTT05QLiBUaGlzIHRyYW5zcG9ydCBpcyBxdWl0ZSBpbmVmZmljaWVudCAtIG9uZVxuLy8gbXNzYWdlIGNvdWxkIHVzZSB1cCB0byBvbmUgaHR0cCByZXF1ZXN0LiBCdXQgYXQgbGVhc3QgaXQgd29ya3MgYWxtb3N0XG4vLyBldmVyeXdoZXJlLlxuLy8gS25vd24gbGltaXRhdGlvbnM6XG4vLyAgIG8geW91IHdpbGwgZ2V0IGEgc3Bpbm5pbmcgY3Vyc29yXG4vLyAgIG8gZm9yIEtvbnF1ZXJvciBhIGR1bWIgdGltZXIgaXMgbmVlZGVkIHRvIGRldGVjdCBlcnJvcnNcblxuXG52YXIgSnNvblBUcmFuc3BvcnQgPSBTb2NrSlNbJ2pzb25wLXBvbGxpbmcnXSA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwpIHtcbiAgICB1dGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQucmkgPSByaTtcbiAgICB0aGF0LnRyYW5zX3VybCA9IHRyYW5zX3VybDtcbiAgICB0aGF0LnNlbmRfY29uc3RydWN0b3IoanNvblBHZW5lcmljU2VuZGVyKTtcbiAgICB0aGF0Ll9zY2hlZHVsZV9yZWN2KCk7XG59O1xuXG4vLyBJbmhlcml0bmFjZVxuSnNvblBUcmFuc3BvcnQucHJvdG90eXBlID0gbmV3IEJ1ZmZlcmVkU2VuZGVyKCk7XG5cbkpzb25QVHJhbnNwb3J0LnByb3RvdHlwZS5fc2NoZWR1bGVfcmVjdiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoYXQuX3JlY3Zfc3RvcCA9IG51bGw7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBubyBkYXRhIC0gaGVhcnRiZWF0O1xuICAgICAgICAgICAgaWYgKCF0aGF0Ll9pc19jbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5yaS5fZGlkTWVzc2FnZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgbWVzc2FnZSBjYW4gYmUgYSBjbG9zZSBtZXNzYWdlLCBhbmQgY2hhbmdlIGlzX2Nsb3Npbmcgc3RhdGUuXG4gICAgICAgIGlmICghdGhhdC5faXNfY2xvc2luZykge1xuICAgICAgICAgICAgdGhhdC5fc2NoZWR1bGVfcmVjdigpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGF0Ll9yZWN2X3N0b3AgPSBqc29uUFJlY2VpdmVyV3JhcHBlcih0aGF0LnRyYW5zX3VybCArICcvanNvbnAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb25QR2VuZXJpY1JlY2VpdmVyLCBjYWxsYmFjayk7XG59O1xuXG5Kc29uUFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5Kc29uUFRyYW5zcG9ydC5uZWVkX2JvZHkgPSB0cnVlO1xuXG5cbkpzb25QVHJhbnNwb3J0LnByb3RvdHlwZS5kb0NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5faXNfY2xvc2luZyA9IHRydWU7XG4gICAgaWYgKHRoYXQuX3JlY3Zfc3RvcCkge1xuICAgICAgICB0aGF0Ll9yZWN2X3N0b3AoKTtcbiAgICB9XG4gICAgdGhhdC5yaSA9IHRoYXQuX3JlY3Zfc3RvcCA9IG51bGw7XG4gICAgdGhhdC5zZW5kX2Rlc3RydWN0b3IoKTtcbn07XG5cblxuLy8gQWJzdHJhY3QgYXdheSBjb2RlIHRoYXQgaGFuZGxlcyBnbG9iYWwgbmFtZXNwYWNlIHBvbGx1dGlvbi5cbnZhciBqc29uUFJlY2VpdmVyV3JhcHBlciA9IGZ1bmN0aW9uKHVybCwgY29uc3RydWN0UmVjZWl2ZXIsIHVzZXJfY2FsbGJhY2spIHtcbiAgICB2YXIgaWQgPSAnYScgKyB1dGlscy5yYW5kb21fc3RyaW5nKDYpO1xuICAgIHZhciB1cmxfaWQgPSB1cmwgKyAnP2M9JyArIGVzY2FwZShXUHJlZml4ICsgJy4nICsgaWQpO1xuXG4gICAgLy8gVW5mb3J0dW5hdGVseSBpdCBpcyBub3QgcG9zc2libGUgdG8gYWJvcnQgbG9hZGluZyBvZiB0aGVcbiAgICAvLyBzY3JpcHQuIFdlIG5lZWQgdG8ga2VlcCB0cmFjayBvZiBmcmFrZSBjbG9zZSBmcmFtZXMuXG4gICAgdmFyIGFib3J0aW5nID0gMDtcblxuICAgIC8vIENhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGV4YWN0bHkgb25jZS5cbiAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbihmcmFtZSkge1xuICAgICAgICBzd2l0Y2goYWJvcnRpbmcpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgLy8gTm9ybWFsIGJlaGF2aW91ciAtIGRlbGV0ZSBob29rIF9hbmRfIGVtaXQgbWVzc2FnZS5cbiAgICAgICAgICAgIGRlbGV0ZSBfd2luZG93W1dQcmVmaXhdW2lkXTtcbiAgICAgICAgICAgIHVzZXJfY2FsbGJhY2soZnJhbWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIC8vIEZha2UgY2xvc2UgZnJhbWUgLSBlbWl0IGJ1dCBkb24ndCBkZWxldGUgaG9vay5cbiAgICAgICAgICAgIHVzZXJfY2FsbGJhY2soZnJhbWUpO1xuICAgICAgICAgICAgYWJvcnRpbmcgPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIC8vIEdvdCBmcmFtZSBhZnRlciBjb25uZWN0aW9uIHdhcyBjbG9zZWQsIGRlbGV0ZSBob29rLCBkb24ndCBlbWl0LlxuICAgICAgICAgICAgZGVsZXRlIF93aW5kb3dbV1ByZWZpeF1baWRdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNsb3NlX3NjcmlwdCA9IGNvbnN0cnVjdFJlY2VpdmVyKHVybF9pZCwgY2FsbGJhY2spO1xuICAgIF93aW5kb3dbV1ByZWZpeF1baWRdID0gY2xvc2Vfc2NyaXB0O1xuICAgIHZhciBzdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChfd2luZG93W1dQcmVmaXhdW2lkXSkge1xuICAgICAgICAgICAgYWJvcnRpbmcgPSAxO1xuICAgICAgICAgICAgX3dpbmRvd1tXUHJlZml4XVtpZF0odXRpbHMuY2xvc2VGcmFtZSgxMDAwLCBcIkpTT05QIHVzZXIgYWJvcnRlZCByZWFkXCIpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHN0b3A7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1qc29ucC1wb2xsaW5nLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy14aHIuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBBamF4QmFzZWRUcmFuc3BvcnQgPSBmdW5jdGlvbigpIHt9O1xuQWpheEJhc2VkVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBCdWZmZXJlZFNlbmRlcigpO1xuXG5BamF4QmFzZWRUcmFuc3BvcnQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybF9zdWZmaXgsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQucmkgPSByaTtcbiAgICB0aGF0LnRyYW5zX3VybCA9IHRyYW5zX3VybDtcbiAgICB0aGF0LnNlbmRfY29uc3RydWN0b3IoY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSk7XG4gICAgdGhhdC5wb2xsID0gbmV3IFBvbGxpbmcocmksIFJlY2VpdmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zX3VybCArIHVybF9zdWZmaXgsIEFqYXhPYmplY3QpO1xufTtcblxuQWpheEJhc2VkVHJhbnNwb3J0LnByb3RvdHlwZS5kb0NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQucG9sbCkge1xuICAgICAgICB0aGF0LnBvbGwuYWJvcnQoKTtcbiAgICAgICAgdGhhdC5wb2xsID0gbnVsbDtcbiAgICB9XG59O1xuXG4vLyB4aHItc3RyZWFtaW5nXG52YXIgWGhyU3RyZWFtaW5nVHJhbnNwb3J0ID0gU29ja0pTWyd4aHItc3RyZWFtaW5nJ10gPSBmdW5jdGlvbihyaSwgdHJhbnNfdXJsKSB7XG4gICAgdGhpcy5ydW4ocmksIHRyYW5zX3VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIHV0aWxzLlhIUkNvcnNPYmplY3QpO1xufTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBBamF4QmFzZWRUcmFuc3BvcnQoKTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBTdXBwb3J0IGZvciBDT1JTIEFqYXggYWthIEFqYXgyPyBPcGVyYSAxMiBjbGFpbXMgQ09SUyBidXRcbiAgICAvLyBkb2Vzbid0IGRvIHN0cmVhbWluZy5cbiAgICByZXR1cm4gKF93aW5kb3cuWE1MSHR0cFJlcXVlc3QgJiZcbiAgICAgICAgICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpICYmXG4gICAgICAgICAgICAoIS9vcGVyYS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpKTtcbn07XG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG4vLyBTYWZhcmkgZ2V0cyBjb25mdXNlZCB3aGVuIGEgc3RyZWFtaW5nIGFqYXggcmVxdWVzdCBpcyBzdGFydGVkXG4vLyBiZWZvcmUgb25sb2FkLiBUaGlzIGNhdXNlcyB0aGUgbG9hZCBpbmRpY2F0b3IgdG8gc3BpbiBpbmRlZmluZXRlbHkuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQubmVlZF9ib2R5ID0gdHJ1ZTtcblxuXG4vLyBBY2NvcmRpbmcgdG86XG4vLyAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY0MTUwNy9kZXRlY3QtYnJvd3Nlci1zdXBwb3J0LWZvci1jcm9zcy1kb21haW4teG1saHR0cHJlcXVlc3RzXG4vLyAgIGh0dHA6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDA5LzA3L2Nyb3NzLXNpdGUteG1saHR0cHJlcXVlc3Qtd2l0aC1jb3JzL1xuXG5cbi8vIHhkci1zdHJlYW1pbmdcbnZhciBYZHJTdHJlYW1pbmdUcmFuc3BvcnQgPSBTb2NrSlNbJ3hkci1zdHJlYW1pbmcnXSA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwpIHtcbiAgICB0aGlzLnJ1bihyaSwgdHJhbnNfdXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgdXRpbHMuWERST2JqZWN0KTtcbn07XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQWpheEJhc2VkVHJhbnNwb3J0KCk7XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhX3dpbmRvdy5YRG9tYWluUmVxdWVzdDtcbn07XG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5cblxuLy8geGhyLXBvbGxpbmdcbnZhciBYaHJQb2xsaW5nVHJhbnNwb3J0ID0gU29ja0pTWyd4aHItcG9sbGluZyddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHRoaXMucnVuKHJpLCB0cmFuc191cmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIHV0aWxzLlhIUkNvcnNPYmplY3QpO1xufTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQWpheEJhc2VkVHJhbnNwb3J0KCk7XG5cblhoclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhoclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xuWGhyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cblxuLy8geGRyLXBvbGxpbmdcbnZhciBYZHJQb2xsaW5nVHJhbnNwb3J0ID0gU29ja0pTWyd4ZHItcG9sbGluZyddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHRoaXMucnVuKHJpLCB0cmFuc191cmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIHV0aWxzLlhEUk9iamVjdCk7XG59O1xuXG5YZHJQb2xsaW5nVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBBamF4QmFzZWRUcmFuc3BvcnQoKTtcblxuWGRyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQ7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMteGhyLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1pZnJhbWUuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIEZldyBjb29sIHRyYW5zcG9ydHMgZG8gd29yayBvbmx5IGZvciBzYW1lLW9yaWdpbi4gSW4gb3JkZXIgdG8gbWFrZVxuLy8gdGhlbSB3b3JraW5nIGNyb3NzLWRvbWFpbiB3ZSBzaGFsbCB1c2UgaWZyYW1lLCBzZXJ2ZWQgZm9ybSB0aGVcbi8vIHJlbW90ZSBkb21haW4uIE5ldyBicm93c2VycywgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gY29tbXVuaWNhdGUgd2l0aFxuLy8gY3Jvc3MgZG9tYWluIGlmcmFtZSwgdXNpbmcgcG9zdE1lc3NhZ2UoKS4gSW4gSUUgaXQgd2FzIGltcGxlbWVudGVkXG4vLyBmcm9tIElFIDgrLCBidXQgb2YgY291cnNlLCBJRSBnb3Qgc29tZSBkZXRhaWxzIHdyb25nOlxuLy8gICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMTk3MDE1KHY9VlMuODUpLmFzcHhcbi8vICAgIGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcblxudmFyIElmcmFtZVRyYW5zcG9ydCA9IGZ1bmN0aW9uKCkge307XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuaV9jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwsIGJhc2VfdXJsKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQucmkgPSByaTtcbiAgICB0aGF0Lm9yaWdpbiA9IHV0aWxzLmdldE9yaWdpbihiYXNlX3VybCk7XG4gICAgdGhhdC5iYXNlX3VybCA9IGJhc2VfdXJsO1xuICAgIHRoYXQudHJhbnNfdXJsID0gdHJhbnNfdXJsO1xuXG4gICAgdmFyIGlmcmFtZV91cmwgPSBiYXNlX3VybCArICcvaWZyYW1lLmh0bWwnO1xuICAgIGlmICh0aGF0LnJpLl9vcHRpb25zLmRldmVsKSB7XG4gICAgICAgIGlmcmFtZV91cmwgKz0gJz90PScgKyAoK25ldyBEYXRlKTtcbiAgICB9XG4gICAgdGhhdC53aW5kb3dfaWQgPSB1dGlscy5yYW5kb21fc3RyaW5nKDgpO1xuICAgIGlmcmFtZV91cmwgKz0gJyMnICsgdGhhdC53aW5kb3dfaWQ7XG5cbiAgICB0aGF0LmlmcmFtZU9iaiA9IHV0aWxzLmNyZWF0ZUlmcmFtZShpZnJhbWVfdXJsLCBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucmkuX2RpZENsb3NlKDEwMDYsIFwiVW5hYmxlIHRvIGxvYWQgYW4gaWZyYW1lIChcIiArIHIgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICB0aGF0Lm9ubWVzc2FnZV9jYiA9IHV0aWxzLmJpbmQodGhhdC5vbm1lc3NhZ2UsIHRoYXQpO1xuICAgIHV0aWxzLmF0dGFjaE1lc3NhZ2UodGhhdC5vbm1lc3NhZ2VfY2IpO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5kb0NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQuaWZyYW1lT2JqKSB7XG4gICAgICAgIHV0aWxzLmRldGFjaE1lc3NhZ2UodGhhdC5vbm1lc3NhZ2VfY2IpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgICAgIGlmICh0aGF0LmlmcmFtZU9iai5pZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgICAgIHRoYXQucG9zdE1lc3NhZ2UoJ2MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgdGhhdC5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgICAgICB0aGF0LmlmcmFtZU9iaiA9IG51bGw7XG4gICAgICAgIHRoYXQub25tZXNzYWdlX2NiID0gdGhhdC5pZnJhbWVPYmogPSBudWxsO1xuICAgIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAoZS5vcmlnaW4gIT09IHRoYXQub3JpZ2luKSByZXR1cm47XG4gICAgdmFyIHdpbmRvd19pZCA9IGUuZGF0YS5zbGljZSgwLCA4KTtcbiAgICB2YXIgdHlwZSA9IGUuZGF0YS5zbGljZSg4LCA5KTtcbiAgICB2YXIgZGF0YSA9IGUuZGF0YS5zbGljZSg5KTtcblxuICAgIGlmICh3aW5kb3dfaWQgIT09IHRoYXQud2luZG93X2lkKSByZXR1cm47XG5cbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgJ3MnOlxuICAgICAgICB0aGF0LmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICAgICAgdGhhdC5wb3N0TWVzc2FnZSgncycsIEpTT04uc3RyaW5naWZ5KFtTb2NrSlMudmVyc2lvbiwgdGhhdC5wcm90b2NvbCwgdGhhdC50cmFuc191cmwsIHRoYXQuYmFzZV91cmxdKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3QnOlxuICAgICAgICB0aGF0LnJpLl9kaWRNZXNzYWdlKGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LmlmcmFtZU9iai5wb3N0KHRoYXQud2luZG93X2lkICsgdHlwZSArIChkYXRhIHx8ICcnKSwgdGhhdC5vcmlnaW4pO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5kb1NlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHRoaXMucG9zdE1lc3NhZ2UoJ20nLCBtZXNzYWdlKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gcG9zdE1lc3NhZ2UgbWlzYmVoYXZlcyBpbiBrb25xdWVyb3IgNC42LjUgLSB0aGUgbWVzc2FnZXMgYXJlIGRlbGl2ZXJlZCB3aXRoXG4gICAgLy8gaHVnZSBkZWxheSwgb3Igbm90IGF0IGFsbC5cbiAgICB2YXIga29ucXVlcm9yID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdLb25xdWVyb3InKSAhPT0gLTE7XG4gICAgcmV0dXJuICgodHlwZW9mIF93aW5kb3cucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIHR5cGVvZiBfd2luZG93LnBvc3RNZXNzYWdlID09PSAnb2JqZWN0JykgJiYgKCFrb25xdWVyb3IpKTtcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLWlmcmFtZS5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtaWZyYW1lLXdpdGhpbi5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIGN1cnJfd2luZG93X2lkO1xuXG52YXIgcG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSkge1xuICAgIGlmKHBhcmVudCAhPT0gX3dpbmRvdykge1xuICAgICAgICBwYXJlbnQucG9zdE1lc3NhZ2UoY3Vycl93aW5kb3dfaWQgKyB0eXBlICsgKGRhdGEgfHwgJycpLCAnKicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWxzLmxvZyhcIkNhbid0IHBvc3RNZXNzYWdlLCBubyBwYXJlbnQgd2luZG93LlwiLCB0eXBlLCBkYXRhKTtcbiAgICB9XG59O1xuXG52YXIgRmFjYWRlSlMgPSBmdW5jdGlvbigpIHt9O1xuRmFjYWRlSlMucHJvdG90eXBlLl9kaWRDbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICBwb3N0TWVzc2FnZSgndCcsIHV0aWxzLmNsb3NlRnJhbWUoY29kZSwgcmVhc29uKSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9kaWRNZXNzYWdlID0gZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgcG9zdE1lc3NhZ2UoJ3QnLCBmcmFtZSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9kb1NlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5kb1NlbmQoZGF0YSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9kb0NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LmRvQ2xlYW51cCgpO1xufTtcblxudXRpbHMucGFyZW50X29yaWdpbiA9IHVuZGVmaW5lZDtcblxuU29ja0pTLmJvb3RzdHJhcF9pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmFjYWRlO1xuICAgIGN1cnJfd2luZG93X2lkID0gX2RvY3VtZW50LmxvY2F0aW9uLmhhc2guc2xpY2UoMSk7XG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYoZS5zb3VyY2UgIT09IHBhcmVudCkgcmV0dXJuO1xuICAgICAgICBpZih0eXBlb2YgdXRpbHMucGFyZW50X29yaWdpbiA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB1dGlscy5wYXJlbnRfb3JpZ2luID0gZS5vcmlnaW47XG4gICAgICAgIGlmIChlLm9yaWdpbiAhPT0gdXRpbHMucGFyZW50X29yaWdpbikgcmV0dXJuO1xuXG4gICAgICAgIHZhciB3aW5kb3dfaWQgPSBlLmRhdGEuc2xpY2UoMCwgOCk7XG4gICAgICAgIHZhciB0eXBlID0gZS5kYXRhLnNsaWNlKDgsIDkpO1xuICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YS5zbGljZSg5KTtcbiAgICAgICAgaWYgKHdpbmRvd19pZCAhPT0gY3Vycl93aW5kb3dfaWQpIHJldHVybjtcbiAgICAgICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICB2YXIgcCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICB2YXIgdmVyc2lvbiA9IHBbMF07XG4gICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBwWzFdO1xuICAgICAgICAgICAgdmFyIHRyYW5zX3VybCA9IHBbMl07XG4gICAgICAgICAgICB2YXIgYmFzZV91cmwgPSBwWzNdO1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gIT09IFNvY2tKUy52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgdXRpbHMubG9nKFwiSW5jb21wYXRpYmlsZSBTb2NrSlMhIE1haW4gc2l0ZSB1c2VzOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgXFxcIlwiICsgdmVyc2lvbiArIFwiXFxcIiwgdGhlIGlmcmFtZTpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFxcXCJcIiArIFNvY2tKUy52ZXJzaW9uICsgXCJcXFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXRpbHMuZmxhdFVybCh0cmFuc191cmwpIHx8ICF1dGlscy5mbGF0VXJsKGJhc2VfdXJsKSkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmxvZyhcIk9ubHkgYmFzaWMgdXJscyBhcmUgc3VwcG9ydGVkIGluIFNvY2tKU1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNTYW1lT3JpZ2luVXJsKHRyYW5zX3VybCkgfHxcbiAgICAgICAgICAgICAgICAhdXRpbHMuaXNTYW1lT3JpZ2luVXJsKGJhc2VfdXJsKSkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmxvZyhcIkNhbid0IGNvbm5lY3QgdG8gZGlmZmVyZW50IGRvbWFpbiBmcm9tIHdpdGhpbiBhbiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWZyYW1lLiAoXCIgKyBKU09OLnN0cmluZ2lmeShbX3dpbmRvdy5sb2NhdGlvbi5ocmVmLCB0cmFuc191cmwsIGJhc2VfdXJsXSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIilcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmFjYWRlID0gbmV3IEZhY2FkZUpTKCk7XG4gICAgICAgICAgICBmYWNhZGUuX3RyYW5zcG9ydCA9IG5ldyBGYWNhZGVKU1twcm90b2NvbF0oZmFjYWRlLCB0cmFuc191cmwsIGJhc2VfdXJsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgIGZhY2FkZS5fZG9TZW5kKGRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgaWYgKGZhY2FkZSlcbiAgICAgICAgICAgICAgICBmYWNhZGUuX2RvQ2xlYW51cCgpO1xuICAgICAgICAgICAgZmFjYWRlID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGFsZXJ0KCd0ZXN0IHRpY2tlcicpO1xuICAgIC8vIGZhY2FkZSA9IG5ldyBGYWNhZGVKUygpO1xuICAgIC8vIGZhY2FkZS5fdHJhbnNwb3J0ID0gbmV3IEZhY2FkZUpTWyd3LWlmcmFtZS14aHItcG9sbGluZyddKGZhY2FkZSwgJ2h0dHA6Ly9ob3N0LmNvbTo5OTk5L3RpY2tlci8xMi9iYXNkJyk7XG5cbiAgICB1dGlscy5hdHRhY2hNZXNzYWdlKG9uTWVzc2FnZSk7XG5cbiAgICAvLyBTdGFydFxuICAgIHBvc3RNZXNzYWdlKCdzJyk7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1pZnJhbWUtd2l0aGluLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9pbmZvLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgSW5mb1JlY2VpdmVyID0gZnVuY3Rpb24oYmFzZV91cmwsIEFqYXhPYmplY3QpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdXRpbHMuZGVsYXkoZnVuY3Rpb24oKXt0aGF0LmRvWGhyKGJhc2VfdXJsLCBBamF4T2JqZWN0KTt9KTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKFsnZmluaXNoJ10pO1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmRvWGhyID0gZnVuY3Rpb24oYmFzZV91cmwsIEFqYXhPYmplY3QpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHQwID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB2YXIgeG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgYmFzZV91cmwgKyAnL2luZm8nKTtcblxuICAgIHZhciB0cmVmID0gdXRpbHMuZGVsYXkoODAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCl7eG8ub250aW1lb3V0KCk7fSk7XG5cbiAgICB4by5vbmZpbmlzaCA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAgIHRyZWYgPSBudWxsO1xuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHZhciBydHQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gdDA7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZm8gIT09ICdvYmplY3QnKSBpbmZvID0ge307XG4gICAgICAgICAgICB0aGF0LmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4by5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgeG8uY2xvc2UoKTtcbiAgICAgICAgdGhhdC5lbWl0KCdmaW5pc2gnKTtcbiAgICB9O1xufTtcblxudmFyIEluZm9SZWNlaXZlcklmcmFtZSA9IGZ1bmN0aW9uKGJhc2VfdXJsKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaWZyID0gbmV3IElmcmFtZVRyYW5zcG9ydCgpO1xuICAgICAgICBpZnIucHJvdG9jb2wgPSAndy1pZnJhbWUtaW5mby1yZWNlaXZlcic7XG4gICAgICAgIHZhciBmdW4gPSBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgPT09ICdzdHJpbmcnICYmIHIuc3Vic3RyKDAsMSkgPT09ICdtJykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gSlNPTi5wYXJzZShyLnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xuICAgICAgICAgICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhhdC5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmci5kb0NsZWFudXAoKTtcbiAgICAgICAgICAgIGlmciA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtb2NrX3JpID0ge1xuICAgICAgICAgICAgX29wdGlvbnM6IHt9LFxuICAgICAgICAgICAgX2RpZENsb3NlOiBmdW4sXG4gICAgICAgICAgICBfZGlkTWVzc2FnZTogZnVuXG4gICAgICAgIH07XG4gICAgICAgIGlmci5pX2NvbnN0cnVjdG9yKG1vY2tfcmksIGJhc2VfdXJsLCBiYXNlX3VybCk7XG4gICAgfVxuICAgIGlmKCFfZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB1dGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIGdvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbygpO1xuICAgIH1cbn07XG5JbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcihbJ2ZpbmlzaCddKTtcblxuXG52YXIgSW5mb1JlY2VpdmVyRmFrZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIEl0IG1heSBub3QgYmUgcG9zc2libGUgdG8gZG8gY3Jvc3MgZG9tYWluIEFKQVggdG8gZ2V0IHRoZSBpbmZvXG4gICAgLy8gZGF0YSwgZm9yIGV4YW1wbGUgZm9yIElFNy4gQnV0IHdlIHdhbnQgdG8gcnVuIEpTT05QLCBzbyBsZXQnc1xuICAgIC8vIGZha2UgdGhlIHJlc3BvbnNlLCB3aXRoIHJ0dD0ycyAocnRvPTZzKS5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdXRpbHMuZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywge30sIDIwMDApO1xuICAgIH0pO1xufTtcbkluZm9SZWNlaXZlckZha2UucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcihbJ2ZpbmlzaCddKTtcblxudmFyIGNyZWF0ZUluZm9SZWNlaXZlciA9IGZ1bmN0aW9uKGJhc2VfdXJsKSB7XG4gICAgaWYgKHV0aWxzLmlzU2FtZU9yaWdpblVybChiYXNlX3VybCkpIHtcbiAgICAgICAgLy8gSWYsIGZvciBzb21lIHJlYXNvbiwgd2UgaGF2ZSBTb2NrSlMgbG9jYWxseSAtIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gbmVlZCB0byBzdGFydCB1cCB0aGUgY29tcGxleCBtYWNoaW5lcnkuIEp1c3QgdXNlIGFqYXguXG4gICAgICAgIHJldHVybiBuZXcgSW5mb1JlY2VpdmVyKGJhc2VfdXJsLCB1dGlscy5YSFJMb2NhbE9iamVjdCk7XG4gICAgfVxuICAgIHN3aXRjaCAodXRpbHMuaXNYSFJDb3JzQ2FwYWJsZSgpKSB7XG4gICAgY2FzZSAxOlxuICAgICAgICAvLyBYSFJMb2NhbE9iamVjdCAtPiBub19jcmVkZW50aWFscz10cnVlXG4gICAgICAgIHJldHVybiBuZXcgSW5mb1JlY2VpdmVyKGJhc2VfdXJsLCB1dGlscy5YSFJMb2NhbE9iamVjdCk7XG4gICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gbmV3IEluZm9SZWNlaXZlcihiYXNlX3VybCwgdXRpbHMuWERST2JqZWN0KTtcbiAgICBjYXNlIDM6XG4gICAgICAgIC8vIE9wZXJhXG4gICAgICAgIHJldHVybiBuZXcgSW5mb1JlY2VpdmVySWZyYW1lKGJhc2VfdXJsKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICAvLyBJRSA3XG4gICAgICAgIHJldHVybiBuZXcgSW5mb1JlY2VpdmVyRmFrZSgpO1xuICAgIH07XG59O1xuXG5cbnZhciBXSW5mb1JlY2VpdmVySWZyYW1lID0gRmFjYWRlSlNbJ3ctaWZyYW1lLWluZm8tcmVjZWl2ZXInXSA9IGZ1bmN0aW9uKHJpLCBfdHJhbnNfdXJsLCBiYXNlX3VybCkge1xuICAgIHZhciBpciA9IG5ldyBJbmZvUmVjZWl2ZXIoYmFzZV91cmwsIHV0aWxzLlhIUkxvY2FsT2JqZWN0KTtcbiAgICBpci5vbmZpbmlzaCA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICAgICAgICByaS5fZGlkTWVzc2FnZSgnbScrSlNPTi5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgICAgICAgcmkuX2RpZENsb3NlKCk7XG4gICAgfVxufTtcbldJbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmRvQ2xlYW51cCA9IGZ1bmN0aW9uKCkge307XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL2luZm8uanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLWlmcmFtZS1ldmVudHNvdXJjZS5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIEV2ZW50U291cmNlSWZyYW1lVHJhbnNwb3J0ID0gU29ja0pTWydpZnJhbWUtZXZlbnRzb3VyY2UnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5wcm90b2NvbCA9ICd3LWlmcmFtZS1ldmVudHNvdXJjZSc7XG4gICAgdGhhdC5pX2NvbnN0cnVjdG9yLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG59O1xuXG5FdmVudFNvdXJjZUlmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgSWZyYW1lVHJhbnNwb3J0KCk7XG5cbkV2ZW50U291cmNlSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgnRXZlbnRTb3VyY2UnIGluIF93aW5kb3cpICYmIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG59O1xuXG5FdmVudFNvdXJjZUlmcmFtZVRyYW5zcG9ydC5uZWVkX2JvZHkgPSB0cnVlO1xuRXZlbnRTb3VyY2VJZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDM7IC8vIGh0bWwsIGphdmFzY3JpcHQsIGV2ZW50c291cmNlXG5cblxuLy8gdy1pZnJhbWUtZXZlbnRzb3VyY2VcbnZhciBFdmVudFNvdXJjZVRyYW5zcG9ydCA9IEZhY2FkZUpTWyd3LWlmcmFtZS1ldmVudHNvdXJjZSddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHRoaXMucnVuKHJpLCB0cmFuc191cmwsICcvZXZlbnRzb3VyY2UnLCBFdmVudFNvdXJjZVJlY2VpdmVyLCB1dGlscy5YSFJMb2NhbE9iamVjdCk7XG59XG5FdmVudFNvdXJjZVRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQWpheEJhc2VkVHJhbnNwb3J0KCk7XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLWlmcmFtZS1ldmVudHNvdXJjZS5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtaWZyYW1lLXhoci1wb2xsaW5nLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgWGhyUG9sbGluZ0lmcmFtZVRyYW5zcG9ydCA9IFNvY2tKU1snaWZyYW1lLXhoci1wb2xsaW5nJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQucHJvdG9jb2wgPSAndy1pZnJhbWUteGhyLXBvbGxpbmcnO1xuICAgIHRoYXQuaV9jb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xufTtcblxuWGhyUG9sbGluZ0lmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgSWZyYW1lVHJhbnNwb3J0KCk7XG5cblhoclBvbGxpbmdJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3dpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xufTtcblxuWGhyUG9sbGluZ0lmcmFtZVRyYW5zcG9ydC5uZWVkX2JvZHkgPSB0cnVlO1xuWGhyUG9sbGluZ0lmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMzsgLy8gaHRtbCwgamF2YXNjcmlwdCwgeGhyXG5cblxuLy8gdy1pZnJhbWUteGhyLXBvbGxpbmdcbnZhciBYaHJQb2xsaW5nSVRyYW5zcG9ydCA9IEZhY2FkZUpTWyd3LWlmcmFtZS14aHItcG9sbGluZyddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHRoaXMucnVuKHJpLCB0cmFuc191cmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIHV0aWxzLlhIUkxvY2FsT2JqZWN0KTtcbn07XG5cblhoclBvbGxpbmdJVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBBamF4QmFzZWRUcmFuc3BvcnQoKTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtaWZyYW1lLXhoci1wb2xsaW5nLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1pZnJhbWUtaHRtbGZpbGUuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIFRoaXMgdHJhbnNwb3J0IGdlbmVyYWxseSB3b3JrcyBpbiBhbnkgYnJvd3NlciwgYnV0IHdpbGwgY2F1c2UgYVxuLy8gc3Bpbm5pbmcgY3Vyc29yIHRvIGFwcGVhciBpbiBhbnkgYnJvd3NlciBvdGhlciB0aGFuIElFLlxuLy8gV2UgbWF5IHRlc3QgdGhpcyB0cmFuc3BvcnQgaW4gYWxsIGJyb3dzZXJzIC0gd2h5IG5vdCwgYnV0IGluXG4vLyBwcm9kdWN0aW9uIGl0IHNob3VsZCBiZSBvbmx5IHJ1biBpbiBJRS5cblxudmFyIEh0bWxGaWxlSWZyYW1lVHJhbnNwb3J0ID0gU29ja0pTWydpZnJhbWUtaHRtbGZpbGUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5wcm90b2NvbCA9ICd3LWlmcmFtZS1odG1sZmlsZSc7XG4gICAgdGhhdC5pX2NvbnN0cnVjdG9yLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG59O1xuXG4vLyBJbmhlcml0YW5jZS5cbkh0bWxGaWxlSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBJZnJhbWVUcmFuc3BvcnQoKTtcblxuSHRtbEZpbGVJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xufTtcblxuSHRtbEZpbGVJZnJhbWVUcmFuc3BvcnQubmVlZF9ib2R5ID0gdHJ1ZTtcbkh0bWxGaWxlSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAzOyAvLyBodG1sLCBqYXZhc2NyaXB0LCBodG1sZmlsZVxuXG5cbi8vIHctaWZyYW1lLWh0bWxmaWxlXG52YXIgSHRtbEZpbGVUcmFuc3BvcnQgPSBGYWNhZGVKU1sndy1pZnJhbWUtaHRtbGZpbGUnXSA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwpIHtcbiAgICB0aGlzLnJ1bihyaSwgdHJhbnNfdXJsLCAnL2h0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlciwgdXRpbHMuWEhSTG9jYWxPYmplY3QpO1xufTtcbkh0bWxGaWxlVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBBamF4QmFzZWRUcmFuc3BvcnQoKTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtaWZyYW1lLWh0bWxmaWxlLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1wb2xsaW5nLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgUG9sbGluZyA9IGZ1bmN0aW9uKHJpLCBSZWNlaXZlciwgcmVjdl91cmwsIEFqYXhPYmplY3QpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5yaSA9IHJpO1xuICAgIHRoYXQuUmVjZWl2ZXIgPSBSZWNlaXZlcjtcbiAgICB0aGF0LnJlY3ZfdXJsID0gcmVjdl91cmw7XG4gICAgdGhhdC5BamF4T2JqZWN0ID0gQWpheE9iamVjdDtcbiAgICB0aGF0Ll9zY2hlZHVsZVJlY3YoKTtcbn07XG5cblBvbGxpbmcucHJvdG90eXBlLl9zY2hlZHVsZVJlY3YgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHBvbGwgPSB0aGF0LnBvbGwgPSBuZXcgdGhhdC5SZWNlaXZlcih0aGF0LnJlY3ZfdXJsLCB0aGF0LkFqYXhPYmplY3QpO1xuICAgIHZhciBtc2dfY291bnRlciA9IDA7XG4gICAgcG9sbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIG1zZ19jb3VudGVyICs9IDE7XG4gICAgICAgIHRoYXQucmkuX2RpZE1lc3NhZ2UoZS5kYXRhKTtcbiAgICB9O1xuICAgIHBvbGwub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhhdC5wb2xsID0gcG9sbCA9IHBvbGwub25tZXNzYWdlID0gcG9sbC5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGF0LnBvbGxfaXNfY2xvc2luZykge1xuICAgICAgICAgICAgaWYgKGUucmVhc29uID09PSAncGVybWFuZW50Jykge1xuICAgICAgICAgICAgICAgIHRoYXQucmkuX2RpZENsb3NlKDEwMDYsICdQb2xsaW5nIGVycm9yICgnICsgZS5yZWFzb24gKyAnKScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9zY2hlZHVsZVJlY3YoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LnBvbGxfaXNfY2xvc2luZyA9IHRydWU7XG4gICAgaWYgKHRoYXQucG9sbCkge1xuICAgICAgICB0aGF0LnBvbGwuYWJvcnQoKTtcbiAgICB9XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1wb2xsaW5nLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1yZWNlaXZlci1ldmVudHNvdXJjZS5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIEV2ZW50U291cmNlUmVjZWl2ZXIgPSBmdW5jdGlvbih1cmwpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIGVzID0gbmV3IEV2ZW50U291cmNlKHVybCk7XG4gICAgZXMub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KCdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J2RhdGEnOiB1bmVzY2FwZShlLmRhdGEpfSkpO1xuICAgIH07XG4gICAgdGhhdC5lc19jbG9zZSA9IGVzLm9uZXJyb3IgPSBmdW5jdGlvbihlLCBhYm9ydF9yZWFzb24pIHtcbiAgICAgICAgLy8gRVMgb24gcmVjb25uZWN0aW9uIGhhcyByZWFkeVN0YXRlID0gMCBvciAxLlxuICAgICAgICAvLyBvbiBuZXR3b3JrIGVycm9yIGl0J3MgQ0xPU0VEID0gMlxuICAgICAgICB2YXIgcmVhc29uID0gYWJvcnRfcmVhc29uID8gJ3VzZXInIDpcbiAgICAgICAgICAgIChlcy5yZWFkeVN0YXRlICE9PSAyID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCcpO1xuICAgICAgICB0aGF0LmVzX2Nsb3NlID0gZXMub25tZXNzYWdlID0gZXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIC8vIEV2ZW50U291cmNlIHJlY29ubmVjdHMgYXV0b21hdGljYWxseS5cbiAgICAgICAgZXMuY2xvc2UoKTtcbiAgICAgICAgZXMgPSBudWxsO1xuICAgICAgICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcbiAgICAgICAgLy8gd2FpdGluZyBmb3IgRVMgY2xlYW51cC4gU2VlOlxuICAgICAgICAvLyAgIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04OTE1NVxuICAgICAgICB1dGlscy5kZWxheSgyMDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5kaXNwYXRjaEV2ZW50KG5ldyBTaW1wbGVFdmVudCgnY2xvc2UnLCB7cmVhc29uOiByZWFzb259KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZSA9IG5ldyBSRXZlbnRUYXJnZXQoKTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQuZXNfY2xvc2UpIHtcbiAgICAgICAgdGhhdC5lc19jbG9zZSh7fSwgdHJ1ZSk7XG4gICAgfVxufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtcmVjZWl2ZXItZXZlbnRzb3VyY2UuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLXJlY2VpdmVyLWh0bWxmaWxlLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgX2lzX2llX2h0bWxmaWxlX2NhcGFibGU7XG52YXIgaXNJZUh0bWxmaWxlQ2FwYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChfaXNfaWVfaHRtbGZpbGVfY2FwYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICgnQWN0aXZlWE9iamVjdCcgaW4gX3dpbmRvdykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfaXNfaWVfaHRtbGZpbGVfY2FwYWJsZSA9ICEhbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2lzX2llX2h0bWxmaWxlX2NhcGFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2lzX2llX2h0bWxmaWxlX2NhcGFibGU7XG59O1xuXG5cbnZhciBIdG1sZmlsZVJlY2VpdmVyID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICAgIHRoYXQuaWQgPSAnYScgKyB1dGlscy5yYW5kb21fc3RyaW5nKDYsIDI2KTtcbiAgICB1cmwgKz0gKCh1cmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICtcbiAgICAgICAgJ2M9JyArIGVzY2FwZShXUHJlZml4ICsgJy4nICsgdGhhdC5pZCk7XG5cbiAgICB2YXIgY29uc3RydWN0b3IgPSBpc0llSHRtbGZpbGVDYXBhYmxlKCkgP1xuICAgICAgICB1dGlscy5jcmVhdGVIdG1sZmlsZSA6IHV0aWxzLmNyZWF0ZUlmcmFtZTtcblxuICAgIHZhciBpZnJhbWVPYmo7XG4gICAgX3dpbmRvd1tXUHJlZml4XVt0aGF0LmlkXSA9IHtcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVzc2FnZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoYXQuZGlzcGF0Y2hFdmVudChuZXcgU2ltcGxlRXZlbnQoJ21lc3NhZ2UnLCB7J2RhdGEnOiBkYXRhfSkpO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LmlmcmFtZV9jbG9zZSh7fSwgJ25ldHdvcmsnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhhdC5pZnJhbWVfY2xvc2UgPSBmdW5jdGlvbihlLCBhYm9ydF9yZWFzb24pIHtcbiAgICAgICAgaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICAgICAgdGhhdC5pZnJhbWVfY2xvc2UgPSBpZnJhbWVPYmogPSBudWxsO1xuICAgICAgICBkZWxldGUgX3dpbmRvd1tXUHJlZml4XVt0aGF0LmlkXTtcbiAgICAgICAgdGhhdC5kaXNwYXRjaEV2ZW50KG5ldyBTaW1wbGVFdmVudCgnY2xvc2UnLCB7cmVhc29uOiBhYm9ydF9yZWFzb259KSk7XG4gICAgfTtcbiAgICBpZnJhbWVPYmogPSBjb25zdHJ1Y3Rvcih1cmwsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5pZnJhbWVfY2xvc2Uoe30sICdwZXJtYW5lbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlID0gbmV3IFJFdmVudFRhcmdldCgpO1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5pZnJhbWVfY2xvc2UpIHtcbiAgICAgICAgdGhhdC5pZnJhbWVfY2xvc2Uoe30sICd1c2VyJyk7XG4gICAgfVxufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtcmVjZWl2ZXItaHRtbGZpbGUuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLXJlY2VpdmVyLXhoci5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIFhoclJlY2VpdmVyID0gZnVuY3Rpb24odXJsLCBBamF4T2JqZWN0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBidWZfcG9zID0gMDtcblxuICAgIHRoYXQueG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIHVybCwgbnVsbCk7XG4gICAgdGhhdC54by5vbmNodW5rID0gZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IDIwMCkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IHRleHQuc2xpY2UoYnVmX3Bvcyk7XG4gICAgICAgICAgICB2YXIgcCA9IGJ1Zi5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgICAgIGlmIChwID09PSAtMSkgYnJlYWs7XG4gICAgICAgICAgICBidWZfcG9zICs9IHArMTtcbiAgICAgICAgICAgIHZhciBtc2cgPSBidWYuc2xpY2UoMCwgcCk7XG4gICAgICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KCdtZXNzYWdlJywge2RhdGE6IG1zZ30pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhhdC54by5vbmZpbmlzaCA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgICAgICB0aGF0LnhvLm9uY2h1bmsoc3RhdHVzLCB0ZXh0KTtcbiAgICAgICAgdGhhdC54byA9IG51bGw7XG4gICAgICAgIHZhciByZWFzb24gPSBzdGF0dXMgPT09IDIwMCA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnO1xuICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KCdjbG9zZScsIHtyZWFzb246IHJlYXNvbn0pKTtcbiAgICB9XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUgPSBuZXcgUkV2ZW50VGFyZ2V0KCk7XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC54bykge1xuICAgICAgICB0aGF0LnhvLmNsb3NlKCk7XG4gICAgICAgIHRoYXQuZGlzcGF0Y2hFdmVudChuZXcgU2ltcGxlRXZlbnQoJ2Nsb3NlJywge3JlYXNvbjogJ3VzZXInfSkpO1xuICAgICAgICB0aGF0LnhvID0gbnVsbDtcbiAgICB9XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1yZWNlaXZlci14aHIuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3Rlc3QtaG9va3MuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIEZvciB0ZXN0aW5nXG5Tb2NrSlMuZ2V0VXRpbHMgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB1dGlscztcbn07XG5cblNvY2tKUy5nZXRJZnJhbWVUcmFuc3BvcnQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBJZnJhbWVUcmFuc3BvcnQ7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90ZXN0LWhvb2tzLmpzXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBTb2NrSlM7XG4gICAgICAgICAgfSkoKTtcbmlmICgnX3NvY2tqc19vbmxvYWQnIGluIHdpbmRvdykgc2V0VGltZW91dChfc29ja2pzX29ubG9hZCwgMSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU29ja0pTO1xuLy8gICAgIFsqXSBFbmQgb2YgbGliL2luZGV4LmpzXG5cbi8vIFsqXSBFbmQgb2YgbGliL2FsbC5qc1xuIiwiYWNlLmRlZmluZShcImFjZS9tb2RlL2RvY19jb21tZW50X2hpZ2hsaWdodF9ydWxlc1wiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9tb2RlL3RleHRfaGlnaGxpZ2h0X3J1bGVzXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG9vcCA9IGFjZXF1aXJlKFwiLi4vbGliL29vcFwiKTtcbnZhciBUZXh0SGlnaGxpZ2h0UnVsZXMgPSBhY2VxdWlyZShcIi4vdGV4dF9oaWdobGlnaHRfcnVsZXNcIikuVGV4dEhpZ2hsaWdodFJ1bGVzO1xuXG52YXIgRG9jQ29tbWVudEhpZ2hsaWdodFJ1bGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy4kcnVsZXMgPSB7XG4gICAgICAgIFwic3RhcnRcIiA6IFsge1xuICAgICAgICAgICAgdG9rZW4gOiBcImNvbW1lbnQuZG9jLnRhZ1wiLFxuICAgICAgICAgICAgcmVnZXggOiBcIkBbXFxcXHdcXFxcZF9dK1wiIC8vIFRPRE86IGZpeCBlbWFpbCBhZGRyZXNzZXNcbiAgICAgICAgfSxcbiAgICAgICAgRG9jQ29tbWVudEhpZ2hsaWdodFJ1bGVzLmdldFRhZ1J1bGUoKSxcbiAgICAgICAge1xuICAgICAgICAgICAgZGVmYXVsdFRva2VuIDogXCJjb21tZW50LmRvY1wiLFxuICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlOiB0cnVlXG4gICAgICAgIH1dXG4gICAgfTtcbn07XG5cbm9vcC5pbmhlcml0cyhEb2NDb21tZW50SGlnaGxpZ2h0UnVsZXMsIFRleHRIaWdobGlnaHRSdWxlcyk7XG5cbkRvY0NvbW1lbnRIaWdobGlnaHRSdWxlcy5nZXRUYWdSdWxlID0gZnVuY3Rpb24oc3RhcnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbiA6IFwiY29tbWVudC5kb2MudGFnLnN0b3JhZ2UudHlwZVwiLFxuICAgICAgICByZWdleCA6IFwiXFxcXGIoPzpUT0RPfEZJWE1FfFhYWHxIQUNLKVxcXFxiXCJcbiAgICB9O1xufVxuXG5Eb2NDb21tZW50SGlnaGxpZ2h0UnVsZXMuZ2V0U3RhcnRSdWxlID0gZnVuY3Rpb24oc3RhcnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b2tlbiA6IFwiY29tbWVudC5kb2NcIiwgLy8gZG9jIGNvbW1lbnRcbiAgICAgICAgcmVnZXggOiBcIlxcXFwvXFxcXCooPz1cXFxcKilcIixcbiAgICAgICAgbmV4dCAgOiBzdGFydFxuICAgIH07XG59O1xuXG5Eb2NDb21tZW50SGlnaGxpZ2h0UnVsZXMuZ2V0RW5kUnVsZSA9IGZ1bmN0aW9uIChzdGFydCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuIDogXCJjb21tZW50LmRvY1wiLCAvLyBjbG9zaW5nIGNvbW1lbnRcbiAgICAgICAgcmVnZXggOiBcIlxcXFwqXFxcXC9cIixcbiAgICAgICAgbmV4dCAgOiBzdGFydFxuICAgIH07XG59O1xuXG5cbmV4cG9ydHMuRG9jQ29tbWVudEhpZ2hsaWdodFJ1bGVzID0gRG9jQ29tbWVudEhpZ2hsaWdodFJ1bGVzO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb2RlL2phdmFzY3JpcHRfaGlnaGxpZ2h0X3J1bGVzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL21vZGUvZG9jX2NvbW1lbnRfaGlnaGxpZ2h0X3J1bGVzXCIsXCJhY2UvbW9kZS90ZXh0X2hpZ2hsaWdodF9ydWxlc1wiXSwgZnVuY3Rpb24oYWNlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBvb3AgPSBhY2VxdWlyZShcIi4uL2xpYi9vb3BcIik7XG52YXIgRG9jQ29tbWVudEhpZ2hsaWdodFJ1bGVzID0gYWNlcXVpcmUoXCIuL2RvY19jb21tZW50X2hpZ2hsaWdodF9ydWxlc1wiKS5Eb2NDb21tZW50SGlnaGxpZ2h0UnVsZXM7XG52YXIgVGV4dEhpZ2hsaWdodFJ1bGVzID0gYWNlcXVpcmUoXCIuL3RleHRfaGlnaGxpZ2h0X3J1bGVzXCIpLlRleHRIaWdobGlnaHRSdWxlcztcblxudmFyIEphdmFTY3JpcHRIaWdobGlnaHRSdWxlcyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIga2V5d29yZE1hcHBlciA9IHRoaXMuY3JlYXRlS2V5d29yZE1hcHBlcih7XG4gICAgICAgIFwidmFyaWFibGUubGFuZ3VhZ2VcIjpcbiAgICAgICAgICAgIFwiQXJyYXl8Qm9vbGVhbnxEYXRlfEZ1bmN0aW9ufEl0ZXJhdG9yfE51bWJlcnxPYmplY3R8UmVnRXhwfFN0cmluZ3xQcm94eXxcIiAgKyAvLyBDb25zdHJ1Y3RvcnNcbiAgICAgICAgICAgIFwiTmFtZXNwYWNlfFFOYW1lfFhNTHxYTUxMaXN0fFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAvLyBFNFhcbiAgICAgICAgICAgIFwiQXJyYXlCdWZmZXJ8RmxvYXQzMkFycmF5fEZsb2F0NjRBcnJheXxJbnQxNkFycmF5fEludDMyQXJyYXl8SW50OEFycmF5fFwiICAgK1xuICAgICAgICAgICAgXCJVaW50MTZBcnJheXxVaW50MzJBcnJheXxVaW50OEFycmF5fFVpbnQ4Q2xhbXBlZEFycmF5fFwiICAgICAgICAgICAgICAgICAgICArXG4gICAgICAgICAgICBcIkVycm9yfEV2YWxFcnJvcnxJbnRlcm5hbEVycm9yfFJhbmdlRXJyb3J8UmVmZXJlbmNlRXJyb3J8U3RvcEl0ZXJhdGlvbnxcIiAgICsgLy8gRXJyb3JzXG4gICAgICAgICAgICBcIlN5bnRheEVycm9yfFR5cGVFcnJvcnxVUklFcnJvcnxcIiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICtcbiAgICAgICAgICAgIFwiZGVjb2RlVVJJfGRlY29kZVVSSUNvbXBvbmVudHxlbmNvZGVVUkl8ZW5jb2RlVVJJQ29tcG9uZW50fGV2YWx8aXNGaW5pdGV8XCIgKyAvLyBOb24tY29uc3RydWN0b3IgZnVuY3Rpb25zXG4gICAgICAgICAgICBcImlzTmFOfHBhcnNlRmxvYXR8cGFyc2VJbnR8XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICtcbiAgICAgICAgICAgIFwiSlNPTnxNYXRofFwiICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAvLyBPdGhlclxuICAgICAgICAgICAgXCJ0aGlzfGFyZ3VtZW50c3xwcm90b3R5cGV8d2luZG93fGRvY3VtZW50XCIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIC8vIFBzZXVkb1xuICAgICAgICBcImtleXdvcmRcIjpcbiAgICAgICAgICAgIFwiY29uc3R8eWllbGR8aW1wb3J0fGdldHxzZXR8XCIgK1xuICAgICAgICAgICAgXCJicmVha3xjYXNlfGNhdGNofGNvbnRpbnVlfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZmluYWxseXxmb3J8ZnVuY3Rpb258XCIgK1xuICAgICAgICAgICAgXCJpZnxpbnxpbnN0YW5jZW9mfG5ld3xyZXR1cm58c3dpdGNofHRocm93fHRyeXx0eXBlb2Z8bGV0fHZhcnx3aGlsZXx3aXRofGRlYnVnZ2VyfFwiICtcbiAgICAgICAgICAgIFwiX19wYXJlbnRfX3xfX2NvdW50X198ZXNjYXBlfHVuZXNjYXBlfHdpdGh8X19wcm90b19ffFwiICtcbiAgICAgICAgICAgIFwiY2xhc3N8ZW51bXxleHRlbmRzfHN1cGVyfGV4cG9ydHxpbXBsZW1lbnRzfHByaXZhdGV8cHVibGljfGludGVyZmFjZXxwYWNrYWdlfHByb3RlY3RlZHxzdGF0aWNcIixcbiAgICAgICAgXCJzdG9yYWdlLnR5cGVcIjpcbiAgICAgICAgICAgIFwiY29uc3R8bGV0fHZhcnxmdW5jdGlvblwiLFxuICAgICAgICBcImNvbnN0YW50Lmxhbmd1YWdlXCI6XG4gICAgICAgICAgICBcIm51bGx8SW5maW5pdHl8TmFOfHVuZGVmaW5lZFwiLFxuICAgICAgICBcInN1cHBvcnQuZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIFwiYWxlcnRcIixcbiAgICAgICAgXCJjb25zdGFudC5sYW5ndWFnZS5ib29sZWFuXCI6IFwidHJ1ZXxmYWxzZVwiXG4gICAgfSwgXCJpZGVudGlmaWVyXCIpO1xuICAgIHZhciBrd0JlZm9yZVJlID0gXCJjYXNlfGRvfGVsc2V8ZmluYWxseXxpbnxpbnN0YW5jZW9mfHJldHVybnx0aHJvd3x0cnl8dHlwZW9mfHlpZWxkfHZvaWRcIjtcbiAgICB2YXIgaWRlbnRpZmllclJlID0gXCJbYS16QS1aXFxcXCRfXFx1MDBhMS1cXHVmZmZmXVthLXpBLVpcXFxcZFxcXFwkX1xcdTAwYTEtXFx1ZmZmZl0qXFxcXGJcIjtcblxuICAgIHZhciBlc2NhcGVkUmUgPSBcIlxcXFxcXFxcKD86eFswLTlhLWZBLUZdezJ9fFwiICsgLy8gaGV4XG4gICAgICAgIFwidVswLTlhLWZBLUZdezR9fFwiICsgLy8gdW5pY29kZVxuICAgICAgICBcIlswLTJdWzAtN117MCwyfXxcIiArIC8vIG9jdFxuICAgICAgICBcIjNbMC02XVswLTddP3xcIiArIC8vIG9jdFxuICAgICAgICBcIjM3WzAtN10/fFwiICsgLy8gb2N0XG4gICAgICAgIFwiWzQtN11bMC03XT98XCIgKyAvL29jdFxuICAgICAgICBcIi4pXCI7XG5cbiAgICB0aGlzLiRydWxlcyA9IHtcbiAgICAgICAgXCJub19yZWdleFwiIDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRva2VuIDogXCJjb21tZW50XCIsXG4gICAgICAgICAgICAgICAgcmVnZXggOiBcIlxcXFwvXFxcXC9cIixcbiAgICAgICAgICAgICAgICBuZXh0IDogXCJsaW5lX2NvbW1lbnRcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIERvY0NvbW1lbnRIaWdobGlnaHRSdWxlcy5nZXRTdGFydFJ1bGUoXCJkb2Mtc3RhcnRcIiksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG9rZW4gOiBcImNvbW1lbnRcIiwgLy8gbXVsdGkgbGluZSBjb21tZW50XG4gICAgICAgICAgICAgICAgcmVnZXggOiAvXFwvXFwqLyxcbiAgICAgICAgICAgICAgICBuZXh0IDogXCJjb21tZW50XCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgcmVnZXggOiBcIicoPz0uKVwiLFxuICAgICAgICAgICAgICAgIG5leHQgIDogXCJxc3RyaW5nXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgcmVnZXggOiAnXCIoPz0uKScsXG4gICAgICAgICAgICAgICAgbmV4dCAgOiBcInFxc3RyaW5nXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA6IFwiY29uc3RhbnQubnVtZXJpY1wiLCAvLyBoZXhcbiAgICAgICAgICAgICAgICByZWdleCA6IC8wW3hYXVswLTlhLWZBLUZdK1xcYi9cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA6IFwiY29uc3RhbnQubnVtZXJpY1wiLCAvLyBmbG9hdFxuICAgICAgICAgICAgICAgIHJlZ2V4IDogL1srLV0/XFxkKyg/Oig/OlxcLlxcZCopPyg/OltlRV1bKy1dP1xcZCspPyk/XFxiL1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogW1xuICAgICAgICAgICAgICAgICAgICBcInN0b3JhZ2UudHlwZVwiLCBcInB1bmN0dWF0aW9uLm9wZXJhdG9yXCIsIFwic3VwcG9ydC5mdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBcInB1bmN0dWF0aW9uLm9wZXJhdG9yXCIsIFwiZW50aXR5Lm5hbWUuZnVuY3Rpb25cIiwgXCJ0ZXh0XCIsXCJrZXl3b3JkLm9wZXJhdG9yXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHJlZ2V4IDogXCIoXCIgKyBpZGVudGlmaWVyUmUgKyBcIikoXFxcXC4pKHByb3RvdHlwZSkoXFxcXC4pKFwiICsgaWRlbnRpZmllclJlICtcIikoXFxcXHMqKSg9KVwiLFxuICAgICAgICAgICAgICAgIG5leHQ6IFwiZnVuY3Rpb25fYXJndW1lbnRzXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA6IFtcbiAgICAgICAgICAgICAgICAgICAgXCJzdG9yYWdlLnR5cGVcIiwgXCJwdW5jdHVhdGlvbi5vcGVyYXRvclwiLCBcImVudGl0eS5uYW1lLmZ1bmN0aW9uXCIsIFwidGV4dFwiLFxuICAgICAgICAgICAgICAgICAgICBcImtleXdvcmQub3BlcmF0b3JcIiwgXCJ0ZXh0XCIsIFwic3RvcmFnZS50eXBlXCIsIFwidGV4dFwiLCBcInBhcmVuLmxwYXJlblwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICByZWdleCA6IFwiKFwiICsgaWRlbnRpZmllclJlICsgXCIpKFxcXFwuKShcIiArIGlkZW50aWZpZXJSZSArXCIpKFxcXFxzKikoPSkoXFxcXHMqKShmdW5jdGlvbikoXFxcXHMqKShcXFxcKClcIixcbiAgICAgICAgICAgICAgICBuZXh0OiBcImZ1bmN0aW9uX2FyZ3VtZW50c1wiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW4gOiBbXG4gICAgICAgICAgICAgICAgICAgIFwiZW50aXR5Lm5hbWUuZnVuY3Rpb25cIiwgXCJ0ZXh0XCIsIFwia2V5d29yZC5vcGVyYXRvclwiLCBcInRleHRcIiwgXCJzdG9yYWdlLnR5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgXCJ0ZXh0XCIsIFwicGFyZW4ubHBhcmVuXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHJlZ2V4IDogXCIoXCIgKyBpZGVudGlmaWVyUmUgK1wiKShcXFxccyopKD0pKFxcXFxzKikoZnVuY3Rpb24pKFxcXFxzKikoXFxcXCgpXCIsXG4gICAgICAgICAgICAgICAgbmV4dDogXCJmdW5jdGlvbl9hcmd1bWVudHNcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogW1xuICAgICAgICAgICAgICAgICAgICBcInN0b3JhZ2UudHlwZVwiLCBcInB1bmN0dWF0aW9uLm9wZXJhdG9yXCIsIFwiZW50aXR5Lm5hbWUuZnVuY3Rpb25cIiwgXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIFwia2V5d29yZC5vcGVyYXRvclwiLCBcInRleHRcIixcbiAgICAgICAgICAgICAgICAgICAgXCJzdG9yYWdlLnR5cGVcIiwgXCJ0ZXh0XCIsIFwiZW50aXR5Lm5hbWUuZnVuY3Rpb25cIiwgXCJ0ZXh0XCIsIFwicGFyZW4ubHBhcmVuXCJcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIHJlZ2V4IDogXCIoXCIgKyBpZGVudGlmaWVyUmUgKyBcIikoXFxcXC4pKFwiICsgaWRlbnRpZmllclJlICtcIikoXFxcXHMqKSg9KShcXFxccyopKGZ1bmN0aW9uKShcXFxccyspKFxcXFx3KykoXFxcXHMqKShcXFxcKClcIixcbiAgICAgICAgICAgICAgICBuZXh0OiBcImZ1bmN0aW9uX2FyZ3VtZW50c1wiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW4gOiBbXG4gICAgICAgICAgICAgICAgICAgIFwic3RvcmFnZS50eXBlXCIsIFwidGV4dFwiLCBcImVudGl0eS5uYW1lLmZ1bmN0aW9uXCIsIFwidGV4dFwiLCBcInBhcmVuLmxwYXJlblwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICByZWdleCA6IFwiKGZ1bmN0aW9uKShcXFxccyspKFwiICsgaWRlbnRpZmllclJlICsgXCIpKFxcXFxzKikoXFxcXCgpXCIsXG4gICAgICAgICAgICAgICAgbmV4dDogXCJmdW5jdGlvbl9hcmd1bWVudHNcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogW1xuICAgICAgICAgICAgICAgICAgICBcImVudGl0eS5uYW1lLmZ1bmN0aW9uXCIsIFwidGV4dFwiLCBcInB1bmN0dWF0aW9uLm9wZXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIFwidGV4dFwiLCBcInN0b3JhZ2UudHlwZVwiLCBcInRleHRcIiwgXCJwYXJlbi5scGFyZW5cIlxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgcmVnZXggOiBcIihcIiArIGlkZW50aWZpZXJSZSArIFwiKShcXFxccyopKDopKFxcXFxzKikoZnVuY3Rpb24pKFxcXFxzKikoXFxcXCgpXCIsXG4gICAgICAgICAgICAgICAgbmV4dDogXCJmdW5jdGlvbl9hcmd1bWVudHNcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogW1xuICAgICAgICAgICAgICAgICAgICBcInRleHRcIiwgXCJ0ZXh0XCIsIFwic3RvcmFnZS50eXBlXCIsIFwidGV4dFwiLCBcInBhcmVuLmxwYXJlblwiXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICByZWdleCA6IFwiKDopKFxcXFxzKikoZnVuY3Rpb24pKFxcXFxzKikoXFxcXCgpXCIsXG4gICAgICAgICAgICAgICAgbmV4dDogXCJmdW5jdGlvbl9hcmd1bWVudHNcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogXCJrZXl3b3JkXCIsXG4gICAgICAgICAgICAgICAgcmVnZXggOiBcIig/OlwiICsga3dCZWZvcmVSZSArIFwiKVxcXFxiXCIsXG4gICAgICAgICAgICAgICAgbmV4dCA6IFwic3RhcnRcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogW1wicHVuY3R1YXRpb24ub3BlcmF0b3JcIiwgXCJzdXBwb3J0LmZ1bmN0aW9uXCJdLFxuICAgICAgICAgICAgICAgIHJlZ2V4IDogLyhcXC4pKHMoPzpoKD86aWZ0fG93KD86TW9kKD86ZWxlc3NEaWFsb2d8YWxEaWFsb2cpfEhlbHApKXxjcm9sbCg/Olh8QnkoPzpQYWdlc3xMaW5lcyk/fFl8VG8pP3x0KD86b3B8cmlrZSl8aSg/Om58emVUb0NvbnRlbnR8ZGViYXJ8Z25UZXh0KXxvcnR8dSg/OnB8Yig/OnN0cig/OmluZyk/KT8pfHBsaSg/OmNlfHQpfGUoPzpuZHx0KD86UmUoPzpzaXphYmxlfHF1ZXN0SGVhZGVyKXxNKD86aSg/Om51dGVzfGxsaXNlY29uZHMpfG9udGgpfFNlY29uZHN8SG8oPzp0S2V5c3x1cnMpfFllYXJ8Q3Vyc29yfFRpbWUoPzpvdXQpP3xJbnRlcnZhbHxaT3B0aW9uc3xEYXRlfFVUQyg/Ok0oPzppKD86bnV0ZXN8bGxpc2Vjb25kcyl8b250aCl8U2Vjb25kc3xIb3Vyc3xEYXRlfEZ1bGxZZWFyKXxGdWxsWWVhcnxBY3RpdmUpfGFyY2gpfHFydHxsaWNlfGF2ZVByZWZlcmVuY2VzfG1hbGwpfGgoPzpvbWV8YW5kbGVFdmVudCl8bmF2aWdhdGV8Yyg/Omhhcig/OkNvZGVBdHxBdCl8byg/OnN8big/OmNhdHx0ZXh0dWFsfGZpcm0pfG1waWxlKXxlaWx8bGVhcig/OlRpbWVvdXR8SW50ZXJ2YWwpP3xhKD86cHR1cmVFdmVudHN8bGwpfHJlYXRlKD86U3R5bGVTaGVldHxQb3B1cHxFdmVudE9iamVjdCkpfHQoPzpvKD86R01UU3RyaW5nfFMoPzp0cmluZ3xvdXJjZSl8VSg/OlRDU3RyaW5nfHBwZXJDYXNlKXxMbyg/OmNhbGVTdHJpbmd8d2VyQ2FzZSkpfGVzdHxhKD86bnxpbnQoPzpFbmFibGVkKT8pKXxpKD86cyg/Ok5hTnxGaW5pdGUpfG5kZXhPZnx0YWxpY3MpfGQoPzppc2FibGVFeHRlcm5hbENhcHR1cmV8dW1wfGV0YWNoRXZlbnQpfHUoPzpuKD86c2hpZnR8dGFpbnR8ZXNjYXBlfHdhdGNoKXxwZGF0ZUNvbW1hbmRzKXxqKD86b2lufGF2YUVuYWJsZWQpfHAoPzpvKD86cHx3KXx1c2h8bHVnaW5zLnJlZnJlc2h8YSg/OmRkaW5nc3xyc2UoPzpJbnR8RmxvYXQpPyl8cig/OmludHxvbXB0fGVmZXJlbmNlKSl8ZSg/OnNjYXBlfG5hYmxlRXh0ZXJuYWxDYXB0dXJlfHZhbHxsZW1lbnRGcm9tUG9pbnR8eCg/OnB8ZWMoPzpTY3JpcHR8Q29tbWFuZCk/KSl8dmFsdWVPZnxVVEN8cXVlcnlDb21tYW5kKD86U3RhdGV8SW5kZXRlcm18RW5hYmxlZHxWYWx1ZSl8Zig/OmkoPzpuZHxsZSg/Ok1vZGlmaWVkRGF0ZXxTaXplfENyZWF0ZWREYXRlfFVwZGF0ZWREYXRlKXx4ZWQpfG8oPzpudCg/OnNpemV8Y29sb3IpfHJ3YXJkKXxsb29yfHJvbUNoYXJDb2RlKXx3YXRjaHxsKD86aW5rfG8oPzphZHxnKXxhc3RJbmRleE9mKXxhKD86c2lufG5jaG9yfGNvc3x0KD86dGFjaEV2ZW50fG9ifGFuKD86Mik/KXxwcGx5fGxlcnR8Yig/OnN8b3J0KSl8cig/Om91KD86bmR8dGVFdmVudHMpfGUoPzpzaXplKD86Qnl8VG8pfGNhbGN8dHVyblZhbHVlfHBsYWNlfHZlcnNlfGwoPzpvYWR8ZWFzZSg/OkNhcHR1cmV8RXZlbnRzKSkpfGFuZG9tKXxnKD86b3xldCg/OlJlc3BvbnNlSGVhZGVyfE0oPzppKD86bnV0ZXN8bGxpc2Vjb25kcyl8b250aCl8U2UoPzpjb25kc3xsZWN0aW9uKXxIb3Vyc3xZZWFyfFRpbWUoPzp6b25lT2Zmc2V0KT98RGEoPzp5fHRlKXxVVEMoPzpNKD86aSg/Om51dGVzfGxsaXNlY29uZHMpfG9udGgpfFNlY29uZHN8SG91cnN8RGEoPzp5fHRlKXxGdWxsWWVhcil8RnVsbFllYXJ8QSg/OnR0ZW50aW9ufGxsUmVzcG9uc2VIZWFkZXJzKSkpfG0oPzppbnxvdmUoPzpCKD86eXxlbG93KXxUbyg/OkFic29sdXRlKT98QWJvdmUpfGVyZ2VBdHRyaWJ1dGVzfGEoPzp0Y2h8cmdpbnN8eCkpfGIoPzp0b2F8aWd8byg/OmxkfHJkZXJXaWR0aHMpfGxpbmt8YWNrKSlcXGIoPz1cXCgpL1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogW1wicHVuY3R1YXRpb24ub3BlcmF0b3JcIiwgXCJzdXBwb3J0LmZ1bmN0aW9uLmRvbVwiXSxcbiAgICAgICAgICAgICAgICByZWdleCA6IC8oXFwuKShzKD86dWIoPzpzdHJpbmdEYXRhfG1pdCl8cGxpdFRleHR8ZSg/OnQoPzpOYW1lZEl0ZW18QXR0cmlidXRlKD86Tm9kZSk/KXxsZWN0KSl8aGFzKD86Q2hpbGROb2Rlc3xGZWF0dXJlKXxuYW1lZEl0ZW18Yyg/OmwoPzppY2t8byg/OnNlfG5lTm9kZSkpfHJlYXRlKD86Qyg/Om9tbWVudHxEQVRBU2VjdGlvbnxhcHRpb24pfFQoPzpIZWFkfGV4dE5vZGV8Rm9vdCl8RG9jdW1lbnRGcmFnbWVudHxQcm9jZXNzaW5nSW5zdHJ1Y3Rpb258RSg/Om50aXR5UmVmZXJlbmNlfGxlbWVudCl8QXR0cmlidXRlKSl8dGFiSW5kZXh8aSg/Om5zZXJ0KD86Um93fEJlZm9yZXxDZWxsfERhdGEpfHRlbSl8b3BlbnxkZWxldGUoPzpSb3d8Qyg/OmVsbHxhcHRpb24pfFQoPzpIZWFkfEZvb3QpfERhdGEpfGZvY3VzfHdyaXRlKD86bG4pP3xhKD86ZGR8cHBlbmQoPzpDaGlsZHxEYXRhKSl8cmUoPzpzZXR8cGxhY2UoPzpDaGlsZHxEYXRhKXxtb3ZlKD86TmFtZWRJdGVtfENoaWxkfEF0dHJpYnV0ZSg/Ok5vZGUpPyk/KXxnZXQoPzpOYW1lZEl0ZW18RWxlbWVudCg/OnNCeSg/Ok5hbWV8VGFnTmFtZSl8QnlJZCl8QXR0cmlidXRlKD86Tm9kZSk/KXxibHVyKVxcYig/PVxcKCkvXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW4gOiBbXCJwdW5jdHVhdGlvbi5vcGVyYXRvclwiLCBcInN1cHBvcnQuY29uc3RhbnRcIl0sXG4gICAgICAgICAgICAgICAgcmVnZXggOiAvKFxcLikocyg/OnlzdGVtTGFuZ3VhZ2V8Y3IoPzppcHRzfG9sbGJhcnN8ZWVuKD86WHxZfFRvcHxMZWZ0KSl8dCg/OnlsZSg/OlNoZWV0cyk/fGF0dXMoPzpUZXh0fGJhcik/KXxpYmxpbmcoPzpCZWxvd3xBYm92ZSl8b3VyY2V8dWZmaXhlc3xlKD86Y3VyaXR5KD86UG9saWN5KT98bCg/OmVjdGlvbnxmKSkpfGgoPzppc3Rvcnl8b3N0KD86bmFtZSk/fGFzKD86aHxGb2N1cykpfHl8WCg/Ok1MRG9jdW1lbnR8U0xEb2N1bWVudCl8big/OmV4dHxhbWUoPzpzcGFjZSg/OnN8VVJJKXxQcm9wKSl8TSg/OklOX1ZBTFVFfEFYX1ZBTFVFKXxjKD86aGFyYWN0ZXJTZXR8byg/Om4oPzpzdHJ1Y3Rvcnx0cm9sbGVycyl8b2tpZUVuYWJsZWR8bG9yRGVwdGh8bXAoPzpvbmVudHN8bGV0ZSkpfHVycmVudHxwdUNsYXNzfGwoPzppKD86cCg/OmJvYXJkRGF0YSk/fGVudEluZm9ybWF0aW9uKXxvc2VkfGFzc2VzKXxhbGxlKD86ZXxyKXxyeXB0byl8dCg/Om8oPzpvbGJhcnxwKXxleHQoPzpUcmFuc2Zvcm18SW5kZW50fERlY29yYXRpb258QWxpZ24pfGFncyl8U1FSVCg/OjFfMnwyKXxpKD86big/Om5lcig/OkhlaWdodHxXaWR0aCl8cHV0KXxkc3xnbm9yZUNhc2UpfHpJbmRleHxvKD86c2NwdXxuKD86cmVhZHlzdGF0ZWNoYW5nZXxMaW5lKXx1dGVyKD86SGVpZ2h0fFdpZHRoKXxwKD86c1Byb2ZpbGV8ZW5lcil8ZmZzY3JlZW5CdWZmZXJpbmcpfE5FR0FUSVZFX0lORklOSVRZfGQoPzppKD86c3BsYXl8YWxvZyg/OkhlaWdodHxUb3B8V2lkdGh8TGVmdHxBcmd1bWVudHMpfHJlY3Rvcmllcyl8ZSg/OnNjcmlwdGlvbnxmYXVsdCg/OlN0YXR1c3xDaCg/OmVja2VkfGFyc2V0KXxWaWV3KSkpfHUoPzpzZXIoPzpQcm9maWxlfExhbmd1YWdlfEFnZW50KXxuKD86aXF1ZUlEfGRlZmluZWQpfHBkYXRlSW50ZXJ2YWwpfF9jb250ZW50fHAoPzppeGVsRGVwdGh8b3J0fGVyc29uYWxiYXJ8a2NzMTF8bCg/OnVnaW5zfGF0Zm9ybSl8YSg/OnRobmFtZXxkZGluZyg/OlJpZ2h0fEJvdHRvbXxUb3B8TGVmdCl8cmVudCg/OldpbmRvd3xMYXllcik/fGdlKD86WCg/Ok9mZnNldCk/fFkoPzpPZmZzZXQpPykpfHIoPzpvKD86dG8oPzpjb2x8dHlwZSl8ZHVjdCg/OlN1Yik/fG1wdGVyKXxlKD86dmlvdXN8Zml4KSkpfGUoPzpuKD86Y29kaW5nfGFibGVkUGx1Z2luKXx4KD86dGVybmFsfHBhbmRvKXxtYmVkcyl8dig/OmlzaWJpbGl0eXxlbmRvcig/OlN1Yik/fExpbmtjb2xvcil8VVJMVW5lbmNvZGVkfFAoPzpJfE9TSVRJVkVfSU5GSU5JVFkpfGYoPzppbGVuYW1lfG8oPzpudCg/OlNpemV8RmFtaWx5fFdlaWdodCl8cm1OYW1lKXxyYW1lKD86c3xFbGVtZW50KXxnQ29sb3IpfEV8d2hpdGVTcGFjZXxsKD86aSg/OnN0U3R5bGVUeXBlfG4oPzplSGVpZ2h0fGtDb2xvcikpfG8oPzpjYSg/OnRpb24oPzpiYXIpP3xsTmFtZSl8d3NyYyl8ZSg/Om5ndGh8ZnQoPzpDb250ZXh0KT8pfGEoPzpzdCg/Ok0oPzpvZGlmaWVkfGF0Y2gpfEluZGV4fFBhcmVuKXx5ZXIoPzpzfFgpfG5ndWFnZSkpfGEoPzpwcCg/Ok1pbm9yVmVyc2lvbnxOYW1lfENvKD86ZGVOYW1lfHJlKXxWZXJzaW9uKXx2YWlsKD86SGVpZ2h0fFRvcHxXaWR0aHxMZWZ0KXxsbHxyKD86aXR5fGd1bWVudHMpfExpbmtjb2xvcnxib3ZlKXxyKD86aWdodCg/OkNvbnRleHQpP3xlKD86c3BvbnNlKD86WE1MfFRleHQpfGFkeVN0YXRlKSl8Z2xvYmFsfHh8bSg/OmltZVR5cGVzfHVsdGlsaW5lfGVudWJhcnxhcmdpbig/OlJpZ2h0fEJvdHRvbXxUb3B8TGVmdCkpfEwoPzpOKD86MTB8Mil8T0coPzoxMEV8MkUpKXxiKD86byg/OnR0b218cmRlcig/OldpZHRofFJpZ2h0V2lkdGh8Qm90dG9tV2lkdGh8U3R5bGV8Q29sb3J8VG9wV2lkdGh8TGVmdFdpZHRoKSl8dWZmZXJEZXB0aHxlbG93fGFja2dyb3VuZCg/OkNvbG9yfEltYWdlKSkpXFxiL1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogW1wic3VwcG9ydC5jb25zdGFudFwiXSxcbiAgICAgICAgICAgICAgICByZWdleCA6IC90aGF0XFxiL1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogW1wic3RvcmFnZS50eXBlXCIsIFwicHVuY3R1YXRpb24ub3BlcmF0b3JcIiwgXCJzdXBwb3J0LmZ1bmN0aW9uLmZpcmVidWdcIl0sXG4gICAgICAgICAgICAgICAgcmVnZXggOiAvKGNvbnNvbGUpKFxcLikod2FybnxpbmZvfGxvZ3xlcnJvcnx0aW1lfHRyYWNlfHRpbWVFbmR8YXNzZXJ0KVxcYi9cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA6IGtleXdvcmRNYXBwZXIsXG4gICAgICAgICAgICAgICAgcmVnZXggOiBpZGVudGlmaWVyUmVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA6IFwia2V5d29yZC5vcGVyYXRvclwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4IDogLy0tfFxcK1xcK3w9PT18PT18PXwhPXwhPT18PD18Pj18PDw9fD4+PXw+Pj49fDw+fDx8PnwhfCYmfFxcfFxcfHxcXD9cXDp8WyEkJSYqK1xcLX5cXC9eXT0/LyxcbiAgICAgICAgICAgICAgICBuZXh0ICA6IFwic3RhcnRcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogXCJwdW5jdHVhdGlvbi5vcGVyYXRvclwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4IDogL1s/Oiw7Ll0vLFxuICAgICAgICAgICAgICAgIG5leHQgIDogXCJzdGFydFwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW4gOiBcInBhcmVuLmxwYXJlblwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4IDogL1tcXFsoe10vLFxuICAgICAgICAgICAgICAgIG5leHQgIDogXCJzdGFydFwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW4gOiBcInBhcmVuLnJwYXJlblwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4IDogL1tcXF0pfV0vXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW46IFwiY29tbWVudFwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiAvXiMhLiokL1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcInN0YXJ0XCI6IFtcbiAgICAgICAgICAgIERvY0NvbW1lbnRIaWdobGlnaHRSdWxlcy5nZXRTdGFydFJ1bGUoXCJkb2Mtc3RhcnRcIiksXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG9rZW4gOiBcImNvbW1lbnRcIiwgLy8gbXVsdGkgbGluZSBjb21tZW50XG4gICAgICAgICAgICAgICAgcmVnZXggOiBcIlxcXFwvXFxcXCpcIixcbiAgICAgICAgICAgICAgICBuZXh0IDogXCJjb21tZW50X3JlZ2V4X2FsbG93ZWRcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogXCJjb21tZW50XCIsXG4gICAgICAgICAgICAgICAgcmVnZXggOiBcIlxcXFwvXFxcXC9cIixcbiAgICAgICAgICAgICAgICBuZXh0IDogXCJsaW5lX2NvbW1lbnRfcmVnZXhfYWxsb3dlZFwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW46IFwic3RyaW5nLnJlZ2V4cFwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiBcIlxcXFwvXCIsXG4gICAgICAgICAgICAgICAgbmV4dDogXCJyZWdleFwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW4gOiBcInRleHRcIixcbiAgICAgICAgICAgICAgICByZWdleCA6IFwiXFxcXHMrfF4kXCIsXG4gICAgICAgICAgICAgICAgbmV4dCA6IFwic3RhcnRcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuOiBcImVtcHR5XCIsXG4gICAgICAgICAgICAgICAgcmVnZXg6IFwiXCIsXG4gICAgICAgICAgICAgICAgbmV4dDogXCJub19yZWdleFwiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwicmVnZXhcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRva2VuOiBcInJlZ2V4cC5rZXl3b3JkLm9wZXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgcmVnZXg6IFwiXFxcXFxcXFwoPzp1W1xcXFxkYS1mQS1GXXs0fXx4W1xcXFxkYS1mQS1GXXsyfXwuKVwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW46IFwic3RyaW5nLnJlZ2V4cFwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiBcIi9bc3huZ2lteV0qXCIsXG4gICAgICAgICAgICAgICAgbmV4dDogXCJub19yZWdleFwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW4gOiBcImludmFsaWRcIixcbiAgICAgICAgICAgICAgICByZWdleDogL1xce1xcZCtcXGIsP1xcZCpcXH1bKypdfFsrKiReP11bKypdfFskXl1bP118XFw/ezMsfS9cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA6IFwiY29uc3RhbnQubGFuZ3VhZ2UuZXNjYXBlXCIsXG4gICAgICAgICAgICAgICAgcmVnZXg6IC9cXChcXD9bOj0hXXxcXCl8XFx7XFxkK1xcYiw/XFxkKlxcfXxbKypdXFw/fFsoKSReKyo/Ll0vXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW4gOiBcImNvbnN0YW50Lmxhbmd1YWdlLmRlbGltaXRlclwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiAvXFx8L1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuOiBcImNvbnN0YW50Lmxhbmd1YWdlLmVzY2FwZVwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiAvXFxbXFxePy8sXG4gICAgICAgICAgICAgICAgbmV4dDogXCJyZWdleF9jaGFyYWN0ZXJfY2xhc3NcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuOiBcImVtcHR5XCIsXG4gICAgICAgICAgICAgICAgcmVnZXg6IFwiJFwiLFxuICAgICAgICAgICAgICAgIG5leHQ6IFwibm9fcmVnZXhcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRUb2tlbjogXCJzdHJpbmcucmVnZXhwXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJyZWdleF9jaGFyYWN0ZXJfY2xhc3NcIjogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRva2VuOiBcInJlZ2V4cC5jaGFyY2xhc3Mua2V5d29yZC5vcGVyYXRvclwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiBcIlxcXFxcXFxcKD86dVtcXFxcZGEtZkEtRl17NH18eFtcXFxcZGEtZkEtRl17Mn18LilcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuOiBcImNvbnN0YW50Lmxhbmd1YWdlLmVzY2FwZVwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiBcIl1cIixcbiAgICAgICAgICAgICAgICBuZXh0OiBcInJlZ2V4XCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0b2tlbjogXCJjb25zdGFudC5sYW5ndWFnZS5lc2NhcGVcIixcbiAgICAgICAgICAgICAgICByZWdleDogXCItXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0b2tlbjogXCJlbXB0eVwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4OiBcIiRcIixcbiAgICAgICAgICAgICAgICBuZXh0OiBcIm5vX3JlZ2V4XCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VG9rZW46IFwic3RyaW5nLnJlZ2V4cC5jaGFyYWNodGVyY2xhc3NcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBcImZ1bmN0aW9uX2FyZ3VtZW50c1wiOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdG9rZW46IFwidmFyaWFibGUucGFyYW1ldGVyXCIsXG4gICAgICAgICAgICAgICAgcmVnZXg6IGlkZW50aWZpZXJSZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuOiBcInB1bmN0dWF0aW9uLm9wZXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgcmVnZXg6IFwiWywgXStcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuOiBcInB1bmN0dWF0aW9uLm9wZXJhdG9yXCIsXG4gICAgICAgICAgICAgICAgcmVnZXg6IFwiJFwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW46IFwiZW1wdHlcIixcbiAgICAgICAgICAgICAgICByZWdleDogXCJcIixcbiAgICAgICAgICAgICAgICBuZXh0OiBcIm5vX3JlZ2V4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgXCJjb21tZW50X3JlZ2V4X2FsbG93ZWRcIiA6IFtcbiAgICAgICAgICAgIERvY0NvbW1lbnRIaWdobGlnaHRSdWxlcy5nZXRUYWdSdWxlKCksXG4gICAgICAgICAgICB7dG9rZW4gOiBcImNvbW1lbnRcIiwgcmVnZXggOiBcIlxcXFwqXFxcXC9cIiwgbmV4dCA6IFwic3RhcnRcIn0sXG4gICAgICAgICAgICB7ZGVmYXVsdFRva2VuIDogXCJjb21tZW50XCIsIGNhc2VJbnNlbnNpdGl2ZTogdHJ1ZX1cbiAgICAgICAgXSxcbiAgICAgICAgXCJjb21tZW50XCIgOiBbXG4gICAgICAgICAgICBEb2NDb21tZW50SGlnaGxpZ2h0UnVsZXMuZ2V0VGFnUnVsZSgpLFxuICAgICAgICAgICAge3Rva2VuIDogXCJjb21tZW50XCIsIHJlZ2V4IDogXCJcXFxcKlxcXFwvXCIsIG5leHQgOiBcIm5vX3JlZ2V4XCJ9LFxuICAgICAgICAgICAge2RlZmF1bHRUb2tlbiA6IFwiY29tbWVudFwiLCBjYXNlSW5zZW5zaXRpdmU6IHRydWV9XG4gICAgICAgIF0sXG4gICAgICAgIFwibGluZV9jb21tZW50X3JlZ2V4X2FsbG93ZWRcIiA6IFtcbiAgICAgICAgICAgIERvY0NvbW1lbnRIaWdobGlnaHRSdWxlcy5nZXRUYWdSdWxlKCksXG4gICAgICAgICAgICB7dG9rZW4gOiBcImNvbW1lbnRcIiwgcmVnZXggOiBcIiR8XlwiLCBuZXh0IDogXCJzdGFydFwifSxcbiAgICAgICAgICAgIHtkZWZhdWx0VG9rZW4gOiBcImNvbW1lbnRcIiwgY2FzZUluc2Vuc2l0aXZlOiB0cnVlfVxuICAgICAgICBdLFxuICAgICAgICBcImxpbmVfY29tbWVudFwiIDogW1xuICAgICAgICAgICAgRG9jQ29tbWVudEhpZ2hsaWdodFJ1bGVzLmdldFRhZ1J1bGUoKSxcbiAgICAgICAgICAgIHt0b2tlbiA6IFwiY29tbWVudFwiLCByZWdleCA6IFwiJHxeXCIsIG5leHQgOiBcIm5vX3JlZ2V4XCJ9LFxuICAgICAgICAgICAge2RlZmF1bHRUb2tlbiA6IFwiY29tbWVudFwiLCBjYXNlSW5zZW5zaXRpdmU6IHRydWV9XG4gICAgICAgIF0sXG4gICAgICAgIFwicXFzdHJpbmdcIiA6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA6IFwiY29uc3RhbnQubGFuZ3VhZ2UuZXNjYXBlXCIsXG4gICAgICAgICAgICAgICAgcmVnZXggOiBlc2NhcGVkUmVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgcmVnZXggOiBcIlxcXFxcXFxcJFwiLFxuICAgICAgICAgICAgICAgIG5leHQgIDogXCJxcXN0cmluZ1wiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW4gOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIHJlZ2V4IDogJ1wifCQnLFxuICAgICAgICAgICAgICAgIG5leHQgIDogXCJub19yZWdleFwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdFRva2VuOiBcInN0cmluZ1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIFwicXN0cmluZ1wiIDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRva2VuIDogXCJjb25zdGFudC5sYW5ndWFnZS5lc2NhcGVcIixcbiAgICAgICAgICAgICAgICByZWdleCA6IGVzY2FwZWRSZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICByZWdleCA6IFwiXFxcXFxcXFwkXCIsXG4gICAgICAgICAgICAgICAgbmV4dCAgOiBcInFzdHJpbmdcIlxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICByZWdleCA6IFwiJ3wkXCIsXG4gICAgICAgICAgICAgICAgbmV4dCAgOiBcIm5vX3JlZ2V4XCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VG9rZW46IFwic3RyaW5nXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgIH07XG4gICAgXG4gICAgXG4gICAgaWYgKCFvcHRpb25zIHx8ICFvcHRpb25zLm5vRVM2KSB7XG4gICAgICAgIHRoaXMuJHJ1bGVzLm5vX3JlZ2V4LnVuc2hpZnQoe1xuICAgICAgICAgICAgcmVnZXg6IFwiW3t9XVwiLCBvbk1hdGNoOiBmdW5jdGlvbih2YWwsIHN0YXRlLCBzdGFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dCA9IHZhbCA9PSBcIntcIiA/IHRoaXMubmV4dFN0YXRlIDogXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAodmFsID09IFwie1wiICYmIHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay51bnNoaWZ0KFwic3RhcnRcIiwgc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwYXJlblwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsID09IFwifVwiICYmIHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHQgPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0LmluZGV4T2YoXCJzdHJpbmdcIikgIT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwYXJlbi5xdWFzaS5lbmRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbCA9PSBcIntcIiA/IFwicGFyZW4ubHBhcmVuXCIgOiBcInBhcmVuLnJwYXJlblwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHRTdGF0ZTogXCJzdGFydFwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHRva2VuIDogXCJzdHJpbmcucXVhc2kuc3RhcnRcIixcbiAgICAgICAgICAgIHJlZ2V4IDogL2AvLFxuICAgICAgICAgICAgcHVzaCAgOiBbe1xuICAgICAgICAgICAgICAgIHRva2VuIDogXCJjb25zdGFudC5sYW5ndWFnZS5lc2NhcGVcIixcbiAgICAgICAgICAgICAgICByZWdleCA6IGVzY2FwZWRSZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHRva2VuIDogXCJwYXJlbi5xdWFzaS5zdGFydFwiLFxuICAgICAgICAgICAgICAgIHJlZ2V4IDogL1xcJHsvLFxuICAgICAgICAgICAgICAgIHB1c2ggIDogXCJzdGFydFwiXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgdG9rZW4gOiBcInN0cmluZy5xdWFzaS5lbmRcIixcbiAgICAgICAgICAgICAgICByZWdleCA6IC9gLyxcbiAgICAgICAgICAgICAgICBuZXh0ICA6IFwicG9wXCJcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0VG9rZW46IFwic3RyaW5nLnF1YXNpXCJcbiAgICAgICAgICAgIH1dXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLmVtYmVkUnVsZXMoRG9jQ29tbWVudEhpZ2hsaWdodFJ1bGVzLCBcImRvYy1cIixcbiAgICAgICAgWyBEb2NDb21tZW50SGlnaGxpZ2h0UnVsZXMuZ2V0RW5kUnVsZShcIm5vX3JlZ2V4XCIpIF0pO1xuICAgIFxuICAgIHRoaXMubm9ybWFsaXplUnVsZXMoKTtcbn07XG5cbm9vcC5pbmhlcml0cyhKYXZhU2NyaXB0SGlnaGxpZ2h0UnVsZXMsIFRleHRIaWdobGlnaHRSdWxlcyk7XG5cbmV4cG9ydHMuSmF2YVNjcmlwdEhpZ2hsaWdodFJ1bGVzID0gSmF2YVNjcmlwdEhpZ2hsaWdodFJ1bGVzO1xufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW9kZS9tYXRjaGluZ19icmFjZV9vdXRkZW50XCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgUmFuZ2UgPSBhY2VxdWlyZShcIi4uL3JhbmdlXCIpLlJhbmdlO1xuXG52YXIgTWF0Y2hpbmdCcmFjZU91dGRlbnQgPSBmdW5jdGlvbigpIHt9O1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLmNoZWNrT3V0ZGVudCA9IGZ1bmN0aW9uKGxpbmUsIGlucHV0KSB7XG4gICAgICAgIGlmICghIC9eXFxzKyQvLnRlc3QobGluZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIC9eXFxzKlxcfS8udGVzdChpbnB1dCk7XG4gICAgfTtcblxuICAgIHRoaXMuYXV0b091dGRlbnQgPSBmdW5jdGlvbihkb2MsIHJvdykge1xuICAgICAgICB2YXIgbGluZSA9IGRvYy5nZXRMaW5lKHJvdyk7XG4gICAgICAgIHZhciBtYXRjaCA9IGxpbmUubWF0Y2goL14oXFxzKlxcfSkvKTtcblxuICAgICAgICBpZiAoIW1hdGNoKSByZXR1cm4gMDtcblxuICAgICAgICB2YXIgY29sdW1uID0gbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICB2YXIgb3BlbkJyYWNlUG9zID0gZG9jLmZpbmRNYXRjaGluZ0JyYWNrZXQoe3Jvdzogcm93LCBjb2x1bW46IGNvbHVtbn0pO1xuXG4gICAgICAgIGlmICghb3BlbkJyYWNlUG9zIHx8IG9wZW5CcmFjZVBvcy5yb3cgPT0gcm93KSByZXR1cm4gMDtcblxuICAgICAgICB2YXIgaW5kZW50ID0gdGhpcy4kZ2V0SW5kZW50KGRvYy5nZXRMaW5lKG9wZW5CcmFjZVBvcy5yb3cpKTtcbiAgICAgICAgZG9jLnJlcGxhY2UobmV3IFJhbmdlKHJvdywgMCwgcm93LCBjb2x1bW4tMSksIGluZGVudCk7XG4gICAgfTtcblxuICAgIHRoaXMuJGdldEluZGVudCA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGxpbmUubWF0Y2goL15cXHMqLylbMF07XG4gICAgfTtcblxufSkuY2FsbChNYXRjaGluZ0JyYWNlT3V0ZGVudC5wcm90b3R5cGUpO1xuXG5leHBvcnRzLk1hdGNoaW5nQnJhY2VPdXRkZW50ID0gTWF0Y2hpbmdCcmFjZU91dGRlbnQ7XG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb2RlL2JlaGF2aW91ci9jc3R5bGVcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2UvbW9kZS9iZWhhdmlvdXJcIixcImFjZS90b2tlbl9pdGVyYXRvclwiLFwiYWNlL2xpYi9sYW5nXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG9vcCA9IGFjZXF1aXJlKFwiLi4vLi4vbGliL29vcFwiKTtcbnZhciBCZWhhdmlvdXIgPSBhY2VxdWlyZShcIi4uL2JlaGF2aW91clwiKS5CZWhhdmlvdXI7XG52YXIgVG9rZW5JdGVyYXRvciA9IGFjZXF1aXJlKFwiLi4vLi4vdG9rZW5faXRlcmF0b3JcIikuVG9rZW5JdGVyYXRvcjtcbnZhciBsYW5nID0gYWNlcXVpcmUoXCIuLi8uLi9saWIvbGFuZ1wiKTtcblxudmFyIFNBRkVfSU5TRVJUX0lOX1RPS0VOUyA9XG4gICAgW1widGV4dFwiLCBcInBhcmVuLnJwYXJlblwiLCBcInB1bmN0dWF0aW9uLm9wZXJhdG9yXCJdO1xudmFyIFNBRkVfSU5TRVJUX0JFRk9SRV9UT0tFTlMgPVxuICAgIFtcInRleHRcIiwgXCJwYXJlbi5ycGFyZW5cIiwgXCJwdW5jdHVhdGlvbi5vcGVyYXRvclwiLCBcImNvbW1lbnRcIl07XG5cbnZhciBjb250ZXh0O1xudmFyIGNvbnRleHRDYWNoZSA9IHt9O1xudmFyIGluaXRDb250ZXh0ID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgdmFyIGlkID0gLTE7XG4gICAgaWYgKGVkaXRvci5tdWx0aVNlbGVjdCkge1xuICAgICAgICBpZCA9IGVkaXRvci5zZWxlY3Rpb24uaW5kZXg7XG4gICAgICAgIGlmIChjb250ZXh0Q2FjaGUucmFuZ2VDb3VudCAhPSBlZGl0b3IubXVsdGlTZWxlY3QucmFuZ2VDb3VudClcbiAgICAgICAgICAgIGNvbnRleHRDYWNoZSA9IHtyYW5nZUNvdW50OiBlZGl0b3IubXVsdGlTZWxlY3QucmFuZ2VDb3VudH07XG4gICAgfVxuICAgIGlmIChjb250ZXh0Q2FjaGVbaWRdKVxuICAgICAgICByZXR1cm4gY29udGV4dCA9IGNvbnRleHRDYWNoZVtpZF07XG4gICAgY29udGV4dCA9IGNvbnRleHRDYWNoZVtpZF0gPSB7XG4gICAgICAgIGF1dG9JbnNlcnRlZEJyYWNrZXRzOiAwLFxuICAgICAgICBhdXRvSW5zZXJ0ZWRSb3c6IC0xLFxuICAgICAgICBhdXRvSW5zZXJ0ZWRMaW5lRW5kOiBcIlwiLFxuICAgICAgICBtYXliZUluc2VydGVkQnJhY2tldHM6IDAsXG4gICAgICAgIG1heWJlSW5zZXJ0ZWRSb3c6IC0xLFxuICAgICAgICBtYXliZUluc2VydGVkTGluZVN0YXJ0OiBcIlwiLFxuICAgICAgICBtYXliZUluc2VydGVkTGluZUVuZDogXCJcIlxuICAgIH07XG59O1xuXG52YXIgQ3N0eWxlQmVoYXZpb3VyID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hZGQoXCJicmFjZXNcIiwgXCJpbnNlcnRpb25cIiwgZnVuY3Rpb24oc3RhdGUsIGFjdGlvbiwgZWRpdG9yLCBzZXNzaW9uLCB0ZXh0KSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cpO1xuICAgICAgICBpZiAodGV4dCA9PSAneycpIHtcbiAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZXNzaW9uLmRvYy5nZXRUZXh0UmFuZ2Uoc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAhPT0gXCJcIiAmJiBzZWxlY3RlZCAhPT0gXCJ7XCIgJiYgZWRpdG9yLmdldFdyYXBCZWhhdmlvdXJzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ3snICsgc2VsZWN0ZWQgKyAnfScsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChDc3R5bGVCZWhhdmlvdXIuaXNTYW5lSW5zZXJ0aW9uKGVkaXRvciwgc2Vzc2lvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoL1tcXF1cXH1cXCldLy50ZXN0KGxpbmVbY3Vyc29yLmNvbHVtbl0pIHx8IGVkaXRvci5pbk11bHRpU2VsZWN0TW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucmVjb3JkQXV0b0luc2VydChlZGl0b3IsIHNlc3Npb24sIFwifVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICd7fScsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIENzdHlsZUJlaGF2aW91ci5yZWNvcmRNYXliZUluc2VydChlZGl0b3IsIHNlc3Npb24sIFwie1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICd7JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogWzEsIDFdXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRleHQgPT0gJ30nKSB7XG4gICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKGN1cnNvci5jb2x1bW4sIGN1cnNvci5jb2x1bW4gKyAxKTtcbiAgICAgICAgICAgIGlmIChyaWdodENoYXIgPT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gc2Vzc2lvbi4kZmluZE9wZW5pbmdCcmFja2V0KCd9Jywge2NvbHVtbjogY3Vyc29yLmNvbHVtbiArIDEsIHJvdzogY3Vyc29yLnJvd30pO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGluZyAhPT0gbnVsbCAmJiBDc3R5bGVCZWhhdmlvdXIuaXNBdXRvSW5zZXJ0ZWRDbG9zaW5nKGN1cnNvciwgbGluZSwgdGV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgQ3N0eWxlQmVoYXZpb3VyLnBvcEF1dG9JbnNlcnRlZENsb3NpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBbMSwgMV1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCA9PSBcIlxcblwiIHx8IHRleHQgPT0gXCJcXHJcXG5cIikge1xuICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciBjbG9zaW5nID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChDc3R5bGVCZWhhdmlvdXIuaXNNYXliZUluc2VydGVkQ2xvc2luZyhjdXJzb3IsIGxpbmUpKSB7XG4gICAgICAgICAgICAgICAgY2xvc2luZyA9IGxhbmcuc3RyaW5nUmVwZWF0KFwifVwiLCBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRCcmFja2V0cyk7XG4gICAgICAgICAgICAgICAgQ3N0eWxlQmVoYXZpb3VyLmNsZWFyTWF5YmVJbnNlcnRlZENsb3NpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByaWdodENoYXIgPSBsaW5lLnN1YnN0cmluZyhjdXJzb3IuY29sdW1uLCBjdXJzb3IuY29sdW1uICsgMSk7XG4gICAgICAgICAgICBpZiAocmlnaHRDaGFyID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3BlbkJyYWNlUG9zID0gc2Vzc2lvbi5maW5kTWF0Y2hpbmdCcmFja2V0KHtyb3c6IGN1cnNvci5yb3csIGNvbHVtbjogY3Vyc29yLmNvbHVtbisxfSwgJ30nKTtcbiAgICAgICAgICAgICAgICBpZiAoIW9wZW5CcmFjZVBvcylcbiAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0X2luZGVudCA9IHRoaXMuJGdldEluZGVudChzZXNzaW9uLmdldExpbmUob3BlbkJyYWNlUG9zLnJvdykpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbG9zaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHRfaW5kZW50ID0gdGhpcy4kZ2V0SW5kZW50KGxpbmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIuY2xlYXJNYXliZUluc2VydGVkQ2xvc2luZygpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSBuZXh0X2luZGVudCArIHNlc3Npb24uZ2V0VGFiU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGV4dDogJ1xcbicgKyBpbmRlbnQgKyAnXFxuJyArIG5leHRfaW5kZW50ICsgY2xvc2luZyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCBpbmRlbnQubGVuZ3RoLCAxLCBpbmRlbnQubGVuZ3RoXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIENzdHlsZUJlaGF2aW91ci5jbGVhck1heWJlSW5zZXJ0ZWRDbG9zaW5nKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuYWRkKFwiYnJhY2VzXCIsIFwiZGVsZXRpb25cIiwgZnVuY3Rpb24oc3RhdGUsIGFjdGlvbiwgZWRpdG9yLCBzZXNzaW9uLCByYW5nZSkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZXNzaW9uLmRvYy5nZXRUZXh0UmFuZ2UocmFuZ2UpO1xuICAgICAgICBpZiAoIXJhbmdlLmlzTXVsdGlMaW5lKCkgJiYgc2VsZWN0ZWQgPT0gJ3snKSB7XG4gICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKHJhbmdlLnN0YXJ0LnJvdyk7XG4gICAgICAgICAgICB2YXIgcmlnaHRDaGFyID0gbGluZS5zdWJzdHJpbmcocmFuZ2UuZW5kLmNvbHVtbiwgcmFuZ2UuZW5kLmNvbHVtbiArIDEpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSAnfScpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRCcmFja2V0cy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZChcInBhcmVuc1wiLCBcImluc2VydGlvblwiLCBmdW5jdGlvbihzdGF0ZSwgYWN0aW9uLCBlZGl0b3IsIHNlc3Npb24sIHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQgPT0gJygnKSB7XG4gICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgIT09IFwiXCIgJiYgZWRpdG9yLmdldFdyYXBCZWhhdmlvdXJzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJygnICsgc2VsZWN0ZWQgKyAnKScsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChDc3R5bGVCZWhhdmlvdXIuaXNTYW5lSW5zZXJ0aW9uKGVkaXRvciwgc2Vzc2lvbikpIHtcbiAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucmVjb3JkQXV0b0luc2VydChlZGl0b3IsIHNlc3Npb24sIFwiKVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnKCknLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCA9PSAnKScpIHtcbiAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZG9jLmdldExpbmUoY3Vyc29yLnJvdyk7XG4gICAgICAgICAgICB2YXIgcmlnaHRDaGFyID0gbGluZS5zdWJzdHJpbmcoY3Vyc29yLmNvbHVtbiwgY3Vyc29yLmNvbHVtbiArIDEpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSAnKScpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hpbmcgPSBzZXNzaW9uLiRmaW5kT3BlbmluZ0JyYWNrZXQoJyknLCB7Y29sdW1uOiBjdXJzb3IuY29sdW1uICsgMSwgcm93OiBjdXJzb3Iucm93fSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nICE9PSBudWxsICYmIENzdHlsZUJlaGF2aW91ci5pc0F1dG9JbnNlcnRlZENsb3NpbmcoY3Vyc29yLCBsaW5lLCB0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucG9wQXV0b0luc2VydGVkQ2xvc2luZygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGQoXCJwYXJlbnNcIiwgXCJkZWxldGlvblwiLCBmdW5jdGlvbihzdGF0ZSwgYWN0aW9uLCBlZGl0b3IsIHNlc3Npb24sIHJhbmdlKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZCA9IHNlc3Npb24uZG9jLmdldFRleHRSYW5nZShyYW5nZSk7XG4gICAgICAgIGlmICghcmFuZ2UuaXNNdWx0aUxpbmUoKSAmJiBzZWxlY3RlZCA9PSAnKCcpIHtcbiAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZG9jLmdldExpbmUocmFuZ2Uuc3RhcnQucm93KTtcbiAgICAgICAgICAgIHZhciByaWdodENoYXIgPSBsaW5lLnN1YnN0cmluZyhyYW5nZS5zdGFydC5jb2x1bW4gKyAxLCByYW5nZS5zdGFydC5jb2x1bW4gKyAyKTtcbiAgICAgICAgICAgIGlmIChyaWdodENoYXIgPT0gJyknKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UuZW5kLmNvbHVtbisrO1xuICAgICAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGQoXCJicmFja2V0c1wiLCBcImluc2VydGlvblwiLCBmdW5jdGlvbihzdGF0ZSwgYWN0aW9uLCBlZGl0b3IsIHNlc3Npb24sIHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQgPT0gJ1snKSB7XG4gICAgICAgICAgICBpbml0Q29udGV4dChlZGl0b3IpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgIT09IFwiXCIgJiYgZWRpdG9yLmdldFdyYXBCZWhhdmlvdXJzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogJ1snICsgc2VsZWN0ZWQgKyAnXScsXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChDc3R5bGVCZWhhdmlvdXIuaXNTYW5lSW5zZXJ0aW9uKGVkaXRvciwgc2Vzc2lvbikpIHtcbiAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucmVjb3JkQXV0b0luc2VydChlZGl0b3IsIHNlc3Npb24sIFwiXVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnW10nLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCA9PSAnXScpIHtcbiAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHNlc3Npb24uZG9jLmdldExpbmUoY3Vyc29yLnJvdyk7XG4gICAgICAgICAgICB2YXIgcmlnaHRDaGFyID0gbGluZS5zdWJzdHJpbmcoY3Vyc29yLmNvbHVtbiwgY3Vyc29yLmNvbHVtbiArIDEpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSAnXScpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2hpbmcgPSBzZXNzaW9uLiRmaW5kT3BlbmluZ0JyYWNrZXQoJ10nLCB7Y29sdW1uOiBjdXJzb3IuY29sdW1uICsgMSwgcm93OiBjdXJzb3Iucm93fSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoaW5nICE9PSBudWxsICYmIENzdHlsZUJlaGF2aW91ci5pc0F1dG9JbnNlcnRlZENsb3NpbmcoY3Vyc29yLCBsaW5lLCB0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBDc3R5bGVCZWhhdmlvdXIucG9wQXV0b0luc2VydGVkQ2xvc2luZygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGQoXCJicmFja2V0c1wiLCBcImRlbGV0aW9uXCIsIGZ1bmN0aW9uKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKCFyYW5nZS5pc011bHRpTGluZSgpICYmIHNlbGVjdGVkID09ICdbJykge1xuICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShyYW5nZS5zdGFydC5yb3cpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0LmNvbHVtbiArIDEsIHJhbmdlLnN0YXJ0LmNvbHVtbiArIDIpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSAnXScpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5lbmQuY29sdW1uKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZChcInN0cmluZ19kcXVvdGVzXCIsIFwiaW5zZXJ0aW9uXCIsIGZ1bmN0aW9uKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgdGV4dCkge1xuICAgICAgICBpZiAodGV4dCA9PSAnXCInIHx8IHRleHQgPT0gXCInXCIpIHtcbiAgICAgICAgICAgIGluaXRDb250ZXh0KGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgcXVvdGUgPSB0ZXh0O1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5nZXRTZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHNlbGVjdGlvbik7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQgIT09IFwiXCIgJiYgc2VsZWN0ZWQgIT09IFwiJ1wiICYmIHNlbGVjdGVkICE9ICdcIicgJiYgZWRpdG9yLmdldFdyYXBCZWhhdmlvdXJzRW5hYmxlZCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogcXVvdGUgKyBzZWxlY3RlZCArIHF1b3RlLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShjdXJzb3Iucm93KTtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdENoYXIgPSBsaW5lLnN1YnN0cmluZyhjdXJzb3IuY29sdW1uLTEsIGN1cnNvci5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0Q2hhciA9PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBzZXNzaW9uLmdldFRva2VucyhzZWxlY3Rpb24uc3RhcnQucm93KTtcbiAgICAgICAgICAgICAgICB2YXIgY29sID0gMCwgdG9rZW47XG4gICAgICAgICAgICAgICAgdmFyIHF1b3RlcG9zID0gLTE7IC8vIFRyYWNrIHdoZXRoZXIgd2UncmUgaW5zaWRlIGFuIG9wZW4gcXVvdGUuXG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHRva2Vucy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1t4XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLnR5cGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgIHF1b3RlcG9zID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocXVvdGVwb3MgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcXVvdGVwb3MgPSB0b2tlbi52YWx1ZS5pbmRleE9mKHF1b3RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKHRva2VuLnZhbHVlLmxlbmd0aCArIGNvbCkgPiBzZWxlY3Rpb24uc3RhcnQuY29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb2wgKz0gdG9rZW5zW3hdLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbiB8fCAocXVvdGVwb3MgPCAwICYmIHRva2VuLnR5cGUgIT09IFwiY29tbWVudFwiICYmICh0b2tlbi50eXBlICE9PSBcInN0cmluZ1wiIHx8ICgoc2VsZWN0aW9uLnN0YXJ0LmNvbHVtbiAhPT0gdG9rZW4udmFsdWUubGVuZ3RoK2NvbC0xKSAmJiB0b2tlbi52YWx1ZS5sYXN0SW5kZXhPZihxdW90ZSkgPT09IHRva2VuLnZhbHVlLmxlbmd0aC0xKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghQ3N0eWxlQmVoYXZpb3VyLmlzU2FuZUluc2VydGlvbihlZGl0b3IsIHNlc3Npb24pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogcXVvdGUgKyBxdW90ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbjogWzEsMV1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRva2VuICYmIHRva2VuLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJpZ2h0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKGN1cnNvci5jb2x1bW4sIGN1cnNvci5jb2x1bW4gKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSBxdW90ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb246IFsxLCAxXVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGQoXCJzdHJpbmdfZHF1b3Rlc1wiLCBcImRlbGV0aW9uXCIsIGZ1bmN0aW9uKHN0YXRlLCBhY3Rpb24sIGVkaXRvciwgc2Vzc2lvbiwgcmFuZ2UpIHtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gc2Vzc2lvbi5kb2MuZ2V0VGV4dFJhbmdlKHJhbmdlKTtcbiAgICAgICAgaWYgKCFyYW5nZS5pc011bHRpTGluZSgpICYmIChzZWxlY3RlZCA9PSAnXCInIHx8IHNlbGVjdGVkID09IFwiJ1wiKSkge1xuICAgICAgICAgICAgaW5pdENvbnRleHQoZWRpdG9yKTtcbiAgICAgICAgICAgIHZhciBsaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShyYW5nZS5zdGFydC5yb3cpO1xuICAgICAgICAgICAgdmFyIHJpZ2h0Q2hhciA9IGxpbmUuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0LmNvbHVtbiArIDEsIHJhbmdlLnN0YXJ0LmNvbHVtbiArIDIpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0Q2hhciA9PSBzZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIHJhbmdlLmVuZC5jb2x1bW4rKztcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxufTtcblxuICAgIFxuQ3N0eWxlQmVoYXZpb3VyLmlzU2FuZUluc2VydGlvbiA9IGZ1bmN0aW9uKGVkaXRvciwgc2Vzc2lvbikge1xuICAgIHZhciBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICB2YXIgaXRlcmF0b3IgPSBuZXcgVG9rZW5JdGVyYXRvcihzZXNzaW9uLCBjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uKTtcbiAgICBpZiAoIXRoaXMuJG1hdGNoVG9rZW5UeXBlKGl0ZXJhdG9yLmdldEN1cnJlbnRUb2tlbigpIHx8IFwidGV4dFwiLCBTQUZFX0lOU0VSVF9JTl9UT0tFTlMpKSB7XG4gICAgICAgIHZhciBpdGVyYXRvcjIgPSBuZXcgVG9rZW5JdGVyYXRvcihzZXNzaW9uLCBjdXJzb3Iucm93LCBjdXJzb3IuY29sdW1uICsgMSk7XG4gICAgICAgIGlmICghdGhpcy4kbWF0Y2hUb2tlblR5cGUoaXRlcmF0b3IyLmdldEN1cnJlbnRUb2tlbigpIHx8IFwidGV4dFwiLCBTQUZFX0lOU0VSVF9JTl9UT0tFTlMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpdGVyYXRvci5zdGVwRm9yd2FyZCgpO1xuICAgIHJldHVybiBpdGVyYXRvci5nZXRDdXJyZW50VG9rZW5Sb3coKSAhPT0gY3Vyc29yLnJvdyB8fFxuICAgICAgICB0aGlzLiRtYXRjaFRva2VuVHlwZShpdGVyYXRvci5nZXRDdXJyZW50VG9rZW4oKSB8fCBcInRleHRcIiwgU0FGRV9JTlNFUlRfQkVGT1JFX1RPS0VOUyk7XG59O1xuXG5Dc3R5bGVCZWhhdmlvdXIuJG1hdGNoVG9rZW5UeXBlID0gZnVuY3Rpb24odG9rZW4sIHR5cGVzKSB7XG4gICAgcmV0dXJuIHR5cGVzLmluZGV4T2YodG9rZW4udHlwZSB8fCB0b2tlbikgPiAtMTtcbn07XG5cbkNzdHlsZUJlaGF2aW91ci5yZWNvcmRBdXRvSW5zZXJ0ID0gZnVuY3Rpb24oZWRpdG9yLCBzZXNzaW9uLCBicmFja2V0KSB7XG4gICAgdmFyIGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgIHZhciBsaW5lID0gc2Vzc2lvbi5kb2MuZ2V0TGluZShjdXJzb3Iucm93KTtcbiAgICBpZiAoIXRoaXMuaXNBdXRvSW5zZXJ0ZWRDbG9zaW5nKGN1cnNvciwgbGluZSwgY29udGV4dC5hdXRvSW5zZXJ0ZWRMaW5lRW5kWzBdKSlcbiAgICAgICAgY29udGV4dC5hdXRvSW5zZXJ0ZWRCcmFja2V0cyA9IDA7XG4gICAgY29udGV4dC5hdXRvSW5zZXJ0ZWRSb3cgPSBjdXJzb3Iucm93O1xuICAgIGNvbnRleHQuYXV0b0luc2VydGVkTGluZUVuZCA9IGJyYWNrZXQgKyBsaW5lLnN1YnN0cihjdXJzb3IuY29sdW1uKTtcbiAgICBjb250ZXh0LmF1dG9JbnNlcnRlZEJyYWNrZXRzKys7XG59O1xuXG5Dc3R5bGVCZWhhdmlvdXIucmVjb3JkTWF5YmVJbnNlcnQgPSBmdW5jdGlvbihlZGl0b3IsIHNlc3Npb24sIGJyYWNrZXQpIHtcbiAgICB2YXIgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgdmFyIGxpbmUgPSBzZXNzaW9uLmRvYy5nZXRMaW5lKGN1cnNvci5yb3cpO1xuICAgIGlmICghdGhpcy5pc01heWJlSW5zZXJ0ZWRDbG9zaW5nKGN1cnNvciwgbGluZSkpXG4gICAgICAgIGNvbnRleHQubWF5YmVJbnNlcnRlZEJyYWNrZXRzID0gMDtcbiAgICBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRSb3cgPSBjdXJzb3Iucm93O1xuICAgIGNvbnRleHQubWF5YmVJbnNlcnRlZExpbmVTdGFydCA9IGxpbmUuc3Vic3RyKDAsIGN1cnNvci5jb2x1bW4pICsgYnJhY2tldDtcbiAgICBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRMaW5lRW5kID0gbGluZS5zdWJzdHIoY3Vyc29yLmNvbHVtbik7XG4gICAgY29udGV4dC5tYXliZUluc2VydGVkQnJhY2tldHMrKztcbn07XG5cbkNzdHlsZUJlaGF2aW91ci5pc0F1dG9JbnNlcnRlZENsb3NpbmcgPSBmdW5jdGlvbihjdXJzb3IsIGxpbmUsIGJyYWNrZXQpIHtcbiAgICByZXR1cm4gY29udGV4dC5hdXRvSW5zZXJ0ZWRCcmFja2V0cyA+IDAgJiZcbiAgICAgICAgY3Vyc29yLnJvdyA9PT0gY29udGV4dC5hdXRvSW5zZXJ0ZWRSb3cgJiZcbiAgICAgICAgYnJhY2tldCA9PT0gY29udGV4dC5hdXRvSW5zZXJ0ZWRMaW5lRW5kWzBdICYmXG4gICAgICAgIGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pID09PSBjb250ZXh0LmF1dG9JbnNlcnRlZExpbmVFbmQ7XG59O1xuXG5Dc3R5bGVCZWhhdmlvdXIuaXNNYXliZUluc2VydGVkQ2xvc2luZyA9IGZ1bmN0aW9uKGN1cnNvciwgbGluZSkge1xuICAgIHJldHVybiBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRCcmFja2V0cyA+IDAgJiZcbiAgICAgICAgY3Vyc29yLnJvdyA9PT0gY29udGV4dC5tYXliZUluc2VydGVkUm93ICYmXG4gICAgICAgIGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pID09PSBjb250ZXh0Lm1heWJlSW5zZXJ0ZWRMaW5lRW5kICYmXG4gICAgICAgIGxpbmUuc3Vic3RyKDAsIGN1cnNvci5jb2x1bW4pID09IGNvbnRleHQubWF5YmVJbnNlcnRlZExpbmVTdGFydDtcbn07XG5cbkNzdHlsZUJlaGF2aW91ci5wb3BBdXRvSW5zZXJ0ZWRDbG9zaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgY29udGV4dC5hdXRvSW5zZXJ0ZWRMaW5lRW5kID0gY29udGV4dC5hdXRvSW5zZXJ0ZWRMaW5lRW5kLnN1YnN0cigxKTtcbiAgICBjb250ZXh0LmF1dG9JbnNlcnRlZEJyYWNrZXRzLS07XG59O1xuXG5Dc3R5bGVCZWhhdmlvdXIuY2xlYXJNYXliZUluc2VydGVkQ2xvc2luZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQubWF5YmVJbnNlcnRlZEJyYWNrZXRzID0gMDtcbiAgICAgICAgY29udGV4dC5tYXliZUluc2VydGVkUm93ID0gLTE7XG4gICAgfVxufTtcblxuXG5cbm9vcC5pbmhlcml0cyhDc3R5bGVCZWhhdmlvdXIsIEJlaGF2aW91cik7XG5cbmV4cG9ydHMuQ3N0eWxlQmVoYXZpb3VyID0gQ3N0eWxlQmVoYXZpb3VyO1xufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvbW9kZS9mb2xkaW5nL2NzdHlsZVwiLFtcInJlcXVpcmVcIixcImV4cG9ydHNcIixcIm1vZHVsZVwiLFwiYWNlL2xpYi9vb3BcIixcImFjZS9yYW5nZVwiLFwiYWNlL21vZGUvZm9sZGluZy9mb2xkX21vZGVcIl0sIGZ1bmN0aW9uKGFjZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xuXG52YXIgb29wID0gYWNlcXVpcmUoXCIuLi8uLi9saWIvb29wXCIpO1xudmFyIFJhbmdlID0gYWNlcXVpcmUoXCIuLi8uLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBCYXNlRm9sZE1vZGUgPSBhY2VxdWlyZShcIi4vZm9sZF9tb2RlXCIpLkZvbGRNb2RlO1xuXG52YXIgRm9sZE1vZGUgPSBleHBvcnRzLkZvbGRNb2RlID0gZnVuY3Rpb24oY29tbWVudFJlZ2V4KSB7XG4gICAgaWYgKGNvbW1lbnRSZWdleCkge1xuICAgICAgICB0aGlzLmZvbGRpbmdTdGFydE1hcmtlciA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICB0aGlzLmZvbGRpbmdTdGFydE1hcmtlci5zb3VyY2UucmVwbGFjZSgvXFx8W158XSo/JC8sIFwifFwiICsgY29tbWVudFJlZ2V4LnN0YXJ0KVxuICAgICAgICApO1xuICAgICAgICB0aGlzLmZvbGRpbmdTdG9wTWFya2VyID0gbmV3IFJlZ0V4cChcbiAgICAgICAgICAgIHRoaXMuZm9sZGluZ1N0b3BNYXJrZXIuc291cmNlLnJlcGxhY2UoL1xcfFtefF0qPyQvLCBcInxcIiArIGNvbW1lbnRSZWdleC5lbmQpXG4gICAgICAgICk7XG4gICAgfVxufTtcbm9vcC5pbmhlcml0cyhGb2xkTW9kZSwgQmFzZUZvbGRNb2RlKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5mb2xkaW5nU3RhcnRNYXJrZXIgPSAvKFxce3xcXFspW15cXH1cXF1dKiR8XlxccyooXFwvXFwqKS87XG4gICAgdGhpcy5mb2xkaW5nU3RvcE1hcmtlciA9IC9eW15cXFtcXHtdKihcXH18XFxdKXxeW1xcc1xcKl0qKFxcKlxcLykvO1xuXG4gICAgdGhpcy5nZXRGb2xkV2lkZ2V0UmFuZ2UgPSBmdW5jdGlvbihzZXNzaW9uLCBmb2xkU3R5bGUsIHJvdywgZm9yY2VNdWx0aWxpbmUpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUocm93KTtcbiAgICAgICAgdmFyIG1hdGNoID0gbGluZS5tYXRjaCh0aGlzLmZvbGRpbmdTdGFydE1hcmtlcik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgdmFyIGkgPSBtYXRjaC5pbmRleDtcblxuICAgICAgICAgICAgaWYgKG1hdGNoWzFdKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW5pbmdCcmFja2V0QmxvY2soc2Vzc2lvbiwgbWF0Y2hbMV0sIHJvdywgaSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBzZXNzaW9uLmdldENvbW1lbnRGb2xkUmFuZ2Uocm93LCBpICsgbWF0Y2hbMF0ubGVuZ3RoLCAxKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHJhbmdlICYmICFyYW5nZS5pc011bHRpTGluZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcmNlTXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlID0gdGhpcy5nZXRTZWN0aW9uUmFuZ2Uoc2Vzc2lvbiwgcm93KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZvbGRTdHlsZSAhPSBcImFsbFwiKVxuICAgICAgICAgICAgICAgICAgICByYW5nZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb2xkU3R5bGUgPT09IFwibWFya2JlZ2luXCIpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIG1hdGNoID0gbGluZS5tYXRjaCh0aGlzLmZvbGRpbmdTdG9wTWFya2VyKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgaSA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xvc2luZ0JyYWNrZXRCbG9jayhzZXNzaW9uLCBtYXRjaFsxXSwgcm93LCBpKTtcblxuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb24uZ2V0Q29tbWVudEZvbGRSYW5nZShyb3csIGksIC0xKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5nZXRTZWN0aW9uUmFuZ2UgPSBmdW5jdGlvbihzZXNzaW9uLCByb3cpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBzZXNzaW9uLmdldExpbmUocm93KTtcbiAgICAgICAgdmFyIHN0YXJ0SW5kZW50ID0gbGluZS5zZWFyY2goL1xcUy8pO1xuICAgICAgICB2YXIgc3RhcnRSb3cgPSByb3c7XG4gICAgICAgIHZhciBzdGFydENvbHVtbiA9IGxpbmUubGVuZ3RoO1xuICAgICAgICByb3cgPSByb3cgKyAxO1xuICAgICAgICB2YXIgZW5kUm93ID0gcm93O1xuICAgICAgICB2YXIgbWF4Um93ID0gc2Vzc2lvbi5nZXRMZW5ndGgoKTtcbiAgICAgICAgd2hpbGUgKCsrcm93IDwgbWF4Um93KSB7XG4gICAgICAgICAgICBsaW5lID0gc2Vzc2lvbi5nZXRMaW5lKHJvdyk7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gbGluZS5zZWFyY2goL1xcUy8pO1xuICAgICAgICAgICAgaWYgKGluZGVudCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAgKHN0YXJ0SW5kZW50ID4gaW5kZW50KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFyIHN1YlJhbmdlID0gdGhpcy5nZXRGb2xkV2lkZ2V0UmFuZ2Uoc2Vzc2lvbiwgXCJhbGxcIiwgcm93KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHN1YlJhbmdlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YlJhbmdlLnN0YXJ0LnJvdyA8PSBzdGFydFJvdykge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN1YlJhbmdlLmlzTXVsdGlMaW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gc3ViUmFuZ2UuZW5kLnJvdztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0SW5kZW50ID09IGluZGVudCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmRSb3cgPSByb3c7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRSb3csIHN0YXJ0Q29sdW1uLCBlbmRSb3csIHNlc3Npb24uZ2V0TGluZShlbmRSb3cpLmxlbmd0aCk7XG4gICAgfTtcblxufSkuY2FsbChGb2xkTW9kZS5wcm90b3R5cGUpO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9tb2RlL2phdmFzY3JpcHRcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9saWIvb29wXCIsXCJhY2UvbW9kZS90ZXh0XCIsXCJhY2UvbW9kZS9qYXZhc2NyaXB0X2hpZ2hsaWdodF9ydWxlc1wiLFwiYWNlL21vZGUvbWF0Y2hpbmdfYnJhY2Vfb3V0ZGVudFwiLFwiYWNlL3JhbmdlXCIsXCJhY2Uvd29ya2VyL3dvcmtlcl9jbGllbnRcIixcImFjZS9tb2RlL2JlaGF2aW91ci9jc3R5bGVcIixcImFjZS9tb2RlL2ZvbGRpbmcvY3N0eWxlXCJdLCBmdW5jdGlvbihhY2VxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG9vcCA9IGFjZXF1aXJlKFwiLi4vbGliL29vcFwiKTtcbnZhciBUZXh0TW9kZSA9IGFjZXF1aXJlKFwiLi90ZXh0XCIpLk1vZGU7XG52YXIgSmF2YVNjcmlwdEhpZ2hsaWdodFJ1bGVzID0gYWNlcXVpcmUoXCIuL2phdmFzY3JpcHRfaGlnaGxpZ2h0X3J1bGVzXCIpLkphdmFTY3JpcHRIaWdobGlnaHRSdWxlcztcbnZhciBNYXRjaGluZ0JyYWNlT3V0ZGVudCA9IGFjZXF1aXJlKFwiLi9tYXRjaGluZ19icmFjZV9vdXRkZW50XCIpLk1hdGNoaW5nQnJhY2VPdXRkZW50O1xudmFyIFJhbmdlID0gYWNlcXVpcmUoXCIuLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBXb3JrZXJDbGllbnQgPSBhY2VxdWlyZShcIi4uL3dvcmtlci93b3JrZXJfY2xpZW50XCIpLldvcmtlckNsaWVudDtcbnZhciBDc3R5bGVCZWhhdmlvdXIgPSBhY2VxdWlyZShcIi4vYmVoYXZpb3VyL2NzdHlsZVwiKS5Dc3R5bGVCZWhhdmlvdXI7XG52YXIgQ1N0eWxlRm9sZE1vZGUgPSBhY2VxdWlyZShcIi4vZm9sZGluZy9jc3R5bGVcIikuRm9sZE1vZGU7XG5cbnZhciBNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5IaWdobGlnaHRSdWxlcyA9IEphdmFTY3JpcHRIaWdobGlnaHRSdWxlcztcbiAgICBcbiAgICB0aGlzLiRvdXRkZW50ID0gbmV3IE1hdGNoaW5nQnJhY2VPdXRkZW50KCk7XG4gICAgdGhpcy4kYmVoYXZpb3VyID0gbmV3IENzdHlsZUJlaGF2aW91cigpO1xuICAgIHRoaXMuZm9sZGluZ1J1bGVzID0gbmV3IENTdHlsZUZvbGRNb2RlKCk7XG59O1xub29wLmluaGVyaXRzKE1vZGUsIFRleHRNb2RlKTtcblxuKGZ1bmN0aW9uKCkge1xuXG4gICAgdGhpcy5saW5lQ29tbWVudFN0YXJ0ID0gXCIvL1wiO1xuICAgIHRoaXMuYmxvY2tDb21tZW50ID0ge3N0YXJ0OiBcIi8qXCIsIGVuZDogXCIqL1wifTtcblxuICAgIHRoaXMuZ2V0TmV4dExpbmVJbmRlbnQgPSBmdW5jdGlvbihzdGF0ZSwgbGluZSwgdGFiKSB7XG4gICAgICAgIHZhciBpbmRlbnQgPSB0aGlzLiRnZXRJbmRlbnQobGluZSk7XG5cbiAgICAgICAgdmFyIHRva2VuaXplZExpbmUgPSB0aGlzLmdldFRva2VuaXplcigpLmdldExpbmVUb2tlbnMobGluZSwgc3RhdGUpO1xuICAgICAgICB2YXIgdG9rZW5zID0gdG9rZW5pemVkTGluZS50b2tlbnM7XG4gICAgICAgIHZhciBlbmRTdGF0ZSA9IHRva2VuaXplZExpbmUuc3RhdGU7XG5cbiAgICAgICAgaWYgKHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW3Rva2Vucy5sZW5ndGgtMV0udHlwZSA9PSBcImNvbW1lbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGluZGVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZSA9PSBcInN0YXJ0XCIgfHwgc3RhdGUgPT0gXCJub19yZWdleFwiKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lLm1hdGNoKC9eLiooPzpcXGJjYXNlXFxiLipcXDp8W1xce1xcKFxcW10pXFxzKiQvKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGluZGVudCArPSB0YWI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhdGUgPT0gXCJkb2Mtc3RhcnRcIikge1xuICAgICAgICAgICAgaWYgKGVuZFN0YXRlID09IFwic3RhcnRcIiB8fCBlbmRTdGF0ZSA9PSBcIm5vX3JlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmUubWF0Y2goL15cXHMqKFxcLz8pXFwqLyk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50ICs9IFwiIFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbmRlbnQgKz0gXCIqIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluZGVudDtcbiAgICB9O1xuXG4gICAgdGhpcy5jaGVja091dGRlbnQgPSBmdW5jdGlvbihzdGF0ZSwgbGluZSwgaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJG91dGRlbnQuY2hlY2tPdXRkZW50KGxpbmUsIGlucHV0KTtcbiAgICB9O1xuXG4gICAgdGhpcy5hdXRvT3V0ZGVudCA9IGZ1bmN0aW9uKHN0YXRlLCBkb2MsIHJvdykge1xuICAgICAgICB0aGlzLiRvdXRkZW50LmF1dG9PdXRkZW50KGRvYywgcm93KTtcbiAgICB9O1xuXG4gICAgdGhpcy5jcmVhdGVXb3JrZXIgPSBmdW5jdGlvbihzZXNzaW9uKSB7XG4gICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyQ2xpZW50KFtcImFjZVwiXSwgcmVxdWlyZShcIi4uL3dvcmtlci9qYXZhc2NyaXB0XCIpLCBcIkphdmFTY3JpcHRXb3JrZXJcIik7XG4gICAgICAgIHdvcmtlci5hdHRhY2hUb0RvY3VtZW50KHNlc3Npb24uZ2V0RG9jdW1lbnQoKSk7XG5cbiAgICAgICAgd29ya2VyLm9uKFwianNsaW50XCIsIGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIHNlc3Npb24uc2V0QW5ub3RhdGlvbnMocmVzdWx0cy5kYXRhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgd29ya2VyLm9uKFwidGVybWluYXRlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2Vzc2lvbi5jbGVhckFubm90YXRpb25zKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB3b3JrZXI7XG4gICAgfTtcblxuICAgIHRoaXMuJGlkID0gXCJhY2UvbW9kZS9qYXZhc2NyaXB0XCI7XG59KS5jYWxsKE1vZGUucHJvdG90eXBlKTtcblxuZXhwb3J0cy5Nb2RlID0gTW9kZTtcbn0pO1xuIiwibW9kdWxlLmV4cG9ydHMuaWQgPSAnYWNlL21vZGUvamF2YXNjcmlwdF93b3JrZXInO1xubW9kdWxlLmV4cG9ydHMuc3JjID0gXCJcXFwibm8gdXNlIHN0cmljdFxcXCI7KGZ1bmN0aW9uKHdpbmRvdyl7aWYodm9pZCAwPT09d2luZG93LndpbmRvd3x8IXdpbmRvdy5kb2N1bWVudCl7d2luZG93LmNvbnNvbGU9ZnVuY3Rpb24oKXt2YXIgbXNncz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMCk7cG9zdE1lc3NhZ2Uoe3R5cGU6XFxcImxvZ1xcXCIsZGF0YTptc2dzfSl9LHdpbmRvdy5jb25zb2xlLmVycm9yPXdpbmRvdy5jb25zb2xlLndhcm49d2luZG93LmNvbnNvbGUubG9nPXdpbmRvdy5jb25zb2xlLnRyYWNlPXdpbmRvdy5jb25zb2xlLHdpbmRvdy53aW5kb3c9d2luZG93LHdpbmRvdy5hY2U9d2luZG93LHdpbmRvdy5vbmVycm9yPWZ1bmN0aW9uKG1lc3NhZ2UsZmlsZSxsaW5lLGNvbCxlcnIpe3Bvc3RNZXNzYWdlKHt0eXBlOlxcXCJlcnJvclxcXCIsZGF0YTp7bWVzc2FnZTptZXNzYWdlLGZpbGU6ZmlsZSxsaW5lOmxpbmUsY29sOmNvbCxzdGFjazplcnIuc3RhY2t9fSl9LHdpbmRvdy5ub3JtYWxpemVNb2R1bGU9ZnVuY3Rpb24ocGFyZW50SWQsbW9kdWxlTmFtZSl7aWYoLTEhPT1tb2R1bGVOYW1lLmluZGV4T2YoXFxcIiFcXFwiKSl7dmFyIGNodW5rcz1tb2R1bGVOYW1lLnNwbGl0KFxcXCIhXFxcIik7cmV0dXJuIHdpbmRvdy5ub3JtYWxpemVNb2R1bGUocGFyZW50SWQsY2h1bmtzWzBdKStcXFwiIVxcXCIrd2luZG93Lm5vcm1hbGl6ZU1vZHVsZShwYXJlbnRJZCxjaHVua3NbMV0pfWlmKFxcXCIuXFxcIj09bW9kdWxlTmFtZS5jaGFyQXQoMCkpe3ZhciBiYXNlPXBhcmVudElkLnNwbGl0KFxcXCIvXFxcIikuc2xpY2UoMCwtMSkuam9pbihcXFwiL1xcXCIpO2Zvcihtb2R1bGVOYW1lPShiYXNlP2Jhc2UrXFxcIi9cXFwiOlxcXCJcXFwiKSttb2R1bGVOYW1lOy0xIT09bW9kdWxlTmFtZS5pbmRleE9mKFxcXCIuXFxcIikmJnByZXZpb3VzIT1tb2R1bGVOYW1lOyl7dmFyIHByZXZpb3VzPW1vZHVsZU5hbWU7bW9kdWxlTmFtZT1tb2R1bGVOYW1lLnJlcGxhY2UoL15cXFxcLlxcXFwvLyxcXFwiXFxcIikucmVwbGFjZSgvXFxcXC9cXFxcLlxcXFwvLyxcXFwiL1xcXCIpLnJlcGxhY2UoL1teXFxcXC9dK1xcXFwvXFxcXC5cXFxcLlxcXFwvLyxcXFwiXFxcIil9fXJldHVybiBtb2R1bGVOYW1lfSx3aW5kb3cuYWNlcXVpcmU9ZnVuY3Rpb24ocGFyZW50SWQsaWQpe2lmKGlkfHwoaWQ9cGFyZW50SWQscGFyZW50SWQ9bnVsbCksIWlkLmNoYXJBdCl0aHJvdyBFcnJvcihcXFwid29ya2VyLmpzIGFjZXF1aXJlKCkgYWNjZXB0cyBvbmx5IChwYXJlbnRJZCwgaWQpIGFzIGFyZ3VtZW50c1xcXCIpO2lkPXdpbmRvdy5ub3JtYWxpemVNb2R1bGUocGFyZW50SWQsaWQpO3ZhciBtb2R1bGU9d2luZG93LmFjZXF1aXJlLm1vZHVsZXNbaWRdO2lmKG1vZHVsZSlyZXR1cm4gbW9kdWxlLmluaXRpYWxpemVkfHwobW9kdWxlLmluaXRpYWxpemVkPSEwLG1vZHVsZS5leHBvcnRzPW1vZHVsZS5mYWN0b3J5KCkuZXhwb3J0cyksbW9kdWxlLmV4cG9ydHM7dmFyIGNodW5rcz1pZC5zcGxpdChcXFwiL1xcXCIpO2lmKCF3aW5kb3cuYWNlcXVpcmUudGxucylyZXR1cm4gY29uc29sZS5sb2coXFxcInVuYWJsZSB0byBsb2FkIFxcXCIraWQpO2NodW5rc1swXT13aW5kb3cuYWNlcXVpcmUudGxuc1tjaHVua3NbMF1dfHxjaHVua3NbMF07dmFyIHBhdGg9Y2h1bmtzLmpvaW4oXFxcIi9cXFwiKStcXFwiLmpzXFxcIjtyZXR1cm4gd2luZG93LmFjZXF1aXJlLmlkPWlkLGltcG9ydFNjcmlwdHMocGF0aCksd2luZG93LmFjZXF1aXJlKHBhcmVudElkLGlkKX0sd2luZG93LmFjZXF1aXJlLm1vZHVsZXM9e30sd2luZG93LmFjZXF1aXJlLnRsbnM9e30sd2luZG93LmRlZmluZT1mdW5jdGlvbihpZCxkZXBzLGZhY3Rvcnkpe2lmKDI9PWFyZ3VtZW50cy5sZW5ndGg/KGZhY3Rvcnk9ZGVwcyxcXFwic3RyaW5nXFxcIiE9dHlwZW9mIGlkJiYoZGVwcz1pZCxpZD13aW5kb3cuYWNlcXVpcmUuaWQpKToxPT1hcmd1bWVudHMubGVuZ3RoJiYoZmFjdG9yeT1pZCxkZXBzPVtdLGlkPXdpbmRvdy5hY2VxdWlyZS5pZCksXFxcImZ1bmN0aW9uXFxcIiE9dHlwZW9mIGZhY3RvcnkpcmV0dXJuIHdpbmRvdy5hY2VxdWlyZS5tb2R1bGVzW2lkXT17ZXhwb3J0czpmYWN0b3J5LGluaXRpYWxpemVkOiEwfSx2b2lkIDA7ZGVwcy5sZW5ndGh8fChkZXBzPVtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiXSk7dmFyIHJlcT1mdW5jdGlvbihjaGlsZElkKXtyZXR1cm4gd2luZG93LmFjZXF1aXJlKGlkLGNoaWxkSWQpfTt3aW5kb3cuYWNlcXVpcmUubW9kdWxlc1tpZF09e2V4cG9ydHM6e30sZmFjdG9yeTpmdW5jdGlvbigpe3ZhciBtb2R1bGU9dGhpcyxyZXR1cm5FeHBvcnRzPWZhY3RvcnkuYXBwbHkodGhpcyxkZXBzLm1hcChmdW5jdGlvbihkZXApe3N3aXRjaChkZXApe2Nhc2VcXFwicmVxdWlyZVxcXCI6cmV0dXJuIHJlcTtjYXNlXFxcImV4cG9ydHNcXFwiOnJldHVybiBtb2R1bGUuZXhwb3J0cztjYXNlXFxcIm1vZHVsZVxcXCI6cmV0dXJuIG1vZHVsZTtkZWZhdWx0OnJldHVybiByZXEoZGVwKX19KSk7cmV0dXJuIHJldHVybkV4cG9ydHMmJihtb2R1bGUuZXhwb3J0cz1yZXR1cm5FeHBvcnRzKSxtb2R1bGV9fX0sd2luZG93LmRlZmluZS5hbWQ9e30sd2luZG93LmluaXRCYXNlVXJscz1mdW5jdGlvbiBpbml0QmFzZVVybHModG9wTGV2ZWxOYW1lc3BhY2VzKXthY2VxdWlyZS50bG5zPXRvcExldmVsTmFtZXNwYWNlc30sd2luZG93LmluaXRTZW5kZXI9ZnVuY3Rpb24gaW5pdFNlbmRlcigpe3ZhciBFdmVudEVtaXR0ZXI9d2luZG93LmFjZXF1aXJlKFxcXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcXFwiKS5FdmVudEVtaXR0ZXIsb29wPXdpbmRvdy5hY2VxdWlyZShcXFwiYWNlL2xpYi9vb3BcXFwiKSxTZW5kZXI9ZnVuY3Rpb24oKXt9O3JldHVybiBmdW5jdGlvbigpe29vcC5pbXBsZW1lbnQodGhpcyxFdmVudEVtaXR0ZXIpLHRoaXMuY2FsbGJhY2s9ZnVuY3Rpb24oZGF0YSxjYWxsYmFja0lkKXtwb3N0TWVzc2FnZSh7dHlwZTpcXFwiY2FsbFxcXCIsaWQ6Y2FsbGJhY2tJZCxkYXRhOmRhdGF9KX0sdGhpcy5lbWl0PWZ1bmN0aW9uKG5hbWUsZGF0YSl7cG9zdE1lc3NhZ2Uoe3R5cGU6XFxcImV2ZW50XFxcIixuYW1lOm5hbWUsZGF0YTpkYXRhfSl9fS5jYWxsKFNlbmRlci5wcm90b3R5cGUpLG5ldyBTZW5kZXJ9O3ZhciBtYWluPXdpbmRvdy5tYWluPW51bGwsc2VuZGVyPXdpbmRvdy5zZW5kZXI9bnVsbDt3aW5kb3cub25tZXNzYWdlPWZ1bmN0aW9uKGUpe3ZhciBtc2c9ZS5kYXRhO2lmKG1zZy5jb21tYW5kKXtpZighbWFpblttc2cuY29tbWFuZF0pdGhyb3cgRXJyb3IoXFxcIlVua25vd24gY29tbWFuZDpcXFwiK21zZy5jb21tYW5kKTttYWluW21zZy5jb21tYW5kXS5hcHBseShtYWluLG1zZy5hcmdzKX1lbHNlIGlmKG1zZy5pbml0KXtpbml0QmFzZVVybHMobXNnLnRsbnMpLGFjZXF1aXJlKFxcXCJhY2UvbGliL2VzNS1zaGltXFxcIiksc2VuZGVyPXdpbmRvdy5zZW5kZXI9aW5pdFNlbmRlcigpO3ZhciBjbGF6ej1hY2VxdWlyZShtc2cubW9kdWxlKVttc2cuY2xhc3NuYW1lXTttYWluPXdpbmRvdy5tYWluPW5ldyBjbGF6eihzZW5kZXIpfWVsc2UgbXNnLmV2ZW50JiZzZW5kZXImJnNlbmRlci5fc2lnbmFsKG1zZy5ldmVudCxtc2cuZGF0YSl9fX0pKHRoaXMpLGFjZS5kZWZpbmUoXFxcImFjZS9saWIvb29wXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIl0sZnVuY3Rpb24oYWNlcXVpcmUsZXhwb3J0cyl7XFxcInVzZSBzdHJpY3RcXFwiO2V4cG9ydHMuaW5oZXJpdHM9ZnVuY3Rpb24oY3RvcixzdXBlckN0b3Ipe2N0b3Iuc3VwZXJfPXN1cGVyQ3RvcixjdG9yLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTpjdG9yLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pfSxleHBvcnRzLm1peGluPWZ1bmN0aW9uKG9iaixtaXhpbil7Zm9yKHZhciBrZXkgaW4gbWl4aW4pb2JqW2tleV09bWl4aW5ba2V5XTtyZXR1cm4gb2JqfSxleHBvcnRzLmltcGxlbWVudD1mdW5jdGlvbihwcm90byxtaXhpbil7ZXhwb3J0cy5taXhpbihwcm90byxtaXhpbil9fSksYWNlLmRlZmluZShcXFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIl0sZnVuY3Rpb24oYWNlcXVpcmUsZXhwb3J0cyl7XFxcInVzZSBzdHJpY3RcXFwiO3ZhciBFdmVudEVtaXR0ZXI9e30sc3RvcFByb3BhZ2F0aW9uPWZ1bmN0aW9uKCl7dGhpcy5wcm9wYWdhdGlvblN0b3BwZWQ9ITB9LHByZXZlbnREZWZhdWx0PWZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwfTtFdmVudEVtaXR0ZXIuX2VtaXQ9RXZlbnRFbWl0dGVyLl9kaXNwYXRjaEV2ZW50PWZ1bmN0aW9uKGV2ZW50TmFtZSxlKXt0aGlzLl9ldmVudFJlZ2lzdHJ5fHwodGhpcy5fZXZlbnRSZWdpc3RyeT17fSksdGhpcy5fZGVmYXVsdEhhbmRsZXJzfHwodGhpcy5fZGVmYXVsdEhhbmRsZXJzPXt9KTt2YXIgbGlzdGVuZXJzPXRoaXMuX2V2ZW50UmVnaXN0cnlbZXZlbnROYW1lXXx8W10sZGVmYXVsdEhhbmRsZXI9dGhpcy5fZGVmYXVsdEhhbmRsZXJzW2V2ZW50TmFtZV07aWYobGlzdGVuZXJzLmxlbmd0aHx8ZGVmYXVsdEhhbmRsZXIpe1xcXCJvYmplY3RcXFwiPT10eXBlb2YgZSYmZXx8KGU9e30pLGUudHlwZXx8KGUudHlwZT1ldmVudE5hbWUpLGUuc3RvcFByb3BhZ2F0aW9ufHwoZS5zdG9wUHJvcGFnYXRpb249c3RvcFByb3BhZ2F0aW9uKSxlLnByZXZlbnREZWZhdWx0fHwoZS5wcmV2ZW50RGVmYXVsdD1wcmV2ZW50RGVmYXVsdCksbGlzdGVuZXJzPWxpc3RlbmVycy5zbGljZSgpO2Zvcih2YXIgaT0wO2xpc3RlbmVycy5sZW5ndGg+aSYmKGxpc3RlbmVyc1tpXShlLHRoaXMpLCFlLnByb3BhZ2F0aW9uU3RvcHBlZCk7aSsrKTtyZXR1cm4gZGVmYXVsdEhhbmRsZXImJiFlLmRlZmF1bHRQcmV2ZW50ZWQ/ZGVmYXVsdEhhbmRsZXIoZSx0aGlzKTp2b2lkIDB9fSxFdmVudEVtaXR0ZXIuX3NpZ25hbD1mdW5jdGlvbihldmVudE5hbWUsZSl7dmFyIGxpc3RlbmVycz0odGhpcy5fZXZlbnRSZWdpc3RyeXx8e30pW2V2ZW50TmFtZV07aWYobGlzdGVuZXJzKXtsaXN0ZW5lcnM9bGlzdGVuZXJzLnNsaWNlKCk7Zm9yKHZhciBpPTA7bGlzdGVuZXJzLmxlbmd0aD5pO2krKylsaXN0ZW5lcnNbaV0oZSx0aGlzKX19LEV2ZW50RW1pdHRlci5vbmNlPWZ1bmN0aW9uKGV2ZW50TmFtZSxjYWxsYmFjayl7dmFyIF9zZWxmPXRoaXM7Y2FsbGJhY2smJnRoaXMuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsZnVuY3Rpb24gbmV3Q2FsbGJhY2soKXtfc2VsZi5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSxuZXdDYWxsYmFjayksY2FsbGJhY2suYXBwbHkobnVsbCxhcmd1bWVudHMpfSl9LEV2ZW50RW1pdHRlci5zZXREZWZhdWx0SGFuZGxlcj1mdW5jdGlvbihldmVudE5hbWUsY2FsbGJhY2spe3ZhciBoYW5kbGVycz10aGlzLl9kZWZhdWx0SGFuZGxlcnM7aWYoaGFuZGxlcnN8fChoYW5kbGVycz10aGlzLl9kZWZhdWx0SGFuZGxlcnM9e19kaXNhYmxlZF86e319KSxoYW5kbGVyc1tldmVudE5hbWVdKXt2YXIgb2xkPWhhbmRsZXJzW2V2ZW50TmFtZV0sZGlzYWJsZWQ9aGFuZGxlcnMuX2Rpc2FibGVkX1tldmVudE5hbWVdO2Rpc2FibGVkfHwoaGFuZGxlcnMuX2Rpc2FibGVkX1tldmVudE5hbWVdPWRpc2FibGVkPVtdKSxkaXNhYmxlZC5wdXNoKG9sZCk7dmFyIGk9ZGlzYWJsZWQuaW5kZXhPZihjYWxsYmFjayk7LTEhPWkmJmRpc2FibGVkLnNwbGljZShpLDEpfWhhbmRsZXJzW2V2ZW50TmFtZV09Y2FsbGJhY2t9LEV2ZW50RW1pdHRlci5yZW1vdmVEZWZhdWx0SGFuZGxlcj1mdW5jdGlvbihldmVudE5hbWUsY2FsbGJhY2spe3ZhciBoYW5kbGVycz10aGlzLl9kZWZhdWx0SGFuZGxlcnM7aWYoaGFuZGxlcnMpe3ZhciBkaXNhYmxlZD1oYW5kbGVycy5fZGlzYWJsZWRfW2V2ZW50TmFtZV07aWYoaGFuZGxlcnNbZXZlbnROYW1lXT09Y2FsbGJhY2spaGFuZGxlcnNbZXZlbnROYW1lXSxkaXNhYmxlZCYmdGhpcy5zZXREZWZhdWx0SGFuZGxlcihldmVudE5hbWUsZGlzYWJsZWQucG9wKCkpO2Vsc2UgaWYoZGlzYWJsZWQpe3ZhciBpPWRpc2FibGVkLmluZGV4T2YoY2FsbGJhY2spOy0xIT1pJiZkaXNhYmxlZC5zcGxpY2UoaSwxKX19fSxFdmVudEVtaXR0ZXIub249RXZlbnRFbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oZXZlbnROYW1lLGNhbGxiYWNrLGNhcHR1cmluZyl7dGhpcy5fZXZlbnRSZWdpc3RyeT10aGlzLl9ldmVudFJlZ2lzdHJ5fHx7fTt2YXIgbGlzdGVuZXJzPXRoaXMuX2V2ZW50UmVnaXN0cnlbZXZlbnROYW1lXTtyZXR1cm4gbGlzdGVuZXJzfHwobGlzdGVuZXJzPXRoaXMuX2V2ZW50UmVnaXN0cnlbZXZlbnROYW1lXT1bXSksLTE9PWxpc3RlbmVycy5pbmRleE9mKGNhbGxiYWNrKSYmbGlzdGVuZXJzW2NhcHR1cmluZz9cXFwidW5zaGlmdFxcXCI6XFxcInB1c2hcXFwiXShjYWxsYmFjayksY2FsbGJhY2t9LEV2ZW50RW1pdHRlci5vZmY9RXZlbnRFbWl0dGVyLnJlbW92ZUxpc3RlbmVyPUV2ZW50RW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGV2ZW50TmFtZSxjYWxsYmFjayl7dGhpcy5fZXZlbnRSZWdpc3RyeT10aGlzLl9ldmVudFJlZ2lzdHJ5fHx7fTt2YXIgbGlzdGVuZXJzPXRoaXMuX2V2ZW50UmVnaXN0cnlbZXZlbnROYW1lXTtpZihsaXN0ZW5lcnMpe3ZhciBpbmRleD1saXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjayk7LTEhPT1pbmRleCYmbGlzdGVuZXJzLnNwbGljZShpbmRleCwxKX19LEV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnM9ZnVuY3Rpb24oZXZlbnROYW1lKXt0aGlzLl9ldmVudFJlZ2lzdHJ5JiYodGhpcy5fZXZlbnRSZWdpc3RyeVtldmVudE5hbWVdPVtdKX0sZXhwb3J0cy5FdmVudEVtaXR0ZXI9RXZlbnRFbWl0dGVyfSksYWNlLmRlZmluZShcXFwiYWNlL3JhbmdlXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIl0sZnVuY3Rpb24oYWNlcXVpcmUsZXhwb3J0cyl7XFxcInVzZSBzdHJpY3RcXFwiO3ZhciBjb21wYXJlUG9pbnRzPWZ1bmN0aW9uKHAxLHAyKXtyZXR1cm4gcDEucm93LXAyLnJvd3x8cDEuY29sdW1uLXAyLmNvbHVtbn0sUmFuZ2U9ZnVuY3Rpb24oc3RhcnRSb3csc3RhcnRDb2x1bW4sZW5kUm93LGVuZENvbHVtbil7dGhpcy5zdGFydD17cm93OnN0YXJ0Um93LGNvbHVtbjpzdGFydENvbHVtbn0sdGhpcy5lbmQ9e3JvdzplbmRSb3csY29sdW1uOmVuZENvbHVtbn19OyhmdW5jdGlvbigpe3RoaXMuaXNFcXVhbD1mdW5jdGlvbihyYW5nZSl7cmV0dXJuIHRoaXMuc3RhcnQucm93PT09cmFuZ2Uuc3RhcnQucm93JiZ0aGlzLmVuZC5yb3c9PT1yYW5nZS5lbmQucm93JiZ0aGlzLnN0YXJ0LmNvbHVtbj09PXJhbmdlLnN0YXJ0LmNvbHVtbiYmdGhpcy5lbmQuY29sdW1uPT09cmFuZ2UuZW5kLmNvbHVtbn0sdGhpcy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblxcXCJSYW5nZTogW1xcXCIrdGhpcy5zdGFydC5yb3crXFxcIi9cXFwiK3RoaXMuc3RhcnQuY29sdW1uK1xcXCJdIC0+IFtcXFwiK3RoaXMuZW5kLnJvdytcXFwiL1xcXCIrdGhpcy5lbmQuY29sdW1uK1xcXCJdXFxcIn0sdGhpcy5jb250YWlucz1mdW5jdGlvbihyb3csY29sdW1uKXtyZXR1cm4gMD09dGhpcy5jb21wYXJlKHJvdyxjb2x1bW4pfSx0aGlzLmNvbXBhcmVSYW5nZT1mdW5jdGlvbihyYW5nZSl7dmFyIGNtcCxlbmQ9cmFuZ2UuZW5kLHN0YXJ0PXJhbmdlLnN0YXJ0O3JldHVybiBjbXA9dGhpcy5jb21wYXJlKGVuZC5yb3csZW5kLmNvbHVtbiksMT09Y21wPyhjbXA9dGhpcy5jb21wYXJlKHN0YXJ0LnJvdyxzdGFydC5jb2x1bW4pLDE9PWNtcD8yOjA9PWNtcD8xOjApOi0xPT1jbXA/LTI6KGNtcD10aGlzLmNvbXBhcmUoc3RhcnQucm93LHN0YXJ0LmNvbHVtbiksLTE9PWNtcD8tMToxPT1jbXA/NDI6MCl9LHRoaXMuY29tcGFyZVBvaW50PWZ1bmN0aW9uKHApe3JldHVybiB0aGlzLmNvbXBhcmUocC5yb3cscC5jb2x1bW4pfSx0aGlzLmNvbnRhaW5zUmFuZ2U9ZnVuY3Rpb24ocmFuZ2Upe3JldHVybiAwPT10aGlzLmNvbXBhcmVQb2ludChyYW5nZS5zdGFydCkmJjA9PXRoaXMuY29tcGFyZVBvaW50KHJhbmdlLmVuZCl9LHRoaXMuaW50ZXJzZWN0cz1mdW5jdGlvbihyYW5nZSl7dmFyIGNtcD10aGlzLmNvbXBhcmVSYW5nZShyYW5nZSk7cmV0dXJuLTE9PWNtcHx8MD09Y21wfHwxPT1jbXB9LHRoaXMuaXNFbmQ9ZnVuY3Rpb24ocm93LGNvbHVtbil7cmV0dXJuIHRoaXMuZW5kLnJvdz09cm93JiZ0aGlzLmVuZC5jb2x1bW49PWNvbHVtbn0sdGhpcy5pc1N0YXJ0PWZ1bmN0aW9uKHJvdyxjb2x1bW4pe3JldHVybiB0aGlzLnN0YXJ0LnJvdz09cm93JiZ0aGlzLnN0YXJ0LmNvbHVtbj09Y29sdW1ufSx0aGlzLnNldFN0YXJ0PWZ1bmN0aW9uKHJvdyxjb2x1bW4pe1xcXCJvYmplY3RcXFwiPT10eXBlb2Ygcm93Pyh0aGlzLnN0YXJ0LmNvbHVtbj1yb3cuY29sdW1uLHRoaXMuc3RhcnQucm93PXJvdy5yb3cpOih0aGlzLnN0YXJ0LnJvdz1yb3csdGhpcy5zdGFydC5jb2x1bW49Y29sdW1uKX0sdGhpcy5zZXRFbmQ9ZnVuY3Rpb24ocm93LGNvbHVtbil7XFxcIm9iamVjdFxcXCI9PXR5cGVvZiByb3c/KHRoaXMuZW5kLmNvbHVtbj1yb3cuY29sdW1uLHRoaXMuZW5kLnJvdz1yb3cucm93KToodGhpcy5lbmQucm93PXJvdyx0aGlzLmVuZC5jb2x1bW49Y29sdW1uKX0sdGhpcy5pbnNpZGU9ZnVuY3Rpb24ocm93LGNvbHVtbil7cmV0dXJuIDA9PXRoaXMuY29tcGFyZShyb3csY29sdW1uKT90aGlzLmlzRW5kKHJvdyxjb2x1bW4pfHx0aGlzLmlzU3RhcnQocm93LGNvbHVtbik/ITE6ITA6ITF9LHRoaXMuaW5zaWRlU3RhcnQ9ZnVuY3Rpb24ocm93LGNvbHVtbil7cmV0dXJuIDA9PXRoaXMuY29tcGFyZShyb3csY29sdW1uKT90aGlzLmlzRW5kKHJvdyxjb2x1bW4pPyExOiEwOiExfSx0aGlzLmluc2lkZUVuZD1mdW5jdGlvbihyb3csY29sdW1uKXtyZXR1cm4gMD09dGhpcy5jb21wYXJlKHJvdyxjb2x1bW4pP3RoaXMuaXNTdGFydChyb3csY29sdW1uKT8hMTohMDohMX0sdGhpcy5jb21wYXJlPWZ1bmN0aW9uKHJvdyxjb2x1bW4pe3JldHVybiB0aGlzLmlzTXVsdGlMaW5lKCl8fHJvdyE9PXRoaXMuc3RhcnQucm93P3RoaXMuc3RhcnQucm93PnJvdz8tMTpyb3c+dGhpcy5lbmQucm93PzE6dGhpcy5zdGFydC5yb3c9PT1yb3c/Y29sdW1uPj10aGlzLnN0YXJ0LmNvbHVtbj8wOi0xOnRoaXMuZW5kLnJvdz09PXJvdz90aGlzLmVuZC5jb2x1bW4+PWNvbHVtbj8wOjE6MDp0aGlzLnN0YXJ0LmNvbHVtbj5jb2x1bW4/LTE6Y29sdW1uPnRoaXMuZW5kLmNvbHVtbj8xOjB9LHRoaXMuY29tcGFyZVN0YXJ0PWZ1bmN0aW9uKHJvdyxjb2x1bW4pe3JldHVybiB0aGlzLnN0YXJ0LnJvdz09cm93JiZ0aGlzLnN0YXJ0LmNvbHVtbj09Y29sdW1uPy0xOnRoaXMuY29tcGFyZShyb3csY29sdW1uKX0sdGhpcy5jb21wYXJlRW5kPWZ1bmN0aW9uKHJvdyxjb2x1bW4pe3JldHVybiB0aGlzLmVuZC5yb3c9PXJvdyYmdGhpcy5lbmQuY29sdW1uPT1jb2x1bW4/MTp0aGlzLmNvbXBhcmUocm93LGNvbHVtbil9LHRoaXMuY29tcGFyZUluc2lkZT1mdW5jdGlvbihyb3csY29sdW1uKXtyZXR1cm4gdGhpcy5lbmQucm93PT1yb3cmJnRoaXMuZW5kLmNvbHVtbj09Y29sdW1uPzE6dGhpcy5zdGFydC5yb3c9PXJvdyYmdGhpcy5zdGFydC5jb2x1bW49PWNvbHVtbj8tMTp0aGlzLmNvbXBhcmUocm93LGNvbHVtbil9LHRoaXMuY2xpcFJvd3M9ZnVuY3Rpb24oZmlyc3RSb3csbGFzdFJvdyl7aWYodGhpcy5lbmQucm93Pmxhc3RSb3cpdmFyIGVuZD17cm93Omxhc3RSb3crMSxjb2x1bW46MH07ZWxzZSBpZihmaXJzdFJvdz50aGlzLmVuZC5yb3cpdmFyIGVuZD17cm93OmZpcnN0Um93LGNvbHVtbjowfTtpZih0aGlzLnN0YXJ0LnJvdz5sYXN0Um93KXZhciBzdGFydD17cm93Omxhc3RSb3crMSxjb2x1bW46MH07ZWxzZSBpZihmaXJzdFJvdz50aGlzLnN0YXJ0LnJvdyl2YXIgc3RhcnQ9e3JvdzpmaXJzdFJvdyxjb2x1bW46MH07cmV0dXJuIFJhbmdlLmZyb21Qb2ludHMoc3RhcnR8fHRoaXMuc3RhcnQsZW5kfHx0aGlzLmVuZCl9LHRoaXMuZXh0ZW5kPWZ1bmN0aW9uKHJvdyxjb2x1bW4pe3ZhciBjbXA9dGhpcy5jb21wYXJlKHJvdyxjb2x1bW4pO2lmKDA9PWNtcClyZXR1cm4gdGhpcztpZigtMT09Y21wKXZhciBzdGFydD17cm93OnJvdyxjb2x1bW46Y29sdW1ufTtlbHNlIHZhciBlbmQ9e3Jvdzpyb3csY29sdW1uOmNvbHVtbn07cmV0dXJuIFJhbmdlLmZyb21Qb2ludHMoc3RhcnR8fHRoaXMuc3RhcnQsZW5kfHx0aGlzLmVuZCl9LHRoaXMuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnN0YXJ0LnJvdz09PXRoaXMuZW5kLnJvdyYmdGhpcy5zdGFydC5jb2x1bW49PT10aGlzLmVuZC5jb2x1bW59LHRoaXMuaXNNdWx0aUxpbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydC5yb3chPT10aGlzLmVuZC5yb3d9LHRoaXMuY2xvbmU9ZnVuY3Rpb24oKXtyZXR1cm4gUmFuZ2UuZnJvbVBvaW50cyh0aGlzLnN0YXJ0LHRoaXMuZW5kKX0sdGhpcy5jb2xsYXBzZVJvd3M9ZnVuY3Rpb24oKXtyZXR1cm4gMD09dGhpcy5lbmQuY29sdW1uP25ldyBSYW5nZSh0aGlzLnN0YXJ0LnJvdywwLE1hdGgubWF4KHRoaXMuc3RhcnQucm93LHRoaXMuZW5kLnJvdy0xKSwwKTpuZXcgUmFuZ2UodGhpcy5zdGFydC5yb3csMCx0aGlzLmVuZC5yb3csMCl9LHRoaXMudG9TY3JlZW5SYW5nZT1mdW5jdGlvbihzZXNzaW9uKXt2YXIgc2NyZWVuUG9zU3RhcnQ9c2Vzc2lvbi5kb2N1bWVudFRvU2NyZWVuUG9zaXRpb24odGhpcy5zdGFydCksc2NyZWVuUG9zRW5kPXNlc3Npb24uZG9jdW1lbnRUb1NjcmVlblBvc2l0aW9uKHRoaXMuZW5kKTtyZXR1cm4gbmV3IFJhbmdlKHNjcmVlblBvc1N0YXJ0LnJvdyxzY3JlZW5Qb3NTdGFydC5jb2x1bW4sc2NyZWVuUG9zRW5kLnJvdyxzY3JlZW5Qb3NFbmQuY29sdW1uKX0sdGhpcy5tb3ZlQnk9ZnVuY3Rpb24ocm93LGNvbHVtbil7dGhpcy5zdGFydC5yb3crPXJvdyx0aGlzLnN0YXJ0LmNvbHVtbis9Y29sdW1uLHRoaXMuZW5kLnJvdys9cm93LHRoaXMuZW5kLmNvbHVtbis9Y29sdW1ufX0pLmNhbGwoUmFuZ2UucHJvdG90eXBlKSxSYW5nZS5mcm9tUG9pbnRzPWZ1bmN0aW9uKHN0YXJ0LGVuZCl7cmV0dXJuIG5ldyBSYW5nZShzdGFydC5yb3csc3RhcnQuY29sdW1uLGVuZC5yb3csZW5kLmNvbHVtbil9LFJhbmdlLmNvbXBhcmVQb2ludHM9Y29tcGFyZVBvaW50cyxSYW5nZS5jb21wYXJlUG9pbnRzPWZ1bmN0aW9uKHAxLHAyKXtyZXR1cm4gcDEucm93LXAyLnJvd3x8cDEuY29sdW1uLXAyLmNvbHVtbn0sZXhwb3J0cy5SYW5nZT1SYW5nZX0pLGFjZS5kZWZpbmUoXFxcImFjZS9hbmNob3JcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL29vcFxcXCIsXFxcImFjZS9saWIvZXZlbnRfZW1pdHRlclxcXCJdLGZ1bmN0aW9uKGFjZXF1aXJlLGV4cG9ydHMpe1xcXCJ1c2Ugc3RyaWN0XFxcIjt2YXIgb29wPWFjZXF1aXJlKFxcXCIuL2xpYi9vb3BcXFwiKSxFdmVudEVtaXR0ZXI9YWNlcXVpcmUoXFxcIi4vbGliL2V2ZW50X2VtaXR0ZXJcXFwiKS5FdmVudEVtaXR0ZXIsQW5jaG9yPWV4cG9ydHMuQW5jaG9yPWZ1bmN0aW9uKGRvYyxyb3csY29sdW1uKXt0aGlzLiRvbkNoYW5nZT10aGlzLm9uQ2hhbmdlLmJpbmQodGhpcyksdGhpcy5hdHRhY2goZG9jKSxjb2x1bW49PT12b2lkIDA/dGhpcy5zZXRQb3NpdGlvbihyb3cucm93LHJvdy5jb2x1bW4pOnRoaXMuc2V0UG9zaXRpb24ocm93LGNvbHVtbil9OyhmdW5jdGlvbigpe29vcC5pbXBsZW1lbnQodGhpcyxFdmVudEVtaXR0ZXIpLHRoaXMuZ2V0UG9zaXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudCh0aGlzLnJvdyx0aGlzLmNvbHVtbil9LHRoaXMuZ2V0RG9jdW1lbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kb2N1bWVudH0sdGhpcy4kaW5zZXJ0UmlnaHQ9ITEsdGhpcy5vbkNoYW5nZT1mdW5jdGlvbihlKXt2YXIgZGVsdGE9ZS5kYXRhLHJhbmdlPWRlbHRhLnJhbmdlO2lmKCEocmFuZ2Uuc3RhcnQucm93PT1yYW5nZS5lbmQucm93JiZyYW5nZS5zdGFydC5yb3chPXRoaXMucm93fHxyYW5nZS5zdGFydC5yb3c+dGhpcy5yb3d8fHJhbmdlLnN0YXJ0LnJvdz09dGhpcy5yb3cmJnJhbmdlLnN0YXJ0LmNvbHVtbj50aGlzLmNvbHVtbikpe3ZhciByb3c9dGhpcy5yb3csY29sdW1uPXRoaXMuY29sdW1uLHN0YXJ0PXJhbmdlLnN0YXJ0LGVuZD1yYW5nZS5lbmQ7XFxcImluc2VydFRleHRcXFwiPT09ZGVsdGEuYWN0aW9uP3N0YXJ0LnJvdz09PXJvdyYmY29sdW1uPj1zdGFydC5jb2x1bW4/c3RhcnQuY29sdW1uPT09Y29sdW1uJiZ0aGlzLiRpbnNlcnRSaWdodHx8KHN0YXJ0LnJvdz09PWVuZC5yb3c/Y29sdW1uKz1lbmQuY29sdW1uLXN0YXJ0LmNvbHVtbjooY29sdW1uLT1zdGFydC5jb2x1bW4scm93Kz1lbmQucm93LXN0YXJ0LnJvdykpOnN0YXJ0LnJvdyE9PWVuZC5yb3cmJnJvdz5zdGFydC5yb3cmJihyb3crPWVuZC5yb3ctc3RhcnQucm93KTpcXFwiaW5zZXJ0TGluZXNcXFwiPT09ZGVsdGEuYWN0aW9uP3N0YXJ0LnJvdz09PXJvdyYmMD09PWNvbHVtbiYmdGhpcy4kaW5zZXJ0UmlnaHR8fHJvdz49c3RhcnQucm93JiYocm93Kz1lbmQucm93LXN0YXJ0LnJvdyk6XFxcInJlbW92ZVRleHRcXFwiPT09ZGVsdGEuYWN0aW9uP3N0YXJ0LnJvdz09PXJvdyYmY29sdW1uPnN0YXJ0LmNvbHVtbj9jb2x1bW49ZW5kLmNvbHVtbj49Y29sdW1uP3N0YXJ0LmNvbHVtbjpNYXRoLm1heCgwLGNvbHVtbi0oZW5kLmNvbHVtbi1zdGFydC5jb2x1bW4pKTpzdGFydC5yb3chPT1lbmQucm93JiZyb3c+c3RhcnQucm93PyhlbmQucm93PT09cm93JiYoY29sdW1uPU1hdGgubWF4KDAsY29sdW1uLWVuZC5jb2x1bW4pK3N0YXJ0LmNvbHVtbikscm93LT1lbmQucm93LXN0YXJ0LnJvdyk6ZW5kLnJvdz09PXJvdyYmKHJvdy09ZW5kLnJvdy1zdGFydC5yb3csY29sdW1uPU1hdGgubWF4KDAsY29sdW1uLWVuZC5jb2x1bW4pK3N0YXJ0LmNvbHVtbik6XFxcInJlbW92ZUxpbmVzXFxcIj09ZGVsdGEuYWN0aW9uJiZyb3c+PXN0YXJ0LnJvdyYmKHJvdz49ZW5kLnJvdz9yb3ctPWVuZC5yb3ctc3RhcnQucm93Oihyb3c9c3RhcnQucm93LGNvbHVtbj0wKSksdGhpcy5zZXRQb3NpdGlvbihyb3csY29sdW1uLCEwKX19LHRoaXMuc2V0UG9zaXRpb249ZnVuY3Rpb24ocm93LGNvbHVtbixub0NsaXApe3ZhciBwb3M7aWYocG9zPW5vQ2xpcD97cm93OnJvdyxjb2x1bW46Y29sdW1ufTp0aGlzLiRjbGlwUG9zaXRpb25Ub0RvY3VtZW50KHJvdyxjb2x1bW4pLHRoaXMucm93IT1wb3Mucm93fHx0aGlzLmNvbHVtbiE9cG9zLmNvbHVtbil7dmFyIG9sZD17cm93OnRoaXMucm93LGNvbHVtbjp0aGlzLmNvbHVtbn07dGhpcy5yb3c9cG9zLnJvdyx0aGlzLmNvbHVtbj1wb3MuY29sdW1uLHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlXFxcIix7b2xkOm9sZCx2YWx1ZTpwb3N9KX19LHRoaXMuZGV0YWNoPWZ1bmN0aW9uKCl7dGhpcy5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJjaGFuZ2VcXFwiLHRoaXMuJG9uQ2hhbmdlKX0sdGhpcy5hdHRhY2g9ZnVuY3Rpb24oZG9jKXt0aGlzLmRvY3VtZW50PWRvY3x8dGhpcy5kb2N1bWVudCx0aGlzLmRvY3VtZW50Lm9uKFxcXCJjaGFuZ2VcXFwiLHRoaXMuJG9uQ2hhbmdlKX0sdGhpcy4kY2xpcFBvc2l0aW9uVG9Eb2N1bWVudD1mdW5jdGlvbihyb3csY29sdW1uKXt2YXIgcG9zPXt9O3JldHVybiByb3c+PXRoaXMuZG9jdW1lbnQuZ2V0TGVuZ3RoKCk/KHBvcy5yb3c9TWF0aC5tYXgoMCx0aGlzLmRvY3VtZW50LmdldExlbmd0aCgpLTEpLHBvcy5jb2x1bW49dGhpcy5kb2N1bWVudC5nZXRMaW5lKHBvcy5yb3cpLmxlbmd0aCk6MD5yb3c/KHBvcy5yb3c9MCxwb3MuY29sdW1uPTApOihwb3Mucm93PXJvdyxwb3MuY29sdW1uPU1hdGgubWluKHRoaXMuZG9jdW1lbnQuZ2V0TGluZShwb3Mucm93KS5sZW5ndGgsTWF0aC5tYXgoMCxjb2x1bW4pKSksMD5jb2x1bW4mJihwb3MuY29sdW1uPTApLHBvc319KS5jYWxsKEFuY2hvci5wcm90b3R5cGUpfSksYWNlLmRlZmluZShcXFwiYWNlL2RvY3VtZW50XFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2xpYi9vb3BcXFwiLFxcXCJhY2UvbGliL2V2ZW50X2VtaXR0ZXJcXFwiLFxcXCJhY2UvcmFuZ2VcXFwiLFxcXCJhY2UvYW5jaG9yXFxcIl0sZnVuY3Rpb24oYWNlcXVpcmUsZXhwb3J0cyl7XFxcInVzZSBzdHJpY3RcXFwiO3ZhciBvb3A9YWNlcXVpcmUoXFxcIi4vbGliL29vcFxcXCIpLEV2ZW50RW1pdHRlcj1hY2VxdWlyZShcXFwiLi9saWIvZXZlbnRfZW1pdHRlclxcXCIpLkV2ZW50RW1pdHRlcixSYW5nZT1hY2VxdWlyZShcXFwiLi9yYW5nZVxcXCIpLlJhbmdlLEFuY2hvcj1hY2VxdWlyZShcXFwiLi9hbmNob3JcXFwiKS5BbmNob3IsRG9jdW1lbnQ9ZnVuY3Rpb24odGV4dCl7dGhpcy4kbGluZXM9W10sMD09PXRleHQubGVuZ3RoP3RoaXMuJGxpbmVzPVtcXFwiXFxcIl06QXJyYXkuaXNBcnJheSh0ZXh0KT90aGlzLl9pbnNlcnRMaW5lcygwLHRleHQpOnRoaXMuaW5zZXJ0KHtyb3c6MCxjb2x1bW46MH0sdGV4dCl9OyhmdW5jdGlvbigpe29vcC5pbXBsZW1lbnQodGhpcyxFdmVudEVtaXR0ZXIpLHRoaXMuc2V0VmFsdWU9ZnVuY3Rpb24odGV4dCl7dmFyIGxlbj10aGlzLmdldExlbmd0aCgpO3RoaXMucmVtb3ZlKG5ldyBSYW5nZSgwLDAsbGVuLHRoaXMuZ2V0TGluZShsZW4tMSkubGVuZ3RoKSksdGhpcy5pbnNlcnQoe3JvdzowLGNvbHVtbjowfSx0ZXh0KX0sdGhpcy5nZXRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEFsbExpbmVzKCkuam9pbih0aGlzLmdldE5ld0xpbmVDaGFyYWN0ZXIoKSl9LHRoaXMuY3JlYXRlQW5jaG9yPWZ1bmN0aW9uKHJvdyxjb2x1bW4pe3JldHVybiBuZXcgQW5jaG9yKHRoaXMscm93LGNvbHVtbil9LHRoaXMuJHNwbGl0PTA9PT1cXFwiYWFhXFxcIi5zcGxpdCgvYS8pLmxlbmd0aD9mdW5jdGlvbih0ZXh0KXtyZXR1cm4gdGV4dC5yZXBsYWNlKC9cXFxcclxcXFxufFxcXFxyL2csXFxcIlxcXFxuXFxcIikuc3BsaXQoXFxcIlxcXFxuXFxcIil9OmZ1bmN0aW9uKHRleHQpe3JldHVybiB0ZXh0LnNwbGl0KC9cXFxcclxcXFxufFxcXFxyfFxcXFxuLyl9LHRoaXMuJGRldGVjdE5ld0xpbmU9ZnVuY3Rpb24odGV4dCl7dmFyIG1hdGNoPXRleHQubWF0Y2goL14uKj8oXFxcXHJcXFxcbnxcXFxccnxcXFxcbikvbSk7dGhpcy4kYXV0b05ld0xpbmU9bWF0Y2g/bWF0Y2hbMV06XFxcIlxcXFxuXFxcIix0aGlzLl9zaWduYWwoXFxcImNoYW5nZU5ld0xpbmVNb2RlXFxcIil9LHRoaXMuZ2V0TmV3TGluZUNoYXJhY3Rlcj1mdW5jdGlvbigpe3N3aXRjaCh0aGlzLiRuZXdMaW5lTW9kZSl7Y2FzZVxcXCJ3aW5kb3dzXFxcIjpyZXR1cm5cXFwiXFxcXHJcXFxcblxcXCI7Y2FzZVxcXCJ1bml4XFxcIjpyZXR1cm5cXFwiXFxcXG5cXFwiO2RlZmF1bHQ6cmV0dXJuIHRoaXMuJGF1dG9OZXdMaW5lfHxcXFwiXFxcXG5cXFwifX0sdGhpcy4kYXV0b05ld0xpbmU9XFxcIlxcXCIsdGhpcy4kbmV3TGluZU1vZGU9XFxcImF1dG9cXFwiLHRoaXMuc2V0TmV3TGluZU1vZGU9ZnVuY3Rpb24obmV3TGluZU1vZGUpe3RoaXMuJG5ld0xpbmVNb2RlIT09bmV3TGluZU1vZGUmJih0aGlzLiRuZXdMaW5lTW9kZT1uZXdMaW5lTW9kZSx0aGlzLl9zaWduYWwoXFxcImNoYW5nZU5ld0xpbmVNb2RlXFxcIikpfSx0aGlzLmdldE5ld0xpbmVNb2RlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJG5ld0xpbmVNb2RlfSx0aGlzLmlzTmV3TGluZT1mdW5jdGlvbih0ZXh0KXtyZXR1cm5cXFwiXFxcXHJcXFxcblxcXCI9PXRleHR8fFxcXCJcXFxcclxcXCI9PXRleHR8fFxcXCJcXFxcblxcXCI9PXRleHR9LHRoaXMuZ2V0TGluZT1mdW5jdGlvbihyb3cpe3JldHVybiB0aGlzLiRsaW5lc1tyb3ddfHxcXFwiXFxcIn0sdGhpcy5nZXRMaW5lcz1mdW5jdGlvbihmaXJzdFJvdyxsYXN0Um93KXtyZXR1cm4gdGhpcy4kbGluZXMuc2xpY2UoZmlyc3RSb3csbGFzdFJvdysxKX0sdGhpcy5nZXRBbGxMaW5lcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldExpbmVzKDAsdGhpcy5nZXRMZW5ndGgoKSl9LHRoaXMuZ2V0TGVuZ3RoPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGxpbmVzLmxlbmd0aH0sdGhpcy5nZXRUZXh0UmFuZ2U9ZnVuY3Rpb24ocmFuZ2Upe2lmKHJhbmdlLnN0YXJ0LnJvdz09cmFuZ2UuZW5kLnJvdylyZXR1cm4gdGhpcy5nZXRMaW5lKHJhbmdlLnN0YXJ0LnJvdykuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0LmNvbHVtbixyYW5nZS5lbmQuY29sdW1uKTt2YXIgbGluZXM9dGhpcy5nZXRMaW5lcyhyYW5nZS5zdGFydC5yb3cscmFuZ2UuZW5kLnJvdyk7bGluZXNbMF09KGxpbmVzWzBdfHxcXFwiXFxcIikuc3Vic3RyaW5nKHJhbmdlLnN0YXJ0LmNvbHVtbik7dmFyIGw9bGluZXMubGVuZ3RoLTE7cmV0dXJuIHJhbmdlLmVuZC5yb3ctcmFuZ2Uuc3RhcnQucm93PT1sJiYobGluZXNbbF09bGluZXNbbF0uc3Vic3RyaW5nKDAscmFuZ2UuZW5kLmNvbHVtbikpLGxpbmVzLmpvaW4odGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkpfSx0aGlzLiRjbGlwUG9zaXRpb249ZnVuY3Rpb24ocG9zaXRpb24pe3ZhciBsZW5ndGg9dGhpcy5nZXRMZW5ndGgoKTtyZXR1cm4gcG9zaXRpb24ucm93Pj1sZW5ndGg/KHBvc2l0aW9uLnJvdz1NYXRoLm1heCgwLGxlbmd0aC0xKSxwb3NpdGlvbi5jb2x1bW49dGhpcy5nZXRMaW5lKGxlbmd0aC0xKS5sZW5ndGgpOjA+cG9zaXRpb24ucm93JiYocG9zaXRpb24ucm93PTApLHBvc2l0aW9ufSx0aGlzLmluc2VydD1mdW5jdGlvbihwb3NpdGlvbix0ZXh0KXtpZighdGV4dHx8MD09PXRleHQubGVuZ3RoKXJldHVybiBwb3NpdGlvbjtwb3NpdGlvbj10aGlzLiRjbGlwUG9zaXRpb24ocG9zaXRpb24pLDE+PXRoaXMuZ2V0TGVuZ3RoKCkmJnRoaXMuJGRldGVjdE5ld0xpbmUodGV4dCk7dmFyIGxpbmVzPXRoaXMuJHNwbGl0KHRleHQpLGZpcnN0TGluZT1saW5lcy5zcGxpY2UoMCwxKVswXSxsYXN0TGluZT0wPT1saW5lcy5sZW5ndGg/bnVsbDpsaW5lcy5zcGxpY2UobGluZXMubGVuZ3RoLTEsMSlbMF07cmV0dXJuIHBvc2l0aW9uPXRoaXMuaW5zZXJ0SW5MaW5lKHBvc2l0aW9uLGZpcnN0TGluZSksbnVsbCE9PWxhc3RMaW5lJiYocG9zaXRpb249dGhpcy5pbnNlcnROZXdMaW5lKHBvc2l0aW9uKSxwb3NpdGlvbj10aGlzLl9pbnNlcnRMaW5lcyhwb3NpdGlvbi5yb3csbGluZXMpLHBvc2l0aW9uPXRoaXMuaW5zZXJ0SW5MaW5lKHBvc2l0aW9uLGxhc3RMaW5lfHxcXFwiXFxcIikpLHBvc2l0aW9ufSx0aGlzLmluc2VydExpbmVzPWZ1bmN0aW9uKHJvdyxsaW5lcyl7cmV0dXJuIHJvdz49dGhpcy5nZXRMZW5ndGgoKT90aGlzLmluc2VydCh7cm93OnJvdyxjb2x1bW46MH0sXFxcIlxcXFxuXFxcIitsaW5lcy5qb2luKFxcXCJcXFxcblxcXCIpKTp0aGlzLl9pbnNlcnRMaW5lcyhNYXRoLm1heChyb3csMCksbGluZXMpfSx0aGlzLl9pbnNlcnRMaW5lcz1mdW5jdGlvbihyb3csbGluZXMpe2lmKDA9PWxpbmVzLmxlbmd0aClyZXR1cm57cm93OnJvdyxjb2x1bW46MH07Zm9yKDtsaW5lcy5sZW5ndGg+NjE0NDA7KXt2YXIgZW5kPXRoaXMuX2luc2VydExpbmVzKHJvdyxsaW5lcy5zbGljZSgwLDYxNDQwKSk7bGluZXM9bGluZXMuc2xpY2UoNjE0NDApLHJvdz1lbmQucm93fXZhciBhcmdzPVtyb3csMF07YXJncy5wdXNoLmFwcGx5KGFyZ3MsbGluZXMpLHRoaXMuJGxpbmVzLnNwbGljZS5hcHBseSh0aGlzLiRsaW5lcyxhcmdzKTt2YXIgcmFuZ2U9bmV3IFJhbmdlKHJvdywwLHJvdytsaW5lcy5sZW5ndGgsMCksZGVsdGE9e2FjdGlvbjpcXFwiaW5zZXJ0TGluZXNcXFwiLHJhbmdlOnJhbmdlLGxpbmVzOmxpbmVzfTtyZXR1cm4gdGhpcy5fc2lnbmFsKFxcXCJjaGFuZ2VcXFwiLHtkYXRhOmRlbHRhfSkscmFuZ2UuZW5kfSx0aGlzLmluc2VydE5ld0xpbmU9ZnVuY3Rpb24ocG9zaXRpb24pe3Bvc2l0aW9uPXRoaXMuJGNsaXBQb3NpdGlvbihwb3NpdGlvbik7dmFyIGxpbmU9dGhpcy4kbGluZXNbcG9zaXRpb24ucm93XXx8XFxcIlxcXCI7dGhpcy4kbGluZXNbcG9zaXRpb24ucm93XT1saW5lLnN1YnN0cmluZygwLHBvc2l0aW9uLmNvbHVtbiksdGhpcy4kbGluZXMuc3BsaWNlKHBvc2l0aW9uLnJvdysxLDAsbGluZS5zdWJzdHJpbmcocG9zaXRpb24uY29sdW1uLGxpbmUubGVuZ3RoKSk7dmFyIGVuZD17cm93OnBvc2l0aW9uLnJvdysxLGNvbHVtbjowfSxkZWx0YT17YWN0aW9uOlxcXCJpbnNlcnRUZXh0XFxcIixyYW5nZTpSYW5nZS5mcm9tUG9pbnRzKHBvc2l0aW9uLGVuZCksdGV4dDp0aGlzLmdldE5ld0xpbmVDaGFyYWN0ZXIoKX07cmV0dXJuIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlXFxcIix7ZGF0YTpkZWx0YX0pLGVuZH0sdGhpcy5pbnNlcnRJbkxpbmU9ZnVuY3Rpb24ocG9zaXRpb24sdGV4dCl7aWYoMD09dGV4dC5sZW5ndGgpcmV0dXJuIHBvc2l0aW9uO3ZhciBsaW5lPXRoaXMuJGxpbmVzW3Bvc2l0aW9uLnJvd118fFxcXCJcXFwiO3RoaXMuJGxpbmVzW3Bvc2l0aW9uLnJvd109bGluZS5zdWJzdHJpbmcoMCxwb3NpdGlvbi5jb2x1bW4pK3RleHQrbGluZS5zdWJzdHJpbmcocG9zaXRpb24uY29sdW1uKTt2YXIgZW5kPXtyb3c6cG9zaXRpb24ucm93LGNvbHVtbjpwb3NpdGlvbi5jb2x1bW4rdGV4dC5sZW5ndGh9LGRlbHRhPXthY3Rpb246XFxcImluc2VydFRleHRcXFwiLHJhbmdlOlJhbmdlLmZyb21Qb2ludHMocG9zaXRpb24sZW5kKSx0ZXh0OnRleHR9O3JldHVybiB0aGlzLl9zaWduYWwoXFxcImNoYW5nZVxcXCIse2RhdGE6ZGVsdGF9KSxlbmR9LHRoaXMucmVtb3ZlPWZ1bmN0aW9uKHJhbmdlKXtpZihyYW5nZSBpbnN0YW5jZW9mIFJhbmdlfHwocmFuZ2U9UmFuZ2UuZnJvbVBvaW50cyhyYW5nZS5zdGFydCxyYW5nZS5lbmQpKSxyYW5nZS5zdGFydD10aGlzLiRjbGlwUG9zaXRpb24ocmFuZ2Uuc3RhcnQpLHJhbmdlLmVuZD10aGlzLiRjbGlwUG9zaXRpb24ocmFuZ2UuZW5kKSxyYW5nZS5pc0VtcHR5KCkpcmV0dXJuIHJhbmdlLnN0YXJ0O3ZhciBmaXJzdFJvdz1yYW5nZS5zdGFydC5yb3csbGFzdFJvdz1yYW5nZS5lbmQucm93O2lmKHJhbmdlLmlzTXVsdGlMaW5lKCkpe3ZhciBmaXJzdEZ1bGxSb3c9MD09cmFuZ2Uuc3RhcnQuY29sdW1uP2ZpcnN0Um93OmZpcnN0Um93KzEsbGFzdEZ1bGxSb3c9bGFzdFJvdy0xO3JhbmdlLmVuZC5jb2x1bW4+MCYmdGhpcy5yZW1vdmVJbkxpbmUobGFzdFJvdywwLHJhbmdlLmVuZC5jb2x1bW4pLGxhc3RGdWxsUm93Pj1maXJzdEZ1bGxSb3cmJnRoaXMuX3JlbW92ZUxpbmVzKGZpcnN0RnVsbFJvdyxsYXN0RnVsbFJvdyksZmlyc3RGdWxsUm93IT1maXJzdFJvdyYmKHRoaXMucmVtb3ZlSW5MaW5lKGZpcnN0Um93LHJhbmdlLnN0YXJ0LmNvbHVtbix0aGlzLmdldExpbmUoZmlyc3RSb3cpLmxlbmd0aCksdGhpcy5yZW1vdmVOZXdMaW5lKHJhbmdlLnN0YXJ0LnJvdykpfWVsc2UgdGhpcy5yZW1vdmVJbkxpbmUoZmlyc3RSb3cscmFuZ2Uuc3RhcnQuY29sdW1uLHJhbmdlLmVuZC5jb2x1bW4pO3JldHVybiByYW5nZS5zdGFydH0sdGhpcy5yZW1vdmVJbkxpbmU9ZnVuY3Rpb24ocm93LHN0YXJ0Q29sdW1uLGVuZENvbHVtbil7aWYoc3RhcnRDb2x1bW4hPWVuZENvbHVtbil7dmFyIHJhbmdlPW5ldyBSYW5nZShyb3csc3RhcnRDb2x1bW4scm93LGVuZENvbHVtbiksbGluZT10aGlzLmdldExpbmUocm93KSxyZW1vdmVkPWxpbmUuc3Vic3RyaW5nKHN0YXJ0Q29sdW1uLGVuZENvbHVtbiksbmV3TGluZT1saW5lLnN1YnN0cmluZygwLHN0YXJ0Q29sdW1uKStsaW5lLnN1YnN0cmluZyhlbmRDb2x1bW4sbGluZS5sZW5ndGgpO3RoaXMuJGxpbmVzLnNwbGljZShyb3csMSxuZXdMaW5lKTt2YXIgZGVsdGE9e2FjdGlvbjpcXFwicmVtb3ZlVGV4dFxcXCIscmFuZ2U6cmFuZ2UsdGV4dDpyZW1vdmVkfTtyZXR1cm4gdGhpcy5fc2lnbmFsKFxcXCJjaGFuZ2VcXFwiLHtkYXRhOmRlbHRhfSkscmFuZ2Uuc3RhcnR9fSx0aGlzLnJlbW92ZUxpbmVzPWZ1bmN0aW9uKGZpcnN0Um93LGxhc3RSb3cpe3JldHVybiAwPmZpcnN0Um93fHxsYXN0Um93Pj10aGlzLmdldExlbmd0aCgpP3RoaXMucmVtb3ZlKG5ldyBSYW5nZShmaXJzdFJvdywwLGxhc3RSb3crMSwwKSk6dGhpcy5fcmVtb3ZlTGluZXMoZmlyc3RSb3csbGFzdFJvdyl9LHRoaXMuX3JlbW92ZUxpbmVzPWZ1bmN0aW9uKGZpcnN0Um93LGxhc3RSb3cpe3ZhciByYW5nZT1uZXcgUmFuZ2UoZmlyc3RSb3csMCxsYXN0Um93KzEsMCkscmVtb3ZlZD10aGlzLiRsaW5lcy5zcGxpY2UoZmlyc3RSb3csbGFzdFJvdy1maXJzdFJvdysxKSxkZWx0YT17YWN0aW9uOlxcXCJyZW1vdmVMaW5lc1xcXCIscmFuZ2U6cmFuZ2Usbmw6dGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCksbGluZXM6cmVtb3ZlZH07cmV0dXJuIHRoaXMuX3NpZ25hbChcXFwiY2hhbmdlXFxcIix7ZGF0YTpkZWx0YX0pLHJlbW92ZWR9LHRoaXMucmVtb3ZlTmV3TGluZT1mdW5jdGlvbihyb3cpe3ZhciBmaXJzdExpbmU9dGhpcy5nZXRMaW5lKHJvdyksc2Vjb25kTGluZT10aGlzLmdldExpbmUocm93KzEpLHJhbmdlPW5ldyBSYW5nZShyb3csZmlyc3RMaW5lLmxlbmd0aCxyb3crMSwwKSxsaW5lPWZpcnN0TGluZStzZWNvbmRMaW5lO3RoaXMuJGxpbmVzLnNwbGljZShyb3csMixsaW5lKTt2YXIgZGVsdGE9e2FjdGlvbjpcXFwicmVtb3ZlVGV4dFxcXCIscmFuZ2U6cmFuZ2UsdGV4dDp0aGlzLmdldE5ld0xpbmVDaGFyYWN0ZXIoKX07dGhpcy5fc2lnbmFsKFxcXCJjaGFuZ2VcXFwiLHtkYXRhOmRlbHRhfSl9LHRoaXMucmVwbGFjZT1mdW5jdGlvbihyYW5nZSx0ZXh0KXtpZihyYW5nZSBpbnN0YW5jZW9mIFJhbmdlfHwocmFuZ2U9UmFuZ2UuZnJvbVBvaW50cyhyYW5nZS5zdGFydCxyYW5nZS5lbmQpKSwwPT10ZXh0Lmxlbmd0aCYmcmFuZ2UuaXNFbXB0eSgpKXJldHVybiByYW5nZS5zdGFydDtpZih0ZXh0PT10aGlzLmdldFRleHRSYW5nZShyYW5nZSkpcmV0dXJuIHJhbmdlLmVuZDtpZih0aGlzLnJlbW92ZShyYW5nZSksdGV4dCl2YXIgZW5kPXRoaXMuaW5zZXJ0KHJhbmdlLnN0YXJ0LHRleHQpO2Vsc2UgZW5kPXJhbmdlLnN0YXJ0O3JldHVybiBlbmR9LHRoaXMuYXBwbHlEZWx0YXM9ZnVuY3Rpb24oZGVsdGFzKXtmb3IodmFyIGk9MDtkZWx0YXMubGVuZ3RoPmk7aSsrKXt2YXIgZGVsdGE9ZGVsdGFzW2ldLHJhbmdlPVJhbmdlLmZyb21Qb2ludHMoZGVsdGEucmFuZ2Uuc3RhcnQsZGVsdGEucmFuZ2UuZW5kKTtcXFwiaW5zZXJ0TGluZXNcXFwiPT1kZWx0YS5hY3Rpb24/dGhpcy5pbnNlcnRMaW5lcyhyYW5nZS5zdGFydC5yb3csZGVsdGEubGluZXMpOlxcXCJpbnNlcnRUZXh0XFxcIj09ZGVsdGEuYWN0aW9uP3RoaXMuaW5zZXJ0KHJhbmdlLnN0YXJ0LGRlbHRhLnRleHQpOlxcXCJyZW1vdmVMaW5lc1xcXCI9PWRlbHRhLmFjdGlvbj90aGlzLl9yZW1vdmVMaW5lcyhyYW5nZS5zdGFydC5yb3cscmFuZ2UuZW5kLnJvdy0xKTpcXFwicmVtb3ZlVGV4dFxcXCI9PWRlbHRhLmFjdGlvbiYmdGhpcy5yZW1vdmUocmFuZ2UpfX0sdGhpcy5yZXZlcnREZWx0YXM9ZnVuY3Rpb24oZGVsdGFzKXtmb3IodmFyIGk9ZGVsdGFzLmxlbmd0aC0xO2k+PTA7aS0tKXt2YXIgZGVsdGE9ZGVsdGFzW2ldLHJhbmdlPVJhbmdlLmZyb21Qb2ludHMoZGVsdGEucmFuZ2Uuc3RhcnQsZGVsdGEucmFuZ2UuZW5kKTtcXFwiaW5zZXJ0TGluZXNcXFwiPT1kZWx0YS5hY3Rpb24/dGhpcy5fcmVtb3ZlTGluZXMocmFuZ2Uuc3RhcnQucm93LHJhbmdlLmVuZC5yb3ctMSk6XFxcImluc2VydFRleHRcXFwiPT1kZWx0YS5hY3Rpb24/dGhpcy5yZW1vdmUocmFuZ2UpOlxcXCJyZW1vdmVMaW5lc1xcXCI9PWRlbHRhLmFjdGlvbj90aGlzLl9pbnNlcnRMaW5lcyhyYW5nZS5zdGFydC5yb3csZGVsdGEubGluZXMpOlxcXCJyZW1vdmVUZXh0XFxcIj09ZGVsdGEuYWN0aW9uJiZ0aGlzLmluc2VydChyYW5nZS5zdGFydCxkZWx0YS50ZXh0KX19LHRoaXMuaW5kZXhUb1Bvc2l0aW9uPWZ1bmN0aW9uKGluZGV4LHN0YXJ0Um93KXtmb3IodmFyIGxpbmVzPXRoaXMuJGxpbmVzfHx0aGlzLmdldEFsbExpbmVzKCksbmV3bGluZUxlbmd0aD10aGlzLmdldE5ld0xpbmVDaGFyYWN0ZXIoKS5sZW5ndGgsaT1zdGFydFJvd3x8MCxsPWxpbmVzLmxlbmd0aDtsPmk7aSsrKWlmKGluZGV4LT1saW5lc1tpXS5sZW5ndGgrbmV3bGluZUxlbmd0aCwwPmluZGV4KXJldHVybntyb3c6aSxjb2x1bW46aW5kZXgrbGluZXNbaV0ubGVuZ3RoK25ld2xpbmVMZW5ndGh9O3JldHVybntyb3c6bC0xLGNvbHVtbjpsaW5lc1tsLTFdLmxlbmd0aH19LHRoaXMucG9zaXRpb25Ub0luZGV4PWZ1bmN0aW9uKHBvcyxzdGFydFJvdyl7Zm9yKHZhciBsaW5lcz10aGlzLiRsaW5lc3x8dGhpcy5nZXRBbGxMaW5lcygpLG5ld2xpbmVMZW5ndGg9dGhpcy5nZXROZXdMaW5lQ2hhcmFjdGVyKCkubGVuZ3RoLGluZGV4PTAscm93PU1hdGgubWluKHBvcy5yb3csbGluZXMubGVuZ3RoKSxpPXN0YXJ0Um93fHwwO3Jvdz5pOysraSlpbmRleCs9bGluZXNbaV0ubGVuZ3RoK25ld2xpbmVMZW5ndGg7cmV0dXJuIGluZGV4K3Bvcy5jb2x1bW59fSkuY2FsbChEb2N1bWVudC5wcm90b3R5cGUpLGV4cG9ydHMuRG9jdW1lbnQ9RG9jdW1lbnR9KSxhY2UuZGVmaW5lKFxcXCJhY2UvbGliL2xhbmdcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiXSxmdW5jdGlvbihhY2VxdWlyZSxleHBvcnRzKXtcXFwidXNlIHN0cmljdFxcXCI7ZXhwb3J0cy5sYXN0PWZ1bmN0aW9uKGEpe3JldHVybiBhW2EubGVuZ3RoLTFdfSxleHBvcnRzLnN0cmluZ1JldmVyc2U9ZnVuY3Rpb24oc3RyaW5nKXtyZXR1cm4gc3RyaW5nLnNwbGl0KFxcXCJcXFwiKS5yZXZlcnNlKCkuam9pbihcXFwiXFxcIil9LGV4cG9ydHMuc3RyaW5nUmVwZWF0PWZ1bmN0aW9uKHN0cmluZyxjb3VudCl7Zm9yKHZhciByZXN1bHQ9XFxcIlxcXCI7Y291bnQ+MDspMSZjb3VudCYmKHJlc3VsdCs9c3RyaW5nKSwoY291bnQ+Pj0xKSYmKHN0cmluZys9c3RyaW5nKTtyZXR1cm4gcmVzdWx0fTt2YXIgdHJpbUJlZ2luUmVnZXhwPS9eXFxcXHNcXFxccyovLHRyaW1FbmRSZWdleHA9L1xcXFxzXFxcXHMqJC87ZXhwb3J0cy5zdHJpbmdUcmltTGVmdD1mdW5jdGlvbihzdHJpbmcpe3JldHVybiBzdHJpbmcucmVwbGFjZSh0cmltQmVnaW5SZWdleHAsXFxcIlxcXCIpfSxleHBvcnRzLnN0cmluZ1RyaW1SaWdodD1mdW5jdGlvbihzdHJpbmcpe3JldHVybiBzdHJpbmcucmVwbGFjZSh0cmltRW5kUmVnZXhwLFxcXCJcXFwiKX0sZXhwb3J0cy5jb3B5T2JqZWN0PWZ1bmN0aW9uKG9iail7dmFyIGNvcHk9e307Zm9yKHZhciBrZXkgaW4gb2JqKWNvcHlba2V5XT1vYmpba2V5XTtyZXR1cm4gY29weX0sZXhwb3J0cy5jb3B5QXJyYXk9ZnVuY3Rpb24oYXJyYXkpe2Zvcih2YXIgY29weT1bXSxpPTAsbD1hcnJheS5sZW5ndGg7bD5pO2krKyljb3B5W2ldPWFycmF5W2ldJiZcXFwib2JqZWN0XFxcIj09dHlwZW9mIGFycmF5W2ldP3RoaXMuY29weU9iamVjdChhcnJheVtpXSk6YXJyYXlbaV07cmV0dXJuIGNvcHl9LGV4cG9ydHMuZGVlcENvcHk9ZnVuY3Rpb24ob2JqKXtpZihcXFwib2JqZWN0XFxcIiE9dHlwZW9mIG9ianx8IW9iailyZXR1cm4gb2JqO3ZhciBjb25zPW9iai5jb25zdHJ1Y3RvcjtpZihjb25zPT09UmVnRXhwKXJldHVybiBvYmo7dmFyIGNvcHk9Y29ucygpO2Zvcih2YXIga2V5IGluIG9iailjb3B5W2tleV09XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBvYmpba2V5XT9leHBvcnRzLmRlZXBDb3B5KG9ialtrZXldKTpvYmpba2V5XTtyZXR1cm4gY29weX0sZXhwb3J0cy5hcnJheVRvTWFwPWZ1bmN0aW9uKGFycil7Zm9yKHZhciBtYXA9e30saT0wO2Fyci5sZW5ndGg+aTtpKyspbWFwW2FycltpXV09MTtyZXR1cm4gbWFwfSxleHBvcnRzLmNyZWF0ZU1hcD1mdW5jdGlvbihwcm9wcyl7dmFyIG1hcD1PYmplY3QuY3JlYXRlKG51bGwpO2Zvcih2YXIgaSBpbiBwcm9wcyltYXBbaV09cHJvcHNbaV07cmV0dXJuIG1hcH0sZXhwb3J0cy5hcnJheVJlbW92ZT1mdW5jdGlvbihhcnJheSx2YWx1ZSl7Zm9yKHZhciBpPTA7YXJyYXkubGVuZ3RoPj1pO2krKyl2YWx1ZT09PWFycmF5W2ldJiZhcnJheS5zcGxpY2UoaSwxKX0sZXhwb3J0cy5lc2NhcGVSZWdFeHA9ZnVuY3Rpb24oc3RyKXtyZXR1cm4gc3RyLnJlcGxhY2UoLyhbLiorP14ke30oKXxbXFxcXF1cXFxcL1xcXFxcXFxcXSkvZyxcXFwiXFxcXFxcXFwkMVxcXCIpfSxleHBvcnRzLmVzY2FwZUhUTUw9ZnVuY3Rpb24oc3RyKXtyZXR1cm4gc3RyLnJlcGxhY2UoLyYvZyxcXFwiJiMzODtcXFwiKS5yZXBsYWNlKC9cXFwiL2csXFxcIiYjMzQ7XFxcIikucmVwbGFjZSgvJy9nLFxcXCImIzM5O1xcXCIpLnJlcGxhY2UoLzwvZyxcXFwiJiM2MDtcXFwiKX0sZXhwb3J0cy5nZXRNYXRjaE9mZnNldHM9ZnVuY3Rpb24oc3RyaW5nLHJlZ0V4cCl7dmFyIG1hdGNoZXM9W107cmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlZ0V4cCxmdW5jdGlvbihzdHIpe21hdGNoZXMucHVzaCh7b2Zmc2V0OmFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoLTJdLGxlbmd0aDpzdHIubGVuZ3RofSl9KSxtYXRjaGVzfSxleHBvcnRzLmRlZmVycmVkQ2FsbD1mdW5jdGlvbihmY24pe3ZhciB0aW1lcj1udWxsLGNhbGxiYWNrPWZ1bmN0aW9uKCl7dGltZXI9bnVsbCxmY24oKX0sZGVmZXJyZWQ9ZnVuY3Rpb24odGltZW91dCl7cmV0dXJuIGRlZmVycmVkLmNhbmNlbCgpLHRpbWVyPXNldFRpbWVvdXQoY2FsbGJhY2ssdGltZW91dHx8MCksZGVmZXJyZWR9O3JldHVybiBkZWZlcnJlZC5zY2hlZHVsZT1kZWZlcnJlZCxkZWZlcnJlZC5jYWxsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2FuY2VsKCksZmNuKCksZGVmZXJyZWR9LGRlZmVycmVkLmNhbmNlbD1mdW5jdGlvbigpe3JldHVybiBjbGVhclRpbWVvdXQodGltZXIpLHRpbWVyPW51bGwsZGVmZXJyZWR9LGRlZmVycmVkLmlzUGVuZGluZz1mdW5jdGlvbigpe3JldHVybiB0aW1lcn0sZGVmZXJyZWR9LGV4cG9ydHMuZGVsYXllZENhbGw9ZnVuY3Rpb24oZmNuLGRlZmF1bHRUaW1lb3V0KXt2YXIgdGltZXI9bnVsbCxjYWxsYmFjaz1mdW5jdGlvbigpe3RpbWVyPW51bGwsZmNuKCl9LF9zZWxmPWZ1bmN0aW9uKHRpbWVvdXQpe251bGw9PXRpbWVyJiYodGltZXI9c2V0VGltZW91dChjYWxsYmFjayx0aW1lb3V0fHxkZWZhdWx0VGltZW91dCkpfTtyZXR1cm4gX3NlbGYuZGVsYXk9ZnVuY3Rpb24odGltZW91dCl7dGltZXImJmNsZWFyVGltZW91dCh0aW1lciksdGltZXI9c2V0VGltZW91dChjYWxsYmFjayx0aW1lb3V0fHxkZWZhdWx0VGltZW91dCl9LF9zZWxmLnNjaGVkdWxlPV9zZWxmLF9zZWxmLmNhbGw9ZnVuY3Rpb24oKXt0aGlzLmNhbmNlbCgpLGZjbigpfSxfc2VsZi5jYW5jZWw9ZnVuY3Rpb24oKXt0aW1lciYmY2xlYXJUaW1lb3V0KHRpbWVyKSx0aW1lcj1udWxsfSxfc2VsZi5pc1BlbmRpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdGltZXJ9LF9zZWxmfX0pLGFjZS5kZWZpbmUoXFxcImFjZS93b3JrZXIvbWlycm9yXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIixcXFwiYWNlL2RvY3VtZW50XFxcIixcXFwiYWNlL2xpYi9sYW5nXFxcIl0sZnVuY3Rpb24oYWNlcXVpcmUsZXhwb3J0cyl7XFxcInVzZSBzdHJpY3RcXFwiO3ZhciBEb2N1bWVudD1hY2VxdWlyZShcXFwiLi4vZG9jdW1lbnRcXFwiKS5Eb2N1bWVudCxsYW5nPWFjZXF1aXJlKFxcXCIuLi9saWIvbGFuZ1xcXCIpLE1pcnJvcj1leHBvcnRzLk1pcnJvcj1mdW5jdGlvbihzZW5kZXIpe3RoaXMuc2VuZGVyPXNlbmRlcjt2YXIgZG9jPXRoaXMuZG9jPW5ldyBEb2N1bWVudChcXFwiXFxcIiksZGVmZXJyZWRVcGRhdGU9dGhpcy5kZWZlcnJlZFVwZGF0ZT1sYW5nLmRlbGF5ZWRDYWxsKHRoaXMub25VcGRhdGUuYmluZCh0aGlzKSksX3NlbGY9dGhpcztzZW5kZXIub24oXFxcImNoYW5nZVxcXCIsZnVuY3Rpb24oZSl7cmV0dXJuIGRvYy5hcHBseURlbHRhcyhlLmRhdGEpLF9zZWxmLiR0aW1lb3V0P2RlZmVycmVkVXBkYXRlLnNjaGVkdWxlKF9zZWxmLiR0aW1lb3V0KTooX3NlbGYub25VcGRhdGUoKSx2b2lkIDApfSl9OyhmdW5jdGlvbigpe3RoaXMuJHRpbWVvdXQ9NTAwLHRoaXMuc2V0VGltZW91dD1mdW5jdGlvbih0aW1lb3V0KXt0aGlzLiR0aW1lb3V0PXRpbWVvdXR9LHRoaXMuc2V0VmFsdWU9ZnVuY3Rpb24odmFsdWUpe3RoaXMuZG9jLnNldFZhbHVlKHZhbHVlKSx0aGlzLmRlZmVycmVkVXBkYXRlLnNjaGVkdWxlKHRoaXMuJHRpbWVvdXQpfSx0aGlzLmdldFZhbHVlPWZ1bmN0aW9uKGNhbGxiYWNrSWQpe3RoaXMuc2VuZGVyLmNhbGxiYWNrKHRoaXMuZG9jLmdldFZhbHVlKCksY2FsbGJhY2tJZCl9LHRoaXMub25VcGRhdGU9ZnVuY3Rpb24oKXt9LHRoaXMuaXNQZW5kaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVmZXJyZWRVcGRhdGUuaXNQZW5kaW5nKCl9fSkuY2FsbChNaXJyb3IucHJvdG90eXBlKX0pLGFjZS5kZWZpbmUoXFxcImFjZS9tb2RlL2phdmFzY3JpcHQvanNoaW50XFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIl0sZnVuY3Rpb24oYWNlcXVpcmUsZXhwb3J0cyxtb2R1bGUpe21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBhY2VxdWlyZSYmYWNlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBFcnJvcihcXFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcXFwiK28rXFxcIidcXFwiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfWZvcih2YXIgaT1cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgYWNlcXVpcmUmJmFjZXF1aXJlLG89MDtyLmxlbmd0aD5vO28rKylzKHJbb10pO3JldHVybiBzfSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUpe2Zvcih2YXIgaWRlbnRpZmllclN0YXJ0VGFibGU9W10saT0wOzEyOD5pO2krKylpZGVudGlmaWVyU3RhcnRUYWJsZVtpXT0zNj09PWl8fGk+PTY1JiY5MD49aXx8OTU9PT1pfHxpPj05NyYmMTIyPj1pO2Zvcih2YXIgaWRlbnRpZmllclBhcnRUYWJsZT1bXSxpPTA7MTI4Pmk7aSsrKWlkZW50aWZpZXJQYXJ0VGFibGVbaV09aWRlbnRpZmllclN0YXJ0VGFibGVbaV18fGk+PTQ4JiY1Nz49aTttb2R1bGUuZXhwb3J0cz17YXNjaWlJZGVudGlmaWVyU3RhcnRUYWJsZTppZGVudGlmaWVyU3RhcnRUYWJsZSxhc2NpaUlkZW50aWZpZXJQYXJ0VGFibGU6aWRlbnRpZmllclBhcnRUYWJsZX19LHt9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oKXt2YXIgcm9vdD10aGlzLHByZXZpb3VzVW5kZXJzY29yZT1yb290Ll8sYnJlYWtlcj17fSxBcnJheVByb3RvPUFycmF5LnByb3RvdHlwZSxPYmpQcm90bz1PYmplY3QucHJvdG90eXBlLEZ1bmNQcm90bz1GdW5jdGlvbi5wcm90b3R5cGUscHVzaD1BcnJheVByb3RvLnB1c2gsc2xpY2U9QXJyYXlQcm90by5zbGljZSxjb25jYXQ9QXJyYXlQcm90by5jb25jYXQsdG9TdHJpbmc9T2JqUHJvdG8udG9TdHJpbmcsaGFzT3duUHJvcGVydHk9T2JqUHJvdG8uaGFzT3duUHJvcGVydHksbmF0aXZlRm9yRWFjaD1BcnJheVByb3RvLmZvckVhY2gsbmF0aXZlTWFwPUFycmF5UHJvdG8ubWFwLG5hdGl2ZVJlZHVjZT1BcnJheVByb3RvLnJlZHVjZSxuYXRpdmVSZWR1Y2VSaWdodD1BcnJheVByb3RvLnJlZHVjZVJpZ2h0LG5hdGl2ZUZpbHRlcj1BcnJheVByb3RvLmZpbHRlcixuYXRpdmVFdmVyeT1BcnJheVByb3RvLmV2ZXJ5LG5hdGl2ZVNvbWU9QXJyYXlQcm90by5zb21lLG5hdGl2ZUluZGV4T2Y9QXJyYXlQcm90by5pbmRleE9mLG5hdGl2ZUxhc3RJbmRleE9mPUFycmF5UHJvdG8ubGFzdEluZGV4T2YsbmF0aXZlSXNBcnJheT1BcnJheS5pc0FycmF5LG5hdGl2ZUtleXM9T2JqZWN0LmtleXMsbmF0aXZlQmluZD1GdW5jUHJvdG8uYmluZCxfPWZ1bmN0aW9uKG9iail7cmV0dXJuIG9iaiBpbnN0YW5jZW9mIF8/b2JqOnRoaXMgaW5zdGFuY2VvZiBfPyh0aGlzLl93cmFwcGVkPW9iaix2b2lkIDApOm5ldyBfKG9iail9O2V4cG9ydHMhPT12b2lkIDA/KG1vZHVsZSE9PXZvaWQgMCYmbW9kdWxlLmV4cG9ydHMmJihleHBvcnRzPW1vZHVsZS5leHBvcnRzPV8pLGV4cG9ydHMuXz1fKTpyb290Ll89XyxfLlZFUlNJT049XFxcIjEuNi4wXFxcIjt2YXIgZWFjaD1fLmVhY2g9Xy5mb3JFYWNoPWZ1bmN0aW9uKG9iaixpdGVyYXRvcixjb250ZXh0KXtpZihudWxsPT1vYmopcmV0dXJuIG9iajtpZihuYXRpdmVGb3JFYWNoJiZvYmouZm9yRWFjaD09PW5hdGl2ZUZvckVhY2gpb2JqLmZvckVhY2goaXRlcmF0b3IsY29udGV4dCk7ZWxzZSBpZihvYmoubGVuZ3RoPT09K29iai5sZW5ndGgpe2Zvcih2YXIgaT0wLGxlbmd0aD1vYmoubGVuZ3RoO2xlbmd0aD5pO2krKylpZihpdGVyYXRvci5jYWxsKGNvbnRleHQsb2JqW2ldLGksb2JqKT09PWJyZWFrZXIpcmV0dXJufWVsc2UgZm9yKHZhciBrZXlzPV8ua2V5cyhvYmopLGk9MCxsZW5ndGg9a2V5cy5sZW5ndGg7bGVuZ3RoPmk7aSsrKWlmKGl0ZXJhdG9yLmNhbGwoY29udGV4dCxvYmpba2V5c1tpXV0sa2V5c1tpXSxvYmopPT09YnJlYWtlcilyZXR1cm47cmV0dXJuIG9ian07Xy5tYXA9Xy5jb2xsZWN0PWZ1bmN0aW9uKG9iaixpdGVyYXRvcixjb250ZXh0KXt2YXIgcmVzdWx0cz1bXTtyZXR1cm4gbnVsbD09b2JqP3Jlc3VsdHM6bmF0aXZlTWFwJiZvYmoubWFwPT09bmF0aXZlTWFwP29iai5tYXAoaXRlcmF0b3IsY29udGV4dCk6KGVhY2gob2JqLGZ1bmN0aW9uKHZhbHVlLGluZGV4LGxpc3Qpe3Jlc3VsdHMucHVzaChpdGVyYXRvci5jYWxsKGNvbnRleHQsdmFsdWUsaW5kZXgsbGlzdCkpfSkscmVzdWx0cyl9O3ZhciByZWR1Y2VFcnJvcj1cXFwiUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZVxcXCI7Xy5yZWR1Y2U9Xy5mb2xkbD1fLmluamVjdD1mdW5jdGlvbihvYmosaXRlcmF0b3IsbWVtbyxjb250ZXh0KXt2YXIgaW5pdGlhbD1hcmd1bWVudHMubGVuZ3RoPjI7aWYobnVsbD09b2JqJiYob2JqPVtdKSxuYXRpdmVSZWR1Y2UmJm9iai5yZWR1Y2U9PT1uYXRpdmVSZWR1Y2UpcmV0dXJuIGNvbnRleHQmJihpdGVyYXRvcj1fLmJpbmQoaXRlcmF0b3IsY29udGV4dCkpLGluaXRpYWw/b2JqLnJlZHVjZShpdGVyYXRvcixtZW1vKTpvYmoucmVkdWNlKGl0ZXJhdG9yKTtpZihlYWNoKG9iaixmdW5jdGlvbih2YWx1ZSxpbmRleCxsaXN0KXtpbml0aWFsP21lbW89aXRlcmF0b3IuY2FsbChjb250ZXh0LG1lbW8sdmFsdWUsaW5kZXgsbGlzdCk6KG1lbW89dmFsdWUsaW5pdGlhbD0hMCl9KSwhaW5pdGlhbCl0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtyZXR1cm4gbWVtb30sXy5yZWR1Y2VSaWdodD1fLmZvbGRyPWZ1bmN0aW9uKG9iaixpdGVyYXRvcixtZW1vLGNvbnRleHQpe3ZhciBpbml0aWFsPWFyZ3VtZW50cy5sZW5ndGg+MjtpZihudWxsPT1vYmomJihvYmo9W10pLG5hdGl2ZVJlZHVjZVJpZ2h0JiZvYmoucmVkdWNlUmlnaHQ9PT1uYXRpdmVSZWR1Y2VSaWdodClyZXR1cm4gY29udGV4dCYmKGl0ZXJhdG9yPV8uYmluZChpdGVyYXRvcixjb250ZXh0KSksaW5pdGlhbD9vYmoucmVkdWNlUmlnaHQoaXRlcmF0b3IsbWVtbyk6b2JqLnJlZHVjZVJpZ2h0KGl0ZXJhdG9yKTt2YXIgbGVuZ3RoPW9iai5sZW5ndGg7aWYobGVuZ3RoIT09K2xlbmd0aCl7dmFyIGtleXM9Xy5rZXlzKG9iaik7bGVuZ3RoPWtleXMubGVuZ3RofWlmKGVhY2gob2JqLGZ1bmN0aW9uKHZhbHVlLGluZGV4LGxpc3Qpe2luZGV4PWtleXM/a2V5c1stLWxlbmd0aF06LS1sZW5ndGgsaW5pdGlhbD9tZW1vPWl0ZXJhdG9yLmNhbGwoY29udGV4dCxtZW1vLG9ialtpbmRleF0saW5kZXgsbGlzdCk6KG1lbW89b2JqW2luZGV4XSxpbml0aWFsPSEwKX0pLCFpbml0aWFsKXRocm93IG5ldyBUeXBlRXJyb3IocmVkdWNlRXJyb3IpO3JldHVybiBtZW1vfSxfLmZpbmQ9Xy5kZXRlY3Q9ZnVuY3Rpb24ob2JqLHByZWRpY2F0ZSxjb250ZXh0KXt2YXIgcmVzdWx0O3JldHVybiBhbnkob2JqLGZ1bmN0aW9uKHZhbHVlLGluZGV4LGxpc3Qpe3JldHVybiBwcmVkaWNhdGUuY2FsbChjb250ZXh0LHZhbHVlLGluZGV4LGxpc3QpPyhyZXN1bHQ9dmFsdWUsITApOnZvaWQgMH0pLHJlc3VsdH0sXy5maWx0ZXI9Xy5zZWxlY3Q9ZnVuY3Rpb24ob2JqLHByZWRpY2F0ZSxjb250ZXh0KXt2YXIgcmVzdWx0cz1bXTtyZXR1cm4gbnVsbD09b2JqP3Jlc3VsdHM6bmF0aXZlRmlsdGVyJiZvYmouZmlsdGVyPT09bmF0aXZlRmlsdGVyP29iai5maWx0ZXIocHJlZGljYXRlLGNvbnRleHQpOihlYWNoKG9iaixmdW5jdGlvbih2YWx1ZSxpbmRleCxsaXN0KXtwcmVkaWNhdGUuY2FsbChjb250ZXh0LHZhbHVlLGluZGV4LGxpc3QpJiZyZXN1bHRzLnB1c2godmFsdWUpfSkscmVzdWx0cyl9LF8ucmVqZWN0PWZ1bmN0aW9uKG9iaixwcmVkaWNhdGUsY29udGV4dCl7cmV0dXJuIF8uZmlsdGVyKG9iaixmdW5jdGlvbih2YWx1ZSxpbmRleCxsaXN0KXtyZXR1cm4hcHJlZGljYXRlLmNhbGwoY29udGV4dCx2YWx1ZSxpbmRleCxsaXN0KX0sY29udGV4dCl9LF8uZXZlcnk9Xy5hbGw9ZnVuY3Rpb24ob2JqLHByZWRpY2F0ZSxjb250ZXh0KXtwcmVkaWNhdGV8fChwcmVkaWNhdGU9Xy5pZGVudGl0eSk7dmFyIHJlc3VsdD0hMDtyZXR1cm4gbnVsbD09b2JqP3Jlc3VsdDpuYXRpdmVFdmVyeSYmb2JqLmV2ZXJ5PT09bmF0aXZlRXZlcnk/b2JqLmV2ZXJ5KHByZWRpY2F0ZSxjb250ZXh0KTooZWFjaChvYmosZnVuY3Rpb24odmFsdWUsaW5kZXgsbGlzdCl7cmV0dXJuKHJlc3VsdD1yZXN1bHQmJnByZWRpY2F0ZS5jYWxsKGNvbnRleHQsdmFsdWUsaW5kZXgsbGlzdCkpP3ZvaWQgMDpicmVha2VyfSksISFyZXN1bHQpfTt2YXIgYW55PV8uc29tZT1fLmFueT1mdW5jdGlvbihvYmoscHJlZGljYXRlLGNvbnRleHQpe3ByZWRpY2F0ZXx8KHByZWRpY2F0ZT1fLmlkZW50aXR5KTt2YXIgcmVzdWx0PSExO3JldHVybiBudWxsPT1vYmo/cmVzdWx0Om5hdGl2ZVNvbWUmJm9iai5zb21lPT09bmF0aXZlU29tZT9vYmouc29tZShwcmVkaWNhdGUsY29udGV4dCk6KGVhY2gob2JqLGZ1bmN0aW9uKHZhbHVlLGluZGV4LGxpc3Qpe3JldHVybiByZXN1bHR8fChyZXN1bHQ9cHJlZGljYXRlLmNhbGwoY29udGV4dCx2YWx1ZSxpbmRleCxsaXN0KSk/YnJlYWtlcjp2b2lkIDB9KSwhIXJlc3VsdCl9O18uY29udGFpbnM9Xy5pbmNsdWRlPWZ1bmN0aW9uKG9iaix0YXJnZXQpe3JldHVybiBudWxsPT1vYmo/ITE6bmF0aXZlSW5kZXhPZiYmb2JqLmluZGV4T2Y9PT1uYXRpdmVJbmRleE9mPy0xIT1vYmouaW5kZXhPZih0YXJnZXQpOmFueShvYmosZnVuY3Rpb24odmFsdWUpe3JldHVybiB2YWx1ZT09PXRhcmdldH0pfSxfLmludm9rZT1mdW5jdGlvbihvYmosbWV0aG9kKXt2YXIgYXJncz1zbGljZS5jYWxsKGFyZ3VtZW50cywyKSxpc0Z1bmM9Xy5pc0Z1bmN0aW9uKG1ldGhvZCk7cmV0dXJuIF8ubWFwKG9iaixmdW5jdGlvbih2YWx1ZSl7cmV0dXJuKGlzRnVuYz9tZXRob2Q6dmFsdWVbbWV0aG9kXSkuYXBwbHkodmFsdWUsYXJncyl9KX0sXy5wbHVjaz1mdW5jdGlvbihvYmosa2V5KXtyZXR1cm4gXy5tYXAob2JqLF8ucHJvcGVydHkoa2V5KSl9LF8ud2hlcmU9ZnVuY3Rpb24ob2JqLGF0dHJzKXtyZXR1cm4gXy5maWx0ZXIob2JqLF8ubWF0Y2hlcyhhdHRycykpfSxfLmZpbmRXaGVyZT1mdW5jdGlvbihvYmosYXR0cnMpe3JldHVybiBfLmZpbmQob2JqLF8ubWF0Y2hlcyhhdHRycykpfSxfLm1heD1mdW5jdGlvbihvYmosaXRlcmF0b3IsY29udGV4dCl7aWYoIWl0ZXJhdG9yJiZfLmlzQXJyYXkob2JqKSYmb2JqWzBdPT09K29ialswXSYmNjU1MzU+b2JqLmxlbmd0aClyZXR1cm4gTWF0aC5tYXguYXBwbHkoTWF0aCxvYmopO3ZhciByZXN1bHQ9LTEvMCxsYXN0Q29tcHV0ZWQ9LTEvMDtyZXR1cm4gZWFjaChvYmosZnVuY3Rpb24odmFsdWUsaW5kZXgsbGlzdCl7dmFyIGNvbXB1dGVkPWl0ZXJhdG9yP2l0ZXJhdG9yLmNhbGwoY29udGV4dCx2YWx1ZSxpbmRleCxsaXN0KTp2YWx1ZTtjb21wdXRlZD5sYXN0Q29tcHV0ZWQmJihyZXN1bHQ9dmFsdWUsbGFzdENvbXB1dGVkPWNvbXB1dGVkKX0pLHJlc3VsdH0sXy5taW49ZnVuY3Rpb24ob2JqLGl0ZXJhdG9yLGNvbnRleHQpe2lmKCFpdGVyYXRvciYmXy5pc0FycmF5KG9iaikmJm9ialswXT09PStvYmpbMF0mJjY1NTM1Pm9iai5sZW5ndGgpcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsb2JqKTt2YXIgcmVzdWx0PTEvMCxsYXN0Q29tcHV0ZWQ9MS8wO3JldHVybiBlYWNoKG9iaixmdW5jdGlvbih2YWx1ZSxpbmRleCxsaXN0KXt2YXIgY29tcHV0ZWQ9aXRlcmF0b3I/aXRlcmF0b3IuY2FsbChjb250ZXh0LHZhbHVlLGluZGV4LGxpc3QpOnZhbHVlO2xhc3RDb21wdXRlZD5jb21wdXRlZCYmKHJlc3VsdD12YWx1ZSxsYXN0Q29tcHV0ZWQ9Y29tcHV0ZWQpfSkscmVzdWx0fSxfLnNodWZmbGU9ZnVuY3Rpb24ob2JqKXt2YXIgcmFuZCxpbmRleD0wLHNodWZmbGVkPVtdO3JldHVybiBlYWNoKG9iaixmdW5jdGlvbih2YWx1ZSl7cmFuZD1fLnJhbmRvbShpbmRleCsrKSxzaHVmZmxlZFtpbmRleC0xXT1zaHVmZmxlZFtyYW5kXSxzaHVmZmxlZFtyYW5kXT12YWx1ZX0pLHNodWZmbGVkfSxfLnNhbXBsZT1mdW5jdGlvbihvYmosbixndWFyZCl7cmV0dXJuIG51bGw9PW58fGd1YXJkPyhvYmoubGVuZ3RoIT09K29iai5sZW5ndGgmJihvYmo9Xy52YWx1ZXMob2JqKSksb2JqW18ucmFuZG9tKG9iai5sZW5ndGgtMSldKTpfLnNodWZmbGUob2JqKS5zbGljZSgwLE1hdGgubWF4KDAsbikpfTt2YXIgbG9va3VwSXRlcmF0b3I9ZnVuY3Rpb24odmFsdWUpe3JldHVybiBudWxsPT12YWx1ZT9fLmlkZW50aXR5Ol8uaXNGdW5jdGlvbih2YWx1ZSk/dmFsdWU6Xy5wcm9wZXJ0eSh2YWx1ZSl9O18uc29ydEJ5PWZ1bmN0aW9uKG9iaixpdGVyYXRvcixjb250ZXh0KXtyZXR1cm4gaXRlcmF0b3I9bG9va3VwSXRlcmF0b3IoaXRlcmF0b3IpLF8ucGx1Y2soXy5tYXAob2JqLGZ1bmN0aW9uKHZhbHVlLGluZGV4LGxpc3Qpe3JldHVybnt2YWx1ZTp2YWx1ZSxpbmRleDppbmRleCxjcml0ZXJpYTppdGVyYXRvci5jYWxsKGNvbnRleHQsdmFsdWUsaW5kZXgsbGlzdCl9XFxufSkuc29ydChmdW5jdGlvbihsZWZ0LHJpZ2h0KXt2YXIgYT1sZWZ0LmNyaXRlcmlhLGI9cmlnaHQuY3JpdGVyaWE7aWYoYSE9PWIpe2lmKGE+Ynx8dm9pZCAwPT09YSlyZXR1cm4gMTtpZihiPmF8fHZvaWQgMD09PWIpcmV0dXJuLTF9cmV0dXJuIGxlZnQuaW5kZXgtcmlnaHQuaW5kZXh9KSxcXFwidmFsdWVcXFwiKX07dmFyIGdyb3VwPWZ1bmN0aW9uKGJlaGF2aW9yKXtyZXR1cm4gZnVuY3Rpb24ob2JqLGl0ZXJhdG9yLGNvbnRleHQpe3ZhciByZXN1bHQ9e307cmV0dXJuIGl0ZXJhdG9yPWxvb2t1cEl0ZXJhdG9yKGl0ZXJhdG9yKSxlYWNoKG9iaixmdW5jdGlvbih2YWx1ZSxpbmRleCl7dmFyIGtleT1pdGVyYXRvci5jYWxsKGNvbnRleHQsdmFsdWUsaW5kZXgsb2JqKTtiZWhhdmlvcihyZXN1bHQsa2V5LHZhbHVlKX0pLHJlc3VsdH19O18uZ3JvdXBCeT1ncm91cChmdW5jdGlvbihyZXN1bHQsa2V5LHZhbHVlKXtfLmhhcyhyZXN1bHQsa2V5KT9yZXN1bHRba2V5XS5wdXNoKHZhbHVlKTpyZXN1bHRba2V5XT1bdmFsdWVdfSksXy5pbmRleEJ5PWdyb3VwKGZ1bmN0aW9uKHJlc3VsdCxrZXksdmFsdWUpe3Jlc3VsdFtrZXldPXZhbHVlfSksXy5jb3VudEJ5PWdyb3VwKGZ1bmN0aW9uKHJlc3VsdCxrZXkpe18uaGFzKHJlc3VsdCxrZXkpP3Jlc3VsdFtrZXldKys6cmVzdWx0W2tleV09MX0pLF8uc29ydGVkSW5kZXg9ZnVuY3Rpb24oYXJyYXksb2JqLGl0ZXJhdG9yLGNvbnRleHQpe2l0ZXJhdG9yPWxvb2t1cEl0ZXJhdG9yKGl0ZXJhdG9yKTtmb3IodmFyIHZhbHVlPWl0ZXJhdG9yLmNhbGwoY29udGV4dCxvYmopLGxvdz0wLGhpZ2g9YXJyYXkubGVuZ3RoO2hpZ2g+bG93Oyl7dmFyIG1pZD1sb3craGlnaD4+PjE7dmFsdWU+aXRlcmF0b3IuY2FsbChjb250ZXh0LGFycmF5W21pZF0pP2xvdz1taWQrMTpoaWdoPW1pZH1yZXR1cm4gbG93fSxfLnRvQXJyYXk9ZnVuY3Rpb24ob2JqKXtyZXR1cm4gb2JqP18uaXNBcnJheShvYmopP3NsaWNlLmNhbGwob2JqKTpvYmoubGVuZ3RoPT09K29iai5sZW5ndGg/Xy5tYXAob2JqLF8uaWRlbnRpdHkpOl8udmFsdWVzKG9iaik6W119LF8uc2l6ZT1mdW5jdGlvbihvYmope3JldHVybiBudWxsPT1vYmo/MDpvYmoubGVuZ3RoPT09K29iai5sZW5ndGg/b2JqLmxlbmd0aDpfLmtleXMob2JqKS5sZW5ndGh9LF8uZmlyc3Q9Xy5oZWFkPV8udGFrZT1mdW5jdGlvbihhcnJheSxuLGd1YXJkKXtyZXR1cm4gbnVsbD09YXJyYXk/dm9pZCAwOm51bGw9PW58fGd1YXJkP2FycmF5WzBdOjA+bj9bXTpzbGljZS5jYWxsKGFycmF5LDAsbil9LF8uaW5pdGlhbD1mdW5jdGlvbihhcnJheSxuLGd1YXJkKXtyZXR1cm4gc2xpY2UuY2FsbChhcnJheSwwLGFycmF5Lmxlbmd0aC0obnVsbD09bnx8Z3VhcmQ/MTpuKSl9LF8ubGFzdD1mdW5jdGlvbihhcnJheSxuLGd1YXJkKXtyZXR1cm4gbnVsbD09YXJyYXk/dm9pZCAwOm51bGw9PW58fGd1YXJkP2FycmF5W2FycmF5Lmxlbmd0aC0xXTpzbGljZS5jYWxsKGFycmF5LE1hdGgubWF4KGFycmF5Lmxlbmd0aC1uLDApKX0sXy5yZXN0PV8udGFpbD1fLmRyb3A9ZnVuY3Rpb24oYXJyYXksbixndWFyZCl7cmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksbnVsbD09bnx8Z3VhcmQ/MTpuKX0sXy5jb21wYWN0PWZ1bmN0aW9uKGFycmF5KXtyZXR1cm4gXy5maWx0ZXIoYXJyYXksXy5pZGVudGl0eSl9O3ZhciBmbGF0dGVuPWZ1bmN0aW9uKGlucHV0LHNoYWxsb3csb3V0cHV0KXtyZXR1cm4gc2hhbGxvdyYmXy5ldmVyeShpbnB1dCxfLmlzQXJyYXkpP2NvbmNhdC5hcHBseShvdXRwdXQsaW5wdXQpOihlYWNoKGlucHV0LGZ1bmN0aW9uKHZhbHVlKXtfLmlzQXJyYXkodmFsdWUpfHxfLmlzQXJndW1lbnRzKHZhbHVlKT9zaGFsbG93P3B1c2guYXBwbHkob3V0cHV0LHZhbHVlKTpmbGF0dGVuKHZhbHVlLHNoYWxsb3csb3V0cHV0KTpvdXRwdXQucHVzaCh2YWx1ZSl9KSxvdXRwdXQpfTtfLmZsYXR0ZW49ZnVuY3Rpb24oYXJyYXksc2hhbGxvdyl7cmV0dXJuIGZsYXR0ZW4oYXJyYXksc2hhbGxvdyxbXSl9LF8ud2l0aG91dD1mdW5jdGlvbihhcnJheSl7cmV0dXJuIF8uZGlmZmVyZW5jZShhcnJheSxzbGljZS5jYWxsKGFyZ3VtZW50cywxKSl9LF8ucGFydGl0aW9uPWZ1bmN0aW9uKGFycmF5LHByZWRpY2F0ZSl7dmFyIHBhc3M9W10sZmFpbD1bXTtyZXR1cm4gZWFjaChhcnJheSxmdW5jdGlvbihlbGVtKXsocHJlZGljYXRlKGVsZW0pP3Bhc3M6ZmFpbCkucHVzaChlbGVtKX0pLFtwYXNzLGZhaWxdfSxfLnVuaXE9Xy51bmlxdWU9ZnVuY3Rpb24oYXJyYXksaXNTb3J0ZWQsaXRlcmF0b3IsY29udGV4dCl7Xy5pc0Z1bmN0aW9uKGlzU29ydGVkKSYmKGNvbnRleHQ9aXRlcmF0b3IsaXRlcmF0b3I9aXNTb3J0ZWQsaXNTb3J0ZWQ9ITEpO3ZhciBpbml0aWFsPWl0ZXJhdG9yP18ubWFwKGFycmF5LGl0ZXJhdG9yLGNvbnRleHQpOmFycmF5LHJlc3VsdHM9W10sc2Vlbj1bXTtyZXR1cm4gZWFjaChpbml0aWFsLGZ1bmN0aW9uKHZhbHVlLGluZGV4KXsoaXNTb3J0ZWQ/aW5kZXgmJnNlZW5bc2Vlbi5sZW5ndGgtMV09PT12YWx1ZTpfLmNvbnRhaW5zKHNlZW4sdmFsdWUpKXx8KHNlZW4ucHVzaCh2YWx1ZSkscmVzdWx0cy5wdXNoKGFycmF5W2luZGV4XSkpfSkscmVzdWx0c30sXy51bmlvbj1mdW5jdGlvbigpe3JldHVybiBfLnVuaXEoXy5mbGF0dGVuKGFyZ3VtZW50cywhMCkpfSxfLmludGVyc2VjdGlvbj1mdW5jdGlvbihhcnJheSl7dmFyIHJlc3Q9c2xpY2UuY2FsbChhcmd1bWVudHMsMSk7cmV0dXJuIF8uZmlsdGVyKF8udW5pcShhcnJheSksZnVuY3Rpb24oaXRlbSl7cmV0dXJuIF8uZXZlcnkocmVzdCxmdW5jdGlvbihvdGhlcil7cmV0dXJuIF8uY29udGFpbnMob3RoZXIsaXRlbSl9KX0pfSxfLmRpZmZlcmVuY2U9ZnVuY3Rpb24oYXJyYXkpe3ZhciByZXN0PWNvbmNhdC5hcHBseShBcnJheVByb3RvLHNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKTtyZXR1cm4gXy5maWx0ZXIoYXJyYXksZnVuY3Rpb24odmFsdWUpe3JldHVybiFfLmNvbnRhaW5zKHJlc3QsdmFsdWUpfSl9LF8uemlwPWZ1bmN0aW9uKCl7Zm9yKHZhciBsZW5ndGg9Xy5tYXgoXy5wbHVjayhhcmd1bWVudHMsXFxcImxlbmd0aFxcXCIpLmNvbmNhdCgwKSkscmVzdWx0cz1BcnJheShsZW5ndGgpLGk9MDtsZW5ndGg+aTtpKyspcmVzdWx0c1tpXT1fLnBsdWNrKGFyZ3VtZW50cyxcXFwiXFxcIitpKTtyZXR1cm4gcmVzdWx0c30sXy5vYmplY3Q9ZnVuY3Rpb24obGlzdCx2YWx1ZXMpe2lmKG51bGw9PWxpc3QpcmV0dXJue307Zm9yKHZhciByZXN1bHQ9e30saT0wLGxlbmd0aD1saXN0Lmxlbmd0aDtsZW5ndGg+aTtpKyspdmFsdWVzP3Jlc3VsdFtsaXN0W2ldXT12YWx1ZXNbaV06cmVzdWx0W2xpc3RbaV1bMF1dPWxpc3RbaV1bMV07cmV0dXJuIHJlc3VsdH0sXy5pbmRleE9mPWZ1bmN0aW9uKGFycmF5LGl0ZW0saXNTb3J0ZWQpe2lmKG51bGw9PWFycmF5KXJldHVybi0xO3ZhciBpPTAsbGVuZ3RoPWFycmF5Lmxlbmd0aDtpZihpc1NvcnRlZCl7aWYoXFxcIm51bWJlclxcXCIhPXR5cGVvZiBpc1NvcnRlZClyZXR1cm4gaT1fLnNvcnRlZEluZGV4KGFycmF5LGl0ZW0pLGFycmF5W2ldPT09aXRlbT9pOi0xO2k9MD5pc1NvcnRlZD9NYXRoLm1heCgwLGxlbmd0aCtpc1NvcnRlZCk6aXNTb3J0ZWR9aWYobmF0aXZlSW5kZXhPZiYmYXJyYXkuaW5kZXhPZj09PW5hdGl2ZUluZGV4T2YpcmV0dXJuIGFycmF5LmluZGV4T2YoaXRlbSxpc1NvcnRlZCk7Zm9yKDtsZW5ndGg+aTtpKyspaWYoYXJyYXlbaV09PT1pdGVtKXJldHVybiBpO3JldHVybi0xfSxfLmxhc3RJbmRleE9mPWZ1bmN0aW9uKGFycmF5LGl0ZW0sZnJvbSl7aWYobnVsbD09YXJyYXkpcmV0dXJuLTE7dmFyIGhhc0luZGV4PW51bGwhPWZyb207aWYobmF0aXZlTGFzdEluZGV4T2YmJmFycmF5Lmxhc3RJbmRleE9mPT09bmF0aXZlTGFzdEluZGV4T2YpcmV0dXJuIGhhc0luZGV4P2FycmF5Lmxhc3RJbmRleE9mKGl0ZW0sZnJvbSk6YXJyYXkubGFzdEluZGV4T2YoaXRlbSk7Zm9yKHZhciBpPWhhc0luZGV4P2Zyb206YXJyYXkubGVuZ3RoO2ktLTspaWYoYXJyYXlbaV09PT1pdGVtKXJldHVybiBpO3JldHVybi0xfSxfLnJhbmdlPWZ1bmN0aW9uKHN0YXJ0LHN0b3Asc3RlcCl7MT49YXJndW1lbnRzLmxlbmd0aCYmKHN0b3A9c3RhcnR8fDAsc3RhcnQ9MCksc3RlcD1hcmd1bWVudHNbMl18fDE7Zm9yKHZhciBsZW5ndGg9TWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wLXN0YXJ0KS9zdGVwKSwwKSxpZHg9MCxyYW5nZT1BcnJheShsZW5ndGgpO2xlbmd0aD5pZHg7KXJhbmdlW2lkeCsrXT1zdGFydCxzdGFydCs9c3RlcDtyZXR1cm4gcmFuZ2V9O3ZhciBjdG9yPWZ1bmN0aW9uKCl7fTtfLmJpbmQ9ZnVuY3Rpb24oZnVuYyxjb250ZXh0KXt2YXIgYXJncyxib3VuZDtpZihuYXRpdmVCaW5kJiZmdW5jLmJpbmQ9PT1uYXRpdmVCaW5kKXJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpO2lmKCFfLmlzRnVuY3Rpb24oZnVuYykpdGhyb3cgbmV3IFR5cGVFcnJvcjtyZXR1cm4gYXJncz1zbGljZS5jYWxsKGFyZ3VtZW50cywyKSxib3VuZD1mdW5jdGlvbigpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSlyZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO2N0b3IucHJvdG90eXBlPWZ1bmMucHJvdG90eXBlO3ZhciBzZWxmPW5ldyBjdG9yO2N0b3IucHJvdG90eXBlPW51bGw7dmFyIHJlc3VsdD1mdW5jLmFwcGx5KHNlbGYsYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7cmV0dXJuIE9iamVjdChyZXN1bHQpPT09cmVzdWx0P3Jlc3VsdDpzZWxmfX0sXy5wYXJ0aWFsPWZ1bmN0aW9uKGZ1bmMpe3ZhciBib3VuZEFyZ3M9c2xpY2UuY2FsbChhcmd1bWVudHMsMSk7cmV0dXJuIGZ1bmN0aW9uKCl7Zm9yKHZhciBwb3NpdGlvbj0wLGFyZ3M9Ym91bmRBcmdzLnNsaWNlKCksaT0wLGxlbmd0aD1hcmdzLmxlbmd0aDtsZW5ndGg+aTtpKyspYXJnc1tpXT09PV8mJihhcmdzW2ldPWFyZ3VtZW50c1twb3NpdGlvbisrXSk7Zm9yKDthcmd1bWVudHMubGVuZ3RoPnBvc2l0aW9uOylhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtyZXR1cm4gZnVuYy5hcHBseSh0aGlzLGFyZ3MpfX0sXy5iaW5kQWxsPWZ1bmN0aW9uKG9iail7dmFyIGZ1bmNzPXNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO2lmKDA9PT1mdW5jcy5sZW5ndGgpdGhyb3cgRXJyb3IoXFxcImJpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXNcXFwiKTtyZXR1cm4gZWFjaChmdW5jcyxmdW5jdGlvbihmKXtvYmpbZl09Xy5iaW5kKG9ialtmXSxvYmopfSksb2JqfSxfLm1lbW9pemU9ZnVuY3Rpb24oZnVuYyxoYXNoZXIpe3ZhciBtZW1vPXt9O3JldHVybiBoYXNoZXJ8fChoYXNoZXI9Xy5pZGVudGl0eSksZnVuY3Rpb24oKXt2YXIga2V5PWhhc2hlci5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIF8uaGFzKG1lbW8sa2V5KT9tZW1vW2tleV06bWVtb1trZXldPWZ1bmMuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0sXy5kZWxheT1mdW5jdGlvbihmdW5jLHdhaXQpe3ZhciBhcmdzPXNsaWNlLmNhbGwoYXJndW1lbnRzLDIpO3JldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmMuYXBwbHkobnVsbCxhcmdzKX0sd2FpdCl9LF8uZGVmZXI9ZnVuY3Rpb24oZnVuYyl7cmV0dXJuIF8uZGVsYXkuYXBwbHkoXyxbZnVuYywxXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpKX0sXy50aHJvdHRsZT1mdW5jdGlvbihmdW5jLHdhaXQsb3B0aW9ucyl7dmFyIGNvbnRleHQsYXJncyxyZXN1bHQsdGltZW91dD1udWxsLHByZXZpb3VzPTA7b3B0aW9uc3x8KG9wdGlvbnM9e30pO3ZhciBsYXRlcj1mdW5jdGlvbigpe3ByZXZpb3VzPW9wdGlvbnMubGVhZGluZz09PSExPzA6Xy5ub3coKSx0aW1lb3V0PW51bGwscmVzdWx0PWZ1bmMuYXBwbHkoY29udGV4dCxhcmdzKSxjb250ZXh0PWFyZ3M9bnVsbH07cmV0dXJuIGZ1bmN0aW9uKCl7dmFyIG5vdz1fLm5vdygpO3ByZXZpb3VzfHxvcHRpb25zLmxlYWRpbmchPT0hMXx8KHByZXZpb3VzPW5vdyk7dmFyIHJlbWFpbmluZz13YWl0LShub3ctcHJldmlvdXMpO3JldHVybiBjb250ZXh0PXRoaXMsYXJncz1hcmd1bWVudHMsMD49cmVtYWluaW5nPyhjbGVhclRpbWVvdXQodGltZW91dCksdGltZW91dD1udWxsLHByZXZpb3VzPW5vdyxyZXN1bHQ9ZnVuYy5hcHBseShjb250ZXh0LGFyZ3MpLGNvbnRleHQ9YXJncz1udWxsKTp0aW1lb3V0fHxvcHRpb25zLnRyYWlsaW5nPT09ITF8fCh0aW1lb3V0PXNldFRpbWVvdXQobGF0ZXIscmVtYWluaW5nKSkscmVzdWx0fX0sXy5kZWJvdW5jZT1mdW5jdGlvbihmdW5jLHdhaXQsaW1tZWRpYXRlKXt2YXIgdGltZW91dCxhcmdzLGNvbnRleHQsdGltZXN0YW1wLHJlc3VsdCxsYXRlcj1mdW5jdGlvbigpe3ZhciBsYXN0PV8ubm93KCktdGltZXN0YW1wO3dhaXQ+bGFzdD90aW1lb3V0PXNldFRpbWVvdXQobGF0ZXIsd2FpdC1sYXN0KToodGltZW91dD1udWxsLGltbWVkaWF0ZXx8KHJlc3VsdD1mdW5jLmFwcGx5KGNvbnRleHQsYXJncyksY29udGV4dD1hcmdzPW51bGwpKX07cmV0dXJuIGZ1bmN0aW9uKCl7Y29udGV4dD10aGlzLGFyZ3M9YXJndW1lbnRzLHRpbWVzdGFtcD1fLm5vdygpO3ZhciBjYWxsTm93PWltbWVkaWF0ZSYmIXRpbWVvdXQ7cmV0dXJuIHRpbWVvdXR8fCh0aW1lb3V0PXNldFRpbWVvdXQobGF0ZXIsd2FpdCkpLGNhbGxOb3cmJihyZXN1bHQ9ZnVuYy5hcHBseShjb250ZXh0LGFyZ3MpLGNvbnRleHQ9YXJncz1udWxsKSxyZXN1bHR9fSxfLm9uY2U9ZnVuY3Rpb24oZnVuYyl7dmFyIG1lbW8scmFuPSExO3JldHVybiBmdW5jdGlvbigpe3JldHVybiByYW4/bWVtbzoocmFuPSEwLG1lbW89ZnVuYy5hcHBseSh0aGlzLGFyZ3VtZW50cyksZnVuYz1udWxsLG1lbW8pfX0sXy53cmFwPWZ1bmN0aW9uKGZ1bmMsd3JhcHBlcil7cmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLGZ1bmMpfSxfLmNvbXBvc2U9ZnVuY3Rpb24oKXt2YXIgZnVuY3M9YXJndW1lbnRzO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgYXJncz1hcmd1bWVudHMsaT1mdW5jcy5sZW5ndGgtMTtpPj0wO2ktLSlhcmdzPVtmdW5jc1tpXS5hcHBseSh0aGlzLGFyZ3MpXTtyZXR1cm4gYXJnc1swXX19LF8uYWZ0ZXI9ZnVuY3Rpb24odGltZXMsZnVuYyl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIDE+LS10aW1lcz9mdW5jLmFwcGx5KHRoaXMsYXJndW1lbnRzKTp2b2lkIDB9fSxfLmtleXM9ZnVuY3Rpb24ob2JqKXtpZighXy5pc09iamVjdChvYmopKXJldHVybltdO2lmKG5hdGl2ZUtleXMpcmV0dXJuIG5hdGl2ZUtleXMob2JqKTt2YXIga2V5cz1bXTtmb3IodmFyIGtleSBpbiBvYmopXy5oYXMob2JqLGtleSkmJmtleXMucHVzaChrZXkpO3JldHVybiBrZXlzfSxfLnZhbHVlcz1mdW5jdGlvbihvYmope2Zvcih2YXIga2V5cz1fLmtleXMob2JqKSxsZW5ndGg9a2V5cy5sZW5ndGgsdmFsdWVzPUFycmF5KGxlbmd0aCksaT0wO2xlbmd0aD5pO2krKyl2YWx1ZXNbaV09b2JqW2tleXNbaV1dO3JldHVybiB2YWx1ZXN9LF8ucGFpcnM9ZnVuY3Rpb24ob2JqKXtmb3IodmFyIGtleXM9Xy5rZXlzKG9iaiksbGVuZ3RoPWtleXMubGVuZ3RoLHBhaXJzPUFycmF5KGxlbmd0aCksaT0wO2xlbmd0aD5pO2krKylwYWlyc1tpXT1ba2V5c1tpXSxvYmpba2V5c1tpXV1dO3JldHVybiBwYWlyc30sXy5pbnZlcnQ9ZnVuY3Rpb24ob2JqKXtmb3IodmFyIHJlc3VsdD17fSxrZXlzPV8ua2V5cyhvYmopLGk9MCxsZW5ndGg9a2V5cy5sZW5ndGg7bGVuZ3RoPmk7aSsrKXJlc3VsdFtvYmpba2V5c1tpXV1dPWtleXNbaV07cmV0dXJuIHJlc3VsdH0sXy5mdW5jdGlvbnM9Xy5tZXRob2RzPWZ1bmN0aW9uKG9iail7dmFyIG5hbWVzPVtdO2Zvcih2YXIga2V5IGluIG9iailfLmlzRnVuY3Rpb24ob2JqW2tleV0pJiZuYW1lcy5wdXNoKGtleSk7cmV0dXJuIG5hbWVzLnNvcnQoKX0sXy5leHRlbmQ9ZnVuY3Rpb24ob2JqKXtyZXR1cm4gZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywxKSxmdW5jdGlvbihzb3VyY2Upe2lmKHNvdXJjZSlmb3IodmFyIHByb3AgaW4gc291cmNlKW9ialtwcm9wXT1zb3VyY2VbcHJvcF19KSxvYmp9LF8ucGljaz1mdW5jdGlvbihvYmope3ZhciBjb3B5PXt9LGtleXM9Y29uY2F0LmFwcGx5KEFycmF5UHJvdG8sc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpO3JldHVybiBlYWNoKGtleXMsZnVuY3Rpb24oa2V5KXtrZXkgaW4gb2JqJiYoY29weVtrZXldPW9ialtrZXldKX0pLGNvcHl9LF8ub21pdD1mdW5jdGlvbihvYmope3ZhciBjb3B5PXt9LGtleXM9Y29uY2F0LmFwcGx5KEFycmF5UHJvdG8sc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpO2Zvcih2YXIga2V5IGluIG9iailfLmNvbnRhaW5zKGtleXMsa2V5KXx8KGNvcHlba2V5XT1vYmpba2V5XSk7cmV0dXJuIGNvcHl9LF8uZGVmYXVsdHM9ZnVuY3Rpb24ob2JqKXtyZXR1cm4gZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywxKSxmdW5jdGlvbihzb3VyY2Upe2lmKHNvdXJjZSlmb3IodmFyIHByb3AgaW4gc291cmNlKXZvaWQgMD09PW9ialtwcm9wXSYmKG9ialtwcm9wXT1zb3VyY2VbcHJvcF0pfSksb2JqfSxfLmNsb25lPWZ1bmN0aW9uKG9iail7cmV0dXJuIF8uaXNPYmplY3Qob2JqKT9fLmlzQXJyYXkob2JqKT9vYmouc2xpY2UoKTpfLmV4dGVuZCh7fSxvYmopOm9ian0sXy50YXA9ZnVuY3Rpb24ob2JqLGludGVyY2VwdG9yKXtyZXR1cm4gaW50ZXJjZXB0b3Iob2JqKSxvYmp9O3ZhciBlcT1mdW5jdGlvbihhLGIsYVN0YWNrLGJTdGFjayl7aWYoYT09PWIpcmV0dXJuIDAhPT1hfHwxL2E9PTEvYjtpZihudWxsPT1hfHxudWxsPT1iKXJldHVybiBhPT09YjthIGluc3RhbmNlb2YgXyYmKGE9YS5fd3JhcHBlZCksYiBpbnN0YW5jZW9mIF8mJihiPWIuX3dyYXBwZWQpO3ZhciBjbGFzc05hbWU9dG9TdHJpbmcuY2FsbChhKTtpZihjbGFzc05hbWUhPXRvU3RyaW5nLmNhbGwoYikpcmV0dXJuITE7c3dpdGNoKGNsYXNzTmFtZSl7Y2FzZVxcXCJbb2JqZWN0IFN0cmluZ11cXFwiOnJldHVybiBhPT1iK1xcXCJcXFwiO2Nhc2VcXFwiW29iamVjdCBOdW1iZXJdXFxcIjpyZXR1cm4gYSE9K2E/YiE9K2I6MD09YT8xL2E9PTEvYjphPT0rYjtjYXNlXFxcIltvYmplY3QgRGF0ZV1cXFwiOmNhc2VcXFwiW29iamVjdCBCb29sZWFuXVxcXCI6cmV0dXJuK2E9PStiO2Nhc2VcXFwiW29iamVjdCBSZWdFeHBdXFxcIjpyZXR1cm4gYS5zb3VyY2U9PWIuc291cmNlJiZhLmdsb2JhbD09Yi5nbG9iYWwmJmEubXVsdGlsaW5lPT1iLm11bHRpbGluZSYmYS5pZ25vcmVDYXNlPT1iLmlnbm9yZUNhc2V9aWYoXFxcIm9iamVjdFxcXCIhPXR5cGVvZiBhfHxcXFwib2JqZWN0XFxcIiE9dHlwZW9mIGIpcmV0dXJuITE7Zm9yKHZhciBsZW5ndGg9YVN0YWNrLmxlbmd0aDtsZW5ndGgtLTspaWYoYVN0YWNrW2xlbmd0aF09PWEpcmV0dXJuIGJTdGFja1tsZW5ndGhdPT1iO3ZhciBhQ3Rvcj1hLmNvbnN0cnVjdG9yLGJDdG9yPWIuY29uc3RydWN0b3I7aWYoYUN0b3IhPT1iQ3RvciYmIShfLmlzRnVuY3Rpb24oYUN0b3IpJiZhQ3RvciBpbnN0YW5jZW9mIGFDdG9yJiZfLmlzRnVuY3Rpb24oYkN0b3IpJiZiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKSYmXFxcImNvbnN0cnVjdG9yXFxcImluIGEmJlxcXCJjb25zdHJ1Y3RvclxcXCJpbiBiKXJldHVybiExO2FTdGFjay5wdXNoKGEpLGJTdGFjay5wdXNoKGIpO3ZhciBzaXplPTAscmVzdWx0PSEwO2lmKFxcXCJbb2JqZWN0IEFycmF5XVxcXCI9PWNsYXNzTmFtZSl7aWYoc2l6ZT1hLmxlbmd0aCxyZXN1bHQ9c2l6ZT09Yi5sZW5ndGgpZm9yKDtzaXplLS0mJihyZXN1bHQ9ZXEoYVtzaXplXSxiW3NpemVdLGFTdGFjayxiU3RhY2spKTspO31lbHNle2Zvcih2YXIga2V5IGluIGEpaWYoXy5oYXMoYSxrZXkpJiYoc2l6ZSsrLCEocmVzdWx0PV8uaGFzKGIsa2V5KSYmZXEoYVtrZXldLGJba2V5XSxhU3RhY2ssYlN0YWNrKSkpKWJyZWFrO2lmKHJlc3VsdCl7Zm9yKGtleSBpbiBiKWlmKF8uaGFzKGIsa2V5KSYmIXNpemUtLSlicmVhaztyZXN1bHQ9IXNpemV9fXJldHVybiBhU3RhY2sucG9wKCksYlN0YWNrLnBvcCgpLHJlc3VsdH07Xy5pc0VxdWFsPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGVxKGEsYixbXSxbXSl9LF8uaXNFbXB0eT1mdW5jdGlvbihvYmope2lmKG51bGw9PW9iailyZXR1cm4hMDtpZihfLmlzQXJyYXkob2JqKXx8Xy5pc1N0cmluZyhvYmopKXJldHVybiAwPT09b2JqLmxlbmd0aDtmb3IodmFyIGtleSBpbiBvYmopaWYoXy5oYXMob2JqLGtleSkpcmV0dXJuITE7cmV0dXJuITB9LF8uaXNFbGVtZW50PWZ1bmN0aW9uKG9iail7cmV0dXJuISghb2JqfHwxIT09b2JqLm5vZGVUeXBlKX0sXy5pc0FycmF5PW5hdGl2ZUlzQXJyYXl8fGZ1bmN0aW9uKG9iail7cmV0dXJuXFxcIltvYmplY3QgQXJyYXldXFxcIj09dG9TdHJpbmcuY2FsbChvYmopfSxfLmlzT2JqZWN0PWZ1bmN0aW9uKG9iail7cmV0dXJuIG9iaj09PU9iamVjdChvYmopfSxlYWNoKFtcXFwiQXJndW1lbnRzXFxcIixcXFwiRnVuY3Rpb25cXFwiLFxcXCJTdHJpbmdcXFwiLFxcXCJOdW1iZXJcXFwiLFxcXCJEYXRlXFxcIixcXFwiUmVnRXhwXFxcIl0sZnVuY3Rpb24obmFtZSl7X1tcXFwiaXNcXFwiK25hbWVdPWZ1bmN0aW9uKG9iail7cmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKT09XFxcIltvYmplY3QgXFxcIituYW1lK1xcXCJdXFxcIn19KSxfLmlzQXJndW1lbnRzKGFyZ3VtZW50cyl8fChfLmlzQXJndW1lbnRzPWZ1bmN0aW9uKG9iail7cmV0dXJuISghb2JqfHwhXy5oYXMob2JqLFxcXCJjYWxsZWVcXFwiKSl9KSxfLmlzRnVuY3Rpb249ZnVuY3Rpb24ob2JqKXtyZXR1cm5cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2Ygb2JqfSxfLmlzRmluaXRlPWZ1bmN0aW9uKG9iail7cmV0dXJuIGlzRmluaXRlKG9iaikmJiFpc05hTihwYXJzZUZsb2F0KG9iaikpfSxfLmlzTmFOPWZ1bmN0aW9uKG9iail7cmV0dXJuIF8uaXNOdW1iZXIob2JqKSYmb2JqIT0rb2JqfSxfLmlzQm9vbGVhbj1mdW5jdGlvbihvYmope3JldHVybiBvYmo9PT0hMHx8b2JqPT09ITF8fFxcXCJbb2JqZWN0IEJvb2xlYW5dXFxcIj09dG9TdHJpbmcuY2FsbChvYmopfSxfLmlzTnVsbD1mdW5jdGlvbihvYmope3JldHVybiBudWxsPT09b2JqfSxfLmlzVW5kZWZpbmVkPWZ1bmN0aW9uKG9iail7cmV0dXJuIHZvaWQgMD09PW9ian0sXy5oYXM9ZnVuY3Rpb24ob2JqLGtleSl7cmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwob2JqLGtleSl9LF8ubm9Db25mbGljdD1mdW5jdGlvbigpe3JldHVybiByb290Ll89cHJldmlvdXNVbmRlcnNjb3JlLHRoaXN9LF8uaWRlbnRpdHk9ZnVuY3Rpb24odmFsdWUpe3JldHVybiB2YWx1ZX0sXy5jb25zdGFudD1mdW5jdGlvbih2YWx1ZSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIHZhbHVlfX0sXy5wcm9wZXJ0eT1mdW5jdGlvbihrZXkpe3JldHVybiBmdW5jdGlvbihvYmope3JldHVybiBvYmpba2V5XX19LF8ubWF0Y2hlcz1mdW5jdGlvbihhdHRycyl7cmV0dXJuIGZ1bmN0aW9uKG9iail7aWYob2JqPT09YXR0cnMpcmV0dXJuITA7Zm9yKHZhciBrZXkgaW4gYXR0cnMpaWYoYXR0cnNba2V5XSE9PW9ialtrZXldKXJldHVybiExO3JldHVybiEwfX0sXy50aW1lcz1mdW5jdGlvbihuLGl0ZXJhdG9yLGNvbnRleHQpe2Zvcih2YXIgYWNjdW09QXJyYXkoTWF0aC5tYXgoMCxuKSksaT0wO24+aTtpKyspYWNjdW1baV09aXRlcmF0b3IuY2FsbChjb250ZXh0LGkpO3JldHVybiBhY2N1bX0sXy5yYW5kb209ZnVuY3Rpb24obWluLG1heCl7cmV0dXJuIG51bGw9PW1heCYmKG1heD1taW4sbWluPTApLG1pbitNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqKG1heC1taW4rMSkpfSxfLm5vdz1EYXRlLm5vd3x8ZnVuY3Rpb24oKXtyZXR1cm4obmV3IERhdGUpLmdldFRpbWUoKX07dmFyIGVudGl0eU1hcD17ZXNjYXBlOntcXFwiJlxcXCI6XFxcIiZhbXA7XFxcIixcXFwiPFxcXCI6XFxcIiZsdDtcXFwiLFxcXCI+XFxcIjpcXFwiJmd0O1xcXCIsJ1xcXCInOlxcXCImcXVvdDtcXFwiLFxcXCInXFxcIjpcXFwiJiN4Mjc7XFxcIn19O2VudGl0eU1hcC51bmVzY2FwZT1fLmludmVydChlbnRpdHlNYXAuZXNjYXBlKTt2YXIgZW50aXR5UmVnZXhlcz17ZXNjYXBlOlJlZ0V4cChcXFwiW1xcXCIrXy5rZXlzKGVudGl0eU1hcC5lc2NhcGUpLmpvaW4oXFxcIlxcXCIpK1xcXCJdXFxcIixcXFwiZ1xcXCIpLHVuZXNjYXBlOlJlZ0V4cChcXFwiKFxcXCIrXy5rZXlzKGVudGl0eU1hcC51bmVzY2FwZSkuam9pbihcXFwifFxcXCIpK1xcXCIpXFxcIixcXFwiZ1xcXCIpfTtfLmVhY2goW1xcXCJlc2NhcGVcXFwiLFxcXCJ1bmVzY2FwZVxcXCJdLGZ1bmN0aW9uKG1ldGhvZCl7X1ttZXRob2RdPWZ1bmN0aW9uKHN0cmluZyl7cmV0dXJuIG51bGw9PXN0cmluZz9cXFwiXFxcIjooXFxcIlxcXCIrc3RyaW5nKS5yZXBsYWNlKGVudGl0eVJlZ2V4ZXNbbWV0aG9kXSxmdW5jdGlvbihtYXRjaCl7cmV0dXJuIGVudGl0eU1hcFttZXRob2RdW21hdGNoXX0pfX0pLF8ucmVzdWx0PWZ1bmN0aW9uKG9iamVjdCxwcm9wZXJ0eSl7aWYobnVsbD09b2JqZWN0KXJldHVybiB2b2lkIDA7dmFyIHZhbHVlPW9iamVjdFtwcm9wZXJ0eV07cmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSk/dmFsdWUuY2FsbChvYmplY3QpOnZhbHVlfSxfLm1peGluPWZ1bmN0aW9uKG9iail7ZWFjaChfLmZ1bmN0aW9ucyhvYmopLGZ1bmN0aW9uKG5hbWUpe3ZhciBmdW5jPV9bbmFtZV09b2JqW25hbWVdO18ucHJvdG90eXBlW25hbWVdPWZ1bmN0aW9uKCl7dmFyIGFyZ3M9W3RoaXMuX3dyYXBwZWRdO3JldHVybiBwdXNoLmFwcGx5KGFyZ3MsYXJndW1lbnRzKSxyZXN1bHQuY2FsbCh0aGlzLGZ1bmMuYXBwbHkoXyxhcmdzKSl9fSl9O3ZhciBpZENvdW50ZXI9MDtfLnVuaXF1ZUlkPWZ1bmN0aW9uKHByZWZpeCl7dmFyIGlkPSsraWRDb3VudGVyK1xcXCJcXFwiO3JldHVybiBwcmVmaXg/cHJlZml4K2lkOmlkfSxfLnRlbXBsYXRlU2V0dGluZ3M9e2V2YWx1YXRlOi88JShbXFxcXHNcXFxcU10rPyklPi9nLGludGVycG9sYXRlOi88JT0oW1xcXFxzXFxcXFNdKz8pJT4vZyxlc2NhcGU6LzwlLShbXFxcXHNcXFxcU10rPyklPi9nfTt2YXIgbm9NYXRjaD0vKC4pXi8sZXNjYXBlcz17XFxcIidcXFwiOlxcXCInXFxcIixcXFwiXFxcXFxcXFxcXFwiOlxcXCJcXFxcXFxcXFxcXCIsXFxcIlxcXFxyXFxcIjpcXFwiclxcXCIsXFxcIlxcXFxuXFxcIjpcXFwiblxcXCIsXFxcIlxcdFxcXCI6XFxcInRcXFwiLFxcXCJcXFxcdTIwMjhcXFwiOlxcXCJ1MjAyOFxcXCIsXFxcIlxcXFx1MjAyOVxcXCI6XFxcInUyMDI5XFxcIn0sZXNjYXBlcj0vXFxcXFxcXFx8J3xcXFxccnxcXFxcbnxcXFxcdHxcXFxcdTIwMjh8XFxcXHUyMDI5L2c7Xy50ZW1wbGF0ZT1mdW5jdGlvbih0ZXh0LGRhdGEsc2V0dGluZ3Mpe3ZhciByZW5kZXI7c2V0dGluZ3M9Xy5kZWZhdWx0cyh7fSxzZXR0aW5ncyxfLnRlbXBsYXRlU2V0dGluZ3MpO3ZhciBtYXRjaGVyPVJlZ0V4cChbKHNldHRpbmdzLmVzY2FwZXx8bm9NYXRjaCkuc291cmNlLChzZXR0aW5ncy5pbnRlcnBvbGF0ZXx8bm9NYXRjaCkuc291cmNlLChzZXR0aW5ncy5ldmFsdWF0ZXx8bm9NYXRjaCkuc291cmNlXS5qb2luKFxcXCJ8XFxcIikrXFxcInwkXFxcIixcXFwiZ1xcXCIpLGluZGV4PTAsc291cmNlPVxcXCJfX3ArPSdcXFwiO3RleHQucmVwbGFjZShtYXRjaGVyLGZ1bmN0aW9uKG1hdGNoLGVzY2FwZSxpbnRlcnBvbGF0ZSxldmFsdWF0ZSxvZmZzZXQpe3JldHVybiBzb3VyY2UrPXRleHQuc2xpY2UoaW5kZXgsb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsZnVuY3Rpb24obWF0Y2gpe3JldHVyblxcXCJcXFxcXFxcXFxcXCIrZXNjYXBlc1ttYXRjaF19KSxlc2NhcGUmJihzb3VyY2UrPVxcXCInK1xcXFxuKChfX3Q9KFxcXCIrZXNjYXBlK1xcXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXFxcbidcXFwiKSxpbnRlcnBvbGF0ZSYmKHNvdXJjZSs9XFxcIicrXFxcXG4oKF9fdD0oXFxcIitpbnRlcnBvbGF0ZStcXFwiKSk9PW51bGw/Jyc6X190KStcXFxcbidcXFwiKSxldmFsdWF0ZSYmKHNvdXJjZSs9XFxcIic7XFxcXG5cXFwiK2V2YWx1YXRlK1xcXCJcXFxcbl9fcCs9J1xcXCIpLGluZGV4PW9mZnNldCttYXRjaC5sZW5ndGgsbWF0Y2h9KSxzb3VyY2UrPVxcXCInO1xcXFxuXFxcIixzZXR0aW5ncy52YXJpYWJsZXx8KHNvdXJjZT1cXFwid2l0aChvYmp8fHt9KXtcXFxcblxcXCIrc291cmNlK1xcXCJ9XFxcXG5cXFwiKSxzb3VyY2U9XFxcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcXFxuXFxcIitzb3VyY2UrXFxcInJldHVybiBfX3A7XFxcXG5cXFwiO3RyeXtyZW5kZXI9RnVuY3Rpb24oc2V0dGluZ3MudmFyaWFibGV8fFxcXCJvYmpcXFwiLFxcXCJfXFxcIixzb3VyY2UpfWNhdGNoKGUpe3Rocm93IGUuc291cmNlPXNvdXJjZSxlfWlmKGRhdGEpcmV0dXJuIHJlbmRlcihkYXRhLF8pO3ZhciB0ZW1wbGF0ZT1mdW5jdGlvbihkYXRhKXtyZXR1cm4gcmVuZGVyLmNhbGwodGhpcyxkYXRhLF8pfTtyZXR1cm4gdGVtcGxhdGUuc291cmNlPVxcXCJmdW5jdGlvbihcXFwiKyhzZXR0aW5ncy52YXJpYWJsZXx8XFxcIm9ialxcXCIpK1xcXCIpe1xcXFxuXFxcIitzb3VyY2UrXFxcIn1cXFwiLHRlbXBsYXRlfSxfLmNoYWluPWZ1bmN0aW9uKG9iail7cmV0dXJuIF8ob2JqKS5jaGFpbigpfTt2YXIgcmVzdWx0PWZ1bmN0aW9uKG9iail7cmV0dXJuIHRoaXMuX2NoYWluP18ob2JqKS5jaGFpbigpOm9ian07Xy5taXhpbihfKSxlYWNoKFtcXFwicG9wXFxcIixcXFwicHVzaFxcXCIsXFxcInJldmVyc2VcXFwiLFxcXCJzaGlmdFxcXCIsXFxcInNvcnRcXFwiLFxcXCJzcGxpY2VcXFwiLFxcXCJ1bnNoaWZ0XFxcIl0sZnVuY3Rpb24obmFtZSl7dmFyIG1ldGhvZD1BcnJheVByb3RvW25hbWVdO18ucHJvdG90eXBlW25hbWVdPWZ1bmN0aW9uKCl7dmFyIG9iaj10aGlzLl93cmFwcGVkO3JldHVybiBtZXRob2QuYXBwbHkob2JqLGFyZ3VtZW50cyksXFxcInNoaWZ0XFxcIiE9bmFtZSYmXFxcInNwbGljZVxcXCIhPW5hbWV8fDAhPT1vYmoubGVuZ3RofHxkZWxldGUgb2JqWzBdLHJlc3VsdC5jYWxsKHRoaXMsb2JqKX19KSxlYWNoKFtcXFwiY29uY2F0XFxcIixcXFwiam9pblxcXCIsXFxcInNsaWNlXFxcIl0sZnVuY3Rpb24obmFtZSl7dmFyIG1ldGhvZD1BcnJheVByb3RvW25hbWVdO18ucHJvdG90eXBlW25hbWVdPWZ1bmN0aW9uKCl7cmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsYXJndW1lbnRzKSl9fSksXy5leHRlbmQoXy5wcm90b3R5cGUse2NoYWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NoYWluPSEwLHRoaXN9LHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dyYXBwZWR9fSksXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZCYmYWNlLmRlZmluZShcXFwidW5kZXJzY29yZVxcXCIsW10sZnVuY3Rpb24oKXtyZXR1cm4gX30pfSkuY2FsbCh0aGlzKX0se31dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBfPV9kZXJlcV8oXFxcInVuZGVyc2NvcmVcXFwiKSxldmVudHM9X2RlcmVxXyhcXFwiZXZlbnRzXFxcIiksdmFycz1fZGVyZXFfKFxcXCIuL3ZhcnMuanNcXFwiKSxtZXNzYWdlcz1fZGVyZXFfKFxcXCIuL21lc3NhZ2VzLmpzXFxcIiksTGV4ZXI9X2RlcmVxXyhcXFwiLi9sZXguanNcXFwiKS5MZXhlcixyZWc9X2RlcmVxXyhcXFwiLi9yZWcuanNcXFwiKSxzdGF0ZT1fZGVyZXFfKFxcXCIuL3N0YXRlLmpzXFxcIikuc3RhdGUsc3R5bGU9X2RlcmVxXyhcXFwiLi9zdHlsZS5qc1xcXCIpLEpTSElOVD1mdW5jdGlvbigpe1xcXCJ1c2Ugc3RyaWN0XFxcIjtmdW5jdGlvbiBjaGVja09wdGlvbihuYW1lLHQpe3JldHVybiBuYW1lPW5hbWUudHJpbSgpLC9eWystXVdcXFxcZHszfSQvZy50ZXN0KG5hbWUpPyEwOnZvaWQgMCE9PXZhbE9wdGlvbnNbbmFtZV18fHZvaWQgMCE9PWJvb2xPcHRpb25zW25hbWVdfHxcXFwianNsaW50XFxcIj09PXQudHlwZXx8cmVtb3ZlZE9wdGlvbnNbbmFtZV0/ITA6KGVycm9yKFxcXCJFMDAxXFxcIix0LG5hbWUpLCExKX1mdW5jdGlvbiBpc1N0cmluZyhvYmope3JldHVyblxcXCJbb2JqZWN0IFN0cmluZ11cXFwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iail9ZnVuY3Rpb24gaXNJZGVudGlmaWVyKHRrbix2YWx1ZSl7cmV0dXJuIHRrbj90a24uaWRlbnRpZmllciYmdGtuLnZhbHVlPT09dmFsdWU/ITA6ITE6ITF9ZnVuY3Rpb24gaXNSZXNlcnZlZCh0b2tlbil7aWYoIXRva2VuLnJlc2VydmVkKXJldHVybiExO3ZhciBtZXRhPXRva2VuLm1ldGE7aWYobWV0YSYmbWV0YS5pc0Z1dHVyZVJlc2VydmVkV29yZCYmc3RhdGUub3B0aW9uLmluRVM1KCkpe2lmKCFtZXRhLmVzNSlyZXR1cm4hMTtpZihtZXRhLnN0cmljdE9ubHkmJiFzdGF0ZS5vcHRpb24uc3RyaWN0JiYhc3RhdGUuZGlyZWN0aXZlW1xcXCJ1c2Ugc3RyaWN0XFxcIl0pcmV0dXJuITE7aWYodG9rZW4uaXNQcm9wZXJ0eSlyZXR1cm4hMX1yZXR1cm4hMH1mdW5jdGlvbiBzdXBwbGFudChzdHIsZGF0YSl7cmV0dXJuIHN0ci5yZXBsYWNlKC9cXFxceyhbXnt9XSopXFxcXH0vZyxmdW5jdGlvbihhLGIpe3ZhciByPWRhdGFbYl07cmV0dXJuXFxcInN0cmluZ1xcXCI9PXR5cGVvZiByfHxcXFwibnVtYmVyXFxcIj09dHlwZW9mIHI/cjphfSl9ZnVuY3Rpb24gY29tYmluZShkZXN0LHNyYyl7T2JqZWN0LmtleXMoc3JjKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe18uaGFzKEpTSElOVC5ibGFja2xpc3QsbmFtZSl8fChkZXN0W25hbWVdPXNyY1tuYW1lXSl9KX1mdW5jdGlvbiBhc3N1bWUoKXtzdGF0ZS5vcHRpb24uZXNuZXh0JiZjb21iaW5lKHByZWRlZmluZWQsdmFycy5uZXdFY21hSWRlbnRpZmllcnMpLHN0YXRlLm9wdGlvbi5jb3VjaCYmY29tYmluZShwcmVkZWZpbmVkLHZhcnMuY291Y2gpLHN0YXRlLm9wdGlvbi5xdW5pdCYmY29tYmluZShwcmVkZWZpbmVkLHZhcnMucXVuaXQpLHN0YXRlLm9wdGlvbi5yaGlubyYmY29tYmluZShwcmVkZWZpbmVkLHZhcnMucmhpbm8pLHN0YXRlLm9wdGlvbi5zaGVsbGpzJiYoY29tYmluZShwcmVkZWZpbmVkLHZhcnMuc2hlbGxqcyksY29tYmluZShwcmVkZWZpbmVkLHZhcnMubm9kZSkpLHN0YXRlLm9wdGlvbi50eXBlZCYmY29tYmluZShwcmVkZWZpbmVkLHZhcnMudHlwZWQpLHN0YXRlLm9wdGlvbi5waGFudG9tJiZjb21iaW5lKHByZWRlZmluZWQsdmFycy5waGFudG9tKSxzdGF0ZS5vcHRpb24ucHJvdG90eXBlanMmJmNvbWJpbmUocHJlZGVmaW5lZCx2YXJzLnByb3RvdHlwZWpzKSxzdGF0ZS5vcHRpb24ubm9kZSYmKGNvbWJpbmUocHJlZGVmaW5lZCx2YXJzLm5vZGUpLGNvbWJpbmUocHJlZGVmaW5lZCx2YXJzLnR5cGVkKSksc3RhdGUub3B0aW9uLmRldmVsJiZjb21iaW5lKHByZWRlZmluZWQsdmFycy5kZXZlbCksc3RhdGUub3B0aW9uLmRvam8mJmNvbWJpbmUocHJlZGVmaW5lZCx2YXJzLmRvam8pLHN0YXRlLm9wdGlvbi5icm93c2VyJiYoY29tYmluZShwcmVkZWZpbmVkLHZhcnMuYnJvd3NlciksY29tYmluZShwcmVkZWZpbmVkLHZhcnMudHlwZWQpKSxzdGF0ZS5vcHRpb24ubm9uc3RhbmRhcmQmJmNvbWJpbmUocHJlZGVmaW5lZCx2YXJzLm5vbnN0YW5kYXJkKSxzdGF0ZS5vcHRpb24uamFzbWluZSYmY29tYmluZShwcmVkZWZpbmVkLHZhcnMuamFzbWluZSksc3RhdGUub3B0aW9uLmpxdWVyeSYmY29tYmluZShwcmVkZWZpbmVkLHZhcnMuanF1ZXJ5KSxzdGF0ZS5vcHRpb24ubW9vdG9vbHMmJmNvbWJpbmUocHJlZGVmaW5lZCx2YXJzLm1vb3Rvb2xzKSxzdGF0ZS5vcHRpb24ud29ya2VyJiZjb21iaW5lKHByZWRlZmluZWQsdmFycy53b3JrZXIpLHN0YXRlLm9wdGlvbi53c2gmJmNvbWJpbmUocHJlZGVmaW5lZCx2YXJzLndzaCksc3RhdGUub3B0aW9uLmdsb2JhbHN0cmljdCYmc3RhdGUub3B0aW9uLnN0cmljdCE9PSExJiYoc3RhdGUub3B0aW9uLnN0cmljdD0hMCksc3RhdGUub3B0aW9uLnl1aSYmY29tYmluZShwcmVkZWZpbmVkLHZhcnMueXVpKSxzdGF0ZS5vcHRpb24ubW9jaGEmJmNvbWJpbmUocHJlZGVmaW5lZCx2YXJzLm1vY2hhKSxzdGF0ZS5vcHRpb24uaW5Nb3o9ZnVuY3Rpb24oKXtyZXR1cm4gc3RhdGUub3B0aW9uLm1ven0sc3RhdGUub3B0aW9uLmluRVNOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHN0YXRlLm9wdGlvbi5tb3p8fHN0YXRlLm9wdGlvbi5lc25leHR9LHN0YXRlLm9wdGlvbi5pbkVTNT1mdW5jdGlvbigpe3JldHVybiFzdGF0ZS5vcHRpb24uZXMzfSxzdGF0ZS5vcHRpb24uaW5FUzM9ZnVuY3Rpb24oc3RyaWN0KXtyZXR1cm4gc3RyaWN0PyFzdGF0ZS5vcHRpb24ubW96JiYhc3RhdGUub3B0aW9uLmVzbmV4dCYmc3RhdGUub3B0aW9uLmVzMzpzdGF0ZS5vcHRpb24uZXMzfX1mdW5jdGlvbiBxdWl0KGNvZGUsbGluZSxjaHIpe3ZhciBwZXJjZW50YWdlPU1hdGguZmxvb3IoMTAwKihsaW5lL3N0YXRlLmxpbmVzLmxlbmd0aCkpLG1lc3NhZ2U9bWVzc2FnZXMuZXJyb3JzW2NvZGVdLmRlc2M7dGhyb3d7bmFtZTpcXFwiSlNIaW50RXJyb3JcXFwiLGxpbmU6bGluZSxjaGFyYWN0ZXI6Y2hyLG1lc3NhZ2U6bWVzc2FnZStcXFwiIChcXFwiK3BlcmNlbnRhZ2UrXFxcIiUgc2Nhbm5lZCkuXFxcIixyYXc6bWVzc2FnZSxjb2RlOmNvZGV9fWZ1bmN0aW9uIGlzdW5kZWYoc2NvcGUsY29kZSx0b2tlbixhKXtyZXR1cm4gSlNISU5ULnVuZGVmcy5wdXNoKFtzY29wZSxjb2RlLHRva2VuLGFdKX1mdW5jdGlvbiByZW1vdmVJZ25vcmVkTWVzc2FnZXMoKXt2YXIgaWdub3JlZD1zdGF0ZS5pZ25vcmVkTGluZXM7Xy5pc0VtcHR5KGlnbm9yZWQpfHwoSlNISU5ULmVycm9ycz1fLnJlamVjdChKU0hJTlQuZXJyb3JzLGZ1bmN0aW9uKGVycil7cmV0dXJuIGlnbm9yZWRbZXJyLmxpbmVdfSkpfWZ1bmN0aW9uIHdhcm5pbmcoY29kZSx0LGEsYixjLGQpe3ZhciBjaCxsLHcsbXNnO2lmKC9eV1xcXFxkezN9JC8udGVzdChjb2RlKSl7aWYoc3RhdGUuaWdub3JlZFtjb2RlXSlyZXR1cm47bXNnPW1lc3NhZ2VzLndhcm5pbmdzW2NvZGVdfWVsc2UvRVxcXFxkezN9Ly50ZXN0KGNvZGUpP21zZz1tZXNzYWdlcy5lcnJvcnNbY29kZV06L0lcXFxcZHszfS8udGVzdChjb2RlKSYmKG1zZz1tZXNzYWdlcy5pbmZvW2NvZGVdKTtyZXR1cm4gdD10fHxzdGF0ZS50b2tlbnMubmV4dCxcXFwiKGVuZClcXFwiPT09dC5pZCYmKHQ9c3RhdGUudG9rZW5zLmN1cnIpLGw9dC5saW5lfHwwLGNoPXQuZnJvbXx8MCx3PXtpZDpcXFwiKGVycm9yKVxcXCIscmF3Om1zZy5kZXNjLGNvZGU6bXNnLmNvZGUsZXZpZGVuY2U6c3RhdGUubGluZXNbbC0xXXx8XFxcIlxcXCIsbGluZTpsLGNoYXJhY3RlcjpjaCxzY29wZTpKU0hJTlQuc2NvcGUsYTphLGI6YixjOmMsZDpkfSx3LnJlYXNvbj1zdXBwbGFudChtc2cuZGVzYyx3KSxKU0hJTlQuZXJyb3JzLnB1c2godykscmVtb3ZlSWdub3JlZE1lc3NhZ2VzKCksSlNISU5ULmVycm9ycy5sZW5ndGg+PXN0YXRlLm9wdGlvbi5tYXhlcnImJnF1aXQoXFxcIkUwNDNcXFwiLGwsY2gpLHd9ZnVuY3Rpb24gd2FybmluZ0F0KG0sbCxjaCxhLGIsYyxkKXtyZXR1cm4gd2FybmluZyhtLHtsaW5lOmwsZnJvbTpjaH0sYSxiLGMsZCl9ZnVuY3Rpb24gZXJyb3IobSx0LGEsYixjLGQpe3dhcm5pbmcobSx0LGEsYixjLGQpfWZ1bmN0aW9uIGVycm9yQXQobSxsLGNoLGEsYixjLGQpe3JldHVybiBlcnJvcihtLHtsaW5lOmwsZnJvbTpjaH0sYSxiLGMsZCl9ZnVuY3Rpb24gYWRkSW50ZXJuYWxTcmMoZWxlbSxzcmMpe3ZhciBpO3JldHVybiBpPXtpZDpcXFwiKGludGVybmFsKVxcXCIsZWxlbTplbGVtLHZhbHVlOnNyY30sSlNISU5ULmludGVybmFscy5wdXNoKGkpLGl9ZnVuY3Rpb24gYWRkbGFiZWwobmFtZSxvcHRzKXtvcHRzPW9wdHN8fHt9O3ZhciB0eXBlPW9wdHMudHlwZSx0b2tlbj1vcHRzLnRva2VuLGlzbGV0PW9wdHMuaXNsZXQ7XFxcImV4Y2VwdGlvblxcXCI9PT10eXBlJiZfLmhhcyhmdW5jdFtcXFwiKGNvbnRleHQpXFxcIl0sbmFtZSkmJihmdW5jdFtuYW1lXT09PSEwfHxzdGF0ZS5vcHRpb24ubm9kZXx8d2FybmluZyhcXFwiVzAwMlxcXCIsc3RhdGUudG9rZW5zLm5leHQsbmFtZSkpLF8uaGFzKGZ1bmN0LG5hbWUpJiYhZnVuY3RbXFxcIihnbG9iYWwpXFxcIl0mJihmdW5jdFtuYW1lXT09PSEwP3N0YXRlLm9wdGlvbi5sYXRlZGVmJiYoc3RhdGUub3B0aW9uLmxhdGVkZWY9PT0hMCYmXy5jb250YWlucyhbZnVuY3RbbmFtZV0sdHlwZV0sXFxcInVuY3Rpb25cXFwiKXx8IV8uY29udGFpbnMoW2Z1bmN0W25hbWVdLHR5cGVdLFxcXCJ1bmN0aW9uXFxcIikpJiZ3YXJuaW5nKFxcXCJXMDAzXFxcIixzdGF0ZS50b2tlbnMubmV4dCxuYW1lKTooKCFzdGF0ZS5vcHRpb24uc2hhZG93fHxfLmNvbnRhaW5zKFtcXFwiaW5uZXJcXFwiLFxcXCJvdXRlclxcXCJdLHN0YXRlLm9wdGlvbi5zaGFkb3cpKSYmXFxcImV4Y2VwdGlvblxcXCIhPT10eXBlfHxmdW5jdFtcXFwiKGJsb2Nrc2NvcGUpXFxcIl0uZ2V0bGFiZWwobmFtZSkpJiZ3YXJuaW5nKFxcXCJXMDA0XFxcIixzdGF0ZS50b2tlbnMubmV4dCxuYW1lKSksZnVuY3RbXFxcIihjb250ZXh0KVxcXCJdJiZfLmhhcyhmdW5jdFtcXFwiKGNvbnRleHQpXFxcIl0sbmFtZSkmJlxcXCJmdW5jdGlvblxcXCIhPT10eXBlJiZcXFwib3V0ZXJcXFwiPT09c3RhdGUub3B0aW9uLnNoYWRvdyYmd2FybmluZyhcXFwiVzEyM1xcXCIsc3RhdGUudG9rZW5zLm5leHQsbmFtZSksaXNsZXQ/ZnVuY3RbXFxcIihibG9ja3Njb3BlKVxcXCJdLmN1cnJlbnQuYWRkKG5hbWUsdHlwZSxzdGF0ZS50b2tlbnMuY3Vycik6KGZ1bmN0W1xcXCIoYmxvY2tzY29wZSlcXFwiXS5zaGFkb3cobmFtZSksZnVuY3RbbmFtZV09dHlwZSx0b2tlbiYmKGZ1bmN0W1xcXCIodG9rZW5zKVxcXCJdW25hbWVdPXRva2VuKSxzZXRwcm9wKGZ1bmN0LG5hbWUse3VudXNlZDpvcHRzLnVudXNlZHx8ITF9KSxmdW5jdFtcXFwiKGdsb2JhbClcXFwiXT8oZ2xvYmFsW25hbWVdPWZ1bmN0LF8uaGFzKGltcGxpZWQsbmFtZSkmJihzdGF0ZS5vcHRpb24ubGF0ZWRlZiYmKHN0YXRlLm9wdGlvbi5sYXRlZGVmPT09ITAmJl8uY29udGFpbnMoW2Z1bmN0W25hbWVdLHR5cGVdLFxcXCJ1bmN0aW9uXFxcIil8fCFfLmNvbnRhaW5zKFtmdW5jdFtuYW1lXSx0eXBlXSxcXFwidW5jdGlvblxcXCIpKSYmd2FybmluZyhcXFwiVzAwM1xcXCIsc3RhdGUudG9rZW5zLm5leHQsbmFtZSksZGVsZXRlIGltcGxpZWRbbmFtZV0pKTpzY29wZVtuYW1lXT1mdW5jdCl9ZnVuY3Rpb24gZG9PcHRpb24oKXt2YXIgbnQ9c3RhdGUudG9rZW5zLm5leHQsYm9keT1udC5ib2R5Lm1hdGNoKC8oLVxcXFxzKyk/W15cXFxccyw6XSsoPzpcXFxccyo6XFxcXHMqKC1cXFxccyspP1teXFxcXHMsXSspPy9nKXx8W10scHJlZGVmPXt9O2lmKFxcXCJnbG9iYWxzXFxcIj09PW50LnR5cGUpe2JvZHkuZm9yRWFjaChmdW5jdGlvbihnKXtnPWcuc3BsaXQoXFxcIjpcXFwiKTt2YXIga2V5PShnWzBdfHxcXFwiXFxcIikudHJpbSgpLHZhbD0oZ1sxXXx8XFxcIlxcXCIpLnRyaW0oKTtcXFwiLVxcXCI9PT1rZXkuY2hhckF0KDApPyhrZXk9a2V5LnNsaWNlKDEpLHZhbD0hMSxKU0hJTlQuYmxhY2tsaXN0W2tleV09a2V5LGRlbGV0ZSBwcmVkZWZpbmVkW2tleV0pOnByZWRlZltrZXldPVxcXCJ0cnVlXFxcIj09PXZhbH0pLGNvbWJpbmUocHJlZGVmaW5lZCxwcmVkZWYpO2Zvcih2YXIga2V5IGluIHByZWRlZilfLmhhcyhwcmVkZWYsa2V5KSYmKGRlY2xhcmVkW2tleV09bnQpfVxcXCJleHBvcnRlZFxcXCI9PT1udC50eXBlJiZib2R5LmZvckVhY2goZnVuY3Rpb24oZSl7ZXhwb3J0ZWRbZV09ITB9KSxcXFwibWVtYmVyc1xcXCI9PT1udC50eXBlJiYobWVtYmVyc09ubHk9bWVtYmVyc09ubHl8fHt9LGJvZHkuZm9yRWFjaChmdW5jdGlvbihtKXt2YXIgY2gxPW0uY2hhckF0KDApLGNoMj1tLmNoYXJBdChtLmxlbmd0aC0xKTtjaDEhPT1jaDJ8fCdcXFwiJyE9PWNoMSYmXFxcIidcXFwiIT09Y2gxfHwobT1tLnN1YnN0cigxLG0ubGVuZ3RoLTIpLnJlcGxhY2UoJ1xcXFxcXFxcXFxcIicsJ1xcXCInKSksbWVtYmVyc09ubHlbbV09ITF9KSk7dmFyIG51bXZhbHM9W1xcXCJtYXhzdGF0ZW1lbnRzXFxcIixcXFwibWF4cGFyYW1zXFxcIixcXFwibWF4ZGVwdGhcXFwiLFxcXCJtYXhjb21wbGV4aXR5XFxcIixcXFwibWF4ZXJyXFxcIixcXFwibWF4bGVuXFxcIixcXFwiaW5kZW50XFxcIl07KFxcXCJqc2hpbnRcXFwiPT09bnQudHlwZXx8XFxcImpzbGludFxcXCI9PT1udC50eXBlKSYmKGJvZHkuZm9yRWFjaChmdW5jdGlvbihnKXtnPWcuc3BsaXQoXFxcIjpcXFwiKTt2YXIga2V5PShnWzBdfHxcXFwiXFxcIikudHJpbSgpLHZhbD0oZ1sxXXx8XFxcIlxcXCIpLnRyaW0oKTtpZihjaGVja09wdGlvbihrZXksbnQpKWlmKG51bXZhbHMuaW5kZXhPZihrZXkpPj0wKWlmKFxcXCJmYWxzZVxcXCIhPT12YWwpe2lmKHZhbD0rdmFsLFxcXCJudW1iZXJcXFwiIT10eXBlb2YgdmFsfHwhaXNGaW5pdGUodmFsKXx8MD49dmFsfHxNYXRoLmZsb29yKHZhbCkhPT12YWwpcmV0dXJuIGVycm9yKFxcXCJFMDMyXFxcIixudCxnWzFdLnRyaW0oKSksdm9pZCAwO3N0YXRlLm9wdGlvbltrZXldPXZhbH1lbHNlIHN0YXRlLm9wdGlvbltrZXldPVxcXCJpbmRlbnRcXFwiPT09a2V5PzQ6ITE7ZWxzZXtpZihcXFwidmFsaWR0aGlzXFxcIj09PWtleSlyZXR1cm4gZnVuY3RbXFxcIihnbG9iYWwpXFxcIl0/dm9pZCBlcnJvcihcXFwiRTAwOVxcXCIpOlxcXCJ0cnVlXFxcIiE9PXZhbCYmXFxcImZhbHNlXFxcIiE9PXZhbD92b2lkIGVycm9yKFxcXCJFMDAyXFxcIixudCk6KHN0YXRlLm9wdGlvbi52YWxpZHRoaXM9XFxcInRydWVcXFwiPT09dmFsLHZvaWQgMCk7aWYoXFxcInF1b3RtYXJrXFxcIiE9PWtleSlpZihcXFwic2hhZG93XFxcIiE9PWtleSlpZihcXFwidW51c2VkXFxcIiE9PWtleSlpZihcXFwibGF0ZWRlZlxcXCIhPT1rZXkpe2lmKFxcXCJpZ25vcmVcXFwiIT09a2V5KXt2YXIgbWF0Y2g9L14oWystXSkoV1xcXFxkezN9KSQvZy5leGVjKGtleSk7aWYobWF0Y2gpcmV0dXJuIHN0YXRlLmlnbm9yZWRbbWF0Y2hbMl1dPVxcXCItXFxcIj09PW1hdGNoWzFdLHZvaWQgMDt2YXIgdG47cmV0dXJuXFxcInRydWVcXFwiPT09dmFsfHxcXFwiZmFsc2VcXFwiPT09dmFsPyhcXFwianNsaW50XFxcIj09PW50LnR5cGU/KHRuPXJlbmFtZWRPcHRpb25zW2tleV18fGtleSxzdGF0ZS5vcHRpb25bdG5dPVxcXCJ0cnVlXFxcIj09PXZhbCx2b2lkIDAhPT1pbnZlcnRlZE9wdGlvbnNbdG5dJiYoc3RhdGUub3B0aW9uW3RuXT0hc3RhdGUub3B0aW9uW3RuXSkpOnN0YXRlLm9wdGlvbltrZXldPVxcXCJ0cnVlXFxcIj09PXZhbCxcXFwibmV3Y2FwXFxcIj09PWtleSYmKHN0YXRlLm9wdGlvbltcXFwiKGV4cGxpY2l0TmV3Y2FwKVxcXCJdPSEwKSx2b2lkIDApOihlcnJvcihcXFwiRTAwMlxcXCIsbnQpLHZvaWQgMCl9c3dpdGNoKHZhbCl7Y2FzZVxcXCJzdGFydFxcXCI6c3RhdGUuaWdub3JlTGludGVyRXJyb3JzPSEwO2JyZWFrO2Nhc2VcXFwiZW5kXFxcIjpzdGF0ZS5pZ25vcmVMaW50ZXJFcnJvcnM9ITE7YnJlYWs7Y2FzZVxcXCJsaW5lXFxcIjpzdGF0ZS5pZ25vcmVkTGluZXNbbnQubGluZV09ITAscmVtb3ZlSWdub3JlZE1lc3NhZ2VzKCk7YnJlYWs7ZGVmYXVsdDplcnJvcihcXFwiRTAwMlxcXCIsbnQpfX1lbHNlIHN3aXRjaCh2YWwpe2Nhc2VcXFwidHJ1ZVxcXCI6c3RhdGUub3B0aW9uLmxhdGVkZWY9ITA7YnJlYWs7Y2FzZVxcXCJmYWxzZVxcXCI6c3RhdGUub3B0aW9uLmxhdGVkZWY9ITE7YnJlYWs7Y2FzZVxcXCJub2Z1bmNcXFwiOnN0YXRlLm9wdGlvbi5sYXRlZGVmPVxcXCJub2Z1bmNcXFwiO2JyZWFrO2RlZmF1bHQ6ZXJyb3IoXFxcIkUwMDJcXFwiLG50KX1lbHNlIHN3aXRjaCh2YWwpe2Nhc2VcXFwidHJ1ZVxcXCI6c3RhdGUub3B0aW9uLnVudXNlZD0hMDticmVhaztjYXNlXFxcImZhbHNlXFxcIjpzdGF0ZS5vcHRpb24udW51c2VkPSExO2JyZWFrO2Nhc2VcXFwidmFyc1xcXCI6Y2FzZVxcXCJzdHJpY3RcXFwiOnN0YXRlLm9wdGlvbi51bnVzZWQ9dmFsO2JyZWFrO2RlZmF1bHQ6ZXJyb3IoXFxcIkUwMDJcXFwiLG50KX1lbHNlIHN3aXRjaCh2YWwpe2Nhc2VcXFwidHJ1ZVxcXCI6c3RhdGUub3B0aW9uLnNoYWRvdz0hMDticmVhaztjYXNlXFxcIm91dGVyXFxcIjpzdGF0ZS5vcHRpb24uc2hhZG93PVxcXCJvdXRlclxcXCI7YnJlYWs7Y2FzZVxcXCJmYWxzZVxcXCI6Y2FzZVxcXCJpbm5lclxcXCI6c3RhdGUub3B0aW9uLnNoYWRvdz1cXFwiaW5uZXJcXFwiO2JyZWFrO2RlZmF1bHQ6ZXJyb3IoXFxcIkUwMDJcXFwiLG50KX1lbHNlIHN3aXRjaCh2YWwpe2Nhc2VcXFwidHJ1ZVxcXCI6Y2FzZVxcXCJmYWxzZVxcXCI6c3RhdGUub3B0aW9uLnF1b3RtYXJrPVxcXCJ0cnVlXFxcIj09PXZhbDticmVhaztjYXNlXFxcImRvdWJsZVxcXCI6Y2FzZVxcXCJzaW5nbGVcXFwiOnN0YXRlLm9wdGlvbi5xdW90bWFyaz12YWw7YnJlYWs7ZGVmYXVsdDplcnJvcihcXFwiRTAwMlxcXCIsbnQpfX19KSxhc3N1bWUoKSl9ZnVuY3Rpb24gcGVlayhwKXtmb3IodmFyIHQsaT1wfHwwLGo9MDtpPj1qOyl0PWxvb2thaGVhZFtqXSx0fHwodD1sb29rYWhlYWRbal09bGV4LnRva2VuKCkpLGorPTE7cmV0dXJuIHR9ZnVuY3Rpb24gYWR2YW5jZShpZCx0KXtzd2l0Y2goc3RhdGUudG9rZW5zLmN1cnIuaWQpe2Nhc2VcXFwiKG51bWJlcilcXFwiOlxcXCIuXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkJiZ3YXJuaW5nKFxcXCJXMDA1XFxcIixzdGF0ZS50b2tlbnMuY3Vycik7YnJlYWs7Y2FzZVxcXCItXFxcIjooXFxcIi1cXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWR8fFxcXCItLVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZCkmJndhcm5pbmcoXFxcIlcwMDZcXFwiKTticmVhaztjYXNlXFxcIitcXFwiOihcXFwiK1xcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZHx8XFxcIisrXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkKSYmd2FybmluZyhcXFwiVzAwN1xcXCIpfWZvcigoXFxcIihzdHJpbmcpXFxcIj09PXN0YXRlLnRva2Vucy5jdXJyLnR5cGV8fHN0YXRlLnRva2Vucy5jdXJyLmlkZW50aWZpZXIpJiYoYW5vbm5hbWU9c3RhdGUudG9rZW5zLmN1cnIudmFsdWUpLGlkJiZzdGF0ZS50b2tlbnMubmV4dC5pZCE9PWlkJiYodD9cXFwiKGVuZClcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQ/ZXJyb3IoXFxcIkUwMTlcXFwiLHQsdC5pZCk6ZXJyb3IoXFxcIkUwMjBcXFwiLHN0YXRlLnRva2Vucy5uZXh0LGlkLHQuaWQsdC5saW5lLHN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKTooXFxcIihpZGVudGlmaWVyKVxcXCIhPT1zdGF0ZS50b2tlbnMubmV4dC50eXBlfHxzdGF0ZS50b2tlbnMubmV4dC52YWx1ZSE9PWlkKSYmd2FybmluZyhcXFwiVzExNlxcXCIsc3RhdGUudG9rZW5zLm5leHQsaWQsc3RhdGUudG9rZW5zLm5leHQudmFsdWUpKSxzdGF0ZS50b2tlbnMucHJldj1zdGF0ZS50b2tlbnMuY3VycixzdGF0ZS50b2tlbnMuY3Vycj1zdGF0ZS50b2tlbnMubmV4dDs7KXtpZihzdGF0ZS50b2tlbnMubmV4dD1sb29rYWhlYWQuc2hpZnQoKXx8bGV4LnRva2VuKCksc3RhdGUudG9rZW5zLm5leHR8fHF1aXQoXFxcIkUwNDFcXFwiLHN0YXRlLnRva2Vucy5jdXJyLmxpbmUpLFxcXCIoZW5kKVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZHx8XFxcIihlcnJvcilcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQpcmV0dXJuO2lmKHN0YXRlLnRva2Vucy5uZXh0LmNoZWNrJiZzdGF0ZS50b2tlbnMubmV4dC5jaGVjaygpLHN0YXRlLnRva2Vucy5uZXh0LmlzU3BlY2lhbClkb09wdGlvbigpO2Vsc2UgaWYoXFxcIihlbmRsaW5lKVxcXCIhPT1zdGF0ZS50b2tlbnMubmV4dC5pZClicmVha319ZnVuY3Rpb24gaXNJbmZpeCh0b2tlbil7cmV0dXJuIHRva2VuLmluZml4fHwhdG9rZW4uaWRlbnRpZmllciYmISF0b2tlbi5sZWR9ZnVuY3Rpb24gaXNFbmRPZkV4cHIoKXt2YXIgY3Vycj1zdGF0ZS50b2tlbnMuY3VycixuZXh0PXN0YXRlLnRva2Vucy5uZXh0O3JldHVyblxcXCI7XFxcIj09PW5leHQuaWR8fFxcXCJ9XFxcIj09PW5leHQuaWR8fFxcXCI6XFxcIj09PW5leHQuaWQ/ITA6aXNJbmZpeChuZXh0KT09PWlzSW5maXgoY3Vycil8fFxcXCJ5aWVsZFxcXCI9PT1jdXJyLmlkJiZzdGF0ZS5vcHRpb24uaW5Nb3ooITApP2N1cnIubGluZSE9PW5leHQubGluZTohMX1mdW5jdGlvbiBleHByZXNzaW9uKHJicCxpbml0aWFsKXt2YXIgbGVmdCxpc0FycmF5PSExLGlzT2JqZWN0PSExLGlzTGV0RXhwcj0hMTtpbml0aWFsfHxcXFwibGV0XFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlfHxcXFwiKFxcXCIhPT1wZWVrKDApLnZhbHVlfHwoc3RhdGUub3B0aW9uLmluTW96KCEwKXx8d2FybmluZyhcXFwiVzExOFxcXCIsc3RhdGUudG9rZW5zLm5leHQsXFxcImxldCBleHByZXNzaW9uc1xcXCIpLGlzTGV0RXhwcj0hMCxmdW5jdFtcXFwiKGJsb2Nrc2NvcGUpXFxcIl0uc3RhY2soKSxhZHZhbmNlKFxcXCJsZXRcXFwiKSxhZHZhbmNlKFxcXCIoXFxcIiksc3RhdGUuc3ludGF4LmxldC5mdWQuY2FsbChzdGF0ZS5zeW50YXgubGV0LmZ1ZCwhMSksYWR2YW5jZShcXFwiKVxcXCIpKSxcXFwiKGVuZClcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQmJmVycm9yKFxcXCJFMDA2XFxcIixzdGF0ZS50b2tlbnMuY3Vycik7dmFyIGlzRGFuZ2Vyb3VzPXN0YXRlLm9wdGlvbi5hc2kmJnN0YXRlLnRva2Vucy5wcmV2LmxpbmU8c3RhdGUudG9rZW5zLmN1cnIubGluZSYmXy5jb250YWlucyhbXFxcIl1cXFwiLFxcXCIpXFxcIl0sc3RhdGUudG9rZW5zLnByZXYuaWQpJiZfLmNvbnRhaW5zKFtcXFwiW1xcXCIsXFxcIihcXFwiXSxzdGF0ZS50b2tlbnMuY3Vyci5pZCk7aWYoaXNEYW5nZXJvdXMmJndhcm5pbmcoXFxcIlcwMTRcXFwiLHN0YXRlLnRva2Vucy5jdXJyLHN0YXRlLnRva2Vucy5jdXJyLmlkKSxhZHZhbmNlKCksaW5pdGlhbCYmKGFub25uYW1lPVxcXCJhbm9ueW1vdXNcXFwiLGZ1bmN0W1xcXCIodmVyYilcXFwiXT1zdGF0ZS50b2tlbnMuY3Vyci52YWx1ZSksaW5pdGlhbD09PSEwJiZzdGF0ZS50b2tlbnMuY3Vyci5mdWQpbGVmdD1zdGF0ZS50b2tlbnMuY3Vyci5mdWQoKTtlbHNlIGZvcihzdGF0ZS50b2tlbnMuY3Vyci5udWQ/bGVmdD1zdGF0ZS50b2tlbnMuY3Vyci5udWQoKTplcnJvcihcXFwiRTAzMFxcXCIsc3RhdGUudG9rZW5zLmN1cnIsc3RhdGUudG9rZW5zLmN1cnIuaWQpO3N0YXRlLnRva2Vucy5uZXh0LmxicD5yYnAmJiFpc0VuZE9mRXhwcigpOylpc0FycmF5PVxcXCJBcnJheVxcXCI9PT1zdGF0ZS50b2tlbnMuY3Vyci52YWx1ZSxpc09iamVjdD1cXFwiT2JqZWN0XFxcIj09PXN0YXRlLnRva2Vucy5jdXJyLnZhbHVlLGxlZnQmJihsZWZ0LnZhbHVlfHxsZWZ0LmZpcnN0JiZsZWZ0LmZpcnN0LnZhbHVlKSYmKFxcXCJuZXdcXFwiIT09bGVmdC52YWx1ZXx8bGVmdC5maXJzdCYmbGVmdC5maXJzdC52YWx1ZSYmXFxcIi5cXFwiPT09bGVmdC5maXJzdC52YWx1ZSkmJihpc0FycmF5PSExLGxlZnQudmFsdWUhPT1zdGF0ZS50b2tlbnMuY3Vyci52YWx1ZSYmKGlzT2JqZWN0PSExKSksYWR2YW5jZSgpLGlzQXJyYXkmJlxcXCIoXFxcIj09PXN0YXRlLnRva2Vucy5jdXJyLmlkJiZcXFwiKVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZCYmd2FybmluZyhcXFwiVzAwOVxcXCIsc3RhdGUudG9rZW5zLmN1cnIpLGlzT2JqZWN0JiZcXFwiKFxcXCI9PT1zdGF0ZS50b2tlbnMuY3Vyci5pZCYmXFxcIilcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQmJndhcm5pbmcoXFxcIlcwMTBcXFwiLHN0YXRlLnRva2Vucy5jdXJyKSxsZWZ0JiZzdGF0ZS50b2tlbnMuY3Vyci5sZWQ/bGVmdD1zdGF0ZS50b2tlbnMuY3Vyci5sZWQobGVmdCk6ZXJyb3IoXFxcIkUwMzNcXFwiLHN0YXRlLnRva2Vucy5jdXJyLHN0YXRlLnRva2Vucy5jdXJyLmlkKTtyZXR1cm4gaXNMZXRFeHByJiZmdW5jdFtcXFwiKGJsb2Nrc2NvcGUpXFxcIl0udW5zdGFjaygpLGxlZnR9ZnVuY3Rpb24gbm9icmVha25vbmFkamFjZW50KGxlZnQscmlnaHQpe2xlZnQ9bGVmdHx8c3RhdGUudG9rZW5zLmN1cnIscmlnaHQ9cmlnaHR8fHN0YXRlLnRva2Vucy5uZXh0LHN0YXRlLm9wdGlvbi5sYXhicmVha3x8bGVmdC5saW5lPT09cmlnaHQubGluZXx8d2FybmluZyhcXFwiVzAxNFxcXCIscmlnaHQscmlnaHQudmFsdWUpfWZ1bmN0aW9uIG5vbGluZWJyZWFrKHQpe3Q9dHx8c3RhdGUudG9rZW5zLmN1cnIsdC5saW5lIT09c3RhdGUudG9rZW5zLm5leHQubGluZSYmd2FybmluZyhcXFwiRTAyMlxcXCIsdCx0LnZhbHVlKX1mdW5jdGlvbiBub2JyZWFrY29tbWEobGVmdCxyaWdodCl7bGVmdC5saW5lIT09cmlnaHQubGluZSYmKHN0YXRlLm9wdGlvbi5sYXhjb21tYXx8KGNvbW1hLmZpcnN0JiYod2FybmluZyhcXFwiSTAwMVxcXCIpLGNvbW1hLmZpcnN0PSExKSx3YXJuaW5nKFxcXCJXMDE0XFxcIixsZWZ0LHJpZ2h0LnZhbHVlKSkpfWZ1bmN0aW9uIGNvbW1hKG9wdHMpe2lmKG9wdHM9b3B0c3x8e30sb3B0cy5wZWVrP25vYnJlYWtjb21tYShzdGF0ZS50b2tlbnMucHJldixzdGF0ZS50b2tlbnMuY3Vycik6KG5vYnJlYWtjb21tYShzdGF0ZS50b2tlbnMuY3VycixzdGF0ZS50b2tlbnMubmV4dCksYWR2YW5jZShcXFwiLFxcXCIpKSxzdGF0ZS50b2tlbnMubmV4dC5pZGVudGlmaWVyJiYoIW9wdHMucHJvcGVydHl8fCFzdGF0ZS5vcHRpb24uaW5FUzUoKSkpc3dpdGNoKHN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKXtjYXNlXFxcImJyZWFrXFxcIjpjYXNlXFxcImNhc2VcXFwiOmNhc2VcXFwiY2F0Y2hcXFwiOmNhc2VcXFwiY29udGludWVcXFwiOmNhc2VcXFwiZGVmYXVsdFxcXCI6Y2FzZVxcXCJkb1xcXCI6Y2FzZVxcXCJlbHNlXFxcIjpjYXNlXFxcImZpbmFsbHlcXFwiOmNhc2VcXFwiZm9yXFxcIjpjYXNlXFxcImlmXFxcIjpjYXNlXFxcImluXFxcIjpjYXNlXFxcImluc3RhbmNlb2ZcXFwiOmNhc2VcXFwicmV0dXJuXFxcIjpjYXNlXFxcInN3aXRjaFxcXCI6Y2FzZVxcXCJ0aHJvd1xcXCI6Y2FzZVxcXCJ0cnlcXFwiOmNhc2VcXFwidmFyXFxcIjpjYXNlXFxcImxldFxcXCI6Y2FzZVxcXCJ3aGlsZVxcXCI6Y2FzZVxcXCJ3aXRoXFxcIjpyZXR1cm4gZXJyb3IoXFxcIkUwMjRcXFwiLHN0YXRlLnRva2Vucy5uZXh0LHN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKSwhMX1pZihcXFwiKHB1bmN0dWF0b3IpXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnR5cGUpc3dpdGNoKHN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKXtjYXNlXFxcIn1cXFwiOmNhc2VcXFwiXVxcXCI6Y2FzZVxcXCIsXFxcIjppZihvcHRzLmFsbG93VHJhaWxpbmcpcmV0dXJuITA7Y2FzZVxcXCIpXFxcIjpyZXR1cm4gZXJyb3IoXFxcIkUwMjRcXFwiLHN0YXRlLnRva2Vucy5uZXh0LHN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKSwhMX1yZXR1cm4hMH1mdW5jdGlvbiBzeW1ib2wocyxwKXt2YXIgeD1zdGF0ZS5zeW50YXhbc107cmV0dXJuIHgmJlxcXCJvYmplY3RcXFwiPT10eXBlb2YgeHx8KHN0YXRlLnN5bnRheFtzXT14PXtpZDpzLGxicDpwLHZhbHVlOnN9KSx4fWZ1bmN0aW9uIGRlbGltKHMpe3JldHVybiBzeW1ib2wocywwKX1mdW5jdGlvbiBzdG10KHMsZil7dmFyIHg9ZGVsaW0ocyk7cmV0dXJuIHguaWRlbnRpZmllcj14LnJlc2VydmVkPSEwLHguZnVkPWYseH1mdW5jdGlvbiBibG9ja3N0bXQocyxmKXt2YXIgeD1zdG10KHMsZik7cmV0dXJuIHguYmxvY2s9ITAseH1mdW5jdGlvbiByZXNlcnZlTmFtZSh4KXt2YXIgYz14LmlkLmNoYXJBdCgwKTtyZXR1cm4oYz49XFxcImFcXFwiJiZcXFwielxcXCI+PWN8fGM+PVxcXCJBXFxcIiYmXFxcIlpcXFwiPj1jKSYmKHguaWRlbnRpZmllcj14LnJlc2VydmVkPSEwKSx4fWZ1bmN0aW9uIHByZWZpeChzLGYpe3ZhciB4PXN5bWJvbChzLDE1MCk7cmV0dXJuIHJlc2VydmVOYW1lKHgpLHgubnVkPVxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBmP2Y6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yaWdodD1leHByZXNzaW9uKDE1MCksdGhpcy5hcml0eT1cXFwidW5hcnlcXFwiLChcXFwiKytcXFwiPT09dGhpcy5pZHx8XFxcIi0tXFxcIj09PXRoaXMuaWQpJiYoc3RhdGUub3B0aW9uLnBsdXNwbHVzP3dhcm5pbmcoXFxcIlcwMTZcXFwiLHRoaXMsdGhpcy5pZCk6IXRoaXMucmlnaHR8fHRoaXMucmlnaHQuaWRlbnRpZmllciYmIWlzUmVzZXJ2ZWQodGhpcy5yaWdodCl8fFxcXCIuXFxcIj09PXRoaXMucmlnaHQuaWR8fFxcXCJbXFxcIj09PXRoaXMucmlnaHQuaWR8fHdhcm5pbmcoXFxcIlcwMTdcXFwiLHRoaXMpKSx0aGlzfSx4fWZ1bmN0aW9uIHR5cGUocyxmKXt2YXIgeD1kZWxpbShzKTtyZXR1cm4geC50eXBlPXMseC5udWQ9Zix4fWZ1bmN0aW9uIHJlc2VydmUobmFtZSxmdW5jKXt2YXIgeD10eXBlKG5hbWUsZnVuYyk7cmV0dXJuIHguaWRlbnRpZmllcj0hMCx4LnJlc2VydmVkPSEwLHh9ZnVuY3Rpb24gRnV0dXJlUmVzZXJ2ZWRXb3JkKG5hbWUsbWV0YSl7dmFyIHg9dHlwZShuYW1lLG1ldGEmJm1ldGEubnVkfHxmdW5jdGlvbigpe3JldHVybiB0aGlzfSk7cmV0dXJuIG1ldGE9bWV0YXx8e30sbWV0YS5pc0Z1dHVyZVJlc2VydmVkV29yZD0hMCx4LnZhbHVlPW5hbWUseC5pZGVudGlmaWVyPSEwLHgucmVzZXJ2ZWQ9ITAseC5tZXRhPW1ldGEseH1mdW5jdGlvbiByZXNlcnZldmFyKHMsdil7cmV0dXJuIHJlc2VydmUocyxmdW5jdGlvbigpe3JldHVyblxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiB2JiZ2KHRoaXMpLHRoaXN9KX1mdW5jdGlvbiBpbmZpeChzLGYscCx3KXt2YXIgeD1zeW1ib2wocyxwKTtyZXR1cm4gcmVzZXJ2ZU5hbWUoeCkseC5pbmZpeD0hMCx4LmxlZD1mdW5jdGlvbihsZWZ0KXtyZXR1cm4gd3x8bm9icmVha25vbmFkamFjZW50KHN0YXRlLnRva2Vucy5wcmV2LHN0YXRlLnRva2Vucy5jdXJyKSxcXFwiaW5cXFwiPT09cyYmXFxcIiFcXFwiPT09bGVmdC5pZCYmd2FybmluZyhcXFwiVzAxOFxcXCIsbGVmdCxcXFwiIVxcXCIpLFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBmP2YobGVmdCx0aGlzKToodGhpcy5sZWZ0PWxlZnQsdGhpcy5yaWdodD1leHByZXNzaW9uKHApLHRoaXMpfSx4fWZ1bmN0aW9uIGFwcGxpY2F0aW9uKHMpe3ZhciB4PXN5bWJvbChzLDQyKTtyZXR1cm4geC5sZWQ9ZnVuY3Rpb24obGVmdCl7cmV0dXJuIHN0YXRlLm9wdGlvbi5pbkVTTmV4dCgpfHx3YXJuaW5nKFxcXCJXMTA0XFxcIixzdGF0ZS50b2tlbnMuY3VycixcXFwiYXJyb3cgZnVuY3Rpb24gc3ludGF4ICg9PilcXFwiKSxub2JyZWFrbm9uYWRqYWNlbnQoc3RhdGUudG9rZW5zLnByZXYsc3RhdGUudG9rZW5zLmN1cnIpLHRoaXMubGVmdD1sZWZ0LHRoaXMucmlnaHQ9ZG9GdW5jdGlvbih2b2lkIDAsdm9pZCAwLCExLGxlZnQpLHRoaXN9LHh9ZnVuY3Rpb24gcmVsYXRpb24ocyxmKXt2YXIgeD1zeW1ib2wocywxMDApO3JldHVybiB4LmxlZD1mdW5jdGlvbihsZWZ0KXtub2JyZWFrbm9uYWRqYWNlbnQoc3RhdGUudG9rZW5zLnByZXYsc3RhdGUudG9rZW5zLmN1cnIpO3ZhciByaWdodD1leHByZXNzaW9uKDEwMCk7cmV0dXJuIGlzSWRlbnRpZmllcihsZWZ0LFxcXCJOYU5cXFwiKXx8aXNJZGVudGlmaWVyKHJpZ2h0LFxcXCJOYU5cXFwiKT93YXJuaW5nKFxcXCJXMDE5XFxcIix0aGlzKTpmJiZmLmFwcGx5KHRoaXMsW2xlZnQscmlnaHRdKSxsZWZ0JiZyaWdodHx8cXVpdChcXFwiRTA0MVxcXCIsc3RhdGUudG9rZW5zLmN1cnIubGluZSksXFxcIiFcXFwiPT09bGVmdC5pZCYmd2FybmluZyhcXFwiVzAxOFxcXCIsbGVmdCxcXFwiIVxcXCIpLFxcXCIhXFxcIj09PXJpZ2h0LmlkJiZ3YXJuaW5nKFxcXCJXMDE4XFxcIixyaWdodCxcXFwiIVxcXCIpLHRoaXMubGVmdD1sZWZ0LHRoaXMucmlnaHQ9cmlnaHQsdGhpc30seH1mdW5jdGlvbiBpc1Bvb3JSZWxhdGlvbihub2RlKXtyZXR1cm4gbm9kZSYmKFxcXCIobnVtYmVyKVxcXCI9PT1ub2RlLnR5cGUmJjA9PT0rbm9kZS52YWx1ZXx8XFxcIihzdHJpbmcpXFxcIj09PW5vZGUudHlwZSYmXFxcIlxcXCI9PT1ub2RlLnZhbHVlfHxcXFwibnVsbFxcXCI9PT1ub2RlLnR5cGUmJiFzdGF0ZS5vcHRpb24uZXFudWxsfHxcXFwidHJ1ZVxcXCI9PT1ub2RlLnR5cGV8fFxcXCJmYWxzZVxcXCI9PT1ub2RlLnR5cGV8fFxcXCJ1bmRlZmluZWRcXFwiPT09bm9kZS50eXBlKX1mdW5jdGlvbiBpc1R5cG9UeXBlb2YobGVmdCxyaWdodCl7aWYoc3RhdGUub3B0aW9uLm5vdHlwZW9mKXJldHVybiExO2lmKCFsZWZ0fHwhcmlnaHQpcmV0dXJuITE7dmFyIHZhbHVlcz1bXFxcInVuZGVmaW5lZFxcXCIsXFxcIm9iamVjdFxcXCIsXFxcImJvb2xlYW5cXFwiLFxcXCJudW1iZXJcXFwiLFxcXCJzdHJpbmdcXFwiLFxcXCJmdW5jdGlvblxcXCIsXFxcInhtbFxcXCIsXFxcIm9iamVjdFxcXCIsXFxcInVua25vd25cXFwiXTtyZXR1cm5cXFwiKGlkZW50aWZpZXIpXFxcIj09PXJpZ2h0LnR5cGUmJlxcXCJ0eXBlb2ZcXFwiPT09cmlnaHQudmFsdWUmJlxcXCIoc3RyaW5nKVxcXCI9PT1sZWZ0LnR5cGU/IV8uY29udGFpbnModmFsdWVzLGxlZnQudmFsdWUpOiExfWZ1bmN0aW9uIGZpbmROYXRpdmVQcm90b3R5cGUobGVmdCl7ZnVuY3Rpb24gd2Fsa1Byb3RvdHlwZShvYmope3JldHVyblxcXCJvYmplY3RcXFwiPT10eXBlb2Ygb2JqP1xcXCJwcm90b3R5cGVcXFwiPT09b2JqLnJpZ2h0P29iajp3YWxrUHJvdG90eXBlKG9iai5sZWZ0KTp2b2lkIDB9ZnVuY3Rpb24gd2Fsa05hdGl2ZShvYmope2Zvcig7IW9iai5pZGVudGlmaWVyJiZcXFwib2JqZWN0XFxcIj09dHlwZW9mIG9iai5sZWZ0OylvYmo9b2JqLmxlZnQ7cmV0dXJuIG9iai5pZGVudGlmaWVyJiZuYXRpdmVzLmluZGV4T2Yob2JqLnZhbHVlKT49MD9vYmoudmFsdWU6dm9pZCAwfXZhciBuYXRpdmVzPVtcXFwiQXJyYXlcXFwiLFxcXCJBcnJheUJ1ZmZlclxcXCIsXFxcIkJvb2xlYW5cXFwiLFxcXCJDb2xsYXRvclxcXCIsXFxcIkRhdGFWaWV3XFxcIixcXFwiRGF0ZVxcXCIsXFxcIkRhdGVUaW1lRm9ybWF0XFxcIixcXFwiRXJyb3JcXFwiLFxcXCJFdmFsRXJyb3JcXFwiLFxcXCJGbG9hdDMyQXJyYXlcXFwiLFxcXCJGbG9hdDY0QXJyYXlcXFwiLFxcXCJGdW5jdGlvblxcXCIsXFxcIkluZmluaXR5XFxcIixcXFwiSW50bFxcXCIsXFxcIkludDE2QXJyYXlcXFwiLFxcXCJJbnQzMkFycmF5XFxcIixcXFwiSW50OEFycmF5XFxcIixcXFwiSXRlcmF0b3JcXFwiLFxcXCJOdW1iZXJcXFwiLFxcXCJOdW1iZXJGb3JtYXRcXFwiLFxcXCJPYmplY3RcXFwiLFxcXCJSYW5nZUVycm9yXFxcIixcXFwiUmVmZXJlbmNlRXJyb3JcXFwiLFxcXCJSZWdFeHBcXFwiLFxcXCJTdG9wSXRlcmF0aW9uXFxcIixcXFwiU3RyaW5nXFxcIixcXFwiU3ludGF4RXJyb3JcXFwiLFxcXCJUeXBlRXJyb3JcXFwiLFxcXCJVaW50MTZBcnJheVxcXCIsXFxcIlVpbnQzMkFycmF5XFxcIixcXFwiVWludDhBcnJheVxcXCIsXFxcIlVpbnQ4Q2xhbXBlZEFycmF5XFxcIixcXFwiVVJJRXJyb3JcXFwiXSxwcm90b3R5cGU9d2Fsa1Byb3RvdHlwZShsZWZ0KTtyZXR1cm4gcHJvdG90eXBlP3dhbGtOYXRpdmUocHJvdG90eXBlKTp2b2lkIDB9ZnVuY3Rpb24gYXNzaWdub3AocyxmLHApe3ZhciB4PWluZml4KHMsXFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGY/ZjpmdW5jdGlvbihsZWZ0LHRoYXQpe2lmKHRoYXQubGVmdD1sZWZ0LGxlZnQpe2lmKHN0YXRlLm9wdGlvbi5mcmVlemUpe3ZhciBuYXRpdmVPYmplY3Q9ZmluZE5hdGl2ZVByb3RvdHlwZShsZWZ0KTtuYXRpdmVPYmplY3QmJndhcm5pbmcoXFxcIlcxMjFcXFwiLGxlZnQsbmF0aXZlT2JqZWN0KX1pZihwcmVkZWZpbmVkW2xlZnQudmFsdWVdPT09ITEmJnNjb3BlW2xlZnQudmFsdWVdW1xcXCIoZ2xvYmFsKVxcXCJdPT09ITA/d2FybmluZyhcXFwiVzAyMFxcXCIsbGVmdCk6bGVmdFtcXFwiZnVuY3Rpb25cXFwiXSYmd2FybmluZyhcXFwiVzAyMVxcXCIsbGVmdCxsZWZ0LnZhbHVlKSxcXFwiY29uc3RcXFwiPT09ZnVuY3RbbGVmdC52YWx1ZV0mJmVycm9yKFxcXCJFMDEzXFxcIixsZWZ0LGxlZnQudmFsdWUpLFxcXCIuXFxcIj09PWxlZnQuaWQpcmV0dXJuIGxlZnQubGVmdD9cXFwiYXJndW1lbnRzXFxcIiE9PWxlZnQubGVmdC52YWx1ZXx8c3RhdGUuZGlyZWN0aXZlW1xcXCJ1c2Ugc3RyaWN0XFxcIl18fHdhcm5pbmcoXFxcIkUwMzFcXFwiLHRoYXQpOndhcm5pbmcoXFxcIkUwMzFcXFwiLHRoYXQpLHRoYXQucmlnaHQ9ZXhwcmVzc2lvbigxMCksdGhhdDtpZihcXFwiW1xcXCI9PT1sZWZ0LmlkKXJldHVybiBzdGF0ZS50b2tlbnMuY3Vyci5sZWZ0LmZpcnN0P3N0YXRlLnRva2Vucy5jdXJyLmxlZnQuZmlyc3QuZm9yRWFjaChmdW5jdGlvbih0KXt0JiZcXFwiY29uc3RcXFwiPT09ZnVuY3RbdC52YWx1ZV0mJmVycm9yKFxcXCJFMDEzXFxcIix0LHQudmFsdWUpfSk6bGVmdC5sZWZ0P1xcXCJhcmd1bWVudHNcXFwiIT09bGVmdC5sZWZ0LnZhbHVlfHxzdGF0ZS5kaXJlY3RpdmVbXFxcInVzZSBzdHJpY3RcXFwiXXx8d2FybmluZyhcXFwiRTAzMVxcXCIsdGhhdCk6d2FybmluZyhcXFwiRTAzMVxcXCIsdGhhdCksdGhhdC5yaWdodD1leHByZXNzaW9uKDEwKSx0aGF0O2lmKGxlZnQuaWRlbnRpZmllciYmIWlzUmVzZXJ2ZWQobGVmdCkpcmV0dXJuXFxcImV4Y2VwdGlvblxcXCI9PT1mdW5jdFtsZWZ0LnZhbHVlXSYmd2FybmluZyhcXFwiVzAyMlxcXCIsbGVmdCksdGhhdC5yaWdodD1leHByZXNzaW9uKDEwKSx0aGF0O2xlZnQ9PT1zdGF0ZS5zeW50YXhbXFxcImZ1bmN0aW9uXFxcIl0mJndhcm5pbmcoXFxcIlcwMjNcXFwiLHN0YXRlLnRva2Vucy5jdXJyKVxcbn1lcnJvcihcXFwiRTAzMVxcXCIsdGhhdCl9LHApO3JldHVybiB4LmV4cHM9ITAseC5hc3NpZ249ITAseH1mdW5jdGlvbiBiaXR3aXNlKHMsZixwKXt2YXIgeD1zeW1ib2wocyxwKTtyZXR1cm4gcmVzZXJ2ZU5hbWUoeCkseC5sZWQ9XFxcImZ1bmN0aW9uXFxcIj09dHlwZW9mIGY/ZjpmdW5jdGlvbihsZWZ0KXtyZXR1cm4gc3RhdGUub3B0aW9uLmJpdHdpc2UmJndhcm5pbmcoXFxcIlcwMTZcXFwiLHRoaXMsdGhpcy5pZCksdGhpcy5sZWZ0PWxlZnQsdGhpcy5yaWdodD1leHByZXNzaW9uKHApLHRoaXN9LHh9ZnVuY3Rpb24gYml0d2lzZWFzc2lnbm9wKHMpe3JldHVybiBhc3NpZ25vcChzLGZ1bmN0aW9uKGxlZnQsdGhhdCl7cmV0dXJuIHN0YXRlLm9wdGlvbi5iaXR3aXNlJiZ3YXJuaW5nKFxcXCJXMDE2XFxcIix0aGF0LHRoYXQuaWQpLGxlZnQ/XFxcIi5cXFwiPT09bGVmdC5pZHx8XFxcIltcXFwiPT09bGVmdC5pZHx8bGVmdC5pZGVudGlmaWVyJiYhaXNSZXNlcnZlZChsZWZ0KT8oZXhwcmVzc2lvbigxMCksdGhhdCk6KGxlZnQ9PT1zdGF0ZS5zeW50YXhbXFxcImZ1bmN0aW9uXFxcIl0mJndhcm5pbmcoXFxcIlcwMjNcXFwiLHN0YXRlLnRva2Vucy5jdXJyKSx0aGF0KTooZXJyb3IoXFxcIkUwMzFcXFwiLHRoYXQpLHZvaWQgMCl9LDIwKX1mdW5jdGlvbiBzdWZmaXgocyl7dmFyIHg9c3ltYm9sKHMsMTUwKTtyZXR1cm4geC5sZWQ9ZnVuY3Rpb24obGVmdCl7cmV0dXJuIHN0YXRlLm9wdGlvbi5wbHVzcGx1cz93YXJuaW5nKFxcXCJXMDE2XFxcIix0aGlzLHRoaXMuaWQpOmxlZnQuaWRlbnRpZmllciYmIWlzUmVzZXJ2ZWQobGVmdCl8fFxcXCIuXFxcIj09PWxlZnQuaWR8fFxcXCJbXFxcIj09PWxlZnQuaWR8fHdhcm5pbmcoXFxcIlcwMTdcXFwiLHRoaXMpLHRoaXMubGVmdD1sZWZ0LHRoaXN9LHh9ZnVuY3Rpb24gb3B0aW9uYWxpZGVudGlmaWVyKGZucGFyYW0scHJvcCl7aWYoc3RhdGUudG9rZW5zLm5leHQuaWRlbnRpZmllcil7YWR2YW5jZSgpO3ZhciBjdXJyPXN0YXRlLnRva2Vucy5jdXJyLHZhbD1zdGF0ZS50b2tlbnMuY3Vyci52YWx1ZTtyZXR1cm4gaXNSZXNlcnZlZChjdXJyKT9wcm9wJiZzdGF0ZS5vcHRpb24uaW5FUzUoKT92YWw6Zm5wYXJhbSYmXFxcInVuZGVmaW5lZFxcXCI9PT12YWw/dmFsOih3YXJuaW5nKFxcXCJXMDI0XFxcIixzdGF0ZS50b2tlbnMuY3VycixzdGF0ZS50b2tlbnMuY3Vyci5pZCksdmFsKTp2YWx9fWZ1bmN0aW9uIGlkZW50aWZpZXIoZm5wYXJhbSxwcm9wKXt2YXIgaT1vcHRpb25hbGlkZW50aWZpZXIoZm5wYXJhbSxwcm9wKTtyZXR1cm4gaT9pOihcXFwiZnVuY3Rpb25cXFwiPT09c3RhdGUudG9rZW5zLmN1cnIuaWQmJlxcXCIoXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkP3dhcm5pbmcoXFxcIlcwMjVcXFwiKTplcnJvcihcXFwiRTAzMFxcXCIsc3RhdGUudG9rZW5zLm5leHQsc3RhdGUudG9rZW5zLm5leHQudmFsdWUpLHZvaWQgMCl9ZnVuY3Rpb24gcmVhY2hhYmxlKHMpe3ZhciB0LGk9MDtpZihcXFwiO1xcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZCYmIW5vcmVhY2gpZm9yKDs7KXtkbyB0PXBlZWsoaSksaSs9MTt3aGlsZShcXFwiKGVuZClcXFwiIT10LmlkJiZcXFwiKGNvbW1lbnQpXFxcIj09PXQuaWQpO2lmKHQucmVhY2gpcmV0dXJuO2lmKFxcXCIoZW5kbGluZSlcXFwiIT09dC5pZCl7aWYoXFxcImZ1bmN0aW9uXFxcIj09PXQuaWQpe3N0YXRlLm9wdGlvbi5sYXRlZGVmPT09ITAmJndhcm5pbmcoXFxcIlcwMjZcXFwiLHQpO2JyZWFrfXdhcm5pbmcoXFxcIlcwMjdcXFwiLHQsdC52YWx1ZSxzKTticmVha319fWZ1bmN0aW9uIHBhcnNlRmluYWxTZW1pY29sb24oKXtcXFwiO1xcXCIhPT1zdGF0ZS50b2tlbnMubmV4dC5pZD9zdGF0ZS5vcHRpb24uYXNpfHxzdGF0ZS5vcHRpb24ubGFzdHNlbWljJiZcXFwifVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZCYmc3RhdGUudG9rZW5zLm5leHQubGluZT09PXN0YXRlLnRva2Vucy5jdXJyLmxpbmV8fHdhcm5pbmdBdChcXFwiVzAzM1xcXCIsc3RhdGUudG9rZW5zLmN1cnIubGluZSxzdGF0ZS50b2tlbnMuY3Vyci5jaGFyYWN0ZXIpOmFkdmFuY2UoXFxcIjtcXFwiKX1mdW5jdGlvbiBzdGF0ZW1lbnQoKXt2YXIgdmFsdWVzLHIsaT1pbmRlbnQscz1zY29wZSx0PXN0YXRlLnRva2Vucy5uZXh0O2lmKFxcXCI7XFxcIj09PXQuaWQpcmV0dXJuIGFkdmFuY2UoXFxcIjtcXFwiKSx2b2lkIDA7dmFyIHJlcz1pc1Jlc2VydmVkKHQpO2lmKHJlcyYmdC5tZXRhJiZ0Lm1ldGEuaXNGdXR1cmVSZXNlcnZlZFdvcmQmJlxcXCI6XFxcIj09PXBlZWsoKS5pZCYmKHdhcm5pbmcoXFxcIlcwMjRcXFwiLHQsdC5pZCkscmVzPSExKSxcXFwibW9kdWxlXFxcIj09PXQudmFsdWUmJlxcXCIoaWRlbnRpZmllcilcXFwiPT09dC50eXBlJiZcXFwiKGlkZW50aWZpZXIpXFxcIj09PXBlZWsoKS50eXBlKXtzdGF0ZS5vcHRpb24uaW5FU05leHQoKXx8d2FybmluZyhcXFwiVzExOVxcXCIsc3RhdGUudG9rZW5zLmN1cnIsXFxcIm1vZHVsZVxcXCIpLGFkdmFuY2UoXFxcIm1vZHVsZVxcXCIpO3ZhciBuYW1lPWlkZW50aWZpZXIoKTtyZXR1cm4gYWRkbGFiZWwobmFtZSx7dHlwZTpcXFwidW51c2VkXFxcIix0b2tlbjpzdGF0ZS50b2tlbnMuY3Vycn0pLGFkdmFuY2UoXFxcImZyb21cXFwiKSxhZHZhbmNlKFxcXCIoc3RyaW5nKVxcXCIpLHBhcnNlRmluYWxTZW1pY29sb24oKSx2b2lkIDB9aWYoXy5oYXMoW1xcXCJbXFxcIixcXFwie1xcXCJdLHQudmFsdWUpJiZsb29rdXBCbG9ja1R5cGUoKS5pc0Rlc3RBc3NpZ24pcmV0dXJuIHN0YXRlLm9wdGlvbi5pbkVTTmV4dCgpfHx3YXJuaW5nKFxcXCJXMTA0XFxcIixzdGF0ZS50b2tlbnMuY3VycixcXFwiZGVzdHJ1Y3R1cmluZyBleHByZXNzaW9uXFxcIiksdmFsdWVzPWRlc3RydWN0dXJpbmdFeHByZXNzaW9uKCksdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odG9rKXtpc3VuZGVmKGZ1bmN0LFxcXCJXMTE3XFxcIix0b2sudG9rZW4sdG9rLmlkKX0pLGFkdmFuY2UoXFxcIj1cXFwiKSxkZXN0cnVjdHVyaW5nRXhwcmVzc2lvbk1hdGNoKHZhbHVlcyxleHByZXNzaW9uKDEwLCEwKSksYWR2YW5jZShcXFwiO1xcXCIpLHZvaWQgMDtpZih0LmlkZW50aWZpZXImJiFyZXMmJlxcXCI6XFxcIj09PXBlZWsoKS5pZCYmKGFkdmFuY2UoKSxhZHZhbmNlKFxcXCI6XFxcIiksc2NvcGU9T2JqZWN0LmNyZWF0ZShzKSxhZGRsYWJlbCh0LnZhbHVlLHt0eXBlOlxcXCJsYWJlbFxcXCJ9KSxzdGF0ZS50b2tlbnMubmV4dC5sYWJlbGxlZHx8XFxcIntcXFwiPT09c3RhdGUudG9rZW5zLm5leHQudmFsdWV8fHdhcm5pbmcoXFxcIlcwMjhcXFwiLHN0YXRlLnRva2Vucy5uZXh0LHQudmFsdWUsc3RhdGUudG9rZW5zLm5leHQudmFsdWUpLHN0YXRlLnRva2Vucy5uZXh0LmxhYmVsPXQudmFsdWUsdD1zdGF0ZS50b2tlbnMubmV4dCksXFxcIntcXFwiPT09dC5pZCl7dmFyIGlzY2FzZT1cXFwiY2FzZVxcXCI9PT1mdW5jdFtcXFwiKHZlcmIpXFxcIl0mJlxcXCI6XFxcIj09PXN0YXRlLnRva2Vucy5jdXJyLnZhbHVlO3JldHVybiBibG9jayghMCwhMCwhMSwhMSxpc2Nhc2UpLHZvaWQgMH1yZXR1cm4gcj1leHByZXNzaW9uKDAsITApLCFyfHxyLmlkZW50aWZpZXImJlxcXCJmdW5jdGlvblxcXCI9PT1yLnZhbHVlfHxcXFwiKHB1bmN0dWF0b3IpXFxcIj09PXIudHlwZXx8IXN0YXRlLmRpcmVjdGl2ZVtcXFwidXNlIHN0cmljdFxcXCJdJiZzdGF0ZS5vcHRpb24uZ2xvYmFsc3RyaWN0JiZzdGF0ZS5vcHRpb24uc3RyaWN0JiZ3YXJuaW5nKFxcXCJFMDA3XFxcIiksdC5ibG9ja3x8KHN0YXRlLm9wdGlvbi5leHByfHxyJiZyLmV4cHM/c3RhdGUub3B0aW9uLm5vbmV3JiZyJiZyLmxlZnQmJlxcXCIoXFxcIj09PXIuaWQmJlxcXCJuZXdcXFwiPT09ci5sZWZ0LmlkJiZ3YXJuaW5nKFxcXCJXMDMxXFxcIix0KTp3YXJuaW5nKFxcXCJXMDMwXFxcIixzdGF0ZS50b2tlbnMuY3VycikscGFyc2VGaW5hbFNlbWljb2xvbigpKSxpbmRlbnQ9aSxzY29wZT1zLHJ9ZnVuY3Rpb24gc3RhdGVtZW50cyhzdGFydExpbmUpe2Zvcih2YXIgcCxhPVtdOyFzdGF0ZS50b2tlbnMubmV4dC5yZWFjaCYmXFxcIihlbmQpXFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LmlkOylcXFwiO1xcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZD8ocD1wZWVrKCksKCFwfHxcXFwiKFxcXCIhPT1wLmlkJiZcXFwiW1xcXCIhPT1wLmlkKSYmd2FybmluZyhcXFwiVzAzMlxcXCIpLGFkdmFuY2UoXFxcIjtcXFwiKSk6YS5wdXNoKHN0YXRlbWVudChzdGFydExpbmU9PT1zdGF0ZS50b2tlbnMubmV4dC5saW5lKSk7cmV0dXJuIGF9ZnVuY3Rpb24gZGlyZWN0aXZlcygpe2Zvcih2YXIgaSxwLHBuO1xcXCIoc3RyaW5nKVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZDspe2lmKHA9cGVlaygwKSxcXFwiKGVuZGxpbmUpXFxcIj09PXAuaWQpe2k9MTtkbyBwbj1wZWVrKGkpLGkrPTE7d2hpbGUoXFxcIihlbmRsaW5lKVxcXCI9PT1wbi5pZCk7aWYoXFxcIjtcXFwiIT09cG4uaWQpe2lmKFxcXCIoc3RyaW5nKVxcXCIhPT1wbi5pZCYmXFxcIihudW1iZXIpXFxcIiE9PXBuLmlkJiZcXFwiKHJlZ2V4cClcXFwiIT09cG4uaWQmJnBuLmlkZW50aWZpZXIhPT0hMCYmXFxcIn1cXFwiIT09cG4uaWQpYnJlYWs7d2FybmluZyhcXFwiVzAzM1xcXCIsc3RhdGUudG9rZW5zLm5leHQpfWVsc2UgcD1wbn1lbHNlIGlmKFxcXCJ9XFxcIj09PXAuaWQpd2FybmluZyhcXFwiVzAzM1xcXCIscCk7ZWxzZSBpZihcXFwiO1xcXCIhPT1wLmlkKWJyZWFrO2FkdmFuY2UoKSxzdGF0ZS5kaXJlY3RpdmVbc3RhdGUudG9rZW5zLmN1cnIudmFsdWVdJiZ3YXJuaW5nKFxcXCJXMDM0XFxcIixzdGF0ZS50b2tlbnMuY3VycixzdGF0ZS50b2tlbnMuY3Vyci52YWx1ZSksXFxcInVzZSBzdHJpY3RcXFwiPT09c3RhdGUudG9rZW5zLmN1cnIudmFsdWUmJihzdGF0ZS5vcHRpb25bXFxcIihleHBsaWNpdE5ld2NhcClcXFwiXXx8KHN0YXRlLm9wdGlvbi5uZXdjYXA9ITApLHN0YXRlLm9wdGlvbi51bmRlZj0hMCksc3RhdGUuZGlyZWN0aXZlW3N0YXRlLnRva2Vucy5jdXJyLnZhbHVlXT0hMCxcXFwiO1xcXCI9PT1wLmlkJiZhZHZhbmNlKFxcXCI7XFxcIil9fWZ1bmN0aW9uIGJsb2NrKG9yZGluYXJ5LHN0bXQsaXNmdW5jLGlzZmF0YXJyb3csaXNjYXNlKXt2YXIgYSxtLHQsbGluZSxkLGI9aW5ibG9jayxvbGRfaW5kZW50PWluZGVudCxzPXNjb3BlO2luYmxvY2s9b3JkaW5hcnksb3JkaW5hcnkmJnN0YXRlLm9wdGlvbi5mdW5jc2NvcGV8fChzY29wZT1PYmplY3QuY3JlYXRlKHNjb3BlKSksdD1zdGF0ZS50b2tlbnMubmV4dDt2YXIgbWV0cmljcz1mdW5jdFtcXFwiKG1ldHJpY3MpXFxcIl07aWYobWV0cmljcy5uZXN0ZWRCbG9ja0RlcHRoKz0xLG1ldHJpY3MudmVyaWZ5TWF4TmVzdGVkQmxvY2tEZXB0aFBlckZ1bmN0aW9uKCksXFxcIntcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQpe2lmKGFkdmFuY2UoXFxcIntcXFwiKSxmdW5jdFtcXFwiKGJsb2Nrc2NvcGUpXFxcIl0uc3RhY2soKSxsaW5lPXN0YXRlLnRva2Vucy5jdXJyLmxpbmUsXFxcIn1cXFwiIT09c3RhdGUudG9rZW5zLm5leHQuaWQpe2ZvcihpbmRlbnQrPXN0YXRlLm9wdGlvbi5pbmRlbnQ7IW9yZGluYXJ5JiZzdGF0ZS50b2tlbnMubmV4dC5mcm9tPmluZGVudDspaW5kZW50Kz1zdGF0ZS5vcHRpb24uaW5kZW50O2lmKGlzZnVuYyl7bT17fTtmb3IoZCBpbiBzdGF0ZS5kaXJlY3RpdmUpXy5oYXMoc3RhdGUuZGlyZWN0aXZlLGQpJiYobVtkXT1zdGF0ZS5kaXJlY3RpdmVbZF0pO2RpcmVjdGl2ZXMoKSxzdGF0ZS5vcHRpb24uc3RyaWN0JiZmdW5jdFtcXFwiKGNvbnRleHQpXFxcIl1bXFxcIihnbG9iYWwpXFxcIl0mJihtW1xcXCJ1c2Ugc3RyaWN0XFxcIl18fHN0YXRlLmRpcmVjdGl2ZVtcXFwidXNlIHN0cmljdFxcXCJdfHx3YXJuaW5nKFxcXCJFMDA3XFxcIikpfWE9c3RhdGVtZW50cyhsaW5lKSxtZXRyaWNzLnN0YXRlbWVudENvdW50Kz1hLmxlbmd0aCxpc2Z1bmMmJihzdGF0ZS5kaXJlY3RpdmU9bSksaW5kZW50LT1zdGF0ZS5vcHRpb24uaW5kZW50fWFkdmFuY2UoXFxcIn1cXFwiLHQpLGZ1bmN0W1xcXCIoYmxvY2tzY29wZSlcXFwiXS51bnN0YWNrKCksaW5kZW50PW9sZF9pbmRlbnR9ZWxzZSBpZihvcmRpbmFyeSlmdW5jdFtcXFwiKG5vbGV0KVxcXCJdPSEwLCghc3RtdHx8c3RhdGUub3B0aW9uLmN1cmx5KSYmd2FybmluZyhcXFwiVzExNlxcXCIsc3RhdGUudG9rZW5zLm5leHQsXFxcIntcXFwiLHN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKSxub3JlYWNoPSEwLGluZGVudCs9c3RhdGUub3B0aW9uLmluZGVudCxhPVtzdGF0ZW1lbnQoKV0saW5kZW50LT1zdGF0ZS5vcHRpb24uaW5kZW50LG5vcmVhY2g9ITEsZGVsZXRlIGZ1bmN0W1xcXCIobm9sZXQpXFxcIl07ZWxzZSBpZihpc2Z1bmMpe2lmKG09e30sIXN0bXR8fGlzZmF0YXJyb3d8fHN0YXRlLm9wdGlvbi5pbk1veighMCl8fGVycm9yKFxcXCJXMTE4XFxcIixzdGF0ZS50b2tlbnMuY3VycixcXFwiZnVuY3Rpb24gY2xvc3VyZSBleHByZXNzaW9uc1xcXCIpLCFzdG10KWZvcihkIGluIHN0YXRlLmRpcmVjdGl2ZSlfLmhhcyhzdGF0ZS5kaXJlY3RpdmUsZCkmJihtW2RdPXN0YXRlLmRpcmVjdGl2ZVtkXSk7ZXhwcmVzc2lvbigxMCksc3RhdGUub3B0aW9uLnN0cmljdCYmZnVuY3RbXFxcIihjb250ZXh0KVxcXCJdW1xcXCIoZ2xvYmFsKVxcXCJdJiYobVtcXFwidXNlIHN0cmljdFxcXCJdfHxzdGF0ZS5kaXJlY3RpdmVbXFxcInVzZSBzdHJpY3RcXFwiXXx8d2FybmluZyhcXFwiRTAwN1xcXCIpKX1lbHNlIGVycm9yKFxcXCJFMDIxXFxcIixzdGF0ZS50b2tlbnMubmV4dCxcXFwie1xcXCIsc3RhdGUudG9rZW5zLm5leHQudmFsdWUpO3N3aXRjaChmdW5jdFtcXFwiKHZlcmIpXFxcIl0pe2Nhc2VcXFwiYnJlYWtcXFwiOmNhc2VcXFwiY29udGludWVcXFwiOmNhc2VcXFwicmV0dXJuXFxcIjpjYXNlXFxcInRocm93XFxcIjppZihpc2Nhc2UpYnJlYWs7ZGVmYXVsdDpmdW5jdFtcXFwiKHZlcmIpXFxcIl09bnVsbH1yZXR1cm4gb3JkaW5hcnkmJnN0YXRlLm9wdGlvbi5mdW5jc2NvcGV8fChzY29wZT1zKSxpbmJsb2NrPWIsIW9yZGluYXJ5fHwhc3RhdGUub3B0aW9uLm5vZW1wdHl8fGEmJjAhPT1hLmxlbmd0aHx8d2FybmluZyhcXFwiVzAzNVxcXCIpLG1ldHJpY3MubmVzdGVkQmxvY2tEZXB0aC09MSxhfWZ1bmN0aW9uIGNvdW50TWVtYmVyKG0pe21lbWJlcnNPbmx5JiZcXFwiYm9vbGVhblxcXCIhPXR5cGVvZiBtZW1iZXJzT25seVttXSYmd2FybmluZyhcXFwiVzAzNlxcXCIsc3RhdGUudG9rZW5zLmN1cnIsbSksXFxcIm51bWJlclxcXCI9PXR5cGVvZiBtZW1iZXJbbV0/bWVtYmVyW21dKz0xOm1lbWJlclttXT0xfWZ1bmN0aW9uIG5vdGVfaW1wbGllZCh0a24pe3ZhciBuYW1lPXRrbi52YWx1ZSxkZXNjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaW1wbGllZCxuYW1lKTtkZXNjP2Rlc2MudmFsdWUucHVzaCh0a24ubGluZSk6aW1wbGllZFtuYW1lXT1bdGtuLmxpbmVdfWZ1bmN0aW9uIGNvbXByZWhlbnNpdmVBcnJheUV4cHJlc3Npb24oKXt2YXIgcmVzPXt9O3Jlcy5leHBzPSEwLGZ1bmN0W1xcXCIoY29tcGFycmF5KVxcXCJdLnN0YWNrKCk7dmFyIHJldmVyc2VkPSExO3JldHVyblxcXCJmb3JcXFwiIT09c3RhdGUudG9rZW5zLm5leHQudmFsdWUmJihyZXZlcnNlZD0hMCxzdGF0ZS5vcHRpb24uaW5Nb3ooITApfHx3YXJuaW5nKFxcXCJXMTE2XFxcIixzdGF0ZS50b2tlbnMubmV4dCxcXFwiZm9yXFxcIixzdGF0ZS50b2tlbnMubmV4dC52YWx1ZSksZnVuY3RbXFxcIihjb21wYXJyYXkpXFxcIl0uc2V0U3RhdGUoXFxcInVzZVxcXCIpLHJlcy5yaWdodD1leHByZXNzaW9uKDEwKSksYWR2YW5jZShcXFwiZm9yXFxcIiksXFxcImVhY2hcXFwiPT09c3RhdGUudG9rZW5zLm5leHQudmFsdWUmJihhZHZhbmNlKFxcXCJlYWNoXFxcIiksc3RhdGUub3B0aW9uLmluTW96KCEwKXx8d2FybmluZyhcXFwiVzExOFxcXCIsc3RhdGUudG9rZW5zLmN1cnIsXFxcImZvciBlYWNoXFxcIikpLGFkdmFuY2UoXFxcIihcXFwiKSxmdW5jdFtcXFwiKGNvbXBhcnJheSlcXFwiXS5zZXRTdGF0ZShcXFwiZGVmaW5lXFxcIikscmVzLmxlZnQ9ZXhwcmVzc2lvbigxMzApLF8uY29udGFpbnMoW1xcXCJpblxcXCIsXFxcIm9mXFxcIl0sc3RhdGUudG9rZW5zLm5leHQudmFsdWUpP2FkdmFuY2UoKTplcnJvcihcXFwiRTA0NVxcXCIsc3RhdGUudG9rZW5zLmN1cnIpLGZ1bmN0W1xcXCIoY29tcGFycmF5KVxcXCJdLnNldFN0YXRlKFxcXCJnZW5lcmF0ZVxcXCIpLGV4cHJlc3Npb24oMTApLGFkdmFuY2UoXFxcIilcXFwiKSxcXFwiaWZcXFwiPT09c3RhdGUudG9rZW5zLm5leHQudmFsdWUmJihhZHZhbmNlKFxcXCJpZlxcXCIpLGFkdmFuY2UoXFxcIihcXFwiKSxmdW5jdFtcXFwiKGNvbXBhcnJheSlcXFwiXS5zZXRTdGF0ZShcXFwiZmlsdGVyXFxcIikscmVzLmZpbHRlcj1leHByZXNzaW9uKDEwKSxhZHZhbmNlKFxcXCIpXFxcIikpLHJldmVyc2VkfHwoZnVuY3RbXFxcIihjb21wYXJyYXkpXFxcIl0uc2V0U3RhdGUoXFxcInVzZVxcXCIpLHJlcy5yaWdodD1leHByZXNzaW9uKDEwKSksYWR2YW5jZShcXFwiXVxcXCIpLGZ1bmN0W1xcXCIoY29tcGFycmF5KVxcXCJdLnVuc3RhY2soKSxyZXN9ZnVuY3Rpb24gcHJvcGVydHlfbmFtZSgpe3ZhciBpZD1vcHRpb25hbGlkZW50aWZpZXIoITEsITApO3JldHVybiBpZHx8KFxcXCIoc3RyaW5nKVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZD8oaWQ9c3RhdGUudG9rZW5zLm5leHQudmFsdWUsYWR2YW5jZSgpKTpcXFwiKG51bWJlcilcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQmJihpZD1cXFwiXFxcIitzdGF0ZS50b2tlbnMubmV4dC52YWx1ZSxhZHZhbmNlKCkpKSxcXFwiaGFzT3duUHJvcGVydHlcXFwiPT09aWQmJndhcm5pbmcoXFxcIlcwMDFcXFwiKSxpZH1mdW5jdGlvbiBmdW5jdGlvbnBhcmFtcyhwYXJzZWQpe3ZhciBjdXJyLG5leHQsaWRlbnQsdCxwYXJhbXM9W10sdG9rZW5zPVtdLHBhc3REZWZhdWx0PSExO2lmKHBhcnNlZCl7aWYoQXJyYXkuaXNBcnJheShwYXJzZWQpKXtmb3IodmFyIGkgaW4gcGFyc2VkKWN1cnI9cGFyc2VkW2ldLFxcXCIuLi5cXFwiIT09Y3Vyci52YWx1ZT9cXFwiLFxcXCIhPT1jdXJyLnZhbHVlJiYocGFyYW1zLnB1c2goY3Vyci52YWx1ZSksYWRkbGFiZWwoY3Vyci52YWx1ZSx7dHlwZTpcXFwidW51c2VkXFxcIix0b2tlbjpjdXJyfSkpOnN0YXRlLm9wdGlvbi5pbkVTTmV4dCgpfHx3YXJuaW5nKFxcXCJXMTA0XFxcIixjdXJyLFxcXCJzcHJlYWQvcmVzdCBvcGVyYXRvclxcXCIpO3JldHVybiBwYXJhbXN9aWYocGFyc2VkLmlkZW50aWZpZXI9PT0hMClyZXR1cm4gYWRkbGFiZWwocGFyc2VkLnZhbHVlLHt0eXBlOlxcXCJ1bnVzZWRcXFwiLHRva2VuOnBhcnNlZH0pLFtwYXJzZWRdfWlmKG5leHQ9c3RhdGUudG9rZW5zLm5leHQsYWR2YW5jZShcXFwiKFxcXCIpLFxcXCIpXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkKXJldHVybiBhZHZhbmNlKFxcXCIpXFxcIiksdm9pZCAwO2Zvcig7Oyl7aWYoXy5jb250YWlucyhbXFxcIntcXFwiLFxcXCJbXFxcIl0sc3RhdGUudG9rZW5zLm5leHQuaWQpKXt0b2tlbnM9ZGVzdHJ1Y3R1cmluZ0V4cHJlc3Npb24oKTtmb3IodCBpbiB0b2tlbnMpdD10b2tlbnNbdF0sdC5pZCYmKHBhcmFtcy5wdXNoKHQuaWQpLGFkZGxhYmVsKHQuaWQse3R5cGU6XFxcInVudXNlZFxcXCIsdG9rZW46dC50b2tlbn0pKX1lbHNlXFxcIi4uLlxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC52YWx1ZT8oc3RhdGUub3B0aW9uLmluRVNOZXh0KCl8fHdhcm5pbmcoXFxcIlcxMDRcXFwiLHN0YXRlLnRva2Vucy5uZXh0LFxcXCJzcHJlYWQvcmVzdCBvcGVyYXRvclxcXCIpLGFkdmFuY2UoXFxcIi4uLlxcXCIpLGlkZW50PWlkZW50aWZpZXIoITApLHBhcmFtcy5wdXNoKGlkZW50KSxhZGRsYWJlbChpZGVudCx7dHlwZTpcXFwidW51c2VkXFxcIix0b2tlbjpzdGF0ZS50b2tlbnMuY3Vycn0pKTooaWRlbnQ9aWRlbnRpZmllcighMCkscGFyYW1zLnB1c2goaWRlbnQpLGFkZGxhYmVsKGlkZW50LHt0eXBlOlxcXCJ1bnVzZWRcXFwiLHRva2VuOnN0YXRlLnRva2Vucy5jdXJyfSkpO2lmKHBhc3REZWZhdWx0JiZcXFwiPVxcXCIhPT1zdGF0ZS50b2tlbnMubmV4dC5pZCYmZXJyb3IoXFxcIkUwNTFcXFwiLHN0YXRlLnRva2Vucy5jdXJyZW50KSxcXFwiPVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZCYmKHN0YXRlLm9wdGlvbi5pbkVTTmV4dCgpfHx3YXJuaW5nKFxcXCJXMTE5XFxcIixzdGF0ZS50b2tlbnMubmV4dCxcXFwiZGVmYXVsdCBwYXJhbWV0ZXJzXFxcIiksYWR2YW5jZShcXFwiPVxcXCIpLHBhc3REZWZhdWx0PSEwLGV4cHJlc3Npb24oMTApKSxcXFwiLFxcXCIhPT1zdGF0ZS50b2tlbnMubmV4dC5pZClyZXR1cm4gYWR2YW5jZShcXFwiKVxcXCIsbmV4dCkscGFyYW1zO2NvbW1hKCl9fWZ1bmN0aW9uIHNldHByb3AoZnVuY3QsbmFtZSx2YWx1ZXMpe2Z1bmN0W1xcXCIocHJvcGVydGllcylcXFwiXVtuYW1lXXx8KGZ1bmN0W1xcXCIocHJvcGVydGllcylcXFwiXVtuYW1lXT17dW51c2VkOiExfSksXy5leHRlbmQoZnVuY3RbXFxcIihwcm9wZXJ0aWVzKVxcXCJdW25hbWVdLHZhbHVlcyl9ZnVuY3Rpb24gZ2V0cHJvcChmdW5jdCxuYW1lLHByb3Ape3JldHVybiBmdW5jdFtcXFwiKHByb3BlcnRpZXMpXFxcIl1bbmFtZV0/ZnVuY3RbXFxcIihwcm9wZXJ0aWVzKVxcXCJdW25hbWVdW3Byb3BdfHxudWxsOm51bGx9ZnVuY3Rpb24gZnVuY3RvcihuYW1lLHRva2VuLHNjb3BlLG92ZXJ3cml0ZXMpe3ZhciBmdW5jdD17XFxcIihuYW1lKVxcXCI6bmFtZSxcXFwiKGJyZWFrYWdlKVxcXCI6MCxcXFwiKGxvb3BhZ2UpXFxcIjowLFxcXCIoc2NvcGUpXFxcIjpzY29wZSxcXFwiKHRva2VucylcXFwiOnt9LFxcXCIocHJvcGVydGllcylcXFwiOnt9LFxcXCIoY2F0Y2gpXFxcIjohMSxcXFwiKGdsb2JhbClcXFwiOiExLFxcXCIobGluZSlcXFwiOm51bGwsXFxcIihjaGFyYWN0ZXIpXFxcIjpudWxsLFxcXCIobWV0cmljcylcXFwiOm51bGwsXFxcIihzdGF0ZW1lbnQpXFxcIjpudWxsLFxcXCIoY29udGV4dClcXFwiOm51bGwsXFxcIihibG9ja3Njb3BlKVxcXCI6bnVsbCxcXFwiKGNvbXBhcnJheSlcXFwiOm51bGwsXFxcIihnZW5lcmF0b3IpXFxcIjpudWxsLFxcXCIocGFyYW1zKVxcXCI6bnVsbH07cmV0dXJuIHRva2VuJiZfLmV4dGVuZChmdW5jdCx7XFxcIihsaW5lKVxcXCI6dG9rZW4ubGluZSxcXFwiKGNoYXJhY3RlcilcXFwiOnRva2VuLmNoYXJhY3RlcixcXFwiKG1ldHJpY3MpXFxcIjpjcmVhdGVNZXRyaWNzKHRva2VuKX0pLF8uZXh0ZW5kKGZ1bmN0LG92ZXJ3cml0ZXMpLGZ1bmN0W1xcXCIoY29udGV4dClcXFwiXSYmKGZ1bmN0W1xcXCIoYmxvY2tzY29wZSlcXFwiXT1mdW5jdFtcXFwiKGNvbnRleHQpXFxcIl1bXFxcIihibG9ja3Njb3BlKVxcXCJdLGZ1bmN0W1xcXCIoY29tcGFycmF5KVxcXCJdPWZ1bmN0W1xcXCIoY29udGV4dClcXFwiXVtcXFwiKGNvbXBhcnJheSlcXFwiXSksZnVuY3R9ZnVuY3Rpb24gZG9GdW5jdGlvbihuYW1lLHN0YXRlbWVudCxnZW5lcmF0b3IsZmF0YXJyb3dwYXJhbXMpe3ZhciBmLG9sZE9wdGlvbj1zdGF0ZS5vcHRpb24sb2xkSWdub3JlZD1zdGF0ZS5pZ25vcmVkLG9sZFNjb3BlPXNjb3BlO3JldHVybiBzdGF0ZS5vcHRpb249T2JqZWN0LmNyZWF0ZShzdGF0ZS5vcHRpb24pLHN0YXRlLmlnbm9yZWQ9T2JqZWN0LmNyZWF0ZShzdGF0ZS5pZ25vcmVkKSxzY29wZT1PYmplY3QuY3JlYXRlKHNjb3BlKSxmdW5jdD1mdW5jdG9yKG5hbWV8fCdcXFwiJythbm9ubmFtZSsnXFxcIicsc3RhdGUudG9rZW5zLm5leHQsc2NvcGUse1xcXCIoc3RhdGVtZW50KVxcXCI6c3RhdGVtZW50LFxcXCIoY29udGV4dClcXFwiOmZ1bmN0LFxcXCIoZ2VuZXJhdG9yKVxcXCI6Z2VuZXJhdG9yPyEwOm51bGx9KSxmPWZ1bmN0LHN0YXRlLnRva2Vucy5jdXJyLmZ1bmN0PWZ1bmN0LGZ1bmN0aW9ucy5wdXNoKGZ1bmN0KSxuYW1lJiZhZGRsYWJlbChuYW1lLHt0eXBlOlxcXCJmdW5jdGlvblxcXCJ9KSxmdW5jdFtcXFwiKHBhcmFtcylcXFwiXT1mdW5jdGlvbnBhcmFtcyhmYXRhcnJvd3BhcmFtcyksZnVuY3RbXFxcIihtZXRyaWNzKVxcXCJdLnZlcmlmeU1heFBhcmFtZXRlcnNQZXJGdW5jdGlvbihmdW5jdFtcXFwiKHBhcmFtcylcXFwiXSksSlNISU5ULnVuZGVmcz1fLmZpbHRlcihKU0hJTlQudW5kZWZzLGZ1bmN0aW9uKGl0ZW0pe3JldHVybiFfLmNvbnRhaW5zKF8udW5pb24oZmF0YXJyb3dwYXJhbXMpLGl0ZW1bMl0pfSksYmxvY2soITEsITAsITAsZmF0YXJyb3dwYXJhbXM/ITA6ITEpLCFzdGF0ZS5vcHRpb24ubm95aWVsZCYmZ2VuZXJhdG9yJiZcXFwieWllbGRlZFxcXCIhPT1mdW5jdFtcXFwiKGdlbmVyYXRvcilcXFwiXSYmd2FybmluZyhcXFwiVzEyNFxcXCIsc3RhdGUudG9rZW5zLmN1cnIpLGZ1bmN0W1xcXCIobWV0cmljcylcXFwiXS52ZXJpZnlNYXhTdGF0ZW1lbnRzUGVyRnVuY3Rpb24oKSxmdW5jdFtcXFwiKG1ldHJpY3MpXFxcIl0udmVyaWZ5TWF4Q29tcGxleGl0eVBlckZ1bmN0aW9uKCksZnVuY3RbXFxcIih1bnVzZWRPcHRpb24pXFxcIl09c3RhdGUub3B0aW9uLnVudXNlZCxzY29wZT1vbGRTY29wZSxzdGF0ZS5vcHRpb249b2xkT3B0aW9uLHN0YXRlLmlnbm9yZWQ9b2xkSWdub3JlZCxmdW5jdFtcXFwiKGxhc3QpXFxcIl09c3RhdGUudG9rZW5zLmN1cnIubGluZSxmdW5jdFtcXFwiKGxhc3RjaGFyYWN0ZXIpXFxcIl09c3RhdGUudG9rZW5zLmN1cnIuY2hhcmFjdGVyLF8ubWFwKE9iamVjdC5rZXlzKGZ1bmN0KSxmdW5jdGlvbihrZXkpe1xcXCIoXFxcIiE9PWtleVswXSYmZnVuY3RbXFxcIihibG9ja3Njb3BlKVxcXCJdLnVuc2hhZG93KGtleSl9KSxmdW5jdD1mdW5jdFtcXFwiKGNvbnRleHQpXFxcIl0sZn1mdW5jdGlvbiBjcmVhdGVNZXRyaWNzKGZ1bmN0aW9uU3RhcnRUb2tlbil7cmV0dXJue3N0YXRlbWVudENvdW50OjAsbmVzdGVkQmxvY2tEZXB0aDotMSxDb21wbGV4aXR5Q291bnQ6MSx2ZXJpZnlNYXhTdGF0ZW1lbnRzUGVyRnVuY3Rpb246ZnVuY3Rpb24oKXtzdGF0ZS5vcHRpb24ubWF4c3RhdGVtZW50cyYmdGhpcy5zdGF0ZW1lbnRDb3VudD5zdGF0ZS5vcHRpb24ubWF4c3RhdGVtZW50cyYmd2FybmluZyhcXFwiVzA3MVxcXCIsZnVuY3Rpb25TdGFydFRva2VuLHRoaXMuc3RhdGVtZW50Q291bnQpfSx2ZXJpZnlNYXhQYXJhbWV0ZXJzUGVyRnVuY3Rpb246ZnVuY3Rpb24ocGFyYW1zKXtwYXJhbXM9cGFyYW1zfHxbXSxzdGF0ZS5vcHRpb24ubWF4cGFyYW1zJiZwYXJhbXMubGVuZ3RoPnN0YXRlLm9wdGlvbi5tYXhwYXJhbXMmJndhcm5pbmcoXFxcIlcwNzJcXFwiLGZ1bmN0aW9uU3RhcnRUb2tlbixwYXJhbXMubGVuZ3RoKX0sdmVyaWZ5TWF4TmVzdGVkQmxvY2tEZXB0aFBlckZ1bmN0aW9uOmZ1bmN0aW9uKCl7c3RhdGUub3B0aW9uLm1heGRlcHRoJiZ0aGlzLm5lc3RlZEJsb2NrRGVwdGg+MCYmdGhpcy5uZXN0ZWRCbG9ja0RlcHRoPT09c3RhdGUub3B0aW9uLm1heGRlcHRoKzEmJndhcm5pbmcoXFxcIlcwNzNcXFwiLG51bGwsdGhpcy5uZXN0ZWRCbG9ja0RlcHRoKX0sdmVyaWZ5TWF4Q29tcGxleGl0eVBlckZ1bmN0aW9uOmZ1bmN0aW9uKCl7dmFyIG1heD1zdGF0ZS5vcHRpb24ubWF4Y29tcGxleGl0eSxjYz10aGlzLkNvbXBsZXhpdHlDb3VudDttYXgmJmNjPm1heCYmd2FybmluZyhcXFwiVzA3NFxcXCIsZnVuY3Rpb25TdGFydFRva2VuLGNjKX19fWZ1bmN0aW9uIGluY3JlYXNlQ29tcGxleGl0eUNvdW50KCl7ZnVuY3RbXFxcIihtZXRyaWNzKVxcXCJdLkNvbXBsZXhpdHlDb3VudCs9MX1mdW5jdGlvbiBjaGVja0NvbmRBc3NpZ25tZW50KGV4cHIpe3ZhciBpZCxwYXJlbjtzd2l0Y2goZXhwciYmKGlkPWV4cHIuaWQscGFyZW49ZXhwci5wYXJlbixcXFwiLFxcXCI9PT1pZCYmKGV4cHI9ZXhwci5leHByc1tleHByLmV4cHJzLmxlbmd0aC0xXSkmJihpZD1leHByLmlkLHBhcmVuPXBhcmVufHxleHByLnBhcmVuKSksaWQpe2Nhc2VcXFwiPVxcXCI6Y2FzZVxcXCIrPVxcXCI6Y2FzZVxcXCItPVxcXCI6Y2FzZVxcXCIqPVxcXCI6Y2FzZVxcXCIlPVxcXCI6Y2FzZVxcXCImPVxcXCI6Y2FzZVxcXCJ8PVxcXCI6Y2FzZVxcXCJePVxcXCI6Y2FzZVxcXCIvPVxcXCI6cGFyZW58fHN0YXRlLm9wdGlvbi5ib3NzfHx3YXJuaW5nKFxcXCJXMDg0XFxcIil9fWZ1bmN0aW9uIGRlc3RydWN0dXJpbmdFeHByZXNzaW9uKCl7dmFyIGlkLGlkcyxpZGVudGlmaWVycz1bXTtzdGF0ZS5vcHRpb24uaW5FU05leHQoKXx8d2FybmluZyhcXFwiVzEwNFxcXCIsc3RhdGUudG9rZW5zLmN1cnIsXFxcImRlc3RydWN0dXJpbmcgZXhwcmVzc2lvblxcXCIpO3ZhciBuZXh0SW5uZXJERT1mdW5jdGlvbigpe3ZhciBpZGVudDtpZihfLmNvbnRhaW5zKFtcXFwiW1xcXCIsXFxcIntcXFwiXSxzdGF0ZS50b2tlbnMubmV4dC52YWx1ZSkpe2lkcz1kZXN0cnVjdHVyaW5nRXhwcmVzc2lvbigpO2Zvcih2YXIgaWQgaW4gaWRzKWlkPWlkc1tpZF0saWRlbnRpZmllcnMucHVzaCh7aWQ6aWQuaWQsdG9rZW46aWQudG9rZW59KX1lbHNlXFxcIixcXFwiPT09c3RhdGUudG9rZW5zLm5leHQudmFsdWU/aWRlbnRpZmllcnMucHVzaCh7aWQ6bnVsbCx0b2tlbjpzdGF0ZS50b2tlbnMuY3Vycn0pOlxcXCIoXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlPyhhZHZhbmNlKFxcXCIoXFxcIiksbmV4dElubmVyREUoKSxhZHZhbmNlKFxcXCIpXFxcIikpOihpZGVudD1pZGVudGlmaWVyKCksaWRlbnQmJmlkZW50aWZpZXJzLnB1c2goe2lkOmlkZW50LHRva2VuOnN0YXRlLnRva2Vucy5jdXJyfSkpfTtpZihcXFwiW1xcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC52YWx1ZSl7Zm9yKGFkdmFuY2UoXFxcIltcXFwiKSxuZXh0SW5uZXJERSgpO1xcXCJdXFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlOylhZHZhbmNlKFxcXCIsXFxcIiksbmV4dElubmVyREUoKTthZHZhbmNlKFxcXCJdXFxcIil9ZWxzZSBpZihcXFwie1xcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC52YWx1ZSl7Zm9yKGFkdmFuY2UoXFxcIntcXFwiKSxpZD1pZGVudGlmaWVyKCksXFxcIjpcXFwiPT09c3RhdGUudG9rZW5zLm5leHQudmFsdWU/KGFkdmFuY2UoXFxcIjpcXFwiKSxuZXh0SW5uZXJERSgpKTppZGVudGlmaWVycy5wdXNoKHtpZDppZCx0b2tlbjpzdGF0ZS50b2tlbnMuY3Vycn0pO1xcXCJ9XFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlOylhZHZhbmNlKFxcXCIsXFxcIiksaWQ9aWRlbnRpZmllcigpLFxcXCI6XFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlPyhhZHZhbmNlKFxcXCI6XFxcIiksbmV4dElubmVyREUoKSk6aWRlbnRpZmllcnMucHVzaCh7aWQ6aWQsdG9rZW46c3RhdGUudG9rZW5zLmN1cnJ9KTthZHZhbmNlKFxcXCJ9XFxcIil9cmV0dXJuIGlkZW50aWZpZXJzfWZ1bmN0aW9uIGRlc3RydWN0dXJpbmdFeHByZXNzaW9uTWF0Y2godG9rZW5zLHZhbHVlKXt2YXIgZmlyc3Q9dmFsdWUuZmlyc3Q7Zmlyc3QmJl8uemlwKHRva2VucyxBcnJheS5pc0FycmF5KGZpcnN0KT9maXJzdDpbZmlyc3RdKS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCl7dmFyIHRva2VuPXZhbFswXSx2YWx1ZT12YWxbMV07dG9rZW4mJnZhbHVlP3Rva2VuLmZpcnN0PXZhbHVlOnRva2VuJiZ0b2tlbi5maXJzdCYmIXZhbHVlJiZ3YXJuaW5nKFxcXCJXMDgwXFxcIix0b2tlbi5maXJzdCx0b2tlbi5maXJzdC52YWx1ZSl9KX1mdW5jdGlvbiBjbGFzc2RlZihzdG10KXtyZXR1cm4gc3RhdGUub3B0aW9uLmluRVNOZXh0KCl8fHdhcm5pbmcoXFxcIlcxMDRcXFwiLHN0YXRlLnRva2Vucy5jdXJyLFxcXCJjbGFzc1xcXCIpLHN0bXQ/KHRoaXMubmFtZT1pZGVudGlmaWVyKCksYWRkbGFiZWwodGhpcy5uYW1lLHt0eXBlOlxcXCJ1bnVzZWRcXFwiLHRva2VuOnN0YXRlLnRva2Vucy5jdXJyfSkpOnN0YXRlLnRva2Vucy5uZXh0LmlkZW50aWZpZXImJlxcXCJleHRlbmRzXFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlJiYodGhpcy5uYW1lPWlkZW50aWZpZXIoKSksY2xhc3N0YWlsKHRoaXMpLHRoaXN9ZnVuY3Rpb24gY2xhc3N0YWlsKGMpe3ZhciBzdHJpY3RuZXNzPXN0YXRlLmRpcmVjdGl2ZVtcXFwidXNlIHN0cmljdFxcXCJdO1xcXCJleHRlbmRzXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlJiYoYWR2YW5jZShcXFwiZXh0ZW5kc1xcXCIpLGMuaGVyaXRhZ2U9ZXhwcmVzc2lvbigxMCkpLHN0YXRlLmRpcmVjdGl2ZVtcXFwidXNlIHN0cmljdFxcXCJdPSEwLGFkdmFuY2UoXFxcIntcXFwiKSxjLmJvZHk9c3RhdGUuc3ludGF4W1xcXCJ7XFxcIl0ubnVkKCEwKSxzdGF0ZS5kaXJlY3RpdmVbXFxcInVzZSBzdHJpY3RcXFwiXT1zdHJpY3RuZXNzfWZ1bmN0aW9uIGRlc3RydWN0dXJpbmdBc3NpZ25Pckpzb25WYWx1ZSgpe3ZhciBibG9jaz1sb29rdXBCbG9ja1R5cGUoKTtibG9jay5ub3RKc29uPyghc3RhdGUub3B0aW9uLmluRVNOZXh0KCkmJmJsb2NrLmlzRGVzdEFzc2lnbiYmd2FybmluZyhcXFwiVzEwNFxcXCIsc3RhdGUudG9rZW5zLmN1cnIsXFxcImRlc3RydWN0dXJpbmcgYXNzaWdubWVudFxcXCIpLHN0YXRlbWVudHMoKSk6KHN0YXRlLm9wdGlvbi5sYXhicmVhaz0hMCxzdGF0ZS5qc29uTW9kZT0hMCxqc29uVmFsdWUoKSl9ZnVuY3Rpb24ganNvblZhbHVlKCl7ZnVuY3Rpb24ganNvbk9iamVjdCgpe3ZhciBvPXt9LHQ9c3RhdGUudG9rZW5zLm5leHQ7aWYoYWR2YW5jZShcXFwie1xcXCIpLFxcXCJ9XFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LmlkKWZvcig7Oyl7aWYoXFxcIihlbmQpXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkKWVycm9yKFxcXCJFMDI2XFxcIixzdGF0ZS50b2tlbnMubmV4dCx0LmxpbmUpO2Vsc2V7aWYoXFxcIn1cXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQpe3dhcm5pbmcoXFxcIlcwOTRcXFwiLHN0YXRlLnRva2Vucy5jdXJyKTticmVha31cXFwiLFxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZD9lcnJvcihcXFwiRTAyOFxcXCIsc3RhdGUudG9rZW5zLm5leHQpOlxcXCIoc3RyaW5nKVxcXCIhPT1zdGF0ZS50b2tlbnMubmV4dC5pZCYmd2FybmluZyhcXFwiVzA5NVxcXCIsc3RhdGUudG9rZW5zLm5leHQsc3RhdGUudG9rZW5zLm5leHQudmFsdWUpfWlmKG9bc3RhdGUudG9rZW5zLm5leHQudmFsdWVdPT09ITA/d2FybmluZyhcXFwiVzA3NVxcXCIsc3RhdGUudG9rZW5zLm5leHQsc3RhdGUudG9rZW5zLm5leHQudmFsdWUpOlxcXCJfX3Byb3RvX19cXFwiPT09c3RhdGUudG9rZW5zLm5leHQudmFsdWUmJiFzdGF0ZS5vcHRpb24ucHJvdG98fFxcXCJfX2l0ZXJhdG9yX19cXFwiPT09c3RhdGUudG9rZW5zLm5leHQudmFsdWUmJiFzdGF0ZS5vcHRpb24uaXRlcmF0b3I/d2FybmluZyhcXFwiVzA5NlxcXCIsc3RhdGUudG9rZW5zLm5leHQsc3RhdGUudG9rZW5zLm5leHQudmFsdWUpOm9bc3RhdGUudG9rZW5zLm5leHQudmFsdWVdPSEwLGFkdmFuY2UoKSxhZHZhbmNlKFxcXCI6XFxcIiksanNvblZhbHVlKCksXFxcIixcXFwiIT09c3RhdGUudG9rZW5zLm5leHQuaWQpYnJlYWs7YWR2YW5jZShcXFwiLFxcXCIpfWFkdmFuY2UoXFxcIn1cXFwiKX1mdW5jdGlvbiBqc29uQXJyYXkoKXt2YXIgdD1zdGF0ZS50b2tlbnMubmV4dDtpZihhZHZhbmNlKFxcXCJbXFxcIiksXFxcIl1cXFwiIT09c3RhdGUudG9rZW5zLm5leHQuaWQpZm9yKDs7KXtpZihcXFwiKGVuZClcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQpZXJyb3IoXFxcIkUwMjdcXFwiLHN0YXRlLnRva2Vucy5uZXh0LHQubGluZSk7ZWxzZXtpZihcXFwiXVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZCl7d2FybmluZyhcXFwiVzA5NFxcXCIsc3RhdGUudG9rZW5zLmN1cnIpO2JyZWFrfVxcXCIsXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkJiZlcnJvcihcXFwiRTAyOFxcXCIsc3RhdGUudG9rZW5zLm5leHQpfWlmKGpzb25WYWx1ZSgpLFxcXCIsXFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LmlkKWJyZWFrO2FkdmFuY2UoXFxcIixcXFwiKX1hZHZhbmNlKFxcXCJdXFxcIil9c3dpdGNoKHN0YXRlLnRva2Vucy5uZXh0LmlkKXtjYXNlXFxcIntcXFwiOmpzb25PYmplY3QoKTticmVhaztjYXNlXFxcIltcXFwiOmpzb25BcnJheSgpO2JyZWFrO2Nhc2VcXFwidHJ1ZVxcXCI6Y2FzZVxcXCJmYWxzZVxcXCI6Y2FzZVxcXCJudWxsXFxcIjpjYXNlXFxcIihudW1iZXIpXFxcIjpjYXNlXFxcIihzdHJpbmcpXFxcIjphZHZhbmNlKCk7YnJlYWs7Y2FzZVxcXCItXFxcIjphZHZhbmNlKFxcXCItXFxcIiksYWR2YW5jZShcXFwiKG51bWJlcilcXFwiKTticmVhaztkZWZhdWx0OmVycm9yKFxcXCJFMDAzXFxcIixzdGF0ZS50b2tlbnMubmV4dCl9fXZhciBhbm9ubmFtZSxhcGksZGVjbGFyZWQsZXhwb3J0ZWQsZnVuY3QsZnVuY3Rpb25zLGdsb2JhbCxpbXBsaWVkLGluYmxvY2ssaW5kZW50LGxvb2thaGVhZCxsZXgsbWVtYmVyLG1lbWJlcnNPbmx5LG5vcmVhY2gscHJlZGVmaW5lZCxzY29wZSxzdGFjayx1bnVzZWRzLHVybHMsYmFuZz17XFxcIjxcXFwiOiEwLFxcXCI8PVxcXCI6ITAsXFxcIj09XFxcIjohMCxcXFwiPT09XFxcIjohMCxcXFwiIT09XFxcIjohMCxcXFwiIT1cXFwiOiEwLFxcXCI+XFxcIjohMCxcXFwiPj1cXFwiOiEwLFxcXCIrXFxcIjohMCxcXFwiLVxcXCI6ITAsXFxcIipcXFwiOiEwLFxcXCIvXFxcIjohMCxcXFwiJVxcXCI6ITB9LGJvb2xPcHRpb25zPXthc2k6ITAsYml0d2lzZTohMCxib3NzOiEwLGJyb3dzZXI6ITAsY2FtZWxjYXNlOiEwLGNvdWNoOiEwLGN1cmx5OiEwLGRlYnVnOiEwLGRldmVsOiEwLGRvam86ITAsZXFlcWVxOiEwLGVxbnVsbDohMCxub3R5cGVvZjohMCxlczM6ITAsZXM1OiEwLGVzbmV4dDohMCxtb3o6ITAsZXZpbDohMCxleHByOiEwLGZvcmluOiEwLGZ1bmNzY29wZTohMCxnbG9iYWxzdHJpY3Q6ITAsaW1tZWQ6ITAsaXRlcmF0b3I6ITAsamFzbWluZTohMCxqcXVlcnk6ITAsbGFzdHNlbWljOiEwLGxheGJyZWFrOiEwLGxheGNvbW1hOiEwLGxvb3BmdW5jOiEwLG1vb3Rvb2xzOiEwLG11bHRpc3RyOiEwLGZyZWV6ZTohMCxuZXdjYXA6ITAsbm9hcmc6ITAsbm9kZTohMCxub2VtcHR5OiEwLG5vbmJzcDohMCxub25ldzohMCxub25zdGFuZGFyZDohMCxwaGFudG9tOiEwLHBsdXNwbHVzOiEwLHByb3RvOiEwLHByb3RvdHlwZWpzOiEwLHF1bml0OiEwLHJoaW5vOiEwLHNoZWxsanM6ITAsdHlwZWQ6ITAsdW5kZWY6ITAsc2NyaXB0dXJsOiEwLHN0cmljdDohMCxzdWI6ITAsc3VwZXJuZXc6ITAsdmFsaWR0aGlzOiEwLHdpdGhzdG10OiEwLHdvcmtlcjohMCx3c2g6ITAseXVpOiEwLG1vY2hhOiEwLG5veWllbGQ6ITAsb25lY2FzZTohMCxyZWdleHA6ITAscmVnZXhkYXNoOiEwfSx2YWxPcHRpb25zPXttYXhsZW46ITEsaW5kZW50OiExLG1heGVycjohMSxwcmVkZWY6ITEsZ2xvYmFsczohMSxxdW90bWFyazohMSxzY29wZTohMSxtYXhzdGF0ZW1lbnRzOiExLG1heGRlcHRoOiExLG1heHBhcmFtczohMSxtYXhjb21wbGV4aXR5OiExLHNoYWRvdzohMSx1bnVzZWQ6ITAsbGF0ZWRlZjohMSxpZ25vcmU6ITF9LGludmVydGVkT3B0aW9ucz17Yml0d2lzZTohMCxmb3JpbjohMCxuZXdjYXA6ITAscGx1c3BsdXM6ITAscmVnZXhwOiEwLHVuZGVmOiEwLGVxZXFlcTohMCxzdHJpY3Q6ITB9LHJlbmFtZWRPcHRpb25zPXtlcWVxOlxcXCJlcWVxZXFcXFwiLHdpbmRvd3M6XFxcIndzaFxcXCIsc2xvcHB5OlxcXCJzdHJpY3RcXFwifSxyZW1vdmVkT3B0aW9ucz17bm9tZW46ITAsb25ldmFyOiEwLHBhc3NmYWlsOiEwLHdoaXRlOiEwLGdjbDohMCxzbWFydHRhYnM6ITAsdHJhaWxpbmc6ITB9LGZ1bmN0aW9uaWNpdHk9W1xcXCJjbG9zdXJlXFxcIixcXFwiZXhjZXB0aW9uXFxcIixcXFwiZ2xvYmFsXFxcIixcXFwibGFiZWxcXFwiLFxcXCJvdXRlclxcXCIsXFxcInVudXNlZFxcXCIsXFxcInZhclxcXCJdLGV4dHJhTW9kdWxlcz1bXSxlbWl0dGVyPW5ldyBldmVudHMuRXZlbnRFbWl0dGVyO3R5cGUoXFxcIihudW1iZXIpXFxcIixmdW5jdGlvbigpe3JldHVybiB0aGlzfSksdHlwZShcXFwiKHN0cmluZylcXFwiLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KSx0eXBlKFxcXCIodGVtcGxhdGUpXFxcIixmdW5jdGlvbigpe3JldHVybiB0aGlzfSksc3RhdGUuc3ludGF4W1xcXCIoaWRlbnRpZmllcilcXFwiXT17dHlwZTpcXFwiKGlkZW50aWZpZXIpXFxcIixsYnA6MCxpZGVudGlmaWVyOiEwLG51ZDpmdW5jdGlvbigpe3ZhciBmLGJsb2NrLHY9dGhpcy52YWx1ZSxzPXNjb3BlW3ZdO2lmKFxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBzP3M9dm9pZCAwOmZ1bmN0W1xcXCIoYmxvY2tzY29wZSlcXFwiXS5jdXJyZW50Lmhhcyh2KXx8XFxcImJvb2xlYW5cXFwiIT10eXBlb2Ygc3x8KGY9ZnVuY3QsZnVuY3Q9ZnVuY3Rpb25zWzBdLGFkZGxhYmVsKHYse3R5cGU6XFxcInZhclxcXCJ9KSxzPWZ1bmN0LGZ1bmN0PWYpLGJsb2NrPWZ1bmN0W1xcXCIoYmxvY2tzY29wZSlcXFwiXS5nZXRsYWJlbCh2KSxmdW5jdD09PXN8fGJsb2NrKXN3aXRjaChibG9jaz9ibG9ja1t2XVtcXFwiKHR5cGUpXFxcIl06ZnVuY3Rbdl0pe2Nhc2VcXFwidW51c2VkXFxcIjpibG9jaz9ibG9ja1t2XVtcXFwiKHR5cGUpXFxcIl09XFxcInZhclxcXCI6ZnVuY3Rbdl09XFxcInZhclxcXCI7YnJlYWs7Y2FzZVxcXCJ1bmN0aW9uXFxcIjpibG9jaz9ibG9ja1t2XVtcXFwiKHR5cGUpXFxcIl09XFxcImZ1bmN0aW9uXFxcIjpmdW5jdFt2XT1cXFwiZnVuY3Rpb25cXFwiLHRoaXNbXFxcImZ1bmN0aW9uXFxcIl09ITA7YnJlYWs7Y2FzZVxcXCJjb25zdFxcXCI6c2V0cHJvcChmdW5jdCx2LHt1bnVzZWQ6ITF9KTticmVhaztjYXNlXFxcImZ1bmN0aW9uXFxcIjp0aGlzW1xcXCJmdW5jdGlvblxcXCJdPSEwO2JyZWFrO2Nhc2VcXFwibGFiZWxcXFwiOndhcm5pbmcoXFxcIlcwMzdcXFwiLHN0YXRlLnRva2Vucy5jdXJyLHYpfWVsc2UgaWYoZnVuY3RbXFxcIihnbG9iYWwpXFxcIl0pXFxcImJvb2xlYW5cXFwiIT10eXBlb2YgcHJlZGVmaW5lZFt2XSYmKFxcXCJ0eXBlb2ZcXFwiIT09YW5vbm5hbWUmJlxcXCJkZWxldGVcXFwiIT09YW5vbm5hbWV8fHN0YXRlLnRva2Vucy5uZXh0JiYoXFxcIi5cXFwiPT09c3RhdGUudG9rZW5zLm5leHQudmFsdWV8fFxcXCJbXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKSkmJihmdW5jdFtcXFwiKGNvbXBhcnJheSlcXFwiXS5jaGVjayh2KXx8aXN1bmRlZihmdW5jdCxcXFwiVzExN1xcXCIsc3RhdGUudG9rZW5zLmN1cnIsdikpLG5vdGVfaW1wbGllZChzdGF0ZS50b2tlbnMuY3Vycik7ZWxzZSBzd2l0Y2goZnVuY3Rbdl0pe2Nhc2VcXFwiY2xvc3VyZVxcXCI6Y2FzZVxcXCJmdW5jdGlvblxcXCI6Y2FzZVxcXCJ2YXJcXFwiOmNhc2VcXFwidW51c2VkXFxcIjp3YXJuaW5nKFxcXCJXMDM4XFxcIixzdGF0ZS50b2tlbnMuY3Vycix2KTticmVhaztjYXNlXFxcImxhYmVsXFxcIjp3YXJuaW5nKFxcXCJXMDM3XFxcIixzdGF0ZS50b2tlbnMuY3Vycix2KTticmVhaztjYXNlXFxcIm91dGVyXFxcIjpjYXNlXFxcImdsb2JhbFxcXCI6YnJlYWs7ZGVmYXVsdDppZihzPT09ITApZnVuY3Rbdl09ITA7ZWxzZSBpZihudWxsPT09cyl3YXJuaW5nKFxcXCJXMDM5XFxcIixzdGF0ZS50b2tlbnMuY3Vycix2KSxub3RlX2ltcGxpZWQoc3RhdGUudG9rZW5zLmN1cnIpO2Vsc2UgaWYoXFxcIm9iamVjdFxcXCIhPXR5cGVvZiBzKShcXFwidHlwZW9mXFxcIiE9PWFub25uYW1lJiZcXFwiZGVsZXRlXFxcIiE9PWFub25uYW1lfHxzdGF0ZS50b2tlbnMubmV4dCYmKFxcXCIuXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlfHxcXFwiW1xcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC52YWx1ZSkpJiZpc3VuZGVmKGZ1bmN0LFxcXCJXMTE3XFxcIixzdGF0ZS50b2tlbnMuY3Vycix2KSxmdW5jdFt2XT0hMCxub3RlX2ltcGxpZWQoc3RhdGUudG9rZW5zLmN1cnIpO2Vsc2Ugc3dpdGNoKHNbdl0pe2Nhc2VcXFwiZnVuY3Rpb25cXFwiOmNhc2VcXFwidW5jdGlvblxcXCI6dGhpc1tcXFwiZnVuY3Rpb25cXFwiXT0hMCxzW3ZdPVxcXCJjbG9zdXJlXFxcIixmdW5jdFt2XT1zW1xcXCIoZ2xvYmFsKVxcXCJdP1xcXCJnbG9iYWxcXFwiOlxcXCJvdXRlclxcXCI7YnJlYWs7Y2FzZVxcXCJ2YXJcXFwiOmNhc2VcXFwidW51c2VkXFxcIjpzW3ZdPVxcXCJjbG9zdXJlXFxcIixmdW5jdFt2XT1zW1xcXCIoZ2xvYmFsKVxcXCJdP1xcXCJnbG9iYWxcXFwiOlxcXCJvdXRlclxcXCI7YnJlYWs7Y2FzZVxcXCJjb25zdFxcXCI6c2V0cHJvcChzLHYse3VudXNlZDohMX0pO2JyZWFrO2Nhc2VcXFwiY2xvc3VyZVxcXCI6ZnVuY3Rbdl09c1tcXFwiKGdsb2JhbClcXFwiXT9cXFwiZ2xvYmFsXFxcIjpcXFwib3V0ZXJcXFwiO2JyZWFrO2Nhc2VcXFwibGFiZWxcXFwiOndhcm5pbmcoXFxcIlcwMzdcXFwiLHN0YXRlLnRva2Vucy5jdXJyLHYpfX1yZXR1cm4gdGhpc30sbGVkOmZ1bmN0aW9uKCl7ZXJyb3IoXFxcIkUwMzNcXFwiLHN0YXRlLnRva2Vucy5uZXh0LHN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKX19LHR5cGUoXFxcIihyZWdleHApXFxcIixmdW5jdGlvbigpe3JldHVybiB0aGlzfSksZGVsaW0oXFxcIihlbmRsaW5lKVxcXCIpLGRlbGltKFxcXCIoYmVnaW4pXFxcIiksZGVsaW0oXFxcIihlbmQpXFxcIikucmVhY2g9ITAsZGVsaW0oXFxcIihlcnJvcilcXFwiKS5yZWFjaD0hMCxkZWxpbShcXFwifVxcXCIpLnJlYWNoPSEwLGRlbGltKFxcXCIpXFxcIiksZGVsaW0oXFxcIl1cXFwiKSxkZWxpbSgnXFxcIicpLnJlYWNoPSEwLGRlbGltKFxcXCInXFxcIikucmVhY2g9ITAsZGVsaW0oXFxcIjtcXFwiKSxkZWxpbShcXFwiOlxcXCIpLnJlYWNoPSEwLGRlbGltKFxcXCIjXFxcIikscmVzZXJ2ZShcXFwiZWxzZVxcXCIpLHJlc2VydmUoXFxcImNhc2VcXFwiKS5yZWFjaD0hMCxyZXNlcnZlKFxcXCJjYXRjaFxcXCIpLHJlc2VydmUoXFxcImRlZmF1bHRcXFwiKS5yZWFjaD0hMCxyZXNlcnZlKFxcXCJmaW5hbGx5XFxcIikscmVzZXJ2ZXZhcihcXFwiYXJndW1lbnRzXFxcIixmdW5jdGlvbih4KXtzdGF0ZS5kaXJlY3RpdmVbXFxcInVzZSBzdHJpY3RcXFwiXSYmZnVuY3RbXFxcIihnbG9iYWwpXFxcIl0mJndhcm5pbmcoXFxcIkUwMDhcXFwiLHgpfSkscmVzZXJ2ZXZhcihcXFwiZXZhbFxcXCIpLHJlc2VydmV2YXIoXFxcImZhbHNlXFxcIikscmVzZXJ2ZXZhcihcXFwiSW5maW5pdHlcXFwiKSxyZXNlcnZldmFyKFxcXCJudWxsXFxcIikscmVzZXJ2ZXZhcihcXFwidGhpc1xcXCIsZnVuY3Rpb24oeCl7c3RhdGUuZGlyZWN0aXZlW1xcXCJ1c2Ugc3RyaWN0XFxcIl0mJiFzdGF0ZS5vcHRpb24udmFsaWR0aGlzJiYoZnVuY3RbXFxcIihzdGF0ZW1lbnQpXFxcIl0mJmZ1bmN0W1xcXCIobmFtZSlcXFwiXS5jaGFyQXQoMCk+XFxcIlpcXFwifHxmdW5jdFtcXFwiKGdsb2JhbClcXFwiXSkmJndhcm5pbmcoXFxcIlcwNDBcXFwiLHgpfSkscmVzZXJ2ZXZhcihcXFwidHJ1ZVxcXCIpLHJlc2VydmV2YXIoXFxcInVuZGVmaW5lZFxcXCIpLGFzc2lnbm9wKFxcXCI9XFxcIixcXFwiYXNzaWduXFxcIiwyMCksYXNzaWdub3AoXFxcIis9XFxcIixcXFwiYXNzaWduYWRkXFxcIiwyMCksYXNzaWdub3AoXFxcIi09XFxcIixcXFwiYXNzaWduc3ViXFxcIiwyMCksYXNzaWdub3AoXFxcIio9XFxcIixcXFwiYXNzaWdubXVsdFxcXCIsMjApLGFzc2lnbm9wKFxcXCIvPVxcXCIsXFxcImFzc2lnbmRpdlxcXCIsMjApLm51ZD1mdW5jdGlvbigpe2Vycm9yKFxcXCJFMDE0XFxcIil9LGFzc2lnbm9wKFxcXCIlPVxcXCIsXFxcImFzc2lnbm1vZFxcXCIsMjApLGJpdHdpc2Vhc3NpZ25vcChcXFwiJj1cXFwiLFxcXCJhc3NpZ25iaXRhbmRcXFwiLDIwKSxiaXR3aXNlYXNzaWdub3AoXFxcInw9XFxcIixcXFwiYXNzaWduYml0b3JcXFwiLDIwKSxiaXR3aXNlYXNzaWdub3AoXFxcIl49XFxcIixcXFwiYXNzaWduYml0eG9yXFxcIiwyMCksYml0d2lzZWFzc2lnbm9wKFxcXCI8PD1cXFwiLFxcXCJhc3NpZ25zaGlmdGxlZnRcXFwiLDIwKSxiaXR3aXNlYXNzaWdub3AoXFxcIj4+PVxcXCIsXFxcImFzc2lnbnNoaWZ0cmlnaHRcXFwiLDIwKSxiaXR3aXNlYXNzaWdub3AoXFxcIj4+Pj1cXFwiLFxcXCJhc3NpZ25zaGlmdHJpZ2h0dW5zaWduZWRcXFwiLDIwKSxpbmZpeChcXFwiLFxcXCIsZnVuY3Rpb24obGVmdCx0aGF0KXt2YXIgZXhwcjtpZih0aGF0LmV4cHJzPVtsZWZ0XSwhY29tbWEoe3BlZWs6ITB9KSlyZXR1cm4gdGhhdDtmb3IoOzspe2lmKCEoZXhwcj1leHByZXNzaW9uKDEwKSkpYnJlYWs7aWYodGhhdC5leHBycy5wdXNoKGV4cHIpLFxcXCIsXFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlfHwhY29tbWEoKSlicmVha31yZXR1cm4gdGhhdH0sMTAsITApLGluZml4KFxcXCI/XFxcIixmdW5jdGlvbihsZWZ0LHRoYXQpe3JldHVybiBpbmNyZWFzZUNvbXBsZXhpdHlDb3VudCgpLHRoYXQubGVmdD1sZWZ0LHRoYXQucmlnaHQ9ZXhwcmVzc2lvbigxMCksYWR2YW5jZShcXFwiOlxcXCIpLHRoYXRbXFxcImVsc2VcXFwiXT1leHByZXNzaW9uKDEwKSx0aGF0fSwzMCk7dmFyIG9yUHJlY2VuZGVuY2U9NDA7aW5maXgoXFxcInx8XFxcIixmdW5jdGlvbihsZWZ0LHRoYXQpe3JldHVybiBpbmNyZWFzZUNvbXBsZXhpdHlDb3VudCgpLHRoYXQubGVmdD1sZWZ0LHRoYXQucmlnaHQ9ZXhwcmVzc2lvbihvclByZWNlbmRlbmNlKSx0aGF0fSxvclByZWNlbmRlbmNlKSxpbmZpeChcXFwiJiZcXFwiLFxcXCJhbmRcXFwiLDUwKSxiaXR3aXNlKFxcXCJ8XFxcIixcXFwiYml0b3JcXFwiLDcwKSxiaXR3aXNlKFxcXCJeXFxcIixcXFwiYml0eG9yXFxcIiw4MCksYml0d2lzZShcXFwiJlxcXCIsXFxcImJpdGFuZFxcXCIsOTApLHJlbGF0aW9uKFxcXCI9PVxcXCIsZnVuY3Rpb24obGVmdCxyaWdodCl7dmFyIGVxbnVsbD1zdGF0ZS5vcHRpb24uZXFudWxsJiYoXFxcIm51bGxcXFwiPT09bGVmdC52YWx1ZXx8XFxcIm51bGxcXFwiPT09cmlnaHQudmFsdWUpO3N3aXRjaCghMCl7Y2FzZSFlcW51bGwmJnN0YXRlLm9wdGlvbi5lcWVxZXE6dGhpcy5mcm9tPXRoaXMuY2hhcmFjdGVyLHdhcm5pbmcoXFxcIlcxMTZcXFwiLHRoaXMsXFxcIj09PVxcXCIsXFxcIj09XFxcIik7YnJlYWs7Y2FzZSBpc1Bvb3JSZWxhdGlvbihsZWZ0KTp3YXJuaW5nKFxcXCJXMDQxXFxcIix0aGlzLFxcXCI9PT1cXFwiLGxlZnQudmFsdWUpO2JyZWFrO2Nhc2UgaXNQb29yUmVsYXRpb24ocmlnaHQpOndhcm5pbmcoXFxcIlcwNDFcXFwiLHRoaXMsXFxcIj09PVxcXCIscmlnaHQudmFsdWUpO2JyZWFrO2Nhc2UgaXNUeXBvVHlwZW9mKHJpZ2h0LGxlZnQpOndhcm5pbmcoXFxcIlcxMjJcXFwiLHRoaXMscmlnaHQudmFsdWUpO2JyZWFrO2Nhc2UgaXNUeXBvVHlwZW9mKGxlZnQscmlnaHQpOndhcm5pbmcoXFxcIlcxMjJcXFwiLHRoaXMsbGVmdC52YWx1ZSl9cmV0dXJuIHRoaXN9KSxyZWxhdGlvbihcXFwiPT09XFxcIixmdW5jdGlvbihsZWZ0LHJpZ2h0KXtyZXR1cm4gaXNUeXBvVHlwZW9mKHJpZ2h0LGxlZnQpP3dhcm5pbmcoXFxcIlcxMjJcXFwiLHRoaXMscmlnaHQudmFsdWUpOmlzVHlwb1R5cGVvZihsZWZ0LHJpZ2h0KSYmd2FybmluZyhcXFwiVzEyMlxcXCIsdGhpcyxsZWZ0LnZhbHVlKSx0aGlzfSkscmVsYXRpb24oXFxcIiE9XFxcIixmdW5jdGlvbihsZWZ0LHJpZ2h0KXt2YXIgZXFudWxsPXN0YXRlLm9wdGlvbi5lcW51bGwmJihcXFwibnVsbFxcXCI9PT1sZWZ0LnZhbHVlfHxcXFwibnVsbFxcXCI9PT1yaWdodC52YWx1ZSk7cmV0dXJuIWVxbnVsbCYmc3RhdGUub3B0aW9uLmVxZXFlcT8odGhpcy5mcm9tPXRoaXMuY2hhcmFjdGVyLHdhcm5pbmcoXFxcIlcxMTZcXFwiLHRoaXMsXFxcIiE9PVxcXCIsXFxcIiE9XFxcIikpOmlzUG9vclJlbGF0aW9uKGxlZnQpP3dhcm5pbmcoXFxcIlcwNDFcXFwiLHRoaXMsXFxcIiE9PVxcXCIsbGVmdC52YWx1ZSk6aXNQb29yUmVsYXRpb24ocmlnaHQpP3dhcm5pbmcoXFxcIlcwNDFcXFwiLHRoaXMsXFxcIiE9PVxcXCIscmlnaHQudmFsdWUpOmlzVHlwb1R5cGVvZihyaWdodCxsZWZ0KT93YXJuaW5nKFxcXCJXMTIyXFxcIix0aGlzLHJpZ2h0LnZhbHVlKTppc1R5cG9UeXBlb2YobGVmdCxyaWdodCkmJndhcm5pbmcoXFxcIlcxMjJcXFwiLHRoaXMsbGVmdC52YWx1ZSksdGhpc30pLHJlbGF0aW9uKFxcXCIhPT1cXFwiLGZ1bmN0aW9uKGxlZnQscmlnaHQpe3JldHVybiBpc1R5cG9UeXBlb2YocmlnaHQsbGVmdCk/d2FybmluZyhcXFwiVzEyMlxcXCIsdGhpcyxyaWdodC52YWx1ZSk6aXNUeXBvVHlwZW9mKGxlZnQscmlnaHQpJiZ3YXJuaW5nKFxcXCJXMTIyXFxcIix0aGlzLGxlZnQudmFsdWUpLHRoaXN9KSxyZWxhdGlvbihcXFwiPFxcXCIpLHJlbGF0aW9uKFxcXCI+XFxcIikscmVsYXRpb24oXFxcIjw9XFxcIikscmVsYXRpb24oXFxcIj49XFxcIiksYml0d2lzZShcXFwiPDxcXFwiLFxcXCJzaGlmdGxlZnRcXFwiLDEyMCksYml0d2lzZShcXFwiPj5cXFwiLFxcXCJzaGlmdHJpZ2h0XFxcIiwxMjApLGJpdHdpc2UoXFxcIj4+PlxcXCIsXFxcInNoaWZ0cmlnaHR1bnNpZ25lZFxcXCIsMTIwKSxpbmZpeChcXFwiaW5cXFwiLFxcXCJpblxcXCIsMTIwKSxpbmZpeChcXFwiaW5zdGFuY2VvZlxcXCIsXFxcImluc3RhbmNlb2ZcXFwiLDEyMCksaW5maXgoXFxcIitcXFwiLGZ1bmN0aW9uKGxlZnQsdGhhdCl7dmFyIHJpZ2h0PWV4cHJlc3Npb24oMTMwKTtyZXR1cm4gbGVmdCYmcmlnaHQmJlxcXCIoc3RyaW5nKVxcXCI9PT1sZWZ0LmlkJiZcXFwiKHN0cmluZylcXFwiPT09cmlnaHQuaWQ/KGxlZnQudmFsdWUrPXJpZ2h0LnZhbHVlLGxlZnQuY2hhcmFjdGVyPXJpZ2h0LmNoYXJhY3Rlciwhc3RhdGUub3B0aW9uLnNjcmlwdHVybCYmcmVnLmphdmFzY3JpcHRVUkwudGVzdChsZWZ0LnZhbHVlKSYmd2FybmluZyhcXFwiVzA1MFxcXCIsbGVmdCksbGVmdCk6KHRoYXQubGVmdD1sZWZ0LHRoYXQucmlnaHQ9cmlnaHQsdGhhdCl9LDEzMCkscHJlZml4KFxcXCIrXFxcIixcXFwibnVtXFxcIikscHJlZml4KFxcXCIrKytcXFwiLGZ1bmN0aW9uKCl7cmV0dXJuIHdhcm5pbmcoXFxcIlcwMDdcXFwiKSx0aGlzLnJpZ2h0PWV4cHJlc3Npb24oMTUwKSx0aGlzLmFyaXR5PVxcXCJ1bmFyeVxcXCIsdGhpc30pLGluZml4KFxcXCIrKytcXFwiLGZ1bmN0aW9uKGxlZnQpe3JldHVybiB3YXJuaW5nKFxcXCJXMDA3XFxcIiksdGhpcy5sZWZ0PWxlZnQsdGhpcy5yaWdodD1leHByZXNzaW9uKDEzMCksdGhpc30sMTMwKSxpbmZpeChcXFwiLVxcXCIsXFxcInN1YlxcXCIsMTMwKSxwcmVmaXgoXFxcIi1cXFwiLFxcXCJuZWdcXFwiKSxwcmVmaXgoXFxcIi0tLVxcXCIsZnVuY3Rpb24oKXtyZXR1cm4gd2FybmluZyhcXFwiVzAwNlxcXCIpLHRoaXMucmlnaHQ9ZXhwcmVzc2lvbigxNTApLHRoaXMuYXJpdHk9XFxcInVuYXJ5XFxcIix0aGlzfSksaW5maXgoXFxcIi0tLVxcXCIsZnVuY3Rpb24obGVmdCl7cmV0dXJuIHdhcm5pbmcoXFxcIlcwMDZcXFwiKSx0aGlzLmxlZnQ9bGVmdCx0aGlzLnJpZ2h0PWV4cHJlc3Npb24oMTMwKSx0aGlzfSwxMzApLGluZml4KFxcXCIqXFxcIixcXFwibXVsdFxcXCIsMTQwKSxpbmZpeChcXFwiL1xcXCIsXFxcImRpdlxcXCIsMTQwKSxpbmZpeChcXFwiJVxcXCIsXFxcIm1vZFxcXCIsMTQwKSxzdWZmaXgoXFxcIisrXFxcIixcXFwicG9zdGluY1xcXCIpLHByZWZpeChcXFwiKytcXFwiLFxcXCJwcmVpbmNcXFwiKSxzdGF0ZS5zeW50YXhbXFxcIisrXFxcIl0uZXhwcz0hMCxzdWZmaXgoXFxcIi0tXFxcIixcXFwicG9zdGRlY1xcXCIpLHByZWZpeChcXFwiLS1cXFwiLFxcXCJwcmVkZWNcXFwiKSxzdGF0ZS5zeW50YXhbXFxcIi0tXFxcIl0uZXhwcz0hMCxwcmVmaXgoXFxcImRlbGV0ZVxcXCIsZnVuY3Rpb24oKXt2YXIgcD1leHByZXNzaW9uKDEwKTtyZXR1cm4oIXB8fFxcXCIuXFxcIiE9PXAuaWQmJlxcXCJbXFxcIiE9PXAuaWQpJiZ3YXJuaW5nKFxcXCJXMDUxXFxcIiksdGhpcy5maXJzdD1wLHRoaXN9KS5leHBzPSEwLHByZWZpeChcXFwiflxcXCIsZnVuY3Rpb24oKXtyZXR1cm4gc3RhdGUub3B0aW9uLmJpdHdpc2UmJndhcm5pbmcoXFxcIlcwNTJcXFwiLHRoaXMsXFxcIn5cXFwiKSxleHByZXNzaW9uKDE1MCksdGhpc30pLHByZWZpeChcXFwiLi4uXFxcIixmdW5jdGlvbigpe3JldHVybiBzdGF0ZS5vcHRpb24uaW5FU05leHQoKXx8d2FybmluZyhcXFwiVzEwNFxcXCIsdGhpcyxcXFwic3ByZWFkL3Jlc3Qgb3BlcmF0b3JcXFwiKSxzdGF0ZS50b2tlbnMubmV4dC5pZGVudGlmaWVyfHxlcnJvcihcXFwiRTAzMFxcXCIsc3RhdGUudG9rZW5zLm5leHQsc3RhdGUudG9rZW5zLm5leHQudmFsdWUpLGV4cHJlc3Npb24oMTUwKSx0aGlzfSkscHJlZml4KFxcXCIhXFxcIixmdW5jdGlvbigpe3JldHVybiB0aGlzLnJpZ2h0PWV4cHJlc3Npb24oMTUwKSx0aGlzLmFyaXR5PVxcXCJ1bmFyeVxcXCIsdGhpcy5yaWdodHx8cXVpdChcXFwiRTA0MVxcXCIsdGhpcy5saW5lfHwwKSxiYW5nW3RoaXMucmlnaHQuaWRdPT09ITAmJndhcm5pbmcoXFxcIlcwMThcXFwiLHRoaXMsXFxcIiFcXFwiKSx0aGlzfSkscHJlZml4KFxcXCJ0eXBlb2ZcXFwiLFxcXCJ0eXBlb2ZcXFwiKSxwcmVmaXgoXFxcIm5ld1xcXCIsZnVuY3Rpb24oKXt2YXIgaSxjPWV4cHJlc3Npb24oMTU1KTtpZihjJiZcXFwiZnVuY3Rpb25cXFwiIT09Yy5pZClpZihjLmlkZW50aWZpZXIpc3dpdGNoKGNbXFxcIm5ld1xcXCJdPSEwLGMudmFsdWUpe2Nhc2VcXFwiTnVtYmVyXFxcIjpjYXNlXFxcIlN0cmluZ1xcXCI6Y2FzZVxcXCJCb29sZWFuXFxcIjpjYXNlXFxcIk1hdGhcXFwiOmNhc2VcXFwiSlNPTlxcXCI6d2FybmluZyhcXFwiVzA1M1xcXCIsc3RhdGUudG9rZW5zLnByZXYsYy52YWx1ZSk7YnJlYWs7Y2FzZVxcXCJGdW5jdGlvblxcXCI6c3RhdGUub3B0aW9uLmV2aWx8fHdhcm5pbmcoXFxcIlcwNTRcXFwiKTticmVhaztjYXNlXFxcIkRhdGVcXFwiOmNhc2VcXFwiUmVnRXhwXFxcIjpjYXNlXFxcInRoaXNcXFwiOmJyZWFrO2RlZmF1bHQ6XFxcImZ1bmN0aW9uXFxcIiE9PWMuaWQmJihpPWMudmFsdWUuc3Vic3RyKDAsMSksc3RhdGUub3B0aW9uLm5ld2NhcCYmKFxcXCJBXFxcIj5pfHxpPlxcXCJaXFxcIikmJiFfLmhhcyhnbG9iYWwsYy52YWx1ZSkmJndhcm5pbmcoXFxcIlcwNTVcXFwiLHN0YXRlLnRva2Vucy5jdXJyKSl9ZWxzZVxcXCIuXFxcIiE9PWMuaWQmJlxcXCJbXFxcIiE9PWMuaWQmJlxcXCIoXFxcIiE9PWMuaWQmJndhcm5pbmcoXFxcIlcwNTZcXFwiLHN0YXRlLnRva2Vucy5jdXJyKTtlbHNlIHN0YXRlLm9wdGlvbi5zdXBlcm5ld3x8d2FybmluZyhcXFwiVzA1N1xcXCIsdGhpcyk7cmV0dXJuXFxcIihcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWR8fHN0YXRlLm9wdGlvbi5zdXBlcm5ld3x8d2FybmluZyhcXFwiVzA1OFxcXCIsc3RhdGUudG9rZW5zLmN1cnIsc3RhdGUudG9rZW5zLmN1cnIudmFsdWUpLHRoaXMuZmlyc3Q9Yyx0aGlzfSksc3RhdGUuc3ludGF4W1xcXCJuZXdcXFwiXS5leHBzPSEwLHByZWZpeChcXFwidm9pZFxcXCIpLmV4cHM9ITAsaW5maXgoXFxcIi5cXFwiLGZ1bmN0aW9uKGxlZnQsdGhhdCl7dmFyIG09aWRlbnRpZmllcighMSwhMCk7cmV0dXJuXFxcInN0cmluZ1xcXCI9PXR5cGVvZiBtJiZjb3VudE1lbWJlcihtKSx0aGF0LmxlZnQ9bGVmdCx0aGF0LnJpZ2h0PW0sbSYmXFxcImhhc093blByb3BlcnR5XFxcIj09PW0mJlxcXCI9XFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlJiZ3YXJuaW5nKFxcXCJXMDAxXFxcIiksIWxlZnR8fFxcXCJhcmd1bWVudHNcXFwiIT09bGVmdC52YWx1ZXx8XFxcImNhbGxlZVxcXCIhPT1tJiZcXFwiY2FsbGVyXFxcIiE9PW0/c3RhdGUub3B0aW9uLmV2aWx8fCFsZWZ0fHxcXFwiZG9jdW1lbnRcXFwiIT09bGVmdC52YWx1ZXx8XFxcIndyaXRlXFxcIiE9PW0mJlxcXCJ3cml0ZWxuXFxcIiE9PW18fHdhcm5pbmcoXFxcIlcwNjBcXFwiLGxlZnQpOnN0YXRlLm9wdGlvbi5ub2FyZz93YXJuaW5nKFxcXCJXMDU5XFxcIixsZWZ0LG0pOnN0YXRlLmRpcmVjdGl2ZVtcXFwidXNlIHN0cmljdFxcXCJdJiZlcnJvcihcXFwiRTAwOFxcXCIpLHN0YXRlLm9wdGlvbi5ldmlsfHxcXFwiZXZhbFxcXCIhPT1tJiZcXFwiZXhlY1NjcmlwdFxcXCIhPT1tfHx3YXJuaW5nKFxcXCJXMDYxXFxcIiksdGhhdH0sMTYwLCEwKSxpbmZpeChcXFwiKFxcXCIsZnVuY3Rpb24obGVmdCx0aGF0KXtzdGF0ZS5vcHRpb24uaW1tZWQmJmxlZnQmJiFsZWZ0LmltbWVkJiZcXFwiZnVuY3Rpb25cXFwiPT09bGVmdC5pZCYmd2FybmluZyhcXFwiVzA2MlxcXCIpO3ZhciBuPTAscD1bXTtpZihsZWZ0JiZcXFwiKGlkZW50aWZpZXIpXFxcIj09PWxlZnQudHlwZSYmbGVmdC52YWx1ZS5tYXRjaCgvXltBLVpdKFtBLVowLTlfJF0qW2Etel1bQS1aYS16MC05XyRdKik/JC8pJiYtMT09PVxcXCJOdW1iZXIgU3RyaW5nIEJvb2xlYW4gRGF0ZSBPYmplY3QgRXJyb3JcXFwiLmluZGV4T2YobGVmdC52YWx1ZSkmJihcXFwiTWF0aFxcXCI9PT1sZWZ0LnZhbHVlP3dhcm5pbmcoXFxcIlcwNjNcXFwiLGxlZnQpOnN0YXRlLm9wdGlvbi5uZXdjYXAmJndhcm5pbmcoXFxcIlcwNjRcXFwiLGxlZnQpKSxcXFwiKVxcXCIhPT1zdGF0ZS50b2tlbnMubmV4dC5pZClmb3IoO3BbcC5sZW5ndGhdPWV4cHJlc3Npb24oMTApLG4rPTEsXFxcIixcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQ7KWNvbW1hKCk7cmV0dXJuIGFkdmFuY2UoXFxcIilcXFwiKSxcXFwib2JqZWN0XFxcIj09dHlwZW9mIGxlZnQmJihzdGF0ZS5vcHRpb24uaW5FUzMoKSYmXFxcInBhcnNlSW50XFxcIj09PWxlZnQudmFsdWUmJjE9PT1uJiZ3YXJuaW5nKFxcXCJXMDY1XFxcIixzdGF0ZS50b2tlbnMuY3Vyciksc3RhdGUub3B0aW9uLmV2aWx8fChcXFwiZXZhbFxcXCI9PT1sZWZ0LnZhbHVlfHxcXFwiRnVuY3Rpb25cXFwiPT09bGVmdC52YWx1ZXx8XFxcImV4ZWNTY3JpcHRcXFwiPT09bGVmdC52YWx1ZT8od2FybmluZyhcXFwiVzA2MVxcXCIsbGVmdCkscFswXSYmXFxcIihzdHJpbmcpXFxcIj09PVswXS5pZCYmYWRkSW50ZXJuYWxTcmMobGVmdCxwWzBdLnZhbHVlKSk6IXBbMF18fFxcXCIoc3RyaW5nKVxcXCIhPT1wWzBdLmlkfHxcXFwic2V0VGltZW91dFxcXCIhPT1sZWZ0LnZhbHVlJiZcXFwic2V0SW50ZXJ2YWxcXFwiIT09bGVmdC52YWx1ZT8hcFswXXx8XFxcIihzdHJpbmcpXFxcIiE9PXBbMF0uaWR8fFxcXCIuXFxcIiE9PWxlZnQudmFsdWV8fFxcXCJ3aW5kb3dcXFwiIT09bGVmdC5sZWZ0LnZhbHVlfHxcXFwic2V0VGltZW91dFxcXCIhPT1sZWZ0LnJpZ2h0JiZcXFwic2V0SW50ZXJ2YWxcXFwiIT09bGVmdC5yaWdodHx8KHdhcm5pbmcoXFxcIlcwNjZcXFwiLGxlZnQpLGFkZEludGVybmFsU3JjKGxlZnQscFswXS52YWx1ZSkpOih3YXJuaW5nKFxcXCJXMDY2XFxcIixsZWZ0KSxhZGRJbnRlcm5hbFNyYyhsZWZ0LHBbMF0udmFsdWUpKSksbGVmdC5pZGVudGlmaWVyfHxcXFwiLlxcXCI9PT1sZWZ0LmlkfHxcXFwiW1xcXCI9PT1sZWZ0LmlkfHxcXFwiKFxcXCI9PT1sZWZ0LmlkfHxcXFwiJiZcXFwiPT09bGVmdC5pZHx8XFxcInx8XFxcIj09PWxlZnQuaWR8fFxcXCI/XFxcIj09PWxlZnQuaWR8fHdhcm5pbmcoXFxcIlcwNjdcXFwiLGxlZnQpKSx0aGF0LmxlZnQ9bGVmdCx0aGF0fSwxNTUsITApLmV4cHM9ITAscHJlZml4KFxcXCIoXFxcIixmdW5jdGlvbigpe3ZhciBicmFja2V0LHBuLHBuMSxyZXQsYnJhY2tldHM9W10saT0wLHBhcmVucz0xO2RvIHBuPXBlZWsoaSksXFxcIihcXFwiPT09cG4udmFsdWU/cGFyZW5zKz0xOlxcXCIpXFxcIj09PXBuLnZhbHVlJiYocGFyZW5zLT0xKSxpKz0xLHBuMT1wZWVrKGkpO3doaWxlKCgwIT09cGFyZW5zfHxcXFwiKVxcXCIhPT1wbi52YWx1ZSkmJlxcXCI9PlxcXCIhPT1wbjEudmFsdWUmJlxcXCI7XFxcIiE9PXBuMS52YWx1ZSYmXFxcIihlbmQpXFxcIiE9PXBuMS50eXBlKTtcXFwiZnVuY3Rpb25cXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQmJihzdGF0ZS50b2tlbnMubmV4dC5pbW1lZD0hMCk7dmFyIGV4cHJzPVtdO2lmKFxcXCIpXFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LmlkKWZvcig7Oyl7aWYoXFxcIj0+XFxcIj09PXBuMS52YWx1ZSYmXy5jb250YWlucyhbXFxcIntcXFwiLFxcXCJbXFxcIl0sc3RhdGUudG9rZW5zLm5leHQudmFsdWUpKXticmFja2V0PXN0YXRlLnRva2Vucy5uZXh0LGJyYWNrZXQubGVmdD1kZXN0cnVjdHVyaW5nRXhwcmVzc2lvbigpLGJyYWNrZXRzLnB1c2goYnJhY2tldCk7Zm9yKHZhciB0IGluIGJyYWNrZXQubGVmdClleHBycy5wdXNoKGJyYWNrZXQubGVmdFt0XS50b2tlbil9ZWxzZSBleHBycy5wdXNoKGV4cHJlc3Npb24oMTApKTtpZihcXFwiLFxcXCIhPT1zdGF0ZS50b2tlbnMubmV4dC5pZClicmVhaztjb21tYSgpfXJldHVybiBhZHZhbmNlKFxcXCIpXFxcIix0aGlzKSxzdGF0ZS5vcHRpb24uaW1tZWQmJmV4cHJzWzBdJiZcXFwiZnVuY3Rpb25cXFwiPT09ZXhwcnNbMF0uaWQmJlxcXCIoXFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LmlkJiYoXFxcIi5cXFwiIT09c3RhdGUudG9rZW5zLm5leHQuaWR8fFxcXCJjYWxsXFxcIiE9PXBlZWsoKS52YWx1ZSYmXFxcImFwcGx5XFxcIiE9PXBlZWsoKS52YWx1ZSkmJndhcm5pbmcoXFxcIlcwNjhcXFwiLHRoaXMpLFxcXCI9PlxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC52YWx1ZT9leHByczpleHBycy5sZW5ndGg/KGV4cHJzLmxlbmd0aD4xPyhyZXQ9T2JqZWN0LmNyZWF0ZShzdGF0ZS5zeW50YXhbXFxcIixcXFwiXSkscmV0LmV4cHJzPWV4cHJzKTpyZXQ9ZXhwcnNbMF0scmV0JiYocmV0LnBhcmVuPSEwKSxyZXQpOnZvaWQgMH0pLGFwcGxpY2F0aW9uKFxcXCI9PlxcXCIpLGluZml4KFxcXCJbXFxcIixmdW5jdGlvbihsZWZ0LHRoYXQpe3ZhciBzLGU9ZXhwcmVzc2lvbigxMCk7cmV0dXJuIGUmJlxcXCIoc3RyaW5nKVxcXCI9PT1lLnR5cGUmJihzdGF0ZS5vcHRpb24uZXZpbHx8XFxcImV2YWxcXFwiIT09ZS52YWx1ZSYmXFxcImV4ZWNTY3JpcHRcXFwiIT09ZS52YWx1ZXx8d2FybmluZyhcXFwiVzA2MVxcXCIsdGhhdCksY291bnRNZW1iZXIoZS52YWx1ZSksIXN0YXRlLm9wdGlvbi5zdWImJnJlZy5pZGVudGlmaWVyLnRlc3QoZS52YWx1ZSkmJihzPXN0YXRlLnN5bnRheFtlLnZhbHVlXSxzJiZpc1Jlc2VydmVkKHMpfHx3YXJuaW5nKFxcXCJXMDY5XFxcIixzdGF0ZS50b2tlbnMucHJldixlLnZhbHVlKSkpLGFkdmFuY2UoXFxcIl1cXFwiLHRoYXQpLGUmJlxcXCJoYXNPd25Qcm9wZXJ0eVxcXCI9PT1lLnZhbHVlJiZcXFwiPVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC52YWx1ZSYmd2FybmluZyhcXFwiVzAwMVxcXCIpLHRoYXQubGVmdD1sZWZ0LHRoYXQucmlnaHQ9ZSx0aGF0fSwxNjAsITApLHByZWZpeChcXFwiW1xcXCIsZnVuY3Rpb24oKXt2YXIgYmxvY2t0eXBlPWxvb2t1cEJsb2NrVHlwZSghMCk7aWYoYmxvY2t0eXBlLmlzQ29tcEFycmF5KXJldHVybiBzdGF0ZS5vcHRpb24uaW5FU05leHQoKXx8d2FybmluZyhcXFwiVzExOVxcXCIsc3RhdGUudG9rZW5zLmN1cnIsXFxcImFycmF5IGNvbXByZWhlbnNpb25cXFwiKSxjb21wcmVoZW5zaXZlQXJyYXlFeHByZXNzaW9uKCk7YmxvY2t0eXBlLmlzRGVzdEFzc2lnbiYmIXN0YXRlLm9wdGlvbi5pbkVTTmV4dCgpJiZ3YXJuaW5nKFxcXCJXMTA0XFxcIixzdGF0ZS50b2tlbnMuY3VycixcXFwiZGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50XFxcIik7dmFyIGI9c3RhdGUudG9rZW5zLmN1cnIubGluZSE9PXN0YXRlLnRva2Vucy5uZXh0LmxpbmU7Zm9yKHRoaXMuZmlyc3Q9W10sYiYmKGluZGVudCs9c3RhdGUub3B0aW9uLmluZGVudCxzdGF0ZS50b2tlbnMubmV4dC5mcm9tPT09aW5kZW50K3N0YXRlLm9wdGlvbi5pbmRlbnQmJihpbmRlbnQrPXN0YXRlLm9wdGlvbi5pbmRlbnQpKTtcXFwiKGVuZClcXFwiIT09c3RhdGUudG9rZW5zLm5leHQuaWQ7KXtmb3IoO1xcXCIsXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkOylzdGF0ZS5vcHRpb24uaW5FUzUoKXx8d2FybmluZyhcXFwiVzA3MFxcXCIpLGFkdmFuY2UoXFxcIixcXFwiKTtpZihcXFwiXVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZClicmVhaztpZih0aGlzLmZpcnN0LnB1c2goZXhwcmVzc2lvbigxMCkpLFxcXCIsXFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LmlkKWJyZWFrO2lmKGNvbW1hKHthbGxvd1RyYWlsaW5nOiEwfSksXFxcIl1cXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQmJiFzdGF0ZS5vcHRpb24uaW5FUzUoITApKXt3YXJuaW5nKFxcXCJXMDcwXFxcIixzdGF0ZS50b2tlbnMuY3Vycik7YnJlYWt9fXJldHVybiBiJiYoaW5kZW50LT1zdGF0ZS5vcHRpb24uaW5kZW50KSxhZHZhbmNlKFxcXCJdXFxcIix0aGlzKSx0aGlzfSwxNjApLGZ1bmN0aW9uKHgpe3gubnVkPWZ1bmN0aW9uKGlzY2xhc3NkZWYpe2Z1bmN0aW9uIHNhdmVQcm9wZXJ0eShuYW1lLHRrbil7cHJvcHNbbmFtZV0mJl8uaGFzKHByb3BzLG5hbWUpP3dhcm5pbmcoXFxcIlcwNzVcXFwiLHN0YXRlLnRva2Vucy5uZXh0LGkpOnByb3BzW25hbWVdPXt9LHByb3BzW25hbWVdLmJhc2ljPSEwLHByb3BzW25hbWVdLmJhc2ljdGtuPXRrbn1mdW5jdGlvbiBzYXZlU2V0dGVyKG5hbWUsdGtuKXtwcm9wc1tuYW1lXSYmXy5oYXMocHJvcHMsbmFtZSk/KHByb3BzW25hbWVdLmJhc2ljfHxwcm9wc1tuYW1lXS5zZXR0ZXIpJiZ3YXJuaW5nKFxcXCJXMDc1XFxcIixzdGF0ZS50b2tlbnMubmV4dCxpKTpwcm9wc1tuYW1lXT17fSxwcm9wc1tuYW1lXS5zZXR0ZXI9ITAscHJvcHNbbmFtZV0uc2V0dGVyVG9rZW49dGtufWZ1bmN0aW9uIHNhdmVHZXR0ZXIobmFtZSl7cHJvcHNbbmFtZV0mJl8uaGFzKHByb3BzLG5hbWUpPyhwcm9wc1tuYW1lXS5iYXNpY3x8cHJvcHNbbmFtZV0uZ2V0dGVyKSYmd2FybmluZyhcXFwiVzA3NVxcXCIsc3RhdGUudG9rZW5zLm5leHQsaSk6cHJvcHNbbmFtZV09e30scHJvcHNbbmFtZV0uZ2V0dGVyPSEwLHByb3BzW25hbWVdLmdldHRlclRva2VuPXN0YXRlLnRva2Vucy5jdXJyfXZhciBiLGYsaSxwLHQsZyxwcm9wcz17fSx0YWc9XFxcIlxcXCI7Zm9yKGI9c3RhdGUudG9rZW5zLmN1cnIubGluZSE9PXN0YXRlLnRva2Vucy5uZXh0LmxpbmUsYiYmKGluZGVudCs9c3RhdGUub3B0aW9uLmluZGVudCxzdGF0ZS50b2tlbnMubmV4dC5mcm9tPT09aW5kZW50K3N0YXRlLm9wdGlvbi5pbmRlbnQmJihpbmRlbnQrPXN0YXRlLm9wdGlvbi5pbmRlbnQpKTtcXFwifVxcXCIhPT1zdGF0ZS50b2tlbnMubmV4dC5pZDspe2lmKGlzY2xhc3NkZWYmJlxcXCJzdGF0aWNcXFwiPT09c3RhdGUudG9rZW5zLm5leHQudmFsdWUmJihhZHZhbmNlKFxcXCJzdGF0aWNcXFwiKSx0YWc9XFxcInN0YXRpYyBcXFwiKSxcXFwiZ2V0XFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlJiZcXFwiOlxcXCIhPT1wZWVrKCkuaWQpYWR2YW5jZShcXFwiZ2V0XFxcIiksc3RhdGUub3B0aW9uLmluRVM1KCFpc2NsYXNzZGVmKXx8ZXJyb3IoXFxcIkUwMzRcXFwiKSxpPXByb3BlcnR5X25hbWUoKSxpfHxzdGF0ZS5vcHRpb24uaW5FU05leHQoKXx8ZXJyb3IoXFxcIkUwMzVcXFwiKSxpc2NsYXNzZGVmJiZcXFwiY29uc3RydWN0b3JcXFwiPT09aSYmZXJyb3IoXFxcIkUwNDlcXFwiLHN0YXRlLnRva2Vucy5uZXh0LFxcXCJjbGFzcyBnZXR0ZXIgbWV0aG9kXFxcIixpKSxpJiZzYXZlR2V0dGVyKHRhZytpKSx0PXN0YXRlLnRva2Vucy5uZXh0LGY9ZG9GdW5jdGlvbigpLHA9ZltcXFwiKHBhcmFtcylcXFwiXSxpJiZwJiZ3YXJuaW5nKFxcXCJXMDc2XFxcIix0LHBbMF0saSk7ZWxzZSBpZihcXFwic2V0XFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlJiZcXFwiOlxcXCIhPT1wZWVrKCkuaWQpYWR2YW5jZShcXFwic2V0XFxcIiksc3RhdGUub3B0aW9uLmluRVM1KCFpc2NsYXNzZGVmKXx8ZXJyb3IoXFxcIkUwMzRcXFwiKSxpPXByb3BlcnR5X25hbWUoKSxpfHxzdGF0ZS5vcHRpb24uaW5FU05leHQoKXx8ZXJyb3IoXFxcIkUwMzVcXFwiKSxpc2NsYXNzZGVmJiZcXFwiY29uc3RydWN0b3JcXFwiPT09aSYmZXJyb3IoXFxcIkUwNDlcXFwiLHN0YXRlLnRva2Vucy5uZXh0LFxcXCJjbGFzcyBzZXR0ZXIgbWV0aG9kXFxcIixpKSxpJiZzYXZlU2V0dGVyKHRhZytpLHN0YXRlLnRva2Vucy5uZXh0KSx0PXN0YXRlLnRva2Vucy5uZXh0LGY9ZG9GdW5jdGlvbigpLHA9ZltcXFwiKHBhcmFtcylcXFwiXSwhaXx8cCYmMT09PXAubGVuZ3RofHx3YXJuaW5nKFxcXCJXMDc3XFxcIix0LGkpO2Vsc2V7aWYoZz0hMSxcXFwiKlxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC52YWx1ZSYmXFxcIihwdW5jdHVhdG9yKVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC50eXBlJiYoc3RhdGUub3B0aW9uLmluRVNOZXh0KCl8fHdhcm5pbmcoXFxcIlcxMDRcXFwiLHN0YXRlLnRva2Vucy5uZXh0LFxcXCJnZW5lcmF0b3IgZnVuY3Rpb25zXFxcIiksYWR2YW5jZShcXFwiKlxcXCIpLGc9ITApLGk9cHJvcGVydHlfbmFtZSgpLHNhdmVQcm9wZXJ0eSh0YWcraSxzdGF0ZS50b2tlbnMubmV4dCksXFxcInN0cmluZ1xcXCIhPXR5cGVvZiBpKWJyZWFrO1xcXCIoXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlPyhzdGF0ZS5vcHRpb24uaW5FU05leHQoKXx8d2FybmluZyhcXFwiVzEwNFxcXCIsc3RhdGUudG9rZW5zLmN1cnIsXFxcImNvbmNpc2UgbWV0aG9kc1xcXCIpLGRvRnVuY3Rpb24oaSx2b2lkIDAsZykpOmlzY2xhc3NkZWZ8fChhZHZhbmNlKFxcXCI6XFxcIiksZXhwcmVzc2lvbigxMCkpfWlmKGlzY2xhc3NkZWYmJlxcXCJwcm90b3R5cGVcXFwiPT09aSYmZXJyb3IoXFxcIkUwNDlcXFwiLHN0YXRlLnRva2Vucy5uZXh0LFxcXCJjbGFzcyBtZXRob2RcXFwiLGkpLGNvdW50TWVtYmVyKGkpLGlzY2xhc3NkZWYpdGFnPVxcXCJcXFwiO1xcbmVsc2V7aWYoXFxcIixcXFwiIT09c3RhdGUudG9rZW5zLm5leHQuaWQpYnJlYWs7Y29tbWEoe2FsbG93VHJhaWxpbmc6ITAscHJvcGVydHk6ITB9KSxcXFwiLFxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZD93YXJuaW5nKFxcXCJXMDcwXFxcIixzdGF0ZS50b2tlbnMuY3Vycik6XFxcIn1cXFwiIT09c3RhdGUudG9rZW5zLm5leHQuaWR8fHN0YXRlLm9wdGlvbi5pbkVTNSghMCl8fHdhcm5pbmcoXFxcIlcwNzBcXFwiLHN0YXRlLnRva2Vucy5jdXJyKX19aWYoYiYmKGluZGVudC09c3RhdGUub3B0aW9uLmluZGVudCksYWR2YW5jZShcXFwifVxcXCIsdGhpcyksc3RhdGUub3B0aW9uLmluRVM1KCkpZm9yKHZhciBuYW1lIGluIHByb3BzKV8uaGFzKHByb3BzLG5hbWUpJiZwcm9wc1tuYW1lXS5zZXR0ZXImJiFwcm9wc1tuYW1lXS5nZXR0ZXImJndhcm5pbmcoXFxcIlcwNzhcXFwiLHByb3BzW25hbWVdLnNldHRlclRva2VuKTtyZXR1cm4gdGhpc30seC5mdWQ9ZnVuY3Rpb24oKXtlcnJvcihcXFwiRTAzNlxcXCIsc3RhdGUudG9rZW5zLmN1cnIpfX0oZGVsaW0oXFxcIntcXFwiKSk7dmFyIGNvbnN0c3RhdGVtZW50PXN0bXQoXFxcImNvbnN0XFxcIixmdW5jdGlvbihwcmVmaXgpe3ZhciB0b2tlbnMsdmFsdWUsbG9uZTtmb3Ioc3RhdGUub3B0aW9uLmluRVNOZXh0KCl8fHdhcm5pbmcoXFxcIlcxMDRcXFwiLHN0YXRlLnRva2Vucy5jdXJyLFxcXCJjb25zdFxcXCIpLHRoaXMuZmlyc3Q9W107Oyl7dmFyIG5hbWVzPVtdO18uY29udGFpbnMoW1xcXCJ7XFxcIixcXFwiW1xcXCJdLHN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKT8odG9rZW5zPWRlc3RydWN0dXJpbmdFeHByZXNzaW9uKCksbG9uZT0hMSk6KHRva2Vucz1be2lkOmlkZW50aWZpZXIoKSx0b2tlbjpzdGF0ZS50b2tlbnMuY3Vycn1dLGxvbmU9ITApO2Zvcih2YXIgdCBpbiB0b2tlbnMpdG9rZW5zLmhhc093blByb3BlcnR5KHQpJiYodD10b2tlbnNbdF0sXFxcImNvbnN0XFxcIj09PWZ1bmN0W3QuaWRdJiZ3YXJuaW5nKFxcXCJFMDExXFxcIixudWxsLHQuaWQpLGZ1bmN0W1xcXCIoZ2xvYmFsKVxcXCJdJiZwcmVkZWZpbmVkW3QuaWRdPT09ITEmJndhcm5pbmcoXFxcIlcwNzlcXFwiLHQudG9rZW4sdC5pZCksdC5pZCYmKGFkZGxhYmVsKHQuaWQse3Rva2VuOnQudG9rZW4sdHlwZTpcXFwiY29uc3RcXFwiLHVudXNlZDohMH0pLG5hbWVzLnB1c2godC50b2tlbikpKTtpZihwcmVmaXgpYnJlYWs7aWYodGhpcy5maXJzdD10aGlzLmZpcnN0LmNvbmNhdChuYW1lcyksXFxcIj1cXFwiIT09c3RhdGUudG9rZW5zLm5leHQuaWQmJndhcm5pbmcoXFxcIkUwMTJcXFwiLHN0YXRlLnRva2Vucy5jdXJyLHN0YXRlLnRva2Vucy5jdXJyLnZhbHVlKSxcXFwiPVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZCYmKGFkdmFuY2UoXFxcIj1cXFwiKSxcXFwidW5kZWZpbmVkXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkJiZ3YXJuaW5nKFxcXCJXMDgwXFxcIixzdGF0ZS50b2tlbnMucHJldixzdGF0ZS50b2tlbnMucHJldi52YWx1ZSksXFxcIj1cXFwiPT09cGVlaygwKS5pZCYmc3RhdGUudG9rZW5zLm5leHQuaWRlbnRpZmllciYmd2FybmluZyhcXFwiVzEyMFxcXCIsc3RhdGUudG9rZW5zLm5leHQsc3RhdGUudG9rZW5zLm5leHQudmFsdWUpLHZhbHVlPWV4cHJlc3Npb24oMTApLGxvbmU/dG9rZW5zWzBdLmZpcnN0PXZhbHVlOmRlc3RydWN0dXJpbmdFeHByZXNzaW9uTWF0Y2gobmFtZXMsdmFsdWUpKSxcXFwiLFxcXCIhPT1zdGF0ZS50b2tlbnMubmV4dC5pZClicmVhaztjb21tYSgpfXJldHVybiB0aGlzfSk7Y29uc3RzdGF0ZW1lbnQuZXhwcz0hMDt2YXIgdmFyc3RhdGVtZW50PXN0bXQoXFxcInZhclxcXCIsZnVuY3Rpb24ocHJlZml4KXt2YXIgdG9rZW5zLGxvbmUsdmFsdWU7Zm9yKHRoaXMuZmlyc3Q9W107Oyl7dmFyIG5hbWVzPVtdO18uY29udGFpbnMoW1xcXCJ7XFxcIixcXFwiW1xcXCJdLHN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKT8odG9rZW5zPWRlc3RydWN0dXJpbmdFeHByZXNzaW9uKCksbG9uZT0hMSk6KHRva2Vucz1be2lkOmlkZW50aWZpZXIoKSx0b2tlbjpzdGF0ZS50b2tlbnMuY3Vycn1dLGxvbmU9ITApO2Zvcih2YXIgdCBpbiB0b2tlbnMpdG9rZW5zLmhhc093blByb3BlcnR5KHQpJiYodD10b2tlbnNbdF0sc3RhdGUub3B0aW9uLmluRVNOZXh0KCkmJlxcXCJjb25zdFxcXCI9PT1mdW5jdFt0LmlkXSYmd2FybmluZyhcXFwiRTAxMVxcXCIsbnVsbCx0LmlkKSxmdW5jdFtcXFwiKGdsb2JhbClcXFwiXSYmcHJlZGVmaW5lZFt0LmlkXT09PSExJiZ3YXJuaW5nKFxcXCJXMDc5XFxcIix0LnRva2VuLHQuaWQpLHQuaWQmJihhZGRsYWJlbCh0LmlkLHt0eXBlOlxcXCJ1bnVzZWRcXFwiLHRva2VuOnQudG9rZW59KSxuYW1lcy5wdXNoKHQudG9rZW4pKSk7aWYocHJlZml4KWJyZWFrO2lmKHRoaXMuZmlyc3Q9dGhpcy5maXJzdC5jb25jYXQobmFtZXMpLFxcXCI9XFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkJiYoYWR2YW5jZShcXFwiPVxcXCIpLFxcXCJ1bmRlZmluZWRcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQmJndhcm5pbmcoXFxcIlcwODBcXFwiLHN0YXRlLnRva2Vucy5wcmV2LHN0YXRlLnRva2Vucy5wcmV2LnZhbHVlKSxcXFwiPVxcXCI9PT1wZWVrKDApLmlkJiZzdGF0ZS50b2tlbnMubmV4dC5pZGVudGlmaWVyJiZ3YXJuaW5nKFxcXCJXMTIwXFxcIixzdGF0ZS50b2tlbnMubmV4dCxzdGF0ZS50b2tlbnMubmV4dC52YWx1ZSksdmFsdWU9ZXhwcmVzc2lvbigxMCksbG9uZT90b2tlbnNbMF0uZmlyc3Q9dmFsdWU6ZGVzdHJ1Y3R1cmluZ0V4cHJlc3Npb25NYXRjaChuYW1lcyx2YWx1ZSkpLFxcXCIsXFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LmlkKWJyZWFrO2NvbW1hKCl9cmV0dXJuIHRoaXN9KTt2YXJzdGF0ZW1lbnQuZXhwcz0hMDt2YXIgbGV0c3RhdGVtZW50PXN0bXQoXFxcImxldFxcXCIsZnVuY3Rpb24ocHJlZml4KXt2YXIgdG9rZW5zLGxvbmUsdmFsdWUsbGV0YmxvY2s7Zm9yKHN0YXRlLm9wdGlvbi5pbkVTTmV4dCgpfHx3YXJuaW5nKFxcXCJXMTA0XFxcIixzdGF0ZS50b2tlbnMuY3VycixcXFwibGV0XFxcIiksXFxcIihcXFwiPT09c3RhdGUudG9rZW5zLm5leHQudmFsdWU/KHN0YXRlLm9wdGlvbi5pbk1veighMCl8fHdhcm5pbmcoXFxcIlcxMThcXFwiLHN0YXRlLnRva2Vucy5uZXh0LFxcXCJsZXQgYmxvY2tcXFwiKSxhZHZhbmNlKFxcXCIoXFxcIiksZnVuY3RbXFxcIihibG9ja3Njb3BlKVxcXCJdLnN0YWNrKCksbGV0YmxvY2s9ITApOmZ1bmN0W1xcXCIobm9sZXQpXFxcIl0mJmVycm9yKFxcXCJFMDQ4XFxcIixzdGF0ZS50b2tlbnMuY3VyciksdGhpcy5maXJzdD1bXTs7KXt2YXIgbmFtZXM9W107Xy5jb250YWlucyhbXFxcIntcXFwiLFxcXCJbXFxcIl0sc3RhdGUudG9rZW5zLm5leHQudmFsdWUpPyh0b2tlbnM9ZGVzdHJ1Y3R1cmluZ0V4cHJlc3Npb24oKSxsb25lPSExKToodG9rZW5zPVt7aWQ6aWRlbnRpZmllcigpLHRva2VuOnN0YXRlLnRva2Vucy5jdXJyLnZhbHVlfV0sbG9uZT0hMCk7Zm9yKHZhciB0IGluIHRva2Vucyl0b2tlbnMuaGFzT3duUHJvcGVydHkodCkmJih0PXRva2Vuc1t0XSxzdGF0ZS5vcHRpb24uaW5FU05leHQoKSYmXFxcImNvbnN0XFxcIj09PWZ1bmN0W3QuaWRdJiZ3YXJuaW5nKFxcXCJFMDExXFxcIixudWxsLHQuaWQpLGZ1bmN0W1xcXCIoZ2xvYmFsKVxcXCJdJiZwcmVkZWZpbmVkW3QuaWRdPT09ITEmJndhcm5pbmcoXFxcIlcwNzlcXFwiLHQudG9rZW4sdC5pZCksdC5pZCYmIWZ1bmN0W1xcXCIobm9sZXQpXFxcIl0mJihhZGRsYWJlbCh0LmlkLHt0eXBlOlxcXCJ1bnVzZWRcXFwiLHRva2VuOnQudG9rZW4saXNsZXQ6ITB9KSxuYW1lcy5wdXNoKHQudG9rZW4pKSk7aWYocHJlZml4KWJyZWFrO2lmKHRoaXMuZmlyc3Q9dGhpcy5maXJzdC5jb25jYXQobmFtZXMpLFxcXCI9XFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkJiYoYWR2YW5jZShcXFwiPVxcXCIpLFxcXCJ1bmRlZmluZWRcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQmJndhcm5pbmcoXFxcIlcwODBcXFwiLHN0YXRlLnRva2Vucy5wcmV2LHN0YXRlLnRva2Vucy5wcmV2LnZhbHVlKSxcXFwiPVxcXCI9PT1wZWVrKDApLmlkJiZzdGF0ZS50b2tlbnMubmV4dC5pZGVudGlmaWVyJiZ3YXJuaW5nKFxcXCJXMTIwXFxcIixzdGF0ZS50b2tlbnMubmV4dCxzdGF0ZS50b2tlbnMubmV4dC52YWx1ZSksdmFsdWU9ZXhwcmVzc2lvbigxMCksbG9uZT90b2tlbnNbMF0uZmlyc3Q9dmFsdWU6ZGVzdHJ1Y3R1cmluZ0V4cHJlc3Npb25NYXRjaChuYW1lcyx2YWx1ZSkpLFxcXCIsXFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LmlkKWJyZWFrO2NvbW1hKCl9cmV0dXJuIGxldGJsb2NrJiYoYWR2YW5jZShcXFwiKVxcXCIpLGJsb2NrKCEwLCEwKSx0aGlzLmJsb2NrPSEwLGZ1bmN0W1xcXCIoYmxvY2tzY29wZSlcXFwiXS51bnN0YWNrKCkpLHRoaXN9KTtsZXRzdGF0ZW1lbnQuZXhwcz0hMCxibG9ja3N0bXQoXFxcImNsYXNzXFxcIixmdW5jdGlvbigpe3JldHVybiBjbGFzc2RlZi5jYWxsKHRoaXMsITApfSksYmxvY2tzdG10KFxcXCJmdW5jdGlvblxcXCIsZnVuY3Rpb24oKXt2YXIgZ2VuZXJhdG9yPSExO1xcXCIqXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlJiYoYWR2YW5jZShcXFwiKlxcXCIpLHN0YXRlLm9wdGlvbi5pbkVTTmV4dCghMCk/Z2VuZXJhdG9yPSEwOndhcm5pbmcoXFxcIlcxMTlcXFwiLHN0YXRlLnRva2Vucy5jdXJyLFxcXCJmdW5jdGlvbipcXFwiKSksaW5ibG9jayYmd2FybmluZyhcXFwiVzA4MlxcXCIsc3RhdGUudG9rZW5zLmN1cnIpO3ZhciBpPWlkZW50aWZpZXIoKTtyZXR1cm5cXFwiY29uc3RcXFwiPT09ZnVuY3RbaV0mJndhcm5pbmcoXFxcIkUwMTFcXFwiLG51bGwsaSksYWRkbGFiZWwoaSx7dHlwZTpcXFwidW5jdGlvblxcXCIsdG9rZW46c3RhdGUudG9rZW5zLmN1cnJ9KSxkb0Z1bmN0aW9uKGkse3N0YXRlbWVudDohMH0sZ2VuZXJhdG9yKSxcXFwiKFxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZCYmc3RhdGUudG9rZW5zLm5leHQubGluZT09PXN0YXRlLnRva2Vucy5jdXJyLmxpbmUmJmVycm9yKFxcXCJFMDM5XFxcIiksdGhpc30pLHByZWZpeChcXFwiZnVuY3Rpb25cXFwiLGZ1bmN0aW9uKCl7dmFyIGdlbmVyYXRvcj0hMTtcXFwiKlxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC52YWx1ZSYmKHN0YXRlLm9wdGlvbi5pbkVTTmV4dCgpfHx3YXJuaW5nKFxcXCJXMTE5XFxcIixzdGF0ZS50b2tlbnMuY3VycixcXFwiZnVuY3Rpb24qXFxcIiksYWR2YW5jZShcXFwiKlxcXCIpLGdlbmVyYXRvcj0hMCk7dmFyIGk9b3B0aW9uYWxpZGVudGlmaWVyKCk7cmV0dXJuIGRvRnVuY3Rpb24oaSx2b2lkIDAsZ2VuZXJhdG9yKSwhc3RhdGUub3B0aW9uLmxvb3BmdW5jJiZmdW5jdFtcXFwiKGxvb3BhZ2UpXFxcIl0mJndhcm5pbmcoXFxcIlcwODNcXFwiKSx0aGlzfSksYmxvY2tzdG10KFxcXCJpZlxcXCIsZnVuY3Rpb24oKXt2YXIgdD1zdGF0ZS50b2tlbnMubmV4dDtyZXR1cm4gaW5jcmVhc2VDb21wbGV4aXR5Q291bnQoKSxzdGF0ZS5jb25kaXRpb249ITAsYWR2YW5jZShcXFwiKFxcXCIpLGNoZWNrQ29uZEFzc2lnbm1lbnQoZXhwcmVzc2lvbigwKSksYWR2YW5jZShcXFwiKVxcXCIsdCksc3RhdGUuY29uZGl0aW9uPSExLGJsb2NrKCEwLCEwKSxcXFwiZWxzZVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZCYmKGFkdmFuY2UoXFxcImVsc2VcXFwiKSxcXFwiaWZcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWR8fFxcXCJzd2l0Y2hcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQ/c3RhdGVtZW50KCEwKTpibG9jayghMCwhMCkpLHRoaXN9KSxibG9ja3N0bXQoXFxcInRyeVxcXCIsZnVuY3Rpb24oKXtmdW5jdGlvbiBkb0NhdGNoKCl7dmFyIGUsb2xkU2NvcGU9c2NvcGU7YWR2YW5jZShcXFwiY2F0Y2hcXFwiKSxhZHZhbmNlKFxcXCIoXFxcIiksc2NvcGU9T2JqZWN0LmNyZWF0ZShvbGRTY29wZSksZT1zdGF0ZS50b2tlbnMubmV4dC52YWx1ZSxcXFwiKGlkZW50aWZpZXIpXFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LnR5cGUmJihlPW51bGwsd2FybmluZyhcXFwiRTAzMFxcXCIsc3RhdGUudG9rZW5zLm5leHQsZSkpLGFkdmFuY2UoKSxmdW5jdD1mdW5jdG9yKFxcXCIoY2F0Y2gpXFxcIixzdGF0ZS50b2tlbnMubmV4dCxzY29wZSx7XFxcIihjb250ZXh0KVxcXCI6ZnVuY3QsXFxcIihicmVha2FnZSlcXFwiOmZ1bmN0W1xcXCIoYnJlYWthZ2UpXFxcIl0sXFxcIihsb29wYWdlKVxcXCI6ZnVuY3RbXFxcIihsb29wYWdlKVxcXCJdLFxcXCIoc3RhdGVtZW50KVxcXCI6ITEsXFxcIihjYXRjaClcXFwiOiEwfSksZSYmYWRkbGFiZWwoZSx7dHlwZTpcXFwiZXhjZXB0aW9uXFxcIn0pLFxcXCJpZlxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC52YWx1ZSYmKHN0YXRlLm9wdGlvbi5pbk1veighMCl8fHdhcm5pbmcoXFxcIlcxMThcXFwiLHN0YXRlLnRva2Vucy5jdXJyLFxcXCJjYXRjaCBmaWx0ZXJcXFwiKSxhZHZhbmNlKFxcXCJpZlxcXCIpLGV4cHJlc3Npb24oMCkpLGFkdmFuY2UoXFxcIilcXFwiKSxzdGF0ZS50b2tlbnMuY3Vyci5mdW5jdD1mdW5jdCxmdW5jdGlvbnMucHVzaChmdW5jdCksYmxvY2soITEpLHNjb3BlPW9sZFNjb3BlLGZ1bmN0W1xcXCIobGFzdClcXFwiXT1zdGF0ZS50b2tlbnMuY3Vyci5saW5lLGZ1bmN0W1xcXCIobGFzdGNoYXJhY3RlcilcXFwiXT1zdGF0ZS50b2tlbnMuY3Vyci5jaGFyYWN0ZXIsZnVuY3Q9ZnVuY3RbXFxcIihjb250ZXh0KVxcXCJdfXZhciBiO2ZvcihibG9jayghMCk7XFxcImNhdGNoXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkOylpbmNyZWFzZUNvbXBsZXhpdHlDb3VudCgpLGImJiFzdGF0ZS5vcHRpb24uaW5Nb3ooITApJiZ3YXJuaW5nKFxcXCJXMTE4XFxcIixzdGF0ZS50b2tlbnMubmV4dCxcXFwibXVsdGlwbGUgY2F0Y2ggYmxvY2tzXFxcIiksZG9DYXRjaCgpLGI9ITA7cmV0dXJuXFxcImZpbmFsbHlcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQ/KGFkdmFuY2UoXFxcImZpbmFsbHlcXFwiKSxibG9jayghMCksdm9pZCAwKTooYnx8ZXJyb3IoXFxcIkUwMjFcXFwiLHN0YXRlLnRva2Vucy5uZXh0LFxcXCJjYXRjaFxcXCIsc3RhdGUudG9rZW5zLm5leHQudmFsdWUpLHRoaXMpfSksYmxvY2tzdG10KFxcXCJ3aGlsZVxcXCIsZnVuY3Rpb24oKXt2YXIgdD1zdGF0ZS50b2tlbnMubmV4dDtyZXR1cm4gZnVuY3RbXFxcIihicmVha2FnZSlcXFwiXSs9MSxmdW5jdFtcXFwiKGxvb3BhZ2UpXFxcIl0rPTEsaW5jcmVhc2VDb21wbGV4aXR5Q291bnQoKSxhZHZhbmNlKFxcXCIoXFxcIiksY2hlY2tDb25kQXNzaWdubWVudChleHByZXNzaW9uKDApKSxhZHZhbmNlKFxcXCIpXFxcIix0KSxibG9jayghMCwhMCksZnVuY3RbXFxcIihicmVha2FnZSlcXFwiXS09MSxmdW5jdFtcXFwiKGxvb3BhZ2UpXFxcIl0tPTEsdGhpc30pLmxhYmVsbGVkPSEwLGJsb2Nrc3RtdChcXFwid2l0aFxcXCIsZnVuY3Rpb24oKXt2YXIgdD1zdGF0ZS50b2tlbnMubmV4dDtyZXR1cm4gc3RhdGUuZGlyZWN0aXZlW1xcXCJ1c2Ugc3RyaWN0XFxcIl0/ZXJyb3IoXFxcIkUwMTBcXFwiLHN0YXRlLnRva2Vucy5jdXJyKTpzdGF0ZS5vcHRpb24ud2l0aHN0bXR8fHdhcm5pbmcoXFxcIlcwODVcXFwiLHN0YXRlLnRva2Vucy5jdXJyKSxhZHZhbmNlKFxcXCIoXFxcIiksZXhwcmVzc2lvbigwKSxhZHZhbmNlKFxcXCIpXFxcIix0KSxibG9jayghMCwhMCksdGhpc30pLGJsb2Nrc3RtdChcXFwic3dpdGNoXFxcIixmdW5jdGlvbigpe3ZhciB0PXN0YXRlLnRva2Vucy5uZXh0LGc9ITEsbm9pbmRlbnQ9ITE7Zm9yKGZ1bmN0W1xcXCIoYnJlYWthZ2UpXFxcIl0rPTEsYWR2YW5jZShcXFwiKFxcXCIpLGNoZWNrQ29uZEFzc2lnbm1lbnQoZXhwcmVzc2lvbigwKSksYWR2YW5jZShcXFwiKVxcXCIsdCksdD1zdGF0ZS50b2tlbnMubmV4dCxhZHZhbmNlKFxcXCJ7XFxcIiksc3RhdGUudG9rZW5zLm5leHQuZnJvbT09PWluZGVudCYmKG5vaW5kZW50PSEwKSxub2luZGVudHx8KGluZGVudCs9c3RhdGUub3B0aW9uLmluZGVudCksdGhpcy5jYXNlcz1bXTs7KXN3aXRjaChzdGF0ZS50b2tlbnMubmV4dC5pZCl7Y2FzZVxcXCJjYXNlXFxcIjpzd2l0Y2goZnVuY3RbXFxcIih2ZXJiKVxcXCJdKXtjYXNlXFxcInlpZWxkXFxcIjpjYXNlXFxcImJyZWFrXFxcIjpjYXNlXFxcImNhc2VcXFwiOmNhc2VcXFwiY29udGludWVcXFwiOmNhc2VcXFwicmV0dXJuXFxcIjpjYXNlXFxcInN3aXRjaFxcXCI6Y2FzZVxcXCJ0aHJvd1xcXCI6YnJlYWs7ZGVmYXVsdDpyZWcuZmFsbHNUaHJvdWdoLnRlc3Qoc3RhdGUubGluZXNbc3RhdGUudG9rZW5zLm5leHQubGluZS0yXSl8fHdhcm5pbmcoXFxcIlcwODZcXFwiLHN0YXRlLnRva2Vucy5jdXJyLFxcXCJjYXNlXFxcIil9YWR2YW5jZShcXFwiY2FzZVxcXCIpLHRoaXMuY2FzZXMucHVzaChleHByZXNzaW9uKDApKSxpbmNyZWFzZUNvbXBsZXhpdHlDb3VudCgpLGc9ITAsYWR2YW5jZShcXFwiOlxcXCIpLGZ1bmN0W1xcXCIodmVyYilcXFwiXT1cXFwiY2FzZVxcXCI7YnJlYWs7Y2FzZVxcXCJkZWZhdWx0XFxcIjpzd2l0Y2goZnVuY3RbXFxcIih2ZXJiKVxcXCJdKXtjYXNlXFxcInlpZWxkXFxcIjpjYXNlXFxcImJyZWFrXFxcIjpjYXNlXFxcImNvbnRpbnVlXFxcIjpjYXNlXFxcInJldHVyblxcXCI6Y2FzZVxcXCJ0aHJvd1xcXCI6YnJlYWs7ZGVmYXVsdDp0aGlzLmNhc2VzLmxlbmd0aCYmKHJlZy5mYWxsc1Rocm91Z2gudGVzdChzdGF0ZS5saW5lc1tzdGF0ZS50b2tlbnMubmV4dC5saW5lLTJdKXx8d2FybmluZyhcXFwiVzA4NlxcXCIsc3RhdGUudG9rZW5zLmN1cnIsXFxcImRlZmF1bHRcXFwiKSl9YWR2YW5jZShcXFwiZGVmYXVsdFxcXCIpLGc9ITAsYWR2YW5jZShcXFwiOlxcXCIpO2JyZWFrO2Nhc2VcXFwifVxcXCI6cmV0dXJuIG5vaW5kZW50fHwoaW5kZW50LT1zdGF0ZS5vcHRpb24uaW5kZW50KSxhZHZhbmNlKFxcXCJ9XFxcIix0KSxmdW5jdFtcXFwiKGJyZWFrYWdlKVxcXCJdLT0xLGZ1bmN0W1xcXCIodmVyYilcXFwiXT12b2lkIDAsdm9pZCAwO2Nhc2VcXFwiKGVuZClcXFwiOnJldHVybiBlcnJvcihcXFwiRTAyM1xcXCIsc3RhdGUudG9rZW5zLm5leHQsXFxcIn1cXFwiKSx2b2lkIDA7ZGVmYXVsdDppZihpbmRlbnQrPXN0YXRlLm9wdGlvbi5pbmRlbnQsZylzd2l0Y2goc3RhdGUudG9rZW5zLmN1cnIuaWQpe2Nhc2VcXFwiLFxcXCI6cmV0dXJuIGVycm9yKFxcXCJFMDQwXFxcIiksdm9pZCAwO2Nhc2VcXFwiOlxcXCI6Zz0hMSxzdGF0ZW1lbnRzKCk7YnJlYWs7ZGVmYXVsdDpyZXR1cm4gZXJyb3IoXFxcIkUwMjVcXFwiLHN0YXRlLnRva2Vucy5jdXJyKSx2b2lkIDB9ZWxzZXtpZihcXFwiOlxcXCIhPT1zdGF0ZS50b2tlbnMuY3Vyci5pZClyZXR1cm4gZXJyb3IoXFxcIkUwMjFcXFwiLHN0YXRlLnRva2Vucy5uZXh0LFxcXCJjYXNlXFxcIixzdGF0ZS50b2tlbnMubmV4dC52YWx1ZSksdm9pZCAwO2FkdmFuY2UoXFxcIjpcXFwiKSxlcnJvcihcXFwiRTAyNFxcXCIsc3RhdGUudG9rZW5zLmN1cnIsXFxcIjpcXFwiKSxzdGF0ZW1lbnRzKCl9aW5kZW50LT1zdGF0ZS5vcHRpb24uaW5kZW50fX0pLmxhYmVsbGVkPSEwLHN0bXQoXFxcImRlYnVnZ2VyXFxcIixmdW5jdGlvbigpe3JldHVybiBzdGF0ZS5vcHRpb24uZGVidWd8fHdhcm5pbmcoXFxcIlcwODdcXFwiLHRoaXMpLHRoaXN9KS5leHBzPSEwLGZ1bmN0aW9uKCl7dmFyIHg9c3RtdChcXFwiZG9cXFwiLGZ1bmN0aW9uKCl7ZnVuY3RbXFxcIihicmVha2FnZSlcXFwiXSs9MSxmdW5jdFtcXFwiKGxvb3BhZ2UpXFxcIl0rPTEsaW5jcmVhc2VDb21wbGV4aXR5Q291bnQoKSx0aGlzLmZpcnN0PWJsb2NrKCEwLCEwKSxhZHZhbmNlKFxcXCJ3aGlsZVxcXCIpO3ZhciB0PXN0YXRlLnRva2Vucy5uZXh0O3JldHVybiBhZHZhbmNlKFxcXCIoXFxcIiksY2hlY2tDb25kQXNzaWdubWVudChleHByZXNzaW9uKDApKSxhZHZhbmNlKFxcXCIpXFxcIix0KSxmdW5jdFtcXFwiKGJyZWFrYWdlKVxcXCJdLT0xLGZ1bmN0W1xcXCIobG9vcGFnZSlcXFwiXS09MSx0aGlzfSk7eC5sYWJlbGxlZD0hMCx4LmV4cHM9ITB9KCksYmxvY2tzdG10KFxcXCJmb3JcXFwiLGZ1bmN0aW9uKCl7dmFyIHMsdD1zdGF0ZS50b2tlbnMubmV4dCxsZXRzY29wZT0hMSxmb3JlYWNodG9rPW51bGw7XFxcImVhY2hcXFwiPT09dC52YWx1ZSYmKGZvcmVhY2h0b2s9dCxhZHZhbmNlKFxcXCJlYWNoXFxcIiksc3RhdGUub3B0aW9uLmluTW96KCEwKXx8d2FybmluZyhcXFwiVzExOFxcXCIsc3RhdGUudG9rZW5zLmN1cnIsXFxcImZvciBlYWNoXFxcIikpLGZ1bmN0W1xcXCIoYnJlYWthZ2UpXFxcIl0rPTEsZnVuY3RbXFxcIihsb29wYWdlKVxcXCJdKz0xLGluY3JlYXNlQ29tcGxleGl0eUNvdW50KCksYWR2YW5jZShcXFwiKFxcXCIpO3ZhciBuZXh0b3AsaT0wLGlub2Y9W1xcXCJpblxcXCIsXFxcIm9mXFxcIl07ZG8gbmV4dG9wPXBlZWsoaSksKytpO3doaWxlKCFfLmNvbnRhaW5zKGlub2YsbmV4dG9wLnZhbHVlKSYmXFxcIjtcXFwiIT09bmV4dG9wLnZhbHVlJiZcXFwiKGVuZClcXFwiIT09bmV4dG9wLnR5cGUpO2lmKF8uY29udGFpbnMoaW5vZixuZXh0b3AudmFsdWUpKXtpZihzdGF0ZS5vcHRpb24uaW5FU05leHQoKXx8XFxcIm9mXFxcIiE9PW5leHRvcC52YWx1ZXx8ZXJyb3IoXFxcIlcxMDRcXFwiLG5leHRvcCxcXFwiZm9yIG9mXFxcIiksXFxcInZhclxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZClhZHZhbmNlKFxcXCJ2YXJcXFwiKSxzdGF0ZS5zeW50YXhbXFxcInZhclxcXCJdLmZ1ZC5jYWxsKHN0YXRlLnN5bnRheFtcXFwidmFyXFxcIl0uZnVkLCEwKTtlbHNlIGlmKFxcXCJsZXRcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQpYWR2YW5jZShcXFwibGV0XFxcIiksbGV0c2NvcGU9ITAsZnVuY3RbXFxcIihibG9ja3Njb3BlKVxcXCJdLnN0YWNrKCksc3RhdGUuc3ludGF4LmxldC5mdWQuY2FsbChzdGF0ZS5zeW50YXgubGV0LmZ1ZCwhMCk7ZWxzZSBpZihzdGF0ZS50b2tlbnMubmV4dC5pZGVudGlmaWVyKXtzd2l0Y2goZnVuY3Rbc3RhdGUudG9rZW5zLm5leHQudmFsdWVdKXtjYXNlXFxcInVudXNlZFxcXCI6ZnVuY3Rbc3RhdGUudG9rZW5zLm5leHQudmFsdWVdPVxcXCJ2YXJcXFwiO2JyZWFrO2Nhc2VcXFwidmFyXFxcIjpicmVhaztkZWZhdWx0OmZ1bmN0W1xcXCIoYmxvY2tzY29wZSlcXFwiXS5nZXRsYWJlbChzdGF0ZS50b2tlbnMubmV4dC52YWx1ZSl8fHdhcm5pbmcoXFxcIlcwODhcXFwiLHN0YXRlLnRva2Vucy5uZXh0LHN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKX1hZHZhbmNlKCl9ZWxzZSBlcnJvcihcXFwiRTAzMFxcXCIsc3RhdGUudG9rZW5zLm5leHQsc3RhdGUudG9rZW5zLm5leHQudHlwZSksYWR2YW5jZSgpO2FkdmFuY2UobmV4dG9wLnZhbHVlKSxleHByZXNzaW9uKDIwKSxhZHZhbmNlKFxcXCIpXFxcIix0KSxzPWJsb2NrKCEwLCEwKSxzdGF0ZS5vcHRpb24uZm9yaW4mJnMmJihzLmxlbmd0aD4xfHxcXFwib2JqZWN0XFxcIiE9dHlwZW9mIHNbMF18fFxcXCJpZlxcXCIhPT1zWzBdLnZhbHVlKSYmd2FybmluZyhcXFwiVzA4OVxcXCIsdGhpcyksZnVuY3RbXFxcIihicmVha2FnZSlcXFwiXS09MSxmdW5jdFtcXFwiKGxvb3BhZ2UpXFxcIl0tPTF9ZWxzZXtpZihmb3JlYWNodG9rJiZlcnJvcihcXFwiRTA0NVxcXCIsZm9yZWFjaHRvayksXFxcIjtcXFwiIT09c3RhdGUudG9rZW5zLm5leHQuaWQpaWYoXFxcInZhclxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZClhZHZhbmNlKFxcXCJ2YXJcXFwiKSxzdGF0ZS5zeW50YXhbXFxcInZhclxcXCJdLmZ1ZC5jYWxsKHN0YXRlLnN5bnRheFtcXFwidmFyXFxcIl0uZnVkKTtlbHNlIGlmKFxcXCJsZXRcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQpYWR2YW5jZShcXFwibGV0XFxcIiksbGV0c2NvcGU9ITAsZnVuY3RbXFxcIihibG9ja3Njb3BlKVxcXCJdLnN0YWNrKCksc3RhdGUuc3ludGF4LmxldC5mdWQuY2FsbChzdGF0ZS5zeW50YXgubGV0LmZ1ZCk7ZWxzZSBmb3IoO2V4cHJlc3Npb24oMCxcXFwiZm9yXFxcIiksXFxcIixcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQ7KWNvbW1hKCk7aWYobm9saW5lYnJlYWsoc3RhdGUudG9rZW5zLmN1cnIpLGFkdmFuY2UoXFxcIjtcXFwiKSxcXFwiO1xcXCIhPT1zdGF0ZS50b2tlbnMubmV4dC5pZCYmY2hlY2tDb25kQXNzaWdubWVudChleHByZXNzaW9uKDApKSxub2xpbmVicmVhayhzdGF0ZS50b2tlbnMuY3VyciksYWR2YW5jZShcXFwiO1xcXCIpLFxcXCI7XFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkJiZlcnJvcihcXFwiRTAyMVxcXCIsc3RhdGUudG9rZW5zLm5leHQsXFxcIilcXFwiLFxcXCI7XFxcIiksXFxcIilcXFwiIT09c3RhdGUudG9rZW5zLm5leHQuaWQpZm9yKDtleHByZXNzaW9uKDAsXFxcImZvclxcXCIpLFxcXCIsXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkOyljb21tYSgpO2FkdmFuY2UoXFxcIilcXFwiLHQpLGJsb2NrKCEwLCEwKSxmdW5jdFtcXFwiKGJyZWFrYWdlKVxcXCJdLT0xLGZ1bmN0W1xcXCIobG9vcGFnZSlcXFwiXS09MX1yZXR1cm4gbGV0c2NvcGUmJmZ1bmN0W1xcXCIoYmxvY2tzY29wZSlcXFwiXS51bnN0YWNrKCksdGhpc30pLmxhYmVsbGVkPSEwLHN0bXQoXFxcImJyZWFrXFxcIixmdW5jdGlvbigpe3ZhciB2PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlO3JldHVybiAwPT09ZnVuY3RbXFxcIihicmVha2FnZSlcXFwiXSYmd2FybmluZyhcXFwiVzA1MlxcXCIsc3RhdGUudG9rZW5zLm5leHQsdGhpcy52YWx1ZSksc3RhdGUub3B0aW9uLmFzaXx8bm9saW5lYnJlYWsodGhpcyksXFxcIjtcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWR8fHN0YXRlLnRva2Vucy5uZXh0LnJlYWNofHxzdGF0ZS50b2tlbnMuY3Vyci5saW5lPT09c3RhdGUudG9rZW5zLm5leHQubGluZSYmKFxcXCJsYWJlbFxcXCIhPT1mdW5jdFt2XT93YXJuaW5nKFxcXCJXMDkwXFxcIixzdGF0ZS50b2tlbnMubmV4dCx2KTpzY29wZVt2XSE9PWZ1bmN0JiZ3YXJuaW5nKFxcXCJXMDkxXFxcIixzdGF0ZS50b2tlbnMubmV4dCx2KSx0aGlzLmZpcnN0PXN0YXRlLnRva2Vucy5uZXh0LGFkdmFuY2UoKSkscmVhY2hhYmxlKFxcXCJicmVha1xcXCIpLHRoaXN9KS5leHBzPSEwLHN0bXQoXFxcImNvbnRpbnVlXFxcIixmdW5jdGlvbigpe3ZhciB2PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlO3JldHVybiAwPT09ZnVuY3RbXFxcIihicmVha2FnZSlcXFwiXSYmd2FybmluZyhcXFwiVzA1MlxcXCIsc3RhdGUudG9rZW5zLm5leHQsdGhpcy52YWx1ZSksc3RhdGUub3B0aW9uLmFzaXx8bm9saW5lYnJlYWsodGhpcyksXFxcIjtcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWR8fHN0YXRlLnRva2Vucy5uZXh0LnJlYWNoP2Z1bmN0W1xcXCIobG9vcGFnZSlcXFwiXXx8d2FybmluZyhcXFwiVzA1MlxcXCIsc3RhdGUudG9rZW5zLm5leHQsdGhpcy52YWx1ZSk6c3RhdGUudG9rZW5zLmN1cnIubGluZT09PXN0YXRlLnRva2Vucy5uZXh0LmxpbmUmJihcXFwibGFiZWxcXFwiIT09ZnVuY3Rbdl0/d2FybmluZyhcXFwiVzA5MFxcXCIsc3RhdGUudG9rZW5zLm5leHQsdik6c2NvcGVbdl0hPT1mdW5jdCYmd2FybmluZyhcXFwiVzA5MVxcXCIsc3RhdGUudG9rZW5zLm5leHQsdiksdGhpcy5maXJzdD1zdGF0ZS50b2tlbnMubmV4dCxhZHZhbmNlKCkpLHJlYWNoYWJsZShcXFwiY29udGludWVcXFwiKSx0aGlzfSkuZXhwcz0hMCxzdG10KFxcXCJyZXR1cm5cXFwiLGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGluZT09PXN0YXRlLnRva2Vucy5uZXh0LmxpbmU/XFxcIjtcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWR8fHN0YXRlLnRva2Vucy5uZXh0LnJlYWNofHwodGhpcy5maXJzdD1leHByZXNzaW9uKDApLCF0aGlzLmZpcnN0fHxcXFwiKHB1bmN0dWF0b3IpXFxcIiE9PXRoaXMuZmlyc3QudHlwZXx8XFxcIj1cXFwiIT09dGhpcy5maXJzdC52YWx1ZXx8dGhpcy5maXJzdC5wYXJlbnx8c3RhdGUub3B0aW9uLmJvc3N8fHdhcm5pbmdBdChcXFwiVzA5M1xcXCIsdGhpcy5maXJzdC5saW5lLHRoaXMuZmlyc3QuY2hhcmFjdGVyKSk6XFxcIihwdW5jdHVhdG9yKVxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC50eXBlJiZbXFxcIltcXFwiLFxcXCJ7XFxcIixcXFwiK1xcXCIsXFxcIi1cXFwiXS5pbmRleE9mKHN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKT4tMSYmbm9saW5lYnJlYWsodGhpcykscmVhY2hhYmxlKFxcXCJyZXR1cm5cXFwiKSx0aGlzfSkuZXhwcz0hMCxmdW5jdGlvbih4KXt4LmV4cHM9ITAseC5sYnA9MjV9KHByZWZpeChcXFwieWllbGRcXFwiLGZ1bmN0aW9uKCl7dmFyIHByZXY9c3RhdGUudG9rZW5zLnByZXY7cmV0dXJuIHN0YXRlLm9wdGlvbi5pbkVTTmV4dCghMCkmJiFmdW5jdFtcXFwiKGdlbmVyYXRvcilcXFwiXT9cXFwiKGNhdGNoKVxcXCI9PT1mdW5jdFtcXFwiKG5hbWUpXFxcIl0mJmZ1bmN0W1xcXCIoY29udGV4dClcXFwiXVtcXFwiKGdlbmVyYXRvcilcXFwiXXx8ZXJyb3IoXFxcIkUwNDZcXFwiLHN0YXRlLnRva2Vucy5jdXJyLFxcXCJ5aWVsZFxcXCIpOnN0YXRlLm9wdGlvbi5pbkVTTmV4dCgpfHx3YXJuaW5nKFxcXCJXMTA0XFxcIixzdGF0ZS50b2tlbnMuY3VycixcXFwieWllbGRcXFwiKSxmdW5jdFtcXFwiKGdlbmVyYXRvcilcXFwiXT1cXFwieWllbGRlZFxcXCIsdGhpcy5saW5lIT09c3RhdGUudG9rZW5zLm5leHQubGluZSYmc3RhdGUub3B0aW9uLmluTW96KCEwKT9zdGF0ZS5vcHRpb24uYXNpfHxub2xpbmVicmVhayh0aGlzKTooXFxcIjtcXFwiIT09c3RhdGUudG9rZW5zLm5leHQuaWQmJiFzdGF0ZS50b2tlbnMubmV4dC5yZWFjaCYmc3RhdGUudG9rZW5zLm5leHQubnVkJiYobm9icmVha25vbmFkamFjZW50KHN0YXRlLnRva2Vucy5jdXJyLHN0YXRlLnRva2Vucy5uZXh0KSx0aGlzLmZpcnN0PWV4cHJlc3Npb24oMTApLFxcXCIocHVuY3R1YXRvcilcXFwiIT09dGhpcy5maXJzdC50eXBlfHxcXFwiPVxcXCIhPT10aGlzLmZpcnN0LnZhbHVlfHx0aGlzLmZpcnN0LnBhcmVufHxzdGF0ZS5vcHRpb24uYm9zc3x8d2FybmluZ0F0KFxcXCJXMDkzXFxcIix0aGlzLmZpcnN0LmxpbmUsdGhpcy5maXJzdC5jaGFyYWN0ZXIpKSxzdGF0ZS5vcHRpb24uaW5Nb3ooITApJiZcXFwiKVxcXCIhPT1zdGF0ZS50b2tlbnMubmV4dC5pZCYmKHByZXYubGJwPjMwfHwhcHJldi5hc3NpZ24mJiFpc0VuZE9mRXhwcigpfHxcXFwieWllbGRcXFwiPT09cHJldi5pZCkmJmVycm9yKFxcXCJFMDUwXFxcIix0aGlzKSksdGhpc30pKSxzdG10KFxcXCJ0aHJvd1xcXCIsZnVuY3Rpb24oKXtyZXR1cm4gbm9saW5lYnJlYWsodGhpcyksdGhpcy5maXJzdD1leHByZXNzaW9uKDIwKSxyZWFjaGFibGUoXFxcInRocm93XFxcIiksdGhpc30pLmV4cHM9ITAsc3RtdChcXFwiaW1wb3J0XFxcIixmdW5jdGlvbigpe2lmKHN0YXRlLm9wdGlvbi5pbkVTTmV4dCgpfHx3YXJuaW5nKFxcXCJXMTE5XFxcIixzdGF0ZS50b2tlbnMuY3VycixcXFwiaW1wb3J0XFxcIiksXFxcIihzdHJpbmcpXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnR5cGUpcmV0dXJuIGFkdmFuY2UoXFxcIihzdHJpbmcpXFxcIiksdGhpcztpZihzdGF0ZS50b2tlbnMubmV4dC5pZGVudGlmaWVyKXRoaXMubmFtZT1pZGVudGlmaWVyKCksYWRkbGFiZWwodGhpcy5uYW1lLHt0eXBlOlxcXCJ1bnVzZWRcXFwiLHRva2VuOnN0YXRlLnRva2Vucy5jdXJyfSk7ZWxzZSBmb3IoYWR2YW5jZShcXFwie1xcXCIpOzspe2lmKFxcXCJ9XFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKXthZHZhbmNlKFxcXCJ9XFxcIik7YnJlYWt9dmFyIGltcG9ydE5hbWU7aWYoXFxcImRlZmF1bHRcXFwiPT09c3RhdGUudG9rZW5zLm5leHQudHlwZT8oaW1wb3J0TmFtZT1cXFwiZGVmYXVsdFxcXCIsYWR2YW5jZShcXFwiZGVmYXVsdFxcXCIpKTppbXBvcnROYW1lPWlkZW50aWZpZXIoKSxcXFwiYXNcXFwiPT09c3RhdGUudG9rZW5zLm5leHQudmFsdWUmJihhZHZhbmNlKFxcXCJhc1xcXCIpLGltcG9ydE5hbWU9aWRlbnRpZmllcigpKSxhZGRsYWJlbChpbXBvcnROYW1lLHt0eXBlOlxcXCJ1bnVzZWRcXFwiLHRva2VuOnN0YXRlLnRva2Vucy5jdXJyfSksXFxcIixcXFwiIT09c3RhdGUudG9rZW5zLm5leHQudmFsdWUpe2lmKFxcXCJ9XFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKXthZHZhbmNlKFxcXCJ9XFxcIik7YnJlYWt9ZXJyb3IoXFxcIkUwMjRcXFwiLHN0YXRlLnRva2Vucy5uZXh0LHN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKTticmVha31hZHZhbmNlKFxcXCIsXFxcIil9cmV0dXJuIGFkdmFuY2UoXFxcImZyb21cXFwiKSxhZHZhbmNlKFxcXCIoc3RyaW5nKVxcXCIpLHRoaXN9KS5leHBzPSEwLHN0bXQoXFxcImV4cG9ydFxcXCIsZnVuY3Rpb24oKXtpZihzdGF0ZS5vcHRpb24uaW5FU05leHQoKXx8d2FybmluZyhcXFwiVzExOVxcXCIsc3RhdGUudG9rZW5zLmN1cnIsXFxcImV4cG9ydFxcXCIpLFxcXCJkZWZhdWx0XFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnR5cGUpcmV0dXJuIGFkdmFuY2UoXFxcImRlZmF1bHRcXFwiKSwoXFxcImZ1bmN0aW9uXFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkfHxcXFwiY2xhc3NcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQpJiYodGhpcy5ibG9jaz0hMCksdGhpcy5leHBvcnRlZT1leHByZXNzaW9uKDEwKSx0aGlzO2lmKFxcXCJ7XFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKXtmb3IoYWR2YW5jZShcXFwie1xcXCIpOzspe2lmKGV4cG9ydGVkW2lkZW50aWZpZXIoKV09ITAsXFxcIixcXFwiIT09c3RhdGUudG9rZW5zLm5leHQudmFsdWUpe2lmKFxcXCJ9XFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKXthZHZhbmNlKFxcXCJ9XFxcIik7YnJlYWt9ZXJyb3IoXFxcIkUwMjRcXFwiLHN0YXRlLnRva2Vucy5uZXh0LHN0YXRlLnRva2Vucy5uZXh0LnZhbHVlKTticmVha31hZHZhbmNlKFxcXCIsXFxcIil9cmV0dXJuIHRoaXN9cmV0dXJuXFxcInZhclxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZD8oYWR2YW5jZShcXFwidmFyXFxcIiksZXhwb3J0ZWRbc3RhdGUudG9rZW5zLm5leHQudmFsdWVdPSEwLHN0YXRlLnN5bnRheFtcXFwidmFyXFxcIl0uZnVkLmNhbGwoc3RhdGUuc3ludGF4W1xcXCJ2YXJcXFwiXS5mdWQpKTpcXFwibGV0XFxcIj09PXN0YXRlLnRva2Vucy5uZXh0LmlkPyhhZHZhbmNlKFxcXCJsZXRcXFwiKSxleHBvcnRlZFtzdGF0ZS50b2tlbnMubmV4dC52YWx1ZV09ITAsc3RhdGUuc3ludGF4LmxldC5mdWQuY2FsbChzdGF0ZS5zeW50YXgubGV0LmZ1ZCkpOlxcXCJjb25zdFxcXCI9PT1zdGF0ZS50b2tlbnMubmV4dC5pZD8oYWR2YW5jZShcXFwiY29uc3RcXFwiKSxleHBvcnRlZFtzdGF0ZS50b2tlbnMubmV4dC52YWx1ZV09ITAsc3RhdGUuc3ludGF4W1xcXCJjb25zdFxcXCJdLmZ1ZC5jYWxsKHN0YXRlLnN5bnRheFtcXFwiY29uc3RcXFwiXS5mdWQpKTpcXFwiZnVuY3Rpb25cXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQ/KHRoaXMuYmxvY2s9ITAsYWR2YW5jZShcXFwiZnVuY3Rpb25cXFwiKSxleHBvcnRlZFtzdGF0ZS50b2tlbnMubmV4dC52YWx1ZV09ITAsc3RhdGUuc3ludGF4W1xcXCJmdW5jdGlvblxcXCJdLmZ1ZCgpKTpcXFwiY2xhc3NcXFwiPT09c3RhdGUudG9rZW5zLm5leHQuaWQ/KHRoaXMuYmxvY2s9ITAsYWR2YW5jZShcXFwiY2xhc3NcXFwiKSxleHBvcnRlZFtzdGF0ZS50b2tlbnMubmV4dC52YWx1ZV09ITAsc3RhdGUuc3ludGF4W1xcXCJjbGFzc1xcXCJdLmZ1ZCgpKTplcnJvcihcXFwiRTAyNFxcXCIsc3RhdGUudG9rZW5zLm5leHQsc3RhdGUudG9rZW5zLm5leHQudmFsdWUpLHRoaXN9KS5leHBzPSEwLEZ1dHVyZVJlc2VydmVkV29yZChcXFwiYWJzdHJhY3RcXFwiKSxGdXR1cmVSZXNlcnZlZFdvcmQoXFxcImJvb2xlYW5cXFwiKSxGdXR1cmVSZXNlcnZlZFdvcmQoXFxcImJ5dGVcXFwiKSxGdXR1cmVSZXNlcnZlZFdvcmQoXFxcImNoYXJcXFwiKSxGdXR1cmVSZXNlcnZlZFdvcmQoXFxcImNsYXNzXFxcIix7ZXM1OiEwLG51ZDpjbGFzc2RlZn0pLEZ1dHVyZVJlc2VydmVkV29yZChcXFwiZG91YmxlXFxcIiksRnV0dXJlUmVzZXJ2ZWRXb3JkKFxcXCJlbnVtXFxcIix7ZXM1OiEwfSksRnV0dXJlUmVzZXJ2ZWRXb3JkKFxcXCJleHBvcnRcXFwiLHtlczU6ITB9KSxGdXR1cmVSZXNlcnZlZFdvcmQoXFxcImV4dGVuZHNcXFwiLHtlczU6ITB9KSxGdXR1cmVSZXNlcnZlZFdvcmQoXFxcImZpbmFsXFxcIiksRnV0dXJlUmVzZXJ2ZWRXb3JkKFxcXCJmbG9hdFxcXCIpLEZ1dHVyZVJlc2VydmVkV29yZChcXFwiZ290b1xcXCIpLEZ1dHVyZVJlc2VydmVkV29yZChcXFwiaW1wbGVtZW50c1xcXCIse2VzNTohMCxzdHJpY3RPbmx5OiEwfSksRnV0dXJlUmVzZXJ2ZWRXb3JkKFxcXCJpbXBvcnRcXFwiLHtlczU6ITB9KSxGdXR1cmVSZXNlcnZlZFdvcmQoXFxcImludFxcXCIpLEZ1dHVyZVJlc2VydmVkV29yZChcXFwiaW50ZXJmYWNlXFxcIix7ZXM1OiEwLHN0cmljdE9ubHk6ITB9KSxGdXR1cmVSZXNlcnZlZFdvcmQoXFxcImxvbmdcXFwiKSxGdXR1cmVSZXNlcnZlZFdvcmQoXFxcIm5hdGl2ZVxcXCIpLEZ1dHVyZVJlc2VydmVkV29yZChcXFwicGFja2FnZVxcXCIse2VzNTohMCxzdHJpY3RPbmx5OiEwfSksRnV0dXJlUmVzZXJ2ZWRXb3JkKFxcXCJwcml2YXRlXFxcIix7ZXM1OiEwLHN0cmljdE9ubHk6ITB9KSxGdXR1cmVSZXNlcnZlZFdvcmQoXFxcInByb3RlY3RlZFxcXCIse2VzNTohMCxzdHJpY3RPbmx5OiEwfSksRnV0dXJlUmVzZXJ2ZWRXb3JkKFxcXCJwdWJsaWNcXFwiLHtlczU6ITAsc3RyaWN0T25seTohMH0pLEZ1dHVyZVJlc2VydmVkV29yZChcXFwic2hvcnRcXFwiKSxGdXR1cmVSZXNlcnZlZFdvcmQoXFxcInN0YXRpY1xcXCIse2VzNTohMCxzdHJpY3RPbmx5OiEwfSksRnV0dXJlUmVzZXJ2ZWRXb3JkKFxcXCJzdXBlclxcXCIse2VzNTohMH0pLEZ1dHVyZVJlc2VydmVkV29yZChcXFwic3luY2hyb25pemVkXFxcIiksRnV0dXJlUmVzZXJ2ZWRXb3JkKFxcXCJ0cmFuc2llbnRcXFwiKSxGdXR1cmVSZXNlcnZlZFdvcmQoXFxcInZvbGF0aWxlXFxcIik7dmFyIGxvb2t1cEJsb2NrVHlwZT1mdW5jdGlvbigpe3ZhciBwbixwbjEsaT0tMSxicmFja2V0U3RhY2s9MCxyZXQ9e307Xy5jb250YWlucyhbXFxcIltcXFwiLFxcXCJ7XFxcIl0sc3RhdGUudG9rZW5zLmN1cnIudmFsdWUpJiYoYnJhY2tldFN0YWNrKz0xKTtkb3tpZihwbj0tMT09PWk/c3RhdGUudG9rZW5zLm5leHQ6cGVlayhpKSxwbjE9cGVlayhpKzEpLGkrPTEsXy5jb250YWlucyhbXFxcIltcXFwiLFxcXCJ7XFxcIl0scG4udmFsdWUpP2JyYWNrZXRTdGFjays9MTpfLmNvbnRhaW5zKFtcXFwiXVxcXCIsXFxcIn1cXFwiXSxwbi52YWx1ZSkmJihicmFja2V0U3RhY2stPTEpLHBuLmlkZW50aWZpZXImJlxcXCJmb3JcXFwiPT09cG4udmFsdWUmJjE9PT1icmFja2V0U3RhY2spe3JldC5pc0NvbXBBcnJheT0hMCxyZXQubm90SnNvbj0hMDticmVha31pZihfLmNvbnRhaW5zKFtcXFwifVxcXCIsXFxcIl1cXFwiXSxwbi52YWx1ZSkmJlxcXCI9XFxcIj09PXBuMS52YWx1ZSYmMD09PWJyYWNrZXRTdGFjayl7cmV0LmlzRGVzdEFzc2lnbj0hMCxyZXQubm90SnNvbj0hMDticmVha31cXFwiO1xcXCI9PT1wbi52YWx1ZSYmKHJldC5pc0Jsb2NrPSEwLHJldC5ub3RKc29uPSEwKX13aGlsZShicmFja2V0U3RhY2s+MCYmXFxcIihlbmQpXFxcIiE9PXBuLmlkJiYxNT5pKTtyZXR1cm4gcmV0fSxhcnJheUNvbXByZWhlbnNpb249ZnVuY3Rpb24oKXtmdW5jdGlvbiBkZWNsYXJlKHYpe3ZhciBsPV9jdXJyZW50LnZhcmlhYmxlcy5maWx0ZXIoZnVuY3Rpb24oZWx0KXtyZXR1cm4gZWx0LnZhbHVlPT09dj8oZWx0LnVuZGVmPSExLHYpOnZvaWQgMH0pLmxlbmd0aDtyZXR1cm4gMCE9PWx9ZnVuY3Rpb24gdXNlKHYpe3ZhciBsPV9jdXJyZW50LnZhcmlhYmxlcy5maWx0ZXIoZnVuY3Rpb24oZWx0KXtyZXR1cm4gZWx0LnZhbHVlIT09dnx8ZWx0LnVuZGVmP3ZvaWQgMDooZWx0LnVudXNlZD09PSEwJiYoZWx0LnVudXNlZD0hMSksdil9KS5sZW5ndGg7cmV0dXJuIDA9PT1sfXZhciBfY3VycmVudCxDb21wQXJyYXk9ZnVuY3Rpb24oKXt0aGlzLm1vZGU9XFxcInVzZVxcXCIsdGhpcy52YXJpYWJsZXM9W119LF9jYXJyYXlzPVtdO3JldHVybntzdGFjazpmdW5jdGlvbigpe19jdXJyZW50PW5ldyBDb21wQXJyYXksX2NhcnJheXMucHVzaChfY3VycmVudCl9LHVuc3RhY2s6ZnVuY3Rpb24oKXtfY3VycmVudC52YXJpYWJsZXMuZmlsdGVyKGZ1bmN0aW9uKHYpe3YudW51c2VkJiZ3YXJuaW5nKFxcXCJXMDk4XFxcIix2LnRva2VuLHYudmFsdWUpLHYudW5kZWYmJmlzdW5kZWYodi5mdW5jdCxcXFwiVzExN1xcXCIsdi50b2tlbix2LnZhbHVlKX0pLF9jYXJyYXlzLnNwbGljZSgtMSwxKSxfY3VycmVudD1fY2FycmF5c1tfY2FycmF5cy5sZW5ndGgtMV19LHNldFN0YXRlOmZ1bmN0aW9uKHMpe18uY29udGFpbnMoW1xcXCJ1c2VcXFwiLFxcXCJkZWZpbmVcXFwiLFxcXCJnZW5lcmF0ZVxcXCIsXFxcImZpbHRlclxcXCJdLHMpJiYoX2N1cnJlbnQubW9kZT1zKX0sY2hlY2s6ZnVuY3Rpb24odil7cmV0dXJuIF9jdXJyZW50P19jdXJyZW50JiZcXFwidXNlXFxcIj09PV9jdXJyZW50Lm1vZGU/KHVzZSh2KSYmX2N1cnJlbnQudmFyaWFibGVzLnB1c2goe2Z1bmN0OmZ1bmN0LHRva2VuOnN0YXRlLnRva2Vucy5jdXJyLHZhbHVlOnYsdW5kZWY6ITAsdW51c2VkOiExfSksITApOl9jdXJyZW50JiZcXFwiZGVmaW5lXFxcIj09PV9jdXJyZW50Lm1vZGU/KGRlY2xhcmUodil8fF9jdXJyZW50LnZhcmlhYmxlcy5wdXNoKHtmdW5jdDpmdW5jdCx0b2tlbjpzdGF0ZS50b2tlbnMuY3Vycix2YWx1ZTp2LHVuZGVmOiExLHVudXNlZDohMH0pLCEwKTpfY3VycmVudCYmXFxcImdlbmVyYXRlXFxcIj09PV9jdXJyZW50Lm1vZGU/KGlzdW5kZWYoZnVuY3QsXFxcIlcxMTdcXFwiLHN0YXRlLnRva2Vucy5jdXJyLHYpLCEwKTpfY3VycmVudCYmXFxcImZpbHRlclxcXCI9PT1fY3VycmVudC5tb2RlPyh1c2UodikmJmlzdW5kZWYoZnVuY3QsXFxcIlcxMTdcXFwiLHN0YXRlLnRva2Vucy5jdXJyLHYpLCEwKTohMTp2b2lkIDB9fX0sYmxvY2tTY29wZT1mdW5jdGlvbigpe2Z1bmN0aW9uIF9jaGVja0Jsb2NrTGFiZWxzKCl7Zm9yKHZhciB0IGluIF9jdXJyZW50KWlmKFxcXCJ1bnVzZWRcXFwiPT09X2N1cnJlbnRbdF1bXFxcIih0eXBlKVxcXCJdJiZzdGF0ZS5vcHRpb24udW51c2VkKXt2YXIgdGtuPV9jdXJyZW50W3RdW1xcXCIodG9rZW4pXFxcIl0sbGluZT10a24ubGluZSxjaHI9dGtuLmNoYXJhY3Rlcjt3YXJuaW5nQXQoXFxcIlcwOThcXFwiLGxpbmUsY2hyLHQpfX12YXIgX2N1cnJlbnQ9e30sX3ZhcmlhYmxlcz1bX2N1cnJlbnRdO3JldHVybntzdGFjazpmdW5jdGlvbigpe19jdXJyZW50PXt9LF92YXJpYWJsZXMucHVzaChfY3VycmVudCl9LHVuc3RhY2s6ZnVuY3Rpb24oKXtfY2hlY2tCbG9ja0xhYmVscygpLF92YXJpYWJsZXMuc3BsaWNlKF92YXJpYWJsZXMubGVuZ3RoLTEsMSksX2N1cnJlbnQ9Xy5sYXN0KF92YXJpYWJsZXMpfSxnZXRsYWJlbDpmdW5jdGlvbihsKXtmb3IodmFyIGk9X3ZhcmlhYmxlcy5sZW5ndGgtMTtpPj0wOy0taSlpZihfLmhhcyhfdmFyaWFibGVzW2ldLGwpJiYhX3ZhcmlhYmxlc1tpXVtsXVtcXFwiKHNoYWRvd2VkKVxcXCJdKXJldHVybiBfdmFyaWFibGVzW2ldfSxzaGFkb3c6ZnVuY3Rpb24obmFtZSl7Zm9yKHZhciBpPV92YXJpYWJsZXMubGVuZ3RoLTE7aT49MDtpLS0pXy5oYXMoX3ZhcmlhYmxlc1tpXSxuYW1lKSYmKF92YXJpYWJsZXNbaV1bbmFtZV1bXFxcIihzaGFkb3dlZClcXFwiXT0hMCl9LHVuc2hhZG93OmZ1bmN0aW9uKG5hbWUpe2Zvcih2YXIgaT1fdmFyaWFibGVzLmxlbmd0aC0xO2k+PTA7aS0tKV8uaGFzKF92YXJpYWJsZXNbaV0sbmFtZSkmJihfdmFyaWFibGVzW2ldW25hbWVdW1xcXCIoc2hhZG93ZWQpXFxcIl09ITEpfSxjdXJyZW50OntoYXM6ZnVuY3Rpb24odCl7cmV0dXJuIF8uaGFzKF9jdXJyZW50LHQpfSxhZGQ6ZnVuY3Rpb24odCx0eXBlLHRvayl7X2N1cnJlbnRbdF09e1xcXCIodHlwZSlcXFwiOnR5cGUsXFxcIih0b2tlbilcXFwiOnRvayxcXFwiKHNoYWRvd2VkKVxcXCI6ITF9fX19fSxpdHNlbGY9ZnVuY3Rpb24ocyxvLGcpe2Z1bmN0aW9uIGVhY2gob2JqLGNiKXtvYmomJihBcnJheS5pc0FycmF5KG9iail8fFxcXCJvYmplY3RcXFwiIT10eXBlb2Ygb2JqfHwob2JqPU9iamVjdC5rZXlzKG9iaikpLG9iai5mb3JFYWNoKGNiKSl9dmFyIGksayx4LG9wdGlvbktleXMsbmV3T3B0aW9uT2JqPXt9LG5ld0lnbm9yZWRPYmo9e307aWYobz1fLmNsb25lKG8pLHN0YXRlLnJlc2V0KCksbyYmby5zY29wZT9KU0hJTlQuc2NvcGU9by5zY29wZTooSlNISU5ULmVycm9ycz1bXSxKU0hJTlQudW5kZWZzPVtdLEpTSElOVC5pbnRlcm5hbHM9W10sSlNISU5ULmJsYWNrbGlzdD17fSxKU0hJTlQuc2NvcGU9XFxcIihtYWluKVxcXCIpLHByZWRlZmluZWQ9T2JqZWN0LmNyZWF0ZShudWxsKSxjb21iaW5lKHByZWRlZmluZWQsdmFycy5lY21hSWRlbnRpZmllcnMpLGNvbWJpbmUocHJlZGVmaW5lZCx2YXJzLnJlc2VydmVkVmFycyksY29tYmluZShwcmVkZWZpbmVkLGd8fHt9KSxkZWNsYXJlZD1PYmplY3QuY3JlYXRlKG51bGwpLGV4cG9ydGVkPU9iamVjdC5jcmVhdGUobnVsbCksbylmb3IoZWFjaChvLnByZWRlZnx8bnVsbCxmdW5jdGlvbihpdGVtKXt2YXIgc2xpY2UscHJvcDtcXFwiLVxcXCI9PT1pdGVtWzBdPyhzbGljZT1pdGVtLnNsaWNlKDEpLEpTSElOVC5ibGFja2xpc3Rbc2xpY2VdPXNsaWNlKToocHJvcD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8ucHJlZGVmLGl0ZW0pLHByZWRlZmluZWRbaXRlbV09cHJvcD9wcm9wLnZhbHVlOiExKX0pLGVhY2goby5leHBvcnRlZHx8bnVsbCxmdW5jdGlvbihpdGVtKXtleHBvcnRlZFtpdGVtXT0hMH0pLGRlbGV0ZSBvLnByZWRlZixkZWxldGUgby5leHBvcnRlZCxvcHRpb25LZXlzPU9iamVjdC5rZXlzKG8pLHg9MDtvcHRpb25LZXlzLmxlbmd0aD54O3grKykvXi1XXFxcXGR7M30kL2cudGVzdChvcHRpb25LZXlzW3hdKT9uZXdJZ25vcmVkT2JqW29wdGlvbktleXNbeF0uc2xpY2UoMSldPSEwOihuZXdPcHRpb25PYmpbb3B0aW9uS2V5c1t4XV09b1tvcHRpb25LZXlzW3hdXSxcXFwibmV3Y2FwXFxcIj09PW9wdGlvbktleXNbeF0mJm9bb3B0aW9uS2V5c1t4XV09PT0hMSYmKG5ld09wdGlvbk9ialtcXFwiKGV4cGxpY2l0TmV3Y2FwKVxcXCJdPSEwKSk7aWYoc3RhdGUub3B0aW9uPW5ld09wdGlvbk9iaixzdGF0ZS5pZ25vcmVkPW5ld0lnbm9yZWRPYmosc3RhdGUub3B0aW9uLmluZGVudD1zdGF0ZS5vcHRpb24uaW5kZW50fHw0LHN0YXRlLm9wdGlvbi5tYXhlcnI9c3RhdGUub3B0aW9uLm1heGVycnx8NTAsaW5kZW50PTEsZ2xvYmFsPU9iamVjdC5jcmVhdGUocHJlZGVmaW5lZCksc2NvcGU9Z2xvYmFsLGZ1bmN0PWZ1bmN0b3IoXFxcIihnbG9iYWwpXFxcIixudWxsLHNjb3BlLHtcXFwiKGdsb2JhbClcXFwiOiEwLFxcXCIoYmxvY2tzY29wZSlcXFwiOmJsb2NrU2NvcGUoKSxcXFwiKGNvbXBhcnJheSlcXFwiOmFycmF5Q29tcHJlaGVuc2lvbigpLFxcXCIobWV0cmljcylcXFwiOmNyZWF0ZU1ldHJpY3Moc3RhdGUudG9rZW5zLm5leHQpfSksZnVuY3Rpb25zPVtmdW5jdF0sdXJscz1bXSxzdGFjaz1udWxsLG1lbWJlcj17fSxtZW1iZXJzT25seT1udWxsLGltcGxpZWQ9e30saW5ibG9jaz0hMSxsb29rYWhlYWQ9W10sdW51c2Vkcz1bXSwhaXNTdHJpbmcocykmJiFBcnJheS5pc0FycmF5KHMpKXJldHVybiBlcnJvckF0KFxcXCJFMDA0XFxcIiwwKSwhMTthcGk9e2dldCBpc0pTT04oKXtyZXR1cm4gc3RhdGUuanNvbk1vZGV9LGdldE9wdGlvbjpmdW5jdGlvbihuYW1lKXtyZXR1cm4gc3RhdGUub3B0aW9uW25hbWVdfHxudWxsfSxnZXRDYWNoZTpmdW5jdGlvbihuYW1lKXtyZXR1cm4gc3RhdGUuY2FjaGVbbmFtZV19LHNldENhY2hlOmZ1bmN0aW9uKG5hbWUsdmFsdWUpe3N0YXRlLmNhY2hlW25hbWVdPXZhbHVlfSx3YXJuOmZ1bmN0aW9uKGNvZGUsZGF0YSl7d2FybmluZ0F0LmFwcGx5KG51bGwsW2NvZGUsZGF0YS5saW5lLGRhdGEuY2hhcl0uY29uY2F0KGRhdGEuZGF0YSkpfSxvbjpmdW5jdGlvbihuYW1lcyxsaXN0ZW5lcil7bmFtZXMuc3BsaXQoXFxcIiBcXFwiKS5mb3JFYWNoKGZ1bmN0aW9uKG5hbWUpe2VtaXR0ZXIub24obmFtZSxsaXN0ZW5lcil9LmJpbmQodGhpcykpfX0sZW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKSwoZXh0cmFNb2R1bGVzfHxbXSkuZm9yRWFjaChmdW5jdGlvbihmdW5jKXtmdW5jKGFwaSl9KSxzdGF0ZS50b2tlbnMucHJldj1zdGF0ZS50b2tlbnMuY3Vycj1zdGF0ZS50b2tlbnMubmV4dD1zdGF0ZS5zeW50YXhbXFxcIihiZWdpbilcXFwiXSxsZXg9bmV3IExleGVyKHMpLGxleC5vbihcXFwid2FybmluZ1xcXCIsZnVuY3Rpb24oZXYpe3dhcm5pbmdBdC5hcHBseShudWxsLFtldi5jb2RlLGV2LmxpbmUsZXYuY2hhcmFjdGVyXS5jb25jYXQoZXYuZGF0YSkpfSksbGV4Lm9uKFxcXCJlcnJvclxcXCIsZnVuY3Rpb24oZXYpe2Vycm9yQXQuYXBwbHkobnVsbCxbZXYuY29kZSxldi5saW5lLGV2LmNoYXJhY3Rlcl0uY29uY2F0KGV2LmRhdGEpKX0pLGxleC5vbihcXFwiZmF0YWxcXFwiLGZ1bmN0aW9uKGV2KXtxdWl0KFxcXCJFMDQxXFxcIixldi5saW5lLGV2LmZyb20pfSksbGV4Lm9uKFxcXCJJZGVudGlmaWVyXFxcIixmdW5jdGlvbihldil7ZW1pdHRlci5lbWl0KFxcXCJJZGVudGlmaWVyXFxcIixldil9KSxsZXgub24oXFxcIlN0cmluZ1xcXCIsZnVuY3Rpb24oZXYpe2VtaXR0ZXIuZW1pdChcXFwiU3RyaW5nXFxcIixldil9KSxsZXgub24oXFxcIk51bWJlclxcXCIsZnVuY3Rpb24oZXYpe2VtaXR0ZXIuZW1pdChcXFwiTnVtYmVyXFxcIixldil9KSxsZXguc3RhcnQoKTtmb3IodmFyIG5hbWUgaW4gbylfLmhhcyhvLG5hbWUpJiZjaGVja09wdGlvbihuYW1lLHN0YXRlLnRva2Vucy5jdXJyKTthc3N1bWUoKSxjb21iaW5lKHByZWRlZmluZWQsZ3x8e30pLGNvbW1hLmZpcnN0PSEwO3RyeXtzd2l0Y2goYWR2YW5jZSgpLHN0YXRlLnRva2Vucy5uZXh0LmlkKXtjYXNlXFxcIntcXFwiOmNhc2VcXFwiW1xcXCI6ZGVzdHJ1Y3R1cmluZ0Fzc2lnbk9ySnNvblZhbHVlKCk7YnJlYWs7ZGVmYXVsdDpkaXJlY3RpdmVzKCksc3RhdGUuZGlyZWN0aXZlW1xcXCJ1c2Ugc3RyaWN0XFxcIl0mJihzdGF0ZS5vcHRpb24uZ2xvYmFsc3RyaWN0fHxzdGF0ZS5vcHRpb24ubm9kZXx8c3RhdGUub3B0aW9uLnBoYW50b218fHdhcm5pbmcoXFxcIlcwOTdcXFwiLHN0YXRlLnRva2Vucy5wcmV2KSksc3RhdGVtZW50cygpfWFkdmFuY2Uoc3RhdGUudG9rZW5zLm5leHQmJlxcXCIuXFxcIiE9PXN0YXRlLnRva2Vucy5uZXh0LnZhbHVlP1xcXCIoZW5kKVxcXCI6dm9pZCAwKSxmdW5jdFtcXFwiKGJsb2Nrc2NvcGUpXFxcIl0udW5zdGFjaygpO3ZhciBtYXJrRGVmaW5lZD1mdW5jdGlvbihuYW1lLGNvbnRleHQpe2Rve2lmKFxcXCJzdHJpbmdcXFwiPT10eXBlb2YgY29udGV4dFtuYW1lXSlyZXR1cm5cXFwidW51c2VkXFxcIj09PWNvbnRleHRbbmFtZV0/Y29udGV4dFtuYW1lXT1cXFwidmFyXFxcIjpcXFwidW5jdGlvblxcXCI9PT1jb250ZXh0W25hbWVdJiYoY29udGV4dFtuYW1lXT1cXFwiY2xvc3VyZVxcXCIpLCEwO2NvbnRleHQ9Y29udGV4dFtcXFwiKGNvbnRleHQpXFxcIl19d2hpbGUoY29udGV4dCk7cmV0dXJuITF9LGNsZWFySW1wbGllZD1mdW5jdGlvbihuYW1lLGxpbmUpe2lmKGltcGxpZWRbbmFtZV0pe2Zvcih2YXIgbmV3SW1wbGllZD1bXSxpPTA7aW1wbGllZFtuYW1lXS5sZW5ndGg+aTtpKz0xKWltcGxpZWRbbmFtZV1baV0hPT1saW5lJiZuZXdJbXBsaWVkLnB1c2goaW1wbGllZFtuYW1lXVtpXSk7MD09PW5ld0ltcGxpZWQubGVuZ3RoP2RlbGV0ZSBpbXBsaWVkW25hbWVdOmltcGxpZWRbbmFtZV09bmV3SW1wbGllZH19LHdhcm5VbnVzZWQ9ZnVuY3Rpb24obmFtZSx0a24sdHlwZSx1bnVzZWRfb3B0KXt2YXIgbGluZT10a24ubGluZSxjaHI9dGtuLmNoYXJhY3Rlcjt2b2lkIDA9PT11bnVzZWRfb3B0JiYodW51c2VkX29wdD1zdGF0ZS5vcHRpb24udW51c2VkKSx1bnVzZWRfb3B0PT09ITAmJih1bnVzZWRfb3B0PVxcXCJsYXN0LXBhcmFtXFxcIik7dmFyIHdhcm5hYmxlX3R5cGVzPXt2YXJzOltcXFwidmFyXFxcIl0sXFxcImxhc3QtcGFyYW1cXFwiOltcXFwidmFyXFxcIixcXFwicGFyYW1cXFwiXSxzdHJpY3Q6W1xcXCJ2YXJcXFwiLFxcXCJwYXJhbVxcXCIsXFxcImxhc3QtcGFyYW1cXFwiXX07dW51c2VkX29wdCYmd2FybmFibGVfdHlwZXNbdW51c2VkX29wdF0mJi0xIT09d2FybmFibGVfdHlwZXNbdW51c2VkX29wdF0uaW5kZXhPZih0eXBlKSYmd2FybmluZ0F0KFxcXCJXMDk4XFxcIixsaW5lLGNocixuYW1lKSx1bnVzZWRzLnB1c2goe25hbWU6bmFtZSxsaW5lOmxpbmUsY2hhcmFjdGVyOmNocn0pfSxjaGVja1VudXNlZD1mdW5jdGlvbihmdW5jLGtleSl7dmFyIHR5cGU9ZnVuY1trZXldLHRrbj1mdW5jW1xcXCIodG9rZW5zKVxcXCJdW2tleV07XFxcIihcXFwiIT09a2V5LmNoYXJBdCgwKSYmKFxcXCJ1bnVzZWRcXFwiPT09dHlwZXx8XFxcInVuY3Rpb25cXFwiPT09dHlwZXx8XFxcImNvbnN0XFxcIj09PXR5cGUpJiYoZnVuY1tcXFwiKHBhcmFtcylcXFwiXSYmLTEhPT1mdW5jW1xcXCIocGFyYW1zKVxcXCJdLmluZGV4T2Yoa2V5KXx8ZnVuY1tcXFwiKGdsb2JhbClcXFwiXSYmXy5oYXMoZXhwb3J0ZWQsa2V5KXx8KFxcXCJjb25zdFxcXCIhPT10eXBlfHxnZXRwcm9wKGZ1bmMsa2V5LFxcXCJ1bnVzZWRcXFwiKSkmJndhcm5VbnVzZWQoa2V5LHRrbixcXFwidmFyXFxcIikpfTtmb3IoaT0wO0pTSElOVC51bmRlZnMubGVuZ3RoPmk7aSs9MSlrPUpTSElOVC51bmRlZnNbaV0uc2xpY2UoMCksbWFya0RlZmluZWQoa1syXS52YWx1ZSxrWzBdKT9jbGVhckltcGxpZWQoa1syXS52YWx1ZSxrWzJdLmxpbmUpOnN0YXRlLm9wdGlvbi51bmRlZiYmd2FybmluZy5hcHBseSh3YXJuaW5nLGsuc2xpY2UoMSkpO2Z1bmN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpe2lmKGZ1bmNbXFxcIih1bnVzZWRPcHRpb24pXFxcIl0hPT0hMSl7Zm9yKHZhciBrZXkgaW4gZnVuYylfLmhhcyhmdW5jLGtleSkmJmNoZWNrVW51c2VkKGZ1bmMsa2V5KTtpZihmdW5jW1xcXCIocGFyYW1zKVxcXCJdKWZvcih2YXIgdHlwZSx1bnVzZWRfb3B0LHBhcmFtcz1mdW5jW1xcXCIocGFyYW1zKVxcXCJdLnNsaWNlKCkscGFyYW09cGFyYW1zLnBvcCgpO3BhcmFtOyl7aWYodHlwZT1mdW5jW3BhcmFtXSx1bnVzZWRfb3B0PWZ1bmNbXFxcIih1bnVzZWRPcHRpb24pXFxcIl18fHN0YXRlLm9wdGlvbi51bnVzZWQsdW51c2VkX29wdD11bnVzZWRfb3B0PT09ITA/XFxcImxhc3QtcGFyYW1cXFwiOnVudXNlZF9vcHQsXFxcInVuZGVmaW5lZFxcXCI9PT1wYXJhbSlyZXR1cm47aWYoXFxcInVudXNlZFxcXCI9PT10eXBlfHxcXFwidW5jdGlvblxcXCI9PT10eXBlKXdhcm5VbnVzZWQocGFyYW0sZnVuY1tcXFwiKHRva2VucylcXFwiXVtwYXJhbV0sXFxcInBhcmFtXFxcIixmdW5jW1xcXCIodW51c2VkT3B0aW9uKVxcXCJdKTtlbHNlIGlmKFxcXCJsYXN0LXBhcmFtXFxcIj09PXVudXNlZF9vcHQpcmV0dXJuO3BhcmFtPXBhcmFtcy5wb3AoKX19fSk7Zm9yKHZhciBrZXkgaW4gZGVjbGFyZWQpIV8uaGFzKGRlY2xhcmVkLGtleSl8fF8uaGFzKGdsb2JhbCxrZXkpfHxfLmhhcyhleHBvcnRlZCxrZXkpfHx3YXJuVW51c2VkKGtleSxkZWNsYXJlZFtrZXldLFxcXCJ2YXJcXFwiKX1jYXRjaChlcnIpe2lmKCFlcnJ8fFxcXCJKU0hpbnRFcnJvclxcXCIhPT1lcnIubmFtZSl0aHJvdyBlcnI7dmFyIG50PXN0YXRlLnRva2Vucy5uZXh0fHx7fTtKU0hJTlQuZXJyb3JzLnB1c2goe3Njb3BlOlxcXCIobWFpbilcXFwiLHJhdzplcnIucmF3LGNvZGU6ZXJyLmNvZGUscmVhc29uOmVyci5tZXNzYWdlLGxpbmU6ZXJyLmxpbmV8fG50LmxpbmUsY2hhcmFjdGVyOmVyci5jaGFyYWN0ZXJ8fG50LmZyb219LG51bGwpfWlmKFxcXCIobWFpbilcXFwiPT09SlNISU5ULnNjb3BlKWZvcihvPW98fHt9LGk9MDtKU0hJTlQuaW50ZXJuYWxzLmxlbmd0aD5pO2krPTEpaz1KU0hJTlQuaW50ZXJuYWxzW2ldLG8uc2NvcGU9ay5lbGVtLGl0c2VsZihrLnZhbHVlLG8sZyk7cmV0dXJuIDA9PT1KU0hJTlQuZXJyb3JzLmxlbmd0aH07cmV0dXJuIGl0c2VsZi5hZGRNb2R1bGU9ZnVuY3Rpb24oZnVuYyl7ZXh0cmFNb2R1bGVzLnB1c2goZnVuYyl9LGl0c2VsZi5hZGRNb2R1bGUoc3R5bGUucmVnaXN0ZXIpLGl0c2VsZi5kYXRhPWZ1bmN0aW9uKCl7dmFyIGZ1LGYsaSxqLG4sZ2xvYmFscyxkYXRhPXtmdW5jdGlvbnM6W10sb3B0aW9uczpzdGF0ZS5vcHRpb259LGltcGxpZWRzPVtdLG1lbWJlcnM9W107aXRzZWxmLmVycm9ycy5sZW5ndGgmJihkYXRhLmVycm9ycz1pdHNlbGYuZXJyb3JzKSxzdGF0ZS5qc29uTW9kZSYmKGRhdGEuanNvbj0hMCk7Zm9yKG4gaW4gaW1wbGllZClfLmhhcyhpbXBsaWVkLG4pJiZpbXBsaWVkcy5wdXNoKHtuYW1lOm4sbGluZTppbXBsaWVkW25dfSk7Zm9yKGltcGxpZWRzLmxlbmd0aD4wJiYoZGF0YS5pbXBsaWVkcz1pbXBsaWVkcyksdXJscy5sZW5ndGg+MCYmKGRhdGEudXJscz11cmxzKSxnbG9iYWxzPU9iamVjdC5rZXlzKHNjb3BlKSxnbG9iYWxzLmxlbmd0aD4wJiYoZGF0YS5nbG9iYWxzPWdsb2JhbHMpLGk9MTtmdW5jdGlvbnMubGVuZ3RoPmk7aSs9MSl7Zm9yKGY9ZnVuY3Rpb25zW2ldLGZ1PXt9LGo9MDtmdW5jdGlvbmljaXR5Lmxlbmd0aD5qO2orPTEpZnVbZnVuY3Rpb25pY2l0eVtqXV09W107Zm9yKGo9MDtmdW5jdGlvbmljaXR5Lmxlbmd0aD5qO2orPTEpMD09PWZ1W2Z1bmN0aW9uaWNpdHlbal1dLmxlbmd0aCYmZGVsZXRlIGZ1W2Z1bmN0aW9uaWNpdHlbal1dO2Z1Lm5hbWU9ZltcXFwiKG5hbWUpXFxcIl0sZnUucGFyYW09ZltcXFwiKHBhcmFtcylcXFwiXSxmdS5saW5lPWZbXFxcIihsaW5lKVxcXCJdLGZ1LmNoYXJhY3Rlcj1mW1xcXCIoY2hhcmFjdGVyKVxcXCJdLGZ1Lmxhc3Q9ZltcXFwiKGxhc3QpXFxcIl0sZnUubGFzdGNoYXJhY3Rlcj1mW1xcXCIobGFzdGNoYXJhY3RlcilcXFwiXSxmdS5tZXRyaWNzPXtjb21wbGV4aXR5OmZbXFxcIihtZXRyaWNzKVxcXCJdLkNvbXBsZXhpdHlDb3VudCxwYXJhbWV0ZXJzOihmW1xcXCIocGFyYW1zKVxcXCJdfHxbXSkubGVuZ3RoLHN0YXRlbWVudHM6ZltcXFwiKG1ldHJpY3MpXFxcIl0uc3RhdGVtZW50Q291bnR9LGRhdGEuZnVuY3Rpb25zLnB1c2goZnUpfXVudXNlZHMubGVuZ3RoPjAmJihkYXRhLnVudXNlZD11bnVzZWRzKSxtZW1iZXJzPVtdO2ZvcihuIGluIG1lbWJlcilpZihcXFwibnVtYmVyXFxcIj09dHlwZW9mIG1lbWJlcltuXSl7ZGF0YS5tZW1iZXI9bWVtYmVyO2JyZWFrfXJldHVybiBkYXRhfSxpdHNlbGYuanNoaW50PWl0c2VsZixpdHNlbGZ9KCk7XFxcIm9iamVjdFxcXCI9PXR5cGVvZiBleHBvcnRzJiZleHBvcnRzJiYoZXhwb3J0cy5KU0hJTlQ9SlNISU5UKX0se1xcXCIuL2xleC5qc1xcXCI6NCxcXFwiLi9tZXNzYWdlcy5qc1xcXCI6NSxcXFwiLi9yZWcuanNcXFwiOjYsXFxcIi4vc3RhdGUuanNcXFwiOjcsXFxcIi4vc3R5bGUuanNcXFwiOjgsXFxcIi4vdmFycy5qc1xcXCI6OSxldmVudHM6MTAsdW5kZXJzY29yZToyfV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XFxcInVzZSBzdHJpY3RcXFwiO2Z1bmN0aW9uIGFzeW5jVHJpZ2dlcigpe3ZhciBfY2hlY2tzPVtdO3JldHVybntwdXNoOmZ1bmN0aW9uKGZuKXtfY2hlY2tzLnB1c2goZm4pfSxjaGVjazpmdW5jdGlvbigpe2Zvcih2YXIgY2hlY2s9MDtfY2hlY2tzLmxlbmd0aD5jaGVjazsrK2NoZWNrKV9jaGVja3NbY2hlY2tdKCk7X2NoZWNrcy5zcGxpY2UoMCxfY2hlY2tzLmxlbmd0aCl9fX1mdW5jdGlvbiBMZXhlcihzb3VyY2Upe3ZhciBsaW5lcz1zb3VyY2U7XFxcInN0cmluZ1xcXCI9PXR5cGVvZiBsaW5lcyYmKGxpbmVzPWxpbmVzLnJlcGxhY2UoL1xcXFxyXFxcXG4vZyxcXFwiXFxcXG5cXFwiKS5yZXBsYWNlKC9cXFxcci9nLFxcXCJcXFxcblxcXCIpLnNwbGl0KFxcXCJcXFxcblxcXCIpKSxsaW5lc1swXSYmXFxcIiMhXFxcIj09PWxpbmVzWzBdLnN1YnN0cigwLDIpJiYoLTEhPT1saW5lc1swXS5pbmRleE9mKFxcXCJub2RlXFxcIikmJihzdGF0ZS5vcHRpb24ubm9kZT0hMCksbGluZXNbMF09XFxcIlxcXCIpLHRoaXMuZW1pdHRlcj1uZXcgZXZlbnRzLkV2ZW50RW1pdHRlcix0aGlzLnNvdXJjZT1zb3VyY2UsdGhpcy5zZXRMaW5lcyhsaW5lcyksdGhpcy5wcmVyZWc9ITAsdGhpcy5saW5lPTAsdGhpcy5jaGFyPTEsdGhpcy5mcm9tPTEsdGhpcy5pbnB1dD1cXFwiXFxcIix0aGlzLmluQ29tbWVudD0hMTtmb3IodmFyIGk9MDtzdGF0ZS5vcHRpb24uaW5kZW50Pmk7aSs9MSlzdGF0ZS50YWIrPVxcXCIgXFxcIn12YXIgXz1fZGVyZXFfKFxcXCJ1bmRlcnNjb3JlXFxcIiksZXZlbnRzPV9kZXJlcV8oXFxcImV2ZW50c1xcXCIpLHJlZz1fZGVyZXFfKFxcXCIuL3JlZy5qc1xcXCIpLHN0YXRlPV9kZXJlcV8oXFxcIi4vc3RhdGUuanNcXFwiKS5zdGF0ZSx1bmljb2RlRGF0YT1fZGVyZXFfKFxcXCIuLi9kYXRhL2FzY2lpLWlkZW50aWZpZXItZGF0YS5qc1xcXCIpLGFzY2lpSWRlbnRpZmllclN0YXJ0VGFibGU9dW5pY29kZURhdGEuYXNjaWlJZGVudGlmaWVyU3RhcnRUYWJsZSxhc2NpaUlkZW50aWZpZXJQYXJ0VGFibGU9dW5pY29kZURhdGEuYXNjaWlJZGVudGlmaWVyUGFydFRhYmxlLFRva2VuPXtJZGVudGlmaWVyOjEsUHVuY3R1YXRvcjoyLE51bWVyaWNMaXRlcmFsOjMsU3RyaW5nTGl0ZXJhbDo0LENvbW1lbnQ6NSxLZXl3b3JkOjYsTnVsbExpdGVyYWw6NyxCb29sZWFuTGl0ZXJhbDo4LFJlZ0V4cDo5LFRlbXBsYXRlTGl0ZXJhbDoxMH07TGV4ZXIucHJvdG90eXBlPXtfbGluZXM6W10sZ2V0TGluZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbGluZXM9c3RhdGUubGluZXMsdGhpcy5fbGluZXN9LHNldExpbmVzOmZ1bmN0aW9uKHZhbCl7dGhpcy5fbGluZXM9dmFsLHN0YXRlLmxpbmVzPXRoaXMuX2xpbmVzfSxwZWVrOmZ1bmN0aW9uKGkpe3JldHVybiB0aGlzLmlucHV0LmNoYXJBdChpfHwwKX0sc2tpcDpmdW5jdGlvbihpKXtpPWl8fDEsdGhpcy5jaGFyKz1pLHRoaXMuaW5wdXQ9dGhpcy5pbnB1dC5zbGljZShpKX0sb246ZnVuY3Rpb24obmFtZXMsbGlzdGVuZXIpe25hbWVzLnNwbGl0KFxcXCIgXFxcIikuZm9yRWFjaChmdW5jdGlvbihuYW1lKXt0aGlzLmVtaXR0ZXIub24obmFtZSxsaXN0ZW5lcil9LmJpbmQodGhpcykpfSx0cmlnZ2VyOmZ1bmN0aW9uKCl7dGhpcy5lbWl0dGVyLmVtaXQuYXBwbHkodGhpcy5lbWl0dGVyLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpfSx0cmlnZ2VyQXN5bmM6ZnVuY3Rpb24odHlwZSxhcmdzLGNoZWNrcyxmbil7Y2hlY2tzLnB1c2goZnVuY3Rpb24oKXtmbigpJiZ0aGlzLnRyaWdnZXIodHlwZSxhcmdzKX0uYmluZCh0aGlzKSl9LHNjYW5QdW5jdHVhdG9yOmZ1bmN0aW9uKCl7dmFyIGNoMixjaDMsY2g0LGNoMT10aGlzLnBlZWsoKTtzd2l0Y2goY2gxKXtjYXNlXFxcIi5cXFwiOmlmKC9eWzAtOV0kLy50ZXN0KHRoaXMucGVlaygxKSkpcmV0dXJuIG51bGw7aWYoXFxcIi5cXFwiPT09dGhpcy5wZWVrKDEpJiZcXFwiLlxcXCI9PT10aGlzLnBlZWsoMikpcmV0dXJue3R5cGU6VG9rZW4uUHVuY3R1YXRvcix2YWx1ZTpcXFwiLi4uXFxcIn07Y2FzZVxcXCIoXFxcIjpjYXNlXFxcIilcXFwiOmNhc2VcXFwiO1xcXCI6Y2FzZVxcXCIsXFxcIjpjYXNlXFxcIntcXFwiOmNhc2VcXFwifVxcXCI6Y2FzZVxcXCJbXFxcIjpjYXNlXFxcIl1cXFwiOmNhc2VcXFwiOlxcXCI6Y2FzZVxcXCJ+XFxcIjpjYXNlXFxcIj9cXFwiOnJldHVybnt0eXBlOlRva2VuLlB1bmN0dWF0b3IsdmFsdWU6Y2gxfTtjYXNlXFxcIiNcXFwiOnJldHVybnt0eXBlOlRva2VuLlB1bmN0dWF0b3IsdmFsdWU6Y2gxfTtjYXNlXFxcIlxcXCI6cmV0dXJuIG51bGx9cmV0dXJuIGNoMj10aGlzLnBlZWsoMSksY2gzPXRoaXMucGVlaygyKSxjaDQ9dGhpcy5wZWVrKDMpLFxcXCI+XFxcIj09PWNoMSYmXFxcIj5cXFwiPT09Y2gyJiZcXFwiPlxcXCI9PT1jaDMmJlxcXCI9XFxcIj09PWNoND97dHlwZTpUb2tlbi5QdW5jdHVhdG9yLHZhbHVlOlxcXCI+Pj49XFxcIn06XFxcIj1cXFwiPT09Y2gxJiZcXFwiPVxcXCI9PT1jaDImJlxcXCI9XFxcIj09PWNoMz97dHlwZTpUb2tlbi5QdW5jdHVhdG9yLHZhbHVlOlxcXCI9PT1cXFwifTpcXFwiIVxcXCI9PT1jaDEmJlxcXCI9XFxcIj09PWNoMiYmXFxcIj1cXFwiPT09Y2gzP3t0eXBlOlRva2VuLlB1bmN0dWF0b3IsdmFsdWU6XFxcIiE9PVxcXCJ9OlxcXCI+XFxcIj09PWNoMSYmXFxcIj5cXFwiPT09Y2gyJiZcXFwiPlxcXCI9PT1jaDM/e3R5cGU6VG9rZW4uUHVuY3R1YXRvcix2YWx1ZTpcXFwiPj4+XFxcIn06XFxcIjxcXFwiPT09Y2gxJiZcXFwiPFxcXCI9PT1jaDImJlxcXCI9XFxcIj09PWNoMz97dHlwZTpUb2tlbi5QdW5jdHVhdG9yLHZhbHVlOlxcXCI8PD1cXFwifTpcXFwiPlxcXCI9PT1jaDEmJlxcXCI+XFxcIj09PWNoMiYmXFxcIj1cXFwiPT09Y2gzP3t0eXBlOlRva2VuLlB1bmN0dWF0b3IsdmFsdWU6XFxcIj4+PVxcXCJ9OlxcXCI9XFxcIj09PWNoMSYmXFxcIj5cXFwiPT09Y2gyP3t0eXBlOlRva2VuLlB1bmN0dWF0b3IsdmFsdWU6Y2gxK2NoMn06Y2gxPT09Y2gyJiZcXFwiKy08PiZ8XFxcIi5pbmRleE9mKGNoMSk+PTA/e3R5cGU6VG9rZW4uUHVuY3R1YXRvcix2YWx1ZTpjaDErY2gyfTpcXFwiPD49ISstKiUmfF5cXFwiLmluZGV4T2YoY2gxKT49MD9cXFwiPVxcXCI9PT1jaDI/e3R5cGU6VG9rZW4uUHVuY3R1YXRvcix2YWx1ZTpjaDErY2gyfTp7dHlwZTpUb2tlbi5QdW5jdHVhdG9yLHZhbHVlOmNoMX06XFxcIi9cXFwiPT09Y2gxP1xcXCI9XFxcIj09PWNoMiYmL1xcXFwvPSg/IShcXFxcUypcXFxcL1tnaW1dPykpLy50ZXN0KHRoaXMuaW5wdXQpP3t0eXBlOlRva2VuLlB1bmN0dWF0b3IsdmFsdWU6XFxcIi89XFxcIn06e3R5cGU6VG9rZW4uUHVuY3R1YXRvcix2YWx1ZTpcXFwiL1xcXCJ9Om51bGx9LHNjYW5Db21tZW50czpmdW5jdGlvbigpe2Z1bmN0aW9uIGNvbW1lbnRUb2tlbihsYWJlbCxib2R5LG9wdCl7dmFyIHNwZWNpYWw9W1xcXCJqc2hpbnRcXFwiLFxcXCJqc2xpbnRcXFwiLFxcXCJtZW1iZXJzXFxcIixcXFwibWVtYmVyXFxcIixcXFwiZ2xvYmFsc1xcXCIsXFxcImdsb2JhbFxcXCIsXFxcImV4cG9ydGVkXFxcIl0saXNTcGVjaWFsPSExLHZhbHVlPWxhYmVsK2JvZHksY29tbWVudFR5cGU9XFxcInBsYWluXFxcIjtyZXR1cm4gb3B0PW9wdHx8e30sb3B0LmlzTXVsdGlsaW5lJiYodmFsdWUrPVxcXCIqL1xcXCIpLHNwZWNpYWwuZm9yRWFjaChmdW5jdGlvbihzdHIpe2lmKCFpc1NwZWNpYWwmJihcXFwiLy9cXFwiIT09bGFiZWx8fFxcXCJqc2hpbnRcXFwiPT09c3RyKSYmKGJvZHkuc3Vic3RyKDAsc3RyLmxlbmd0aCk9PT1zdHImJihpc1NwZWNpYWw9ITAsbGFiZWwrPXN0cixib2R5PWJvZHkuc3Vic3RyKHN0ci5sZW5ndGgpKSxpc1NwZWNpYWx8fFxcXCIgXFxcIiE9PWJvZHkuY2hhckF0KDApfHxib2R5LnN1YnN0cigxLHN0ci5sZW5ndGgpIT09c3RyfHwoaXNTcGVjaWFsPSEwLGxhYmVsPWxhYmVsK1xcXCIgXFxcIitzdHIsYm9keT1ib2R5LnN1YnN0cihzdHIubGVuZ3RoKzEpKSxpc1NwZWNpYWwpKXN3aXRjaChzdHIpe2Nhc2VcXFwibWVtYmVyXFxcIjpjb21tZW50VHlwZT1cXFwibWVtYmVyc1xcXCI7YnJlYWs7Y2FzZVxcXCJnbG9iYWxcXFwiOmNvbW1lbnRUeXBlPVxcXCJnbG9iYWxzXFxcIjticmVhaztkZWZhdWx0OmNvbW1lbnRUeXBlPXN0cn19KSx7dHlwZTpUb2tlbi5Db21tZW50LGNvbW1lbnRUeXBlOmNvbW1lbnRUeXBlLHZhbHVlOnZhbHVlLGJvZHk6Ym9keSxpc1NwZWNpYWw6aXNTcGVjaWFsLGlzTXVsdGlsaW5lOm9wdC5pc011bHRpbGluZXx8ITEsaXNNYWxmb3JtZWQ6b3B0LmlzTWFsZm9ybWVkfHwhMX19dmFyIGNoMT10aGlzLnBlZWsoKSxjaDI9dGhpcy5wZWVrKDEpLHJlc3Q9dGhpcy5pbnB1dC5zdWJzdHIoMiksc3RhcnRMaW5lPXRoaXMubGluZSxzdGFydENoYXI9dGhpcy5jaGFyO2lmKFxcXCIqXFxcIj09PWNoMSYmXFxcIi9cXFwiPT09Y2gyKXJldHVybiB0aGlzLnRyaWdnZXIoXFxcImVycm9yXFxcIix7Y29kZTpcXFwiRTAxOFxcXCIsbGluZTpzdGFydExpbmUsY2hhcmFjdGVyOnN0YXJ0Q2hhcn0pLHRoaXMuc2tpcCgyKSxudWxsO2lmKFxcXCIvXFxcIiE9PWNoMXx8XFxcIipcXFwiIT09Y2gyJiZcXFwiL1xcXCIhPT1jaDIpcmV0dXJuIG51bGw7aWYoXFxcIi9cXFwiPT09Y2gyKXJldHVybiB0aGlzLnNraXAodGhpcy5pbnB1dC5sZW5ndGgpLGNvbW1lbnRUb2tlbihcXFwiLy9cXFwiLHJlc3QpO3ZhciBib2R5PVxcXCJcXFwiO2lmKFxcXCIqXFxcIj09PWNoMil7Zm9yKHRoaXMuaW5Db21tZW50PSEwLHRoaXMuc2tpcCgyKTtcXFwiKlxcXCIhPT10aGlzLnBlZWsoKXx8XFxcIi9cXFwiIT09dGhpcy5wZWVrKDEpOylpZihcXFwiXFxcIj09PXRoaXMucGVlaygpKXtpZihib2R5Kz1cXFwiXFxcXG5cXFwiLCF0aGlzLm5leHRMaW5lKCkpcmV0dXJuIHRoaXMudHJpZ2dlcihcXFwiZXJyb3JcXFwiLHtjb2RlOlxcXCJFMDE3XFxcIixsaW5lOnN0YXJ0TGluZSxjaGFyYWN0ZXI6c3RhcnRDaGFyfSksdGhpcy5pbkNvbW1lbnQ9ITEsY29tbWVudFRva2VuKFxcXCIvKlxcXCIsYm9keSx7aXNNdWx0aWxpbmU6ITAsaXNNYWxmb3JtZWQ6ITB9KX1lbHNlIGJvZHkrPXRoaXMucGVlaygpLHRoaXMuc2tpcCgpO3JldHVybiB0aGlzLnNraXAoMiksdGhpcy5pbkNvbW1lbnQ9ITEsY29tbWVudFRva2VuKFxcXCIvKlxcXCIsYm9keSx7aXNNdWx0aWxpbmU6ITB9KX19LHNjYW5LZXl3b3JkOmZ1bmN0aW9uKCl7dmFyIHJlc3VsdD0vXlthLXpBLVpfJF1bYS16QS1aMC05XyRdKi8uZXhlYyh0aGlzLmlucHV0KSxrZXl3b3Jkcz1bXFxcImlmXFxcIixcXFwiaW5cXFwiLFxcXCJkb1xcXCIsXFxcInZhclxcXCIsXFxcImZvclxcXCIsXFxcIm5ld1xcXCIsXFxcInRyeVxcXCIsXFxcImxldFxcXCIsXFxcInRoaXNcXFwiLFxcXCJlbHNlXFxcIixcXFwiY2FzZVxcXCIsXFxcInZvaWRcXFwiLFxcXCJ3aXRoXFxcIixcXFwiZW51bVxcXCIsXFxcIndoaWxlXFxcIixcXFwiYnJlYWtcXFwiLFxcXCJjYXRjaFxcXCIsXFxcInRocm93XFxcIixcXFwiY29uc3RcXFwiLFxcXCJ5aWVsZFxcXCIsXFxcImNsYXNzXFxcIixcXFwic3VwZXJcXFwiLFxcXCJyZXR1cm5cXFwiLFxcXCJ0eXBlb2ZcXFwiLFxcXCJkZWxldGVcXFwiLFxcXCJzd2l0Y2hcXFwiLFxcXCJleHBvcnRcXFwiLFxcXCJpbXBvcnRcXFwiLFxcXCJkZWZhdWx0XFxcIixcXFwiZmluYWxseVxcXCIsXFxcImV4dGVuZHNcXFwiLFxcXCJmdW5jdGlvblxcXCIsXFxcImNvbnRpbnVlXFxcIixcXFwiZGVidWdnZXJcXFwiLFxcXCJpbnN0YW5jZW9mXFxcIl07cmV0dXJuIHJlc3VsdCYma2V5d29yZHMuaW5kZXhPZihyZXN1bHRbMF0pPj0wP3t0eXBlOlRva2VuLktleXdvcmQsdmFsdWU6cmVzdWx0WzBdfTpudWxsfSxzY2FuSWRlbnRpZmllcjpmdW5jdGlvbigpe2Z1bmN0aW9uIGlzTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQoY29kZSl7cmV0dXJuIGNvZGU+MjU2fWZ1bmN0aW9uIGlzTm9uQXNjaWlJZGVudGlmaWVyUGFydChjb2RlKXtyZXR1cm4gY29kZT4yNTZ9ZnVuY3Rpb24gaXNIZXhEaWdpdChzdHIpe3JldHVybi9eWzAtOWEtZkEtRl0kLy50ZXN0KHN0cil9dmFyIHR5cGUsY2hhcixpZD1cXFwiXFxcIixpbmRleD0wLHJlYWRVbmljb2RlRXNjYXBlU2VxdWVuY2U9ZnVuY3Rpb24oKXtpZihpbmRleCs9MSxcXFwidVxcXCIhPT10aGlzLnBlZWsoaW5kZXgpKXJldHVybiBudWxsO3ZhciBjb2RlLGNoMT10aGlzLnBlZWsoaW5kZXgrMSksY2gyPXRoaXMucGVlayhpbmRleCsyKSxjaDM9dGhpcy5wZWVrKGluZGV4KzMpLGNoND10aGlzLnBlZWsoaW5kZXgrNCk7cmV0dXJuIGlzSGV4RGlnaXQoY2gxKSYmaXNIZXhEaWdpdChjaDIpJiZpc0hleERpZ2l0KGNoMykmJmlzSGV4RGlnaXQoY2g0KT8oY29kZT1wYXJzZUludChjaDErY2gyK2NoMytjaDQsMTYpLGFzY2lpSWRlbnRpZmllclBhcnRUYWJsZVtjb2RlXXx8aXNOb25Bc2NpaUlkZW50aWZpZXJQYXJ0KGNvZGUpPyhpbmRleCs9NSxcXFwiXFxcXFxcXFx1XFxcIitjaDErY2gyK2NoMytjaDQpOm51bGwpOm51bGxcXG59LmJpbmQodGhpcyksZ2V0SWRlbnRpZmllclN0YXJ0PWZ1bmN0aW9uKCl7dmFyIGNocj10aGlzLnBlZWsoaW5kZXgpLGNvZGU9Y2hyLmNoYXJDb2RlQXQoMCk7cmV0dXJuIDkyPT09Y29kZT9yZWFkVW5pY29kZUVzY2FwZVNlcXVlbmNlKCk6MTI4PmNvZGU/YXNjaWlJZGVudGlmaWVyU3RhcnRUYWJsZVtjb2RlXT8oaW5kZXgrPTEsY2hyKTpudWxsOmlzTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQoY29kZSk/KGluZGV4Kz0xLGNocik6bnVsbH0uYmluZCh0aGlzKSxnZXRJZGVudGlmaWVyUGFydD1mdW5jdGlvbigpe3ZhciBjaHI9dGhpcy5wZWVrKGluZGV4KSxjb2RlPWNoci5jaGFyQ29kZUF0KDApO3JldHVybiA5Mj09PWNvZGU/cmVhZFVuaWNvZGVFc2NhcGVTZXF1ZW5jZSgpOjEyOD5jb2RlP2FzY2lpSWRlbnRpZmllclBhcnRUYWJsZVtjb2RlXT8oaW5kZXgrPTEsY2hyKTpudWxsOmlzTm9uQXNjaWlJZGVudGlmaWVyUGFydChjb2RlKT8oaW5kZXgrPTEsY2hyKTpudWxsfS5iaW5kKHRoaXMpO2lmKGNoYXI9Z2V0SWRlbnRpZmllclN0YXJ0KCksbnVsbD09PWNoYXIpcmV0dXJuIG51bGw7Zm9yKGlkPWNoYXI7Y2hhcj1nZXRJZGVudGlmaWVyUGFydCgpLG51bGwhPT1jaGFyOylpZCs9Y2hhcjtzd2l0Y2goaWQpe2Nhc2VcXFwidHJ1ZVxcXCI6Y2FzZVxcXCJmYWxzZVxcXCI6dHlwZT1Ub2tlbi5Cb29sZWFuTGl0ZXJhbDticmVhaztjYXNlXFxcIm51bGxcXFwiOnR5cGU9VG9rZW4uTnVsbExpdGVyYWw7YnJlYWs7ZGVmYXVsdDp0eXBlPVRva2VuLklkZW50aWZpZXJ9cmV0dXJue3R5cGU6dHlwZSx2YWx1ZTppZH19LHNjYW5OdW1lcmljTGl0ZXJhbDpmdW5jdGlvbigpe2Z1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KHN0cil7cmV0dXJuL15bMC05XSQvLnRlc3Qoc3RyKX1mdW5jdGlvbiBpc09jdGFsRGlnaXQoc3RyKXtyZXR1cm4vXlswLTddJC8udGVzdChzdHIpfWZ1bmN0aW9uIGlzSGV4RGlnaXQoc3RyKXtyZXR1cm4vXlswLTlhLWZBLUZdJC8udGVzdChzdHIpfWZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKXtyZXR1cm5cXFwiJFxcXCI9PT1jaHx8XFxcIl9cXFwiPT09Y2h8fFxcXCJcXFxcXFxcXFxcXCI9PT1jaHx8Y2g+PVxcXCJhXFxcIiYmXFxcInpcXFwiPj1jaHx8Y2g+PVxcXCJBXFxcIiYmXFxcIlpcXFwiPj1jaH12YXIgYmFkLGluZGV4PTAsdmFsdWU9XFxcIlxcXCIsbGVuZ3RoPXRoaXMuaW5wdXQubGVuZ3RoLGNoYXI9dGhpcy5wZWVrKGluZGV4KTtpZihcXFwiLlxcXCIhPT1jaGFyJiYhaXNEZWNpbWFsRGlnaXQoY2hhcikpcmV0dXJuIG51bGw7aWYoXFxcIi5cXFwiIT09Y2hhcil7aWYodmFsdWU9dGhpcy5wZWVrKGluZGV4KSxpbmRleCs9MSxjaGFyPXRoaXMucGVlayhpbmRleCksXFxcIjBcXFwiPT09dmFsdWUpe2lmKFxcXCJ4XFxcIj09PWNoYXJ8fFxcXCJYXFxcIj09PWNoYXIpe2ZvcihpbmRleCs9MSx2YWx1ZSs9Y2hhcjtsZW5ndGg+aW5kZXgmJihjaGFyPXRoaXMucGVlayhpbmRleCksaXNIZXhEaWdpdChjaGFyKSk7KXZhbHVlKz1jaGFyLGluZGV4Kz0xO3JldHVybiAyPj12YWx1ZS5sZW5ndGg/e3R5cGU6VG9rZW4uTnVtZXJpY0xpdGVyYWwsdmFsdWU6dmFsdWUsaXNNYWxmb3JtZWQ6ITB9Omxlbmd0aD5pbmRleCYmKGNoYXI9dGhpcy5wZWVrKGluZGV4KSxpc0lkZW50aWZpZXJTdGFydChjaGFyKSk/bnVsbDp7dHlwZTpUb2tlbi5OdW1lcmljTGl0ZXJhbCx2YWx1ZTp2YWx1ZSxiYXNlOjE2LGlzTWFsZm9ybWVkOiExfX1pZihpc09jdGFsRGlnaXQoY2hhcikpe2ZvcihpbmRleCs9MSx2YWx1ZSs9Y2hhcixiYWQ9ITE7bGVuZ3RoPmluZGV4Oyl7aWYoY2hhcj10aGlzLnBlZWsoaW5kZXgpLGlzRGVjaW1hbERpZ2l0KGNoYXIpKWJhZD0hMDtlbHNlIGlmKCFpc09jdGFsRGlnaXQoY2hhcikpYnJlYWs7dmFsdWUrPWNoYXIsaW5kZXgrPTF9cmV0dXJuIGxlbmd0aD5pbmRleCYmKGNoYXI9dGhpcy5wZWVrKGluZGV4KSxpc0lkZW50aWZpZXJTdGFydChjaGFyKSk/bnVsbDp7dHlwZTpUb2tlbi5OdW1lcmljTGl0ZXJhbCx2YWx1ZTp2YWx1ZSxiYXNlOjgsaXNNYWxmb3JtZWQ6ITF9fWlzRGVjaW1hbERpZ2l0KGNoYXIpJiYoaW5kZXgrPTEsdmFsdWUrPWNoYXIpfWZvcig7bGVuZ3RoPmluZGV4JiYoY2hhcj10aGlzLnBlZWsoaW5kZXgpLGlzRGVjaW1hbERpZ2l0KGNoYXIpKTspdmFsdWUrPWNoYXIsaW5kZXgrPTF9aWYoXFxcIi5cXFwiPT09Y2hhcilmb3IodmFsdWUrPWNoYXIsaW5kZXgrPTE7bGVuZ3RoPmluZGV4JiYoY2hhcj10aGlzLnBlZWsoaW5kZXgpLGlzRGVjaW1hbERpZ2l0KGNoYXIpKTspdmFsdWUrPWNoYXIsaW5kZXgrPTE7aWYoXFxcImVcXFwiPT09Y2hhcnx8XFxcIkVcXFwiPT09Y2hhcil7aWYodmFsdWUrPWNoYXIsaW5kZXgrPTEsY2hhcj10aGlzLnBlZWsoaW5kZXgpLChcXFwiK1xcXCI9PT1jaGFyfHxcXFwiLVxcXCI9PT1jaGFyKSYmKHZhbHVlKz10aGlzLnBlZWsoaW5kZXgpLGluZGV4Kz0xKSxjaGFyPXRoaXMucGVlayhpbmRleCksIWlzRGVjaW1hbERpZ2l0KGNoYXIpKXJldHVybiBudWxsO2Zvcih2YWx1ZSs9Y2hhcixpbmRleCs9MTtsZW5ndGg+aW5kZXgmJihjaGFyPXRoaXMucGVlayhpbmRleCksaXNEZWNpbWFsRGlnaXQoY2hhcikpOyl2YWx1ZSs9Y2hhcixpbmRleCs9MX1yZXR1cm4gbGVuZ3RoPmluZGV4JiYoY2hhcj10aGlzLnBlZWsoaW5kZXgpLGlzSWRlbnRpZmllclN0YXJ0KGNoYXIpKT9udWxsOnt0eXBlOlRva2VuLk51bWVyaWNMaXRlcmFsLHZhbHVlOnZhbHVlLGJhc2U6MTAsaXNNYWxmb3JtZWQ6IWlzRmluaXRlKHZhbHVlKX19LHNjYW5UZW1wbGF0ZUxpdGVyYWw6ZnVuY3Rpb24oKXtpZighc3RhdGUub3B0aW9uLmVzbmV4dHx8XFxcImBcXFwiIT09dGhpcy5wZWVrKCkpcmV0dXJuIG51bGw7dmFyIHN0YXJ0TGluZT10aGlzLmxpbmUsc3RhcnRDaGFyPXRoaXMuY2hhcixqdW1wPTEsdmFsdWU9XFxcIlxcXCI7Zm9yKHRoaXMuc2tpcCgpO1xcXCJgXFxcIiE9PXRoaXMucGVlaygpOyl7Zm9yKDtcXFwiXFxcIj09PXRoaXMucGVlaygpOyl7aWYoIXRoaXMubmV4dExpbmUoKSlyZXR1cm4gdGhpcy50cmlnZ2VyKFxcXCJlcnJvclxcXCIse2NvZGU6XFxcIkUwNTJcXFwiLGxpbmU6c3RhcnRMaW5lLGNoYXJhY3RlcjpzdGFydENoYXJ9KSx7dHlwZTpUb2tlbi5UZW1wbGF0ZUxpdGVyYWwsdmFsdWU6dmFsdWUsaXNVbmNsb3NlZDohMH07dmFsdWUrPVxcXCJcXFxcblxcXCJ9dmFyIGNoYXI9dGhpcy5wZWVrKCk7dGhpcy5za2lwKGp1bXApLHZhbHVlKz1jaGFyfXJldHVybiB0aGlzLnNraXAoKSx7dHlwZTpUb2tlbi5UZW1wbGF0ZUxpdGVyYWwsdmFsdWU6dmFsdWUsaXNVbmNsb3NlZDohMX19LHNjYW5TdHJpbmdMaXRlcmFsOmZ1bmN0aW9uKGNoZWNrcyl7dmFyIHF1b3RlPXRoaXMucGVlaygpO2lmKCdcXFwiJyE9PXF1b3RlJiZcXFwiJ1xcXCIhPT1xdW90ZSlyZXR1cm4gbnVsbDt0aGlzLnRyaWdnZXJBc3luYyhcXFwid2FybmluZ1xcXCIse2NvZGU6XFxcIlcxMDhcXFwiLGxpbmU6dGhpcy5saW5lLGNoYXJhY3Rlcjp0aGlzLmNoYXJ9LGNoZWNrcyxmdW5jdGlvbigpe3JldHVybiBzdGF0ZS5qc29uTW9kZSYmJ1xcXCInIT09cXVvdGV9KTt2YXIgdmFsdWU9XFxcIlxcXCIsc3RhcnRMaW5lPXRoaXMubGluZSxzdGFydENoYXI9dGhpcy5jaGFyLGFsbG93TmV3TGluZT0hMTt0aGlzLnNraXAoKTtvdXRlcjpmb3IoO3RoaXMucGVlaygpIT09cXVvdGU7KXtmb3IoO1xcXCJcXFwiPT09dGhpcy5wZWVrKCk7KXtpZihhbGxvd05ld0xpbmU/KGFsbG93TmV3TGluZT0hMSx0aGlzLnRyaWdnZXJBc3luYyhcXFwid2FybmluZ1xcXCIse2NvZGU6XFxcIlcwNDNcXFwiLGxpbmU6dGhpcy5saW5lLGNoYXJhY3Rlcjp0aGlzLmNoYXJ9LGNoZWNrcyxmdW5jdGlvbigpe3JldHVybiFzdGF0ZS5vcHRpb24ubXVsdGlzdHJ9KSx0aGlzLnRyaWdnZXJBc3luYyhcXFwid2FybmluZ1xcXCIse2NvZGU6XFxcIlcwNDJcXFwiLGxpbmU6dGhpcy5saW5lLGNoYXJhY3Rlcjp0aGlzLmNoYXJ9LGNoZWNrcyxmdW5jdGlvbigpe3JldHVybiBzdGF0ZS5qc29uTW9kZSYmc3RhdGUub3B0aW9uLm11bHRpc3RyfSkpOnRoaXMudHJpZ2dlcihcXFwid2FybmluZ1xcXCIse2NvZGU6XFxcIlcxMTJcXFwiLGxpbmU6dGhpcy5saW5lLGNoYXJhY3Rlcjp0aGlzLmNoYXJ9KSwhdGhpcy5uZXh0TGluZSgpKXJldHVybiB0aGlzLnRyaWdnZXIoXFxcImVycm9yXFxcIix7Y29kZTpcXFwiRTAyOVxcXCIsbGluZTpzdGFydExpbmUsY2hhcmFjdGVyOnN0YXJ0Q2hhcn0pLHt0eXBlOlRva2VuLlN0cmluZ0xpdGVyYWwsdmFsdWU6dmFsdWUsaXNVbmNsb3NlZDohMCxxdW90ZTpxdW90ZX07aWYodGhpcy5wZWVrKCk9PXF1b3RlKWJyZWFrIG91dGVyfWFsbG93TmV3TGluZT0hMTt2YXIgY2hhcj10aGlzLnBlZWsoKSxqdW1wPTE7aWYoXFxcIiBcXFwiPmNoYXImJnRoaXMudHJpZ2dlcihcXFwid2FybmluZ1xcXCIse2NvZGU6XFxcIlcxMTNcXFwiLGxpbmU6dGhpcy5saW5lLGNoYXJhY3Rlcjp0aGlzLmNoYXIsZGF0YTpbXFxcIjxub24tcHJpbnRhYmxlPlxcXCJdfSksXFxcIlxcXFxcXFxcXFxcIj09PWNoYXIpc3dpdGNoKHRoaXMuc2tpcCgpLGNoYXI9dGhpcy5wZWVrKCkpe2Nhc2VcXFwiJ1xcXCI6dGhpcy50cmlnZ2VyQXN5bmMoXFxcIndhcm5pbmdcXFwiLHtjb2RlOlxcXCJXMTE0XFxcIixsaW5lOnRoaXMubGluZSxjaGFyYWN0ZXI6dGhpcy5jaGFyLGRhdGE6W1xcXCJcXFxcXFxcXCdcXFwiXX0sY2hlY2tzLGZ1bmN0aW9uKCl7cmV0dXJuIHN0YXRlLmpzb25Nb2RlfSk7YnJlYWs7Y2FzZVxcXCJiXFxcIjpjaGFyPVxcXCJcXFxcXFxcXGJcXFwiO2JyZWFrO2Nhc2VcXFwiZlxcXCI6Y2hhcj1cXFwiXFxcXFxcXFxmXFxcIjticmVhaztjYXNlXFxcIm5cXFwiOmNoYXI9XFxcIlxcXFxcXFxcblxcXCI7YnJlYWs7Y2FzZVxcXCJyXFxcIjpjaGFyPVxcXCJcXFxcXFxcXHJcXFwiO2JyZWFrO2Nhc2VcXFwidFxcXCI6Y2hhcj1cXFwiXFxcXFxcXFx0XFxcIjticmVhaztjYXNlXFxcIjBcXFwiOmNoYXI9XFxcIlxcXFxcXFxcMFxcXCI7dmFyIG49cGFyc2VJbnQodGhpcy5wZWVrKDEpLDEwKTt0aGlzLnRyaWdnZXJBc3luYyhcXFwid2FybmluZ1xcXCIse2NvZGU6XFxcIlcxMTVcXFwiLGxpbmU6dGhpcy5saW5lLGNoYXJhY3Rlcjp0aGlzLmNoYXJ9LGNoZWNrcyxmdW5jdGlvbigpe3JldHVybiBuPj0wJiY3Pj1uJiZzdGF0ZS5kaXJlY3RpdmVbXFxcInVzZSBzdHJpY3RcXFwiXX0pO2JyZWFrO2Nhc2VcXFwidVxcXCI6Y2hhcj1TdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHRoaXMuaW5wdXQuc3Vic3RyKDEsNCksMTYpKSxqdW1wPTU7YnJlYWs7Y2FzZVxcXCJ2XFxcIjp0aGlzLnRyaWdnZXJBc3luYyhcXFwid2FybmluZ1xcXCIse2NvZGU6XFxcIlcxMTRcXFwiLGxpbmU6dGhpcy5saW5lLGNoYXJhY3Rlcjp0aGlzLmNoYXIsZGF0YTpbXFxcIlxcXFxcXFxcdlxcXCJdfSxjaGVja3MsZnVuY3Rpb24oKXtyZXR1cm4gc3RhdGUuanNvbk1vZGV9KSxjaGFyPVxcXCJcXHUwMDBiXFxcIjticmVhaztjYXNlXFxcInhcXFwiOnZhciB4PXBhcnNlSW50KHRoaXMuaW5wdXQuc3Vic3RyKDEsMiksMTYpO3RoaXMudHJpZ2dlckFzeW5jKFxcXCJ3YXJuaW5nXFxcIix7Y29kZTpcXFwiVzExNFxcXCIsbGluZTp0aGlzLmxpbmUsY2hhcmFjdGVyOnRoaXMuY2hhcixkYXRhOltcXFwiXFxcXFxcXFx4LVxcXCJdfSxjaGVja3MsZnVuY3Rpb24oKXtyZXR1cm4gc3RhdGUuanNvbk1vZGV9KSxjaGFyPVN0cmluZy5mcm9tQ2hhckNvZGUoeCksanVtcD0zO2JyZWFrO2Nhc2VcXFwiXFxcXFxcXFxcXFwiOmNoYXI9XFxcIlxcXFxcXFxcXFxcXFxcXFxcXFwiO2JyZWFrO2Nhc2UnXFxcIic6Y2hhcj0nXFxcXFxcXFxcXFwiJzticmVhaztjYXNlXFxcIi9cXFwiOmJyZWFrO2Nhc2VcXFwiXFxcIjphbGxvd05ld0xpbmU9ITAsY2hhcj1cXFwiXFxcIjticmVhaztjYXNlXFxcIiFcXFwiOmlmKFxcXCI8XFxcIj09PXZhbHVlLnNsaWNlKHZhbHVlLmxlbmd0aC0yKSlicmVhaztkZWZhdWx0OnRoaXMudHJpZ2dlcihcXFwid2FybmluZ1xcXCIse2NvZGU6XFxcIlcwNDRcXFwiLGxpbmU6dGhpcy5saW5lLGNoYXJhY3Rlcjp0aGlzLmNoYXJ9KX12YWx1ZSs9Y2hhcix0aGlzLnNraXAoanVtcCl9cmV0dXJuIHRoaXMuc2tpcCgpLHt0eXBlOlRva2VuLlN0cmluZ0xpdGVyYWwsdmFsdWU6dmFsdWUsaXNVbmNsb3NlZDohMSxxdW90ZTpxdW90ZX19LHNjYW5SZWdFeHA6ZnVuY3Rpb24oKXt2YXIgdGVybWluYXRlZCxpbmRleD0wLGxlbmd0aD10aGlzLmlucHV0Lmxlbmd0aCxjaGFyPXRoaXMucGVlaygpLHZhbHVlPWNoYXIsYm9keT1cXFwiXFxcIixmbGFncz1bXSxtYWxmb3JtZWQ9ITEsaXNDaGFyU2V0PSExLHNjYW5VbmV4cGVjdGVkQ2hhcnM9ZnVuY3Rpb24oKXtcXFwiIFxcXCI+Y2hhciYmKG1hbGZvcm1lZD0hMCx0aGlzLnRyaWdnZXIoXFxcIndhcm5pbmdcXFwiLHtjb2RlOlxcXCJXMDQ4XFxcIixsaW5lOnRoaXMubGluZSxjaGFyYWN0ZXI6dGhpcy5jaGFyfSkpLFxcXCI8XFxcIj09PWNoYXImJihtYWxmb3JtZWQ9ITAsdGhpcy50cmlnZ2VyKFxcXCJ3YXJuaW5nXFxcIix7Y29kZTpcXFwiVzA0OVxcXCIsbGluZTp0aGlzLmxpbmUsY2hhcmFjdGVyOnRoaXMuY2hhcixkYXRhOltjaGFyXX0pKX0uYmluZCh0aGlzKTtpZighdGhpcy5wcmVyZWd8fFxcXCIvXFxcIiE9PWNoYXIpcmV0dXJuIG51bGw7Zm9yKGluZGV4Kz0xLHRlcm1pbmF0ZWQ9ITE7bGVuZ3RoPmluZGV4OylpZihjaGFyPXRoaXMucGVlayhpbmRleCksdmFsdWUrPWNoYXIsYm9keSs9Y2hhcixpc0NoYXJTZXQpXFxcIl1cXFwiPT09Y2hhciYmKFxcXCJcXFxcXFxcXFxcXCIhPT10aGlzLnBlZWsoaW5kZXgtMSl8fFxcXCJcXFxcXFxcXFxcXCI9PT10aGlzLnBlZWsoaW5kZXgtMikpJiYoaXNDaGFyU2V0PSExKSxcXFwiXFxcXFxcXFxcXFwiPT09Y2hhciYmKGluZGV4Kz0xLGNoYXI9dGhpcy5wZWVrKGluZGV4KSxib2R5Kz1jaGFyLHZhbHVlKz1jaGFyLHNjYW5VbmV4cGVjdGVkQ2hhcnMoKSksaW5kZXgrPTE7ZWxzZXtpZihcXFwiXFxcXFxcXFxcXFwiPT09Y2hhcil7aWYoaW5kZXgrPTEsY2hhcj10aGlzLnBlZWsoaW5kZXgpLGJvZHkrPWNoYXIsdmFsdWUrPWNoYXIsc2NhblVuZXhwZWN0ZWRDaGFycygpLFxcXCIvXFxcIj09PWNoYXIpe2luZGV4Kz0xO2NvbnRpbnVlfWlmKFxcXCJbXFxcIj09PWNoYXIpe2luZGV4Kz0xO2NvbnRpbnVlfX1pZihcXFwiW1xcXCIhPT1jaGFyKXtpZihcXFwiL1xcXCI9PT1jaGFyKXtib2R5PWJvZHkuc3Vic3RyKDAsYm9keS5sZW5ndGgtMSksdGVybWluYXRlZD0hMCxpbmRleCs9MTticmVha31pbmRleCs9MX1lbHNlIGlzQ2hhclNldD0hMCxpbmRleCs9MX1pZighdGVybWluYXRlZClyZXR1cm4gdGhpcy50cmlnZ2VyKFxcXCJlcnJvclxcXCIse2NvZGU6XFxcIkUwMTVcXFwiLGxpbmU6dGhpcy5saW5lLGNoYXJhY3Rlcjp0aGlzLmZyb219KSx2b2lkIHRoaXMudHJpZ2dlcihcXFwiZmF0YWxcXFwiLHtsaW5lOnRoaXMubGluZSxmcm9tOnRoaXMuZnJvbX0pO2Zvcig7bGVuZ3RoPmluZGV4JiYoY2hhcj10aGlzLnBlZWsoaW5kZXgpLC9bZ2ltXS8udGVzdChjaGFyKSk7KWZsYWdzLnB1c2goY2hhciksdmFsdWUrPWNoYXIsaW5kZXgrPTE7dHJ5e1JlZ0V4cChib2R5LGZsYWdzLmpvaW4oXFxcIlxcXCIpKX1jYXRjaChlcnIpe21hbGZvcm1lZD0hMCx0aGlzLnRyaWdnZXIoXFxcImVycm9yXFxcIix7Y29kZTpcXFwiRTAxNlxcXCIsbGluZTp0aGlzLmxpbmUsY2hhcmFjdGVyOnRoaXMuY2hhcixkYXRhOltlcnIubWVzc2FnZV19KX1yZXR1cm57dHlwZTpUb2tlbi5SZWdFeHAsdmFsdWU6dmFsdWUsZmxhZ3M6ZmxhZ3MsaXNNYWxmb3JtZWQ6bWFsZm9ybWVkfX0sc2Nhbk5vbkJyZWFraW5nU3BhY2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHN0YXRlLm9wdGlvbi5ub25ic3A/dGhpcy5pbnB1dC5zZWFyY2goLyhcXFxcdTAwQTApLyk6LTF9LHNjYW5VbnNhZmVDaGFyczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlucHV0LnNlYXJjaChyZWcudW5zYWZlQ2hhcnMpfSxuZXh0OmZ1bmN0aW9uKGNoZWNrcyl7dGhpcy5mcm9tPXRoaXMuY2hhcjt2YXIgc3RhcnQ7aWYoL1xcXFxzLy50ZXN0KHRoaXMucGVlaygpKSlmb3Ioc3RhcnQ9dGhpcy5jaGFyOy9cXFxccy8udGVzdCh0aGlzLnBlZWsoKSk7KXRoaXMuZnJvbSs9MSx0aGlzLnNraXAoKTt2YXIgbWF0Y2g9dGhpcy5zY2FuQ29tbWVudHMoKXx8dGhpcy5zY2FuU3RyaW5nTGl0ZXJhbChjaGVja3MpfHx0aGlzLnNjYW5UZW1wbGF0ZUxpdGVyYWwoKTtyZXR1cm4gbWF0Y2g/bWF0Y2g6KG1hdGNoPXRoaXMuc2NhblJlZ0V4cCgpfHx0aGlzLnNjYW5QdW5jdHVhdG9yKCl8fHRoaXMuc2NhbktleXdvcmQoKXx8dGhpcy5zY2FuSWRlbnRpZmllcigpfHx0aGlzLnNjYW5OdW1lcmljTGl0ZXJhbCgpLG1hdGNoPyh0aGlzLnNraXAobWF0Y2gudmFsdWUubGVuZ3RoKSxtYXRjaCk6bnVsbCl9LG5leHRMaW5lOmZ1bmN0aW9uKCl7dmFyIGNoYXI7aWYodGhpcy5saW5lPj10aGlzLmdldExpbmVzKCkubGVuZ3RoKXJldHVybiExO3RoaXMuaW5wdXQ9dGhpcy5nZXRMaW5lcygpW3RoaXMubGluZV0sdGhpcy5saW5lKz0xLHRoaXMuY2hhcj0xLHRoaXMuZnJvbT0xO3ZhciBpbnB1dFRyaW1tZWQ9dGhpcy5pbnB1dC50cmltKCksc3RhcnRzV2l0aD1mdW5jdGlvbigpe3JldHVybiBfLnNvbWUoYXJndW1lbnRzLGZ1bmN0aW9uKHByZWZpeCl7cmV0dXJuIDA9PT1pbnB1dFRyaW1tZWQuaW5kZXhPZihwcmVmaXgpfSl9LGVuZHNXaXRoPWZ1bmN0aW9uKCl7cmV0dXJuIF8uc29tZShhcmd1bWVudHMsZnVuY3Rpb24oc3VmZml4KXtyZXR1cm4tMSE9PWlucHV0VHJpbW1lZC5pbmRleE9mKHN1ZmZpeCxpbnB1dFRyaW1tZWQubGVuZ3RoLXN1ZmZpeC5sZW5ndGgpfSl9O2lmKHN0YXRlLmlnbm9yZUxpbnRlckVycm9ycz09PSEwJiYoc3RhcnRzV2l0aChcXFwiLypcXFwiLFxcXCIvL1xcXCIpfHxlbmRzV2l0aChcXFwiKi9cXFwiKXx8KHRoaXMuaW5wdXQ9XFxcIlxcXCIpKSxjaGFyPXRoaXMuc2Nhbk5vbkJyZWFraW5nU3BhY2VzKCksY2hhcj49MCYmdGhpcy50cmlnZ2VyKFxcXCJ3YXJuaW5nXFxcIix7Y29kZTpcXFwiVzEyNVxcXCIsbGluZTp0aGlzLmxpbmUsY2hhcmFjdGVyOmNoYXIrMX0pLHRoaXMuaW5wdXQ9dGhpcy5pbnB1dC5yZXBsYWNlKC9cXFxcdC9nLHN0YXRlLnRhYiksY2hhcj10aGlzLnNjYW5VbnNhZmVDaGFycygpLGNoYXI+PTAmJnRoaXMudHJpZ2dlcihcXFwid2FybmluZ1xcXCIse2NvZGU6XFxcIlcxMDBcXFwiLGxpbmU6dGhpcy5saW5lLGNoYXJhY3RlcjpjaGFyfSksc3RhdGUub3B0aW9uLm1heGxlbiYmc3RhdGUub3B0aW9uLm1heGxlbjx0aGlzLmlucHV0Lmxlbmd0aCl7dmFyIGluQ29tbWVudD10aGlzLmluQ29tbWVudHx8c3RhcnRzV2l0aC5jYWxsKGlucHV0VHJpbW1lZCxcXFwiLy9cXFwiKXx8c3RhcnRzV2l0aC5jYWxsKGlucHV0VHJpbW1lZCxcXFwiLypcXFwiKSxzaG91bGRUcmlnZ2VyRXJyb3I9IWluQ29tbWVudHx8IXJlZy5tYXhsZW5FeGNlcHRpb24udGVzdChpbnB1dFRyaW1tZWQpO3Nob3VsZFRyaWdnZXJFcnJvciYmdGhpcy50cmlnZ2VyKFxcXCJ3YXJuaW5nXFxcIix7Y29kZTpcXFwiVzEwMVxcXCIsbGluZTp0aGlzLmxpbmUsY2hhcmFjdGVyOnRoaXMuaW5wdXQubGVuZ3RofSl9cmV0dXJuITB9LHN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5uZXh0TGluZSgpfSx0b2tlbjpmdW5jdGlvbigpe2Z1bmN0aW9uIGlzUmVzZXJ2ZWQodG9rZW4saXNQcm9wZXJ0eSl7aWYoIXRva2VuLnJlc2VydmVkKXJldHVybiExO3ZhciBtZXRhPXRva2VuLm1ldGE7aWYobWV0YSYmbWV0YS5pc0Z1dHVyZVJlc2VydmVkV29yZCYmc3RhdGUub3B0aW9uLmluRVM1KCkpe2lmKCFtZXRhLmVzNSlyZXR1cm4hMTtpZihtZXRhLnN0cmljdE9ubHkmJiFzdGF0ZS5vcHRpb24uc3RyaWN0JiYhc3RhdGUuZGlyZWN0aXZlW1xcXCJ1c2Ugc3RyaWN0XFxcIl0pcmV0dXJuITE7aWYoaXNQcm9wZXJ0eSlyZXR1cm4hMX1yZXR1cm4hMH1mb3IodmFyIHRva2VuLGNoZWNrcz1hc3luY1RyaWdnZXIoKSxjcmVhdGU9ZnVuY3Rpb24odHlwZSx2YWx1ZSxpc1Byb3BlcnR5KXt2YXIgb2JqO2lmKFxcXCIoZW5kbGluZSlcXFwiIT09dHlwZSYmXFxcIihlbmQpXFxcIiE9PXR5cGUmJih0aGlzLnByZXJlZz0hMSksXFxcIihwdW5jdHVhdG9yKVxcXCI9PT10eXBlKXtzd2l0Y2godmFsdWUpe2Nhc2VcXFwiLlxcXCI6Y2FzZVxcXCIpXFxcIjpjYXNlXFxcIn5cXFwiOmNhc2VcXFwiI1xcXCI6Y2FzZVxcXCJdXFxcIjp0aGlzLnByZXJlZz0hMTticmVhaztkZWZhdWx0OnRoaXMucHJlcmVnPSEwfW9iaj1PYmplY3QuY3JlYXRlKHN0YXRlLnN5bnRheFt2YWx1ZV18fHN0YXRlLnN5bnRheFtcXFwiKGVycm9yKVxcXCJdKX1yZXR1cm5cXFwiKGlkZW50aWZpZXIpXFxcIj09PXR5cGUmJigoXFxcInJldHVyblxcXCI9PT12YWx1ZXx8XFxcImNhc2VcXFwiPT09dmFsdWV8fFxcXCJ0eXBlb2ZcXFwiPT09dmFsdWUpJiYodGhpcy5wcmVyZWc9ITApLF8uaGFzKHN0YXRlLnN5bnRheCx2YWx1ZSkmJihvYmo9T2JqZWN0LmNyZWF0ZShzdGF0ZS5zeW50YXhbdmFsdWVdfHxzdGF0ZS5zeW50YXhbXFxcIihlcnJvcilcXFwiXSksaXNSZXNlcnZlZChvYmosaXNQcm9wZXJ0eSYmXFxcIihpZGVudGlmaWVyKVxcXCI9PT10eXBlKXx8KG9iaj1udWxsKSkpLG9ianx8KG9iaj1PYmplY3QuY3JlYXRlKHN0YXRlLnN5bnRheFt0eXBlXSkpLG9iai5pZGVudGlmaWVyPVxcXCIoaWRlbnRpZmllcilcXFwiPT09dHlwZSxvYmoudHlwZT1vYmoudHlwZXx8dHlwZSxvYmoudmFsdWU9dmFsdWUsb2JqLmxpbmU9dGhpcy5saW5lLG9iai5jaGFyYWN0ZXI9dGhpcy5jaGFyLG9iai5mcm9tPXRoaXMuZnJvbSxpc1Byb3BlcnR5JiZvYmouaWRlbnRpZmllciYmKG9iai5pc1Byb3BlcnR5PWlzUHJvcGVydHkpLG9iai5jaGVjaz1jaGVja3MuY2hlY2ssb2JqfS5iaW5kKHRoaXMpOzspe2lmKCF0aGlzLmlucHV0Lmxlbmd0aClyZXR1cm4gY3JlYXRlKHRoaXMubmV4dExpbmUoKT9cXFwiKGVuZGxpbmUpXFxcIjpcXFwiKGVuZClcXFwiLFxcXCJcXFwiKTtpZih0b2tlbj10aGlzLm5leHQoY2hlY2tzKSlzd2l0Y2godG9rZW4udHlwZSl7Y2FzZSBUb2tlbi5TdHJpbmdMaXRlcmFsOnJldHVybiB0aGlzLnRyaWdnZXJBc3luYyhcXFwiU3RyaW5nXFxcIix7bGluZTp0aGlzLmxpbmUsXFxcImNoYXJcXFwiOnRoaXMuY2hhcixmcm9tOnRoaXMuZnJvbSx2YWx1ZTp0b2tlbi52YWx1ZSxxdW90ZTp0b2tlbi5xdW90ZX0sY2hlY2tzLGZ1bmN0aW9uKCl7cmV0dXJuITB9KSxjcmVhdGUoXFxcIihzdHJpbmcpXFxcIix0b2tlbi52YWx1ZSk7Y2FzZSBUb2tlbi5UZW1wbGF0ZUxpdGVyYWw6cmV0dXJuIHRoaXMudHJpZ2dlcihcXFwiVGVtcGxhdGVcXFwiLHtsaW5lOnRoaXMubGluZSxcXFwiY2hhclxcXCI6dGhpcy5jaGFyLGZyb206dGhpcy5mcm9tLHZhbHVlOnRva2VuLnZhbHVlfSksY3JlYXRlKFxcXCIodGVtcGxhdGUpXFxcIix0b2tlbi52YWx1ZSk7Y2FzZSBUb2tlbi5JZGVudGlmaWVyOnRoaXMudHJpZ2dlcihcXFwiSWRlbnRpZmllclxcXCIse2xpbmU6dGhpcy5saW5lLFxcXCJjaGFyXFxcIjp0aGlzLmNoYXIsZnJvbTp0aGlzLmZvcm0sbmFtZTp0b2tlbi52YWx1ZSxpc1Byb3BlcnR5OlxcXCIuXFxcIj09PXN0YXRlLnRva2Vucy5jdXJyLmlkfSk7Y2FzZSBUb2tlbi5LZXl3b3JkOmNhc2UgVG9rZW4uTnVsbExpdGVyYWw6Y2FzZSBUb2tlbi5Cb29sZWFuTGl0ZXJhbDpyZXR1cm4gY3JlYXRlKFxcXCIoaWRlbnRpZmllcilcXFwiLHRva2VuLnZhbHVlLFxcXCIuXFxcIj09PXN0YXRlLnRva2Vucy5jdXJyLmlkKTtjYXNlIFRva2VuLk51bWVyaWNMaXRlcmFsOnJldHVybiB0b2tlbi5pc01hbGZvcm1lZCYmdGhpcy50cmlnZ2VyKFxcXCJ3YXJuaW5nXFxcIix7Y29kZTpcXFwiVzA0NVxcXCIsbGluZTp0aGlzLmxpbmUsY2hhcmFjdGVyOnRoaXMuY2hhcixkYXRhOlt0b2tlbi52YWx1ZV19KSx0aGlzLnRyaWdnZXJBc3luYyhcXFwid2FybmluZ1xcXCIse2NvZGU6XFxcIlcxMTRcXFwiLGxpbmU6dGhpcy5saW5lLGNoYXJhY3Rlcjp0aGlzLmNoYXIsZGF0YTpbXFxcIjB4LVxcXCJdfSxjaGVja3MsZnVuY3Rpb24oKXtyZXR1cm4gMTY9PT10b2tlbi5iYXNlJiZzdGF0ZS5qc29uTW9kZX0pLHRoaXMudHJpZ2dlckFzeW5jKFxcXCJ3YXJuaW5nXFxcIix7Y29kZTpcXFwiVzExNVxcXCIsbGluZTp0aGlzLmxpbmUsY2hhcmFjdGVyOnRoaXMuY2hhcn0sY2hlY2tzLGZ1bmN0aW9uKCl7cmV0dXJuIHN0YXRlLmRpcmVjdGl2ZVtcXFwidXNlIHN0cmljdFxcXCJdJiY4PT09dG9rZW4uYmFzZX0pLHRoaXMudHJpZ2dlcihcXFwiTnVtYmVyXFxcIix7bGluZTp0aGlzLmxpbmUsXFxcImNoYXJcXFwiOnRoaXMuY2hhcixmcm9tOnRoaXMuZnJvbSx2YWx1ZTp0b2tlbi52YWx1ZSxiYXNlOnRva2VuLmJhc2UsaXNNYWxmb3JtZWQ6dG9rZW4ubWFsZm9ybWVkfSksY3JlYXRlKFxcXCIobnVtYmVyKVxcXCIsdG9rZW4udmFsdWUpO2Nhc2UgVG9rZW4uUmVnRXhwOnJldHVybiBjcmVhdGUoXFxcIihyZWdleHApXFxcIix0b2tlbi52YWx1ZSk7Y2FzZSBUb2tlbi5Db21tZW50OmlmKHN0YXRlLnRva2Vucy5jdXJyLmNvbW1lbnQ9ITAsdG9rZW4uaXNTcGVjaWFsKXJldHVybntpZDpcXFwiKGNvbW1lbnQpXFxcIix2YWx1ZTp0b2tlbi52YWx1ZSxib2R5OnRva2VuLmJvZHksdHlwZTp0b2tlbi5jb21tZW50VHlwZSxpc1NwZWNpYWw6dG9rZW4uaXNTcGVjaWFsLGxpbmU6dGhpcy5saW5lLGNoYXJhY3Rlcjp0aGlzLmNoYXIsZnJvbTp0aGlzLmZyb219O2JyZWFrO2Nhc2VcXFwiXFxcIjpicmVhaztkZWZhdWx0OnJldHVybiBjcmVhdGUoXFxcIihwdW5jdHVhdG9yKVxcXCIsdG9rZW4udmFsdWUpfWVsc2UgdGhpcy5pbnB1dC5sZW5ndGgmJih0aGlzLnRyaWdnZXIoXFxcImVycm9yXFxcIix7Y29kZTpcXFwiRTAyNFxcXCIsbGluZTp0aGlzLmxpbmUsY2hhcmFjdGVyOnRoaXMuY2hhcixkYXRhOlt0aGlzLnBlZWsoKV19KSx0aGlzLmlucHV0PVxcXCJcXFwiKX19fSxleHBvcnRzLkxleGVyPUxleGVyfSx7XFxcIi4uL2RhdGEvYXNjaWktaWRlbnRpZmllci1kYXRhLmpzXFxcIjoxLFxcXCIuL3JlZy5qc1xcXCI6NixcXFwiLi9zdGF0ZS5qc1xcXCI6NyxldmVudHM6MTAsdW5kZXJzY29yZToyfV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XFxcInVzZSBzdHJpY3RcXFwiO3ZhciBfPV9kZXJlcV8oXFxcInVuZGVyc2NvcmVcXFwiKSxlcnJvcnM9e0UwMDE6XFxcIkJhZCBvcHRpb246ICd7YX0nLlxcXCIsRTAwMjpcXFwiQmFkIG9wdGlvbiB2YWx1ZS5cXFwiLEUwMDM6XFxcIkV4cGVjdGVkIGEgSlNPTiB2YWx1ZS5cXFwiLEUwMDQ6XFxcIklucHV0IGlzIG5laXRoZXIgYSBzdHJpbmcgbm9yIGFuIGFycmF5IG9mIHN0cmluZ3MuXFxcIixFMDA1OlxcXCJJbnB1dCBpcyBlbXB0eS5cXFwiLEUwMDY6XFxcIlVuZXhwZWN0ZWQgZWFybHkgZW5kIG9mIHByb2dyYW0uXFxcIixFMDA3OidNaXNzaW5nIFxcXCJ1c2Ugc3RyaWN0XFxcIiBzdGF0ZW1lbnQuJyxFMDA4OlxcXCJTdHJpY3QgdmlvbGF0aW9uLlxcXCIsRTAwOTpcXFwiT3B0aW9uICd2YWxpZHRoaXMnIGNhbid0IGJlIHVzZWQgaW4gYSBnbG9iYWwgc2NvcGUuXFxcIixFMDEwOlxcXCInd2l0aCcgaXMgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuXFxcIixFMDExOlxcXCJjb25zdCAne2F9JyBoYXMgYWxyZWFkeSBiZWVuIGRlY2xhcmVkLlxcXCIsRTAxMjpcXFwiY29uc3QgJ3thfScgaXMgaW5pdGlhbGl6ZWQgdG8gJ3VuZGVmaW5lZCcuXFxcIixFMDEzOlxcXCJBdHRlbXB0aW5nIHRvIG92ZXJyaWRlICd7YX0nIHdoaWNoIGlzIGEgY29uc3RhbnQuXFxcIixFMDE0OlxcXCJBIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaXRlcmFsIGNhbiBiZSBjb25mdXNlZCB3aXRoICcvPScuXFxcIixFMDE1OlxcXCJVbmNsb3NlZCByZWd1bGFyIGV4cHJlc3Npb24uXFxcIixFMDE2OlxcXCJJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbi5cXFwiLEUwMTc6XFxcIlVuY2xvc2VkIGNvbW1lbnQuXFxcIixFMDE4OlxcXCJVbmJlZ3VuIGNvbW1lbnQuXFxcIixFMDE5OlxcXCJVbm1hdGNoZWQgJ3thfScuXFxcIixFMDIwOlxcXCJFeHBlY3RlZCAne2F9JyB0byBtYXRjaCAne2J9JyBmcm9tIGxpbmUge2N9IGFuZCBpbnN0ZWFkIHNhdyAne2R9Jy5cXFwiLEUwMjE6XFxcIkV4cGVjdGVkICd7YX0nIGFuZCBpbnN0ZWFkIHNhdyAne2J9Jy5cXFwiLEUwMjI6XFxcIkxpbmUgYnJlYWtpbmcgZXJyb3IgJ3thfScuXFxcIixFMDIzOlxcXCJNaXNzaW5nICd7YX0nLlxcXCIsRTAyNDpcXFwiVW5leHBlY3RlZCAne2F9Jy5cXFwiLEUwMjU6XFxcIk1pc3NpbmcgJzonIG9uIGEgY2FzZSBjbGF1c2UuXFxcIixFMDI2OlxcXCJNaXNzaW5nICd9JyB0byBtYXRjaCAneycgZnJvbSBsaW5lIHthfS5cXFwiLEUwMjc6XFxcIk1pc3NpbmcgJ10nIHRvIG1hdGNoICdbJyBmcm9tIGxpbmUge2F9LlxcXCIsRTAyODpcXFwiSWxsZWdhbCBjb21tYS5cXFwiLEUwMjk6XFxcIlVuY2xvc2VkIHN0cmluZy5cXFwiLEUwMzA6XFxcIkV4cGVjdGVkIGFuIGlkZW50aWZpZXIgYW5kIGluc3RlYWQgc2F3ICd7YX0nLlxcXCIsRTAzMTpcXFwiQmFkIGFzc2lnbm1lbnQuXFxcIixFMDMyOlxcXCJFeHBlY3RlZCBhIHNtYWxsIGludGVnZXIgb3IgJ2ZhbHNlJyBhbmQgaW5zdGVhZCBzYXcgJ3thfScuXFxcIixFMDMzOlxcXCJFeHBlY3RlZCBhbiBvcGVyYXRvciBhbmQgaW5zdGVhZCBzYXcgJ3thfScuXFxcIixFMDM0OlxcXCJnZXQvc2V0IGFyZSBFUzUgZmVhdHVyZXMuXFxcIixFMDM1OlxcXCJNaXNzaW5nIHByb3BlcnR5IG5hbWUuXFxcIixFMDM2OlxcXCJFeHBlY3RlZCB0byBzZWUgYSBzdGF0ZW1lbnQgYW5kIGluc3RlYWQgc2F3IGEgYmxvY2suXFxcIixFMDM3Om51bGwsRTAzODpudWxsLEUwMzk6XFxcIkZ1bmN0aW9uIGRlY2xhcmF0aW9ucyBhcmUgbm90IGludm9jYWJsZS4gV3JhcCB0aGUgd2hvbGUgZnVuY3Rpb24gaW52b2NhdGlvbiBpbiBwYXJlbnMuXFxcIixFMDQwOlxcXCJFYWNoIHZhbHVlIHNob3VsZCBoYXZlIGl0cyBvd24gY2FzZSBsYWJlbC5cXFwiLEUwNDE6XFxcIlVucmVjb3ZlcmFibGUgc3ludGF4IGVycm9yLlxcXCIsRTA0MjpcXFwiU3RvcHBpbmcuXFxcIixFMDQzOlxcXCJUb28gbWFueSBlcnJvcnMuXFxcIixFMDQ0Om51bGwsRTA0NTpcXFwiSW52YWxpZCBmb3IgZWFjaCBsb29wLlxcXCIsRTA0NjpcXFwiQSB5aWVsZCBzdGF0ZW1lbnQgc2hhbGwgYmUgd2l0aGluIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uICh3aXRoIHN5bnRheDogYGZ1bmN0aW9uKmApXFxcIixFMDQ3Om51bGwsRTA0ODpcXFwiTGV0IGRlY2xhcmF0aW9uIG5vdCBkaXJlY3RseSB3aXRoaW4gYmxvY2suXFxcIixFMDQ5OlxcXCJBIHthfSBjYW5ub3QgYmUgbmFtZWQgJ3tifScuXFxcIixFMDUwOlxcXCJNb3ppbGxhIGFjZXF1aXJlcyB0aGUgeWllbGQgZXhwcmVzc2lvbiB0byBiZSBwYXJlbnRoZXNpemVkIGhlcmUuXFxcIixFMDUxOlxcXCJSZWd1bGFyIHBhcmFtZXRlcnMgY2Fubm90IGNvbWUgYWZ0ZXIgZGVmYXVsdCBwYXJhbWV0ZXJzLlxcXCIsRTA1MjpcXFwiVW5jbG9zZWQgdGVtcGxhdGUgbGl0ZXJhbC5cXFwifSx3YXJuaW5ncz17VzAwMTpcXFwiJ2hhc093blByb3BlcnR5JyBpcyBhIHJlYWxseSBiYWQgbmFtZS5cXFwiLFcwMDI6XFxcIlZhbHVlIG9mICd7YX0nIG1heSBiZSBvdmVyd3JpdHRlbiBpbiBJRSA4IGFuZCBlYXJsaWVyLlxcXCIsVzAwMzpcXFwiJ3thfScgd2FzIHVzZWQgYmVmb3JlIGl0IHdhcyBkZWZpbmVkLlxcXCIsVzAwNDpcXFwiJ3thfScgaXMgYWxyZWFkeSBkZWZpbmVkLlxcXCIsVzAwNTpcXFwiQSBkb3QgZm9sbG93aW5nIGEgbnVtYmVyIGNhbiBiZSBjb25mdXNlZCB3aXRoIGEgZGVjaW1hbCBwb2ludC5cXFwiLFcwMDY6XFxcIkNvbmZ1c2luZyBtaW51c2VzLlxcXCIsVzAwNzpcXFwiQ29uZnVzaW5nIHBsdXNzZXMuXFxcIixXMDA4OlxcXCJBIGxlYWRpbmcgZGVjaW1hbCBwb2ludCBjYW4gYmUgY29uZnVzZWQgd2l0aCBhIGRvdDogJ3thfScuXFxcIixXMDA5OlxcXCJUaGUgYXJyYXkgbGl0ZXJhbCBub3RhdGlvbiBbXSBpcyBwcmVmZXJhYmxlLlxcXCIsVzAxMDpcXFwiVGhlIG9iamVjdCBsaXRlcmFsIG5vdGF0aW9uIHt9IGlzIHByZWZlcmFibGUuXFxcIixXMDExOm51bGwsVzAxMjpudWxsLFcwMTM6bnVsbCxXMDE0OlxcXCJCYWQgbGluZSBicmVha2luZyBiZWZvcmUgJ3thfScuXFxcIixXMDE1Om51bGwsVzAxNjpcXFwiVW5leHBlY3RlZCB1c2Ugb2YgJ3thfScuXFxcIixXMDE3OlxcXCJCYWQgb3BlcmFuZC5cXFwiLFcwMTg6XFxcIkNvbmZ1c2luZyB1c2Ugb2YgJ3thfScuXFxcIixXMDE5OlxcXCJVc2UgdGhlIGlzTmFOIGZ1bmN0aW9uIHRvIGNvbXBhcmUgd2l0aCBOYU4uXFxcIixXMDIwOlxcXCJSZWFkIG9ubHkuXFxcIixXMDIxOlxcXCIne2F9JyBpcyBhIGZ1bmN0aW9uLlxcXCIsVzAyMjpcXFwiRG8gbm90IGFzc2lnbiB0byB0aGUgZXhjZXB0aW9uIHBhcmFtZXRlci5cXFwiLFcwMjM6XFxcIkV4cGVjdGVkIGFuIGlkZW50aWZpZXIgaW4gYW4gYXNzaWdubWVudCBhbmQgaW5zdGVhZCBzYXcgYSBmdW5jdGlvbiBpbnZvY2F0aW9uLlxcXCIsVzAyNDpcXFwiRXhwZWN0ZWQgYW4gaWRlbnRpZmllciBhbmQgaW5zdGVhZCBzYXcgJ3thfScgKGEgcmVzZXJ2ZWQgd29yZCkuXFxcIixXMDI1OlxcXCJNaXNzaW5nIG5hbWUgaW4gZnVuY3Rpb24gZGVjbGFyYXRpb24uXFxcIixXMDI2OlxcXCJJbm5lciBmdW5jdGlvbnMgc2hvdWxkIGJlIGxpc3RlZCBhdCB0aGUgdG9wIG9mIHRoZSBvdXRlciBmdW5jdGlvbi5cXFwiLFcwMjc6XFxcIlVucmVhY2hhYmxlICd7YX0nIGFmdGVyICd7Yn0nLlxcXCIsVzAyODpcXFwiTGFiZWwgJ3thfScgb24ge2J9IHN0YXRlbWVudC5cXFwiLFcwMzA6XFxcIkV4cGVjdGVkIGFuIGFzc2lnbm1lbnQgb3IgZnVuY3Rpb24gY2FsbCBhbmQgaW5zdGVhZCBzYXcgYW4gZXhwcmVzc2lvbi5cXFwiLFcwMzE6XFxcIkRvIG5vdCB1c2UgJ25ldycgZm9yIHNpZGUgZWZmZWN0cy5cXFwiLFcwMzI6XFxcIlVubmVjZXNzYXJ5IHNlbWljb2xvbi5cXFwiLFcwMzM6XFxcIk1pc3Npbmcgc2VtaWNvbG9uLlxcXCIsVzAzNDonVW5uZWNlc3NhcnkgZGlyZWN0aXZlIFxcXCJ7YX1cXFwiLicsVzAzNTpcXFwiRW1wdHkgYmxvY2suXFxcIixXMDM2OlxcXCJVbmV4cGVjdGVkIC8qbWVtYmVyICd7YX0nLlxcXCIsVzAzNzpcXFwiJ3thfScgaXMgYSBzdGF0ZW1lbnQgbGFiZWwuXFxcIixXMDM4OlxcXCIne2F9JyB1c2VkIG91dCBvZiBzY29wZS5cXFwiLFcwMzk6XFxcIid7YX0nIGlzIG5vdCBhbGxvd2VkLlxcXCIsVzA0MDpcXFwiUG9zc2libGUgc3RyaWN0IHZpb2xhdGlvbi5cXFwiLFcwNDE6XFxcIlVzZSAne2F9JyB0byBjb21wYXJlIHdpdGggJ3tifScuXFxcIixXMDQyOlxcXCJBdm9pZCBFT0wgZXNjYXBpbmcuXFxcIixXMDQzOlxcXCJCYWQgZXNjYXBpbmcgb2YgRU9MLiBVc2Ugb3B0aW9uIG11bHRpc3RyIGlmIG5lZWRlZC5cXFwiLFcwNDQ6XFxcIkJhZCBvciB1bm5lY2Vzc2FyeSBlc2NhcGluZy5cXFwiLFcwNDU6XFxcIkJhZCBudW1iZXIgJ3thfScuXFxcIixXMDQ2OlxcXCJEb24ndCB1c2UgZXh0cmEgbGVhZGluZyB6ZXJvcyAne2F9Jy5cXFwiLFcwNDc6XFxcIkEgdHJhaWxpbmcgZGVjaW1hbCBwb2ludCBjYW4gYmUgY29uZnVzZWQgd2l0aCBhIGRvdDogJ3thfScuXFxcIixXMDQ4OlxcXCJVbmV4cGVjdGVkIGNvbnRyb2wgY2hhcmFjdGVyIGluIHJlZ3VsYXIgZXhwcmVzc2lvbi5cXFwiLFcwNDk6XFxcIlVuZXhwZWN0ZWQgZXNjYXBlZCBjaGFyYWN0ZXIgJ3thfScgaW4gcmVndWxhciBleHByZXNzaW9uLlxcXCIsVzA1MDpcXFwiSmF2YVNjcmlwdCBVUkwuXFxcIixXMDUxOlxcXCJWYXJpYWJsZXMgc2hvdWxkIG5vdCBiZSBkZWxldGVkLlxcXCIsVzA1MjpcXFwiVW5leHBlY3RlZCAne2F9Jy5cXFwiLFcwNTM6XFxcIkRvIG5vdCB1c2Uge2F9IGFzIGEgY29uc3RydWN0b3IuXFxcIixXMDU0OlxcXCJUaGUgRnVuY3Rpb24gY29uc3RydWN0b3IgaXMgYSBmb3JtIG9mIGV2YWwuXFxcIixXMDU1OlxcXCJBIGNvbnN0cnVjdG9yIG5hbWUgc2hvdWxkIHN0YXJ0IHdpdGggYW4gdXBwZXJjYXNlIGxldHRlci5cXFwiLFcwNTY6XFxcIkJhZCBjb25zdHJ1Y3Rvci5cXFwiLFcwNTc6XFxcIldlaXJkIGNvbnN0cnVjdGlvbi4gSXMgJ25ldycgbmVjZXNzYXJ5P1xcXCIsVzA1ODpcXFwiTWlzc2luZyAnKCknIGludm9raW5nIGEgY29uc3RydWN0b3IuXFxcIixXMDU5OlxcXCJBdm9pZCBhcmd1bWVudHMue2F9LlxcXCIsVzA2MDpcXFwiZG9jdW1lbnQud3JpdGUgY2FuIGJlIGEgZm9ybSBvZiBldmFsLlxcXCIsVzA2MTpcXFwiZXZhbCBjYW4gYmUgaGFybWZ1bC5cXFwiLFcwNjI6XFxcIldyYXAgYW4gaW1tZWRpYXRlIGZ1bmN0aW9uIGludm9jYXRpb24gaW4gcGFyZW5zIHRvIGFzc2lzdCB0aGUgcmVhZGVyIGluIHVuZGVyc3RhbmRpbmcgdGhhdCB0aGUgZXhwcmVzc2lvbiBpcyB0aGUgcmVzdWx0IG9mIGEgZnVuY3Rpb24sIGFuZCBub3QgdGhlIGZ1bmN0aW9uIGl0c2VsZi5cXFwiLFcwNjM6XFxcIk1hdGggaXMgbm90IGEgZnVuY3Rpb24uXFxcIixXMDY0OlxcXCJNaXNzaW5nICduZXcnIHByZWZpeCB3aGVuIGludm9raW5nIGEgY29uc3RydWN0b3IuXFxcIixXMDY1OlxcXCJNaXNzaW5nIHJhZGl4IHBhcmFtZXRlci5cXFwiLFcwNjY6XFxcIkltcGxpZWQgZXZhbC4gQ29uc2lkZXIgcGFzc2luZyBhIGZ1bmN0aW9uIGluc3RlYWQgb2YgYSBzdHJpbmcuXFxcIixXMDY3OlxcXCJCYWQgaW52b2NhdGlvbi5cXFwiLFcwNjg6XFxcIldyYXBwaW5nIG5vbi1JSUZFIGZ1bmN0aW9uIGxpdGVyYWxzIGluIHBhcmVucyBpcyB1bm5lY2Vzc2FyeS5cXFwiLFcwNjk6XFxcIlsne2F9J10gaXMgYmV0dGVyIHdyaXR0ZW4gaW4gZG90IG5vdGF0aW9uLlxcXCIsVzA3MDpcXFwiRXh0cmEgY29tbWEuIChpdCBicmVha3Mgb2xkZXIgdmVyc2lvbnMgb2YgSUUpXFxcIixXMDcxOlxcXCJUaGlzIGZ1bmN0aW9uIGhhcyB0b28gbWFueSBzdGF0ZW1lbnRzLiAoe2F9KVxcXCIsVzA3MjpcXFwiVGhpcyBmdW5jdGlvbiBoYXMgdG9vIG1hbnkgcGFyYW1ldGVycy4gKHthfSlcXFwiLFcwNzM6XFxcIkJsb2NrcyBhcmUgbmVzdGVkIHRvbyBkZWVwbHkuICh7YX0pXFxcIixXMDc0OlxcXCJUaGlzIGZ1bmN0aW9uJ3MgY3ljbG9tYXRpYyBjb21wbGV4aXR5IGlzIHRvbyBoaWdoLiAoe2F9KVxcXCIsVzA3NTpcXFwiRHVwbGljYXRlIGtleSAne2F9Jy5cXFwiLFcwNzY6XFxcIlVuZXhwZWN0ZWQgcGFyYW1ldGVyICd7YX0nIGluIGdldCB7Yn0gZnVuY3Rpb24uXFxcIixXMDc3OlxcXCJFeHBlY3RlZCBhIHNpbmdsZSBwYXJhbWV0ZXIgaW4gc2V0IHthfSBmdW5jdGlvbi5cXFwiLFcwNzg6XFxcIlNldHRlciBpcyBkZWZpbmVkIHdpdGhvdXQgZ2V0dGVyLlxcXCIsVzA3OTpcXFwiUmVkZWZpbml0aW9uIG9mICd7YX0nLlxcXCIsVzA4MDpcXFwiSXQncyBub3QgbmVjZXNzYXJ5IHRvIGluaXRpYWxpemUgJ3thfScgdG8gJ3VuZGVmaW5lZCcuXFxcIixXMDgxOm51bGwsVzA4MjpcXFwiRnVuY3Rpb24gZGVjbGFyYXRpb25zIHNob3VsZCBub3QgYmUgcGxhY2VkIGluIGJsb2Nrcy4gVXNlIGEgZnVuY3Rpb24gZXhwcmVzc2lvbiBvciBtb3ZlIHRoZSBzdGF0ZW1lbnQgdG8gdGhlIHRvcCBvZiB0aGUgb3V0ZXIgZnVuY3Rpb24uXFxcIixXMDgzOlxcXCJEb24ndCBtYWtlIGZ1bmN0aW9ucyB3aXRoaW4gYSBsb29wLlxcXCIsVzA4NDpcXFwiQXNzaWdubWVudCBpbiBjb25kaXRpb25hbCBleHByZXNzaW9uXFxcIixXMDg1OlxcXCJEb24ndCB1c2UgJ3dpdGgnLlxcXCIsVzA4NjpcXFwiRXhwZWN0ZWQgYSAnYnJlYWsnIHN0YXRlbWVudCBiZWZvcmUgJ3thfScuXFxcIixXMDg3OlxcXCJGb3Jnb3R0ZW4gJ2RlYnVnZ2VyJyBzdGF0ZW1lbnQ/XFxcIixXMDg4OlxcXCJDcmVhdGluZyBnbG9iYWwgJ2ZvcicgdmFyaWFibGUuIFNob3VsZCBiZSAnZm9yICh2YXIge2F9IC4uLicuXFxcIixXMDg5OlxcXCJUaGUgYm9keSBvZiBhIGZvciBpbiBzaG91bGQgYmUgd3JhcHBlZCBpbiBhbiBpZiBzdGF0ZW1lbnQgdG8gZmlsdGVyIHVud2FudGVkIHByb3BlcnRpZXMgZnJvbSB0aGUgcHJvdG90eXBlLlxcXCIsVzA5MDpcXFwiJ3thfScgaXMgbm90IGEgc3RhdGVtZW50IGxhYmVsLlxcXCIsVzA5MTpcXFwiJ3thfScgaXMgb3V0IG9mIHNjb3BlLlxcXCIsVzA5MzpcXFwiRGlkIHlvdSBtZWFuIHRvIHJldHVybiBhIGNvbmRpdGlvbmFsIGluc3RlYWQgb2YgYW4gYXNzaWdubWVudD9cXFwiLFcwOTQ6XFxcIlVuZXhwZWN0ZWQgY29tbWEuXFxcIixXMDk1OlxcXCJFeHBlY3RlZCBhIHN0cmluZyBhbmQgaW5zdGVhZCBzYXcge2F9LlxcXCIsVzA5NjpcXFwiVGhlICd7YX0nIGtleSBtYXkgcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXFxcIixXMDk3OidVc2UgdGhlIGZ1bmN0aW9uIGZvcm0gb2YgXFxcInVzZSBzdHJpY3RcXFwiLicsVzA5ODpcXFwiJ3thfScgaXMgZGVmaW5lZCBidXQgbmV2ZXIgdXNlZC5cXFwiLFcwOTk6bnVsbCxXMTAwOlxcXCJUaGlzIGNoYXJhY3RlciBtYXkgZ2V0IHNpbGVudGx5IGRlbGV0ZWQgYnkgb25lIG9yIG1vcmUgYnJvd3NlcnMuXFxcIixXMTAxOlxcXCJMaW5lIGlzIHRvbyBsb25nLlxcXCIsVzEwMjpudWxsLFcxMDM6XFxcIlRoZSAne2F9JyBwcm9wZXJ0eSBpcyBkZXByZWNhdGVkLlxcXCIsVzEwNDpcXFwiJ3thfScgaXMgYXZhaWxhYmxlIGluIEVTNiAodXNlIGVzbmV4dCBvcHRpb24pIG9yIE1vemlsbGEgSlMgZXh0ZW5zaW9ucyAodXNlIG1veikuXFxcIixXMTA1OlxcXCJVbmV4cGVjdGVkIHthfSBpbiAne2J9Jy5cXFwiLFcxMDY6XFxcIklkZW50aWZpZXIgJ3thfScgaXMgbm90IGluIGNhbWVsIGNhc2UuXFxcIixXMTA3OlxcXCJTY3JpcHQgVVJMLlxcXCIsVzEwODpcXFwiU3RyaW5ncyBtdXN0IHVzZSBkb3VibGVxdW90ZS5cXFwiLFcxMDk6XFxcIlN0cmluZ3MgbXVzdCB1c2Ugc2luZ2xlcXVvdGUuXFxcIixXMTEwOlxcXCJNaXhlZCBkb3VibGUgYW5kIHNpbmdsZSBxdW90ZXMuXFxcIixXMTEyOlxcXCJVbmNsb3NlZCBzdHJpbmcuXFxcIixXMTEzOlxcXCJDb250cm9sIGNoYXJhY3RlciBpbiBzdHJpbmc6IHthfS5cXFwiLFcxMTQ6XFxcIkF2b2lkIHthfS5cXFwiLFcxMTU6XFxcIk9jdGFsIGxpdGVyYWxzIGFyZSBub3QgYWxsb3dlZCBpbiBzdHJpY3QgbW9kZS5cXFwiLFcxMTY6XFxcIkV4cGVjdGVkICd7YX0nIGFuZCBpbnN0ZWFkIHNhdyAne2J9Jy5cXFwiLFcxMTc6XFxcIid7YX0nIGlzIG5vdCBkZWZpbmVkLlxcXCIsVzExODpcXFwiJ3thfScgaXMgb25seSBhdmFpbGFibGUgaW4gTW96aWxsYSBKYXZhU2NyaXB0IGV4dGVuc2lvbnMgKHVzZSBtb3ogb3B0aW9uKS5cXFwiLFcxMTk6XFxcIid7YX0nIGlzIG9ubHkgYXZhaWxhYmxlIGluIEVTNiAodXNlIGVzbmV4dCBvcHRpb24pLlxcXCIsVzEyMDpcXFwiWW91IG1pZ2h0IGJlIGxlYWtpbmcgYSB2YXJpYWJsZSAoe2F9KSBoZXJlLlxcXCIsVzEyMTpcXFwiRXh0ZW5kaW5nIHByb3RvdHlwZSBvZiBuYXRpdmUgb2JqZWN0OiAne2F9Jy5cXFwiLFcxMjI6XFxcIkludmFsaWQgdHlwZW9mIHZhbHVlICd7YX0nXFxcIixXMTIzOlxcXCIne2F9JyBpcyBhbHJlYWR5IGRlZmluZWQgaW4gb3V0ZXIgc2NvcGUuXFxcIixXMTI0OlxcXCJBIGdlbmVyYXRvciBmdW5jdGlvbiBzaGFsbCBjb250YWluIGEgeWllbGQgc3RhdGVtZW50LlxcXCIsVzEyNTpcXFwiVGhpcyBsaW5lIGNvbnRhaW5zIG5vbi1icmVha2luZyBzcGFjZXM6IGh0dHA6Ly9qc2hpbnQuY29tL2RvYy9vcHRpb25zLyNub25ic3BcXFwifSxpbmZvPXtJMDAxOlxcXCJDb21tYSB3YXJuaW5ncyBjYW4gYmUgdHVybmVkIG9mZiB3aXRoICdsYXhjb21tYScuXFxcIixJMDAyOm51bGwsSTAwMzpcXFwiRVM1IG9wdGlvbiBpcyBub3cgc2V0IHBlciBkZWZhdWx0XFxcIn07ZXhwb3J0cy5lcnJvcnM9e30sZXhwb3J0cy53YXJuaW5ncz17fSxleHBvcnRzLmluZm89e30sXy5lYWNoKGVycm9ycyxmdW5jdGlvbihkZXNjLGNvZGUpe2V4cG9ydHMuZXJyb3JzW2NvZGVdPXtjb2RlOmNvZGUsZGVzYzpkZXNjfX0pLF8uZWFjaCh3YXJuaW5ncyxmdW5jdGlvbihkZXNjLGNvZGUpe2V4cG9ydHMud2FybmluZ3NbY29kZV09e2NvZGU6Y29kZSxkZXNjOmRlc2N9fSksXy5lYWNoKGluZm8sZnVuY3Rpb24oZGVzYyxjb2RlKXtleHBvcnRzLmluZm9bY29kZV09e2NvZGU6Y29kZSxkZXNjOmRlc2N9fSl9LHt1bmRlcnNjb3JlOjJ9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcXFwidXNlIHN0cmluZ1xcXCI7ZXhwb3J0cy51bnNhZmVTdHJpbmc9L0BjY3w8XFxcXC8/fHNjcmlwdHxcXFxcXVxcXFxzKlxcXFxdfDxcXFxccyohfCZsdC9pLGV4cG9ydHMudW5zYWZlQ2hhcnM9L1tcXFxcdTAwMDAtXFxcXHUwMDFmXFxcXHUwMDdmLVxcXFx1MDA5ZlxcXFx1MDBhZFxcXFx1MDYwMC1cXFxcdTA2MDRcXFxcdTA3MGZcXFxcdTE3YjRcXFxcdTE3YjVcXFxcdTIwMGMtXFxcXHUyMDBmXFxcXHUyMDI4LVxcXFx1MjAyZlxcXFx1MjA2MC1cXFxcdTIwNmZcXFxcdWZlZmZcXFxcdWZmZjAtXFxcXHVmZmZmXS8sZXhwb3J0cy5uZWVkRXNjPS9bXFxcXHUwMDAwLVxcXFx1MDAxZiY8XFxcIlxcXFwvXFxcXFxcXFxcXFxcdTAwN2YtXFxcXHUwMDlmXFxcXHUwMGFkXFxcXHUwNjAwLVxcXFx1MDYwNFxcXFx1MDcwZlxcXFx1MTdiNFxcXFx1MTdiNVxcXFx1MjAwYy1cXFxcdTIwMGZcXFxcdTIwMjgtXFxcXHUyMDJmXFxcXHUyMDYwLVxcXFx1MjA2ZlxcXFx1ZmVmZlxcXFx1ZmZmMC1cXFxcdWZmZmZdLyxleHBvcnRzLm5lZWRFc2NHbG9iYWw9L1tcXFxcdTAwMDAtXFxcXHUwMDFmJjxcXFwiXFxcXC9cXFxcXFxcXFxcXFx1MDA3Zi1cXFxcdTAwOWZcXFxcdTAwYWRcXFxcdTA2MDAtXFxcXHUwNjA0XFxcXHUwNzBmXFxcXHUxN2I0XFxcXHUxN2I1XFxcXHUyMDBjLVxcXFx1MjAwZlxcXFx1MjAyOC1cXFxcdTIwMmZcXFxcdTIwNjAtXFxcXHUyMDZmXFxcXHVmZWZmXFxcXHVmZmYwLVxcXFx1ZmZmZl0vZyxleHBvcnRzLnN0YXJTbGFzaD0vXFxcXCpcXFxcLy8sZXhwb3J0cy5pZGVudGlmaWVyPS9eKFthLXpBLVpfJF1bYS16QS1aMC05XyRdKikkLyxleHBvcnRzLmphdmFzY3JpcHRVUkw9L14oPzpqYXZhc2NyaXB0fGpzY3JpcHR8ZWNtYXNjcmlwdHx2YnNjcmlwdHxsaXZlc2NyaXB0KVxcXFxzKjovaSxleHBvcnRzLmZhbGxzVGhyb3VnaD0vXlxcXFxzKlxcXFwvXFxcXCpcXFxccypmYWxscz9cXFxcc3Rocm91Z2hcXFxccypcXFxcKlxcXFwvXFxcXHMqJC8sZXhwb3J0cy5tYXhsZW5FeGNlcHRpb249L14oPzooPzpcXFxcL1xcXFwvfFxcXFwvXFxcXCp8XFxcXCopID8pP1teIF0rJC99LHt9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcXFwidXNlIHN0cmljdFxcXCI7dmFyIHN0YXRlPXtzeW50YXg6e30scmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLnRva2Vucz17cHJldjpudWxsLG5leHQ6bnVsbCxjdXJyOm51bGx9LHRoaXMub3B0aW9uPXt9LHRoaXMuaWdub3JlZD17fSx0aGlzLmRpcmVjdGl2ZT17fSx0aGlzLmpzb25Nb2RlPSExLHRoaXMuanNvbldhcm5pbmdzPVtdLHRoaXMubGluZXM9W10sdGhpcy50YWI9XFxcIlxcXCIsdGhpcy5jYWNoZT17fSx0aGlzLmlnbm9yZWRMaW5lcz17fSx0aGlzLmlnbm9yZUxpbnRlckVycm9ycz0hMX19O2V4cG9ydHMuc3RhdGU9c3RhdGV9LHt9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcXFwidXNlIHN0cmljdFxcXCI7ZXhwb3J0cy5yZWdpc3Rlcj1mdW5jdGlvbihsaW50ZXIpe2xpbnRlci5vbihcXFwiSWRlbnRpZmllclxcXCIsZnVuY3Rpb24oZGF0YSl7bGludGVyLmdldE9wdGlvbihcXFwicHJvdG9cXFwiKXx8XFxcIl9fcHJvdG9fX1xcXCI9PT1kYXRhLm5hbWUmJmxpbnRlci53YXJuKFxcXCJXMTAzXFxcIix7bGluZTpkYXRhLmxpbmUsXFxcImNoYXJcXFwiOmRhdGEuY2hhcixkYXRhOltkYXRhLm5hbWVdfSl9KSxsaW50ZXIub24oXFxcIklkZW50aWZpZXJcXFwiLGZ1bmN0aW9uKGRhdGEpe2xpbnRlci5nZXRPcHRpb24oXFxcIml0ZXJhdG9yXFxcIil8fFxcXCJfX2l0ZXJhdG9yX19cXFwiPT09ZGF0YS5uYW1lJiZsaW50ZXIud2FybihcXFwiVzEwNFxcXCIse2xpbmU6ZGF0YS5saW5lLFxcXCJjaGFyXFxcIjpkYXRhLmNoYXIsZGF0YTpbZGF0YS5uYW1lXX0pfSksbGludGVyLm9uKFxcXCJJZGVudGlmaWVyXFxcIixmdW5jdGlvbihkYXRhKXtsaW50ZXIuZ2V0T3B0aW9uKFxcXCJjYW1lbGNhc2VcXFwiKSYmZGF0YS5uYW1lLnJlcGxhY2UoL15fK3xfKyQvZyxcXFwiXFxcIikuaW5kZXhPZihcXFwiX1xcXCIpPi0xJiYhZGF0YS5uYW1lLm1hdGNoKC9eW0EtWjAtOV9dKiQvKSYmbGludGVyLndhcm4oXFxcIlcxMDZcXFwiLHtsaW5lOmRhdGEubGluZSxcXFwiY2hhclxcXCI6ZGF0YS5mcm9tLGRhdGE6W2RhdGEubmFtZV19KX0pLGxpbnRlci5vbihcXFwiU3RyaW5nXFxcIixmdW5jdGlvbihkYXRhKXt2YXIgY29kZSxxdW90bWFyaz1saW50ZXIuZ2V0T3B0aW9uKFxcXCJxdW90bWFya1xcXCIpO3F1b3RtYXJrJiYoXFxcInNpbmdsZVxcXCI9PT1xdW90bWFyayYmXFxcIidcXFwiIT09ZGF0YS5xdW90ZSYmKGNvZGU9XFxcIlcxMDlcXFwiKSxcXFwiZG91YmxlXFxcIj09PXF1b3RtYXJrJiYnXFxcIichPT1kYXRhLnF1b3RlJiYoY29kZT1cXFwiVzEwOFxcXCIpLHF1b3RtYXJrPT09ITAmJihsaW50ZXIuZ2V0Q2FjaGUoXFxcInF1b3RtYXJrXFxcIil8fGxpbnRlci5zZXRDYWNoZShcXFwicXVvdG1hcmtcXFwiLGRhdGEucXVvdGUpLGxpbnRlci5nZXRDYWNoZShcXFwicXVvdG1hcmtcXFwiKSE9PWRhdGEucXVvdGUmJihjb2RlPVxcXCJXMTEwXFxcIikpLGNvZGUmJmxpbnRlci53YXJuKGNvZGUse2xpbmU6ZGF0YS5saW5lLFxcXCJjaGFyXFxcIjpkYXRhLmNoYXJ9KSl9KSxsaW50ZXIub24oXFxcIk51bWJlclxcXCIsZnVuY3Rpb24oZGF0YSl7XFxcIi5cXFwiPT09ZGF0YS52YWx1ZS5jaGFyQXQoMCkmJmxpbnRlci53YXJuKFxcXCJXMDA4XFxcIix7bGluZTpkYXRhLmxpbmUsXFxcImNoYXJcXFwiOmRhdGEuY2hhcixkYXRhOltkYXRhLnZhbHVlXX0pLFxcXCIuXFxcIj09PWRhdGEudmFsdWUuc3Vic3RyKGRhdGEudmFsdWUubGVuZ3RoLTEpJiZsaW50ZXIud2FybihcXFwiVzA0N1xcXCIse2xpbmU6ZGF0YS5saW5lLFxcXCJjaGFyXFxcIjpkYXRhLmNoYXIsZGF0YTpbZGF0YS52YWx1ZV19KSwvXjAwKy8udGVzdChkYXRhLnZhbHVlKSYmbGludGVyLndhcm4oXFxcIlcwNDZcXFwiLHtsaW5lOmRhdGEubGluZSxcXFwiY2hhclxcXCI6ZGF0YS5jaGFyLGRhdGE6W2RhdGEudmFsdWVdfSl9KSxsaW50ZXIub24oXFxcIlN0cmluZ1xcXCIsZnVuY3Rpb24oZGF0YSl7dmFyIHJlPS9eKD86amF2YXNjcmlwdHxqc2NyaXB0fGVjbWFzY3JpcHR8dmJzY3JpcHR8bGl2ZXNjcmlwdClcXFxccyo6L2k7bGludGVyLmdldE9wdGlvbihcXFwic2NyaXB0dXJsXFxcIil8fHJlLnRlc3QoZGF0YS52YWx1ZSkmJmxpbnRlci53YXJuKFxcXCJXMTA3XFxcIix7bGluZTpkYXRhLmxpbmUsXFxcImNoYXJcXFwiOmRhdGEuY2hhcn0pfSl9fSx7fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XFxcInVzZSBzdHJpY3RcXFwiO2V4cG9ydHMucmVzZXJ2ZWRWYXJzPXthcmd1bWVudHM6ITEsTmFOOiExfSxleHBvcnRzLmVjbWFJZGVudGlmaWVycz17QXJyYXk6ITEsQm9vbGVhbjohMSxEYXRlOiExLGRlY29kZVVSSTohMSxkZWNvZGVVUklDb21wb25lbnQ6ITEsZW5jb2RlVVJJOiExLGVuY29kZVVSSUNvbXBvbmVudDohMSxFcnJvcjohMSxldmFsOiExLEV2YWxFcnJvcjohMSxGdW5jdGlvbjohMSxoYXNPd25Qcm9wZXJ0eTohMSxpc0Zpbml0ZTohMSxpc05hTjohMSxKU09OOiExLE1hdGg6ITEsTnVtYmVyOiExLE9iamVjdDohMSxwYXJzZUludDohMSxwYXJzZUZsb2F0OiExLFJhbmdlRXJyb3I6ITEsUmVmZXJlbmNlRXJyb3I6ITEsUmVnRXhwOiExLFN0cmluZzohMSxTeW50YXhFcnJvcjohMSxUeXBlRXJyb3I6ITEsVVJJRXJyb3I6ITF9LGV4cG9ydHMubmV3RWNtYUlkZW50aWZpZXJzPXtTZXQ6ITEsTWFwOiExLFdlYWtNYXA6ITEsV2Vha1NldDohMSxQcm94eTohMSxQcm9taXNlOiExfSxleHBvcnRzLmJyb3dzZXI9e0F1ZGlvOiExLEJsb2I6ITEsYWRkRXZlbnRMaXN0ZW5lcjohMSxhcHBsaWNhdGlvbkNhY2hlOiExLGF0b2I6ITEsYmx1cjohMSxidG9hOiExLENhbnZhc0dyYWRpZW50OiExLENhbnZhc1BhdHRlcm46ITEsQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEOiExLGNsZWFySW50ZXJ2YWw6ITEsY2xlYXJUaW1lb3V0OiExLGNsb3NlOiExLGNsb3NlZDohMSxDdXN0b21FdmVudDohMSxET01QYXJzZXI6ITEsZGVmYXVsdFN0YXR1czohMSxkb2N1bWVudDohMSxFbGVtZW50OiExLEVsZW1lbnRUaW1lQ29udHJvbDohMSxldmVudDohMSxGaWxlUmVhZGVyOiExLEZvcm1EYXRhOiExLGZvY3VzOiExLGZyYW1lczohMSxnZXRDb21wdXRlZFN0eWxlOiExLEhUTUxFbGVtZW50OiExLEhUTUxBbmNob3JFbGVtZW50OiExLEhUTUxCYXNlRWxlbWVudDohMSxIVE1MQmxvY2txdW90ZUVsZW1lbnQ6ITEsSFRNTEJvZHlFbGVtZW50OiExLEhUTUxCUkVsZW1lbnQ6ITEsSFRNTEJ1dHRvbkVsZW1lbnQ6ITEsSFRNTENhbnZhc0VsZW1lbnQ6ITEsSFRNTERpcmVjdG9yeUVsZW1lbnQ6ITEsSFRNTERpdkVsZW1lbnQ6ITEsSFRNTERMaXN0RWxlbWVudDohMSxIVE1MRmllbGRTZXRFbGVtZW50OiExLEhUTUxGb250RWxlbWVudDohMSxIVE1MRm9ybUVsZW1lbnQ6ITEsSFRNTEZyYW1lRWxlbWVudDohMSxIVE1MRnJhbWVTZXRFbGVtZW50OiExLEhUTUxIZWFkRWxlbWVudDohMSxIVE1MSGVhZGluZ0VsZW1lbnQ6ITEsSFRNTEhSRWxlbWVudDohMSxIVE1MSHRtbEVsZW1lbnQ6ITEsSFRNTElGcmFtZUVsZW1lbnQ6ITEsSFRNTEltYWdlRWxlbWVudDohMSxIVE1MSW5wdXRFbGVtZW50OiExLEhUTUxJc0luZGV4RWxlbWVudDohMSxIVE1MTGFiZWxFbGVtZW50OiExLEhUTUxMYXllckVsZW1lbnQ6ITEsSFRNTExlZ2VuZEVsZW1lbnQ6ITEsSFRNTExJRWxlbWVudDohMSxIVE1MTGlua0VsZW1lbnQ6ITEsSFRNTE1hcEVsZW1lbnQ6ITEsSFRNTE1lbnVFbGVtZW50OiExLEhUTUxNZXRhRWxlbWVudDohMSxIVE1MTW9kRWxlbWVudDohMSxIVE1MT2JqZWN0RWxlbWVudDohMSxIVE1MT0xpc3RFbGVtZW50OiExLEhUTUxPcHRHcm91cEVsZW1lbnQ6ITEsSFRNTE9wdGlvbkVsZW1lbnQ6ITEsSFRNTFBhcmFncmFwaEVsZW1lbnQ6ITEsSFRNTFBhcmFtRWxlbWVudDohMSxIVE1MUHJlRWxlbWVudDohMSxIVE1MUXVvdGVFbGVtZW50OiExLEhUTUxTY3JpcHRFbGVtZW50OiExLEhUTUxTZWxlY3RFbGVtZW50OiExLEhUTUxTdHlsZUVsZW1lbnQ6ITEsSFRNTFRhYmxlQ2FwdGlvbkVsZW1lbnQ6ITEsSFRNTFRhYmxlQ2VsbEVsZW1lbnQ6ITEsSFRNTFRhYmxlQ29sRWxlbWVudDohMSxIVE1MVGFibGVFbGVtZW50OiExLEhUTUxUYWJsZVJvd0VsZW1lbnQ6ITEsSFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQ6ITEsSFRNTFRleHRBcmVhRWxlbWVudDohMSxIVE1MVGl0bGVFbGVtZW50OiExLEhUTUxVTGlzdEVsZW1lbnQ6ITEsSFRNTFZpZGVvRWxlbWVudDohMSxoaXN0b3J5OiExLEltYWdlOiExLGxlbmd0aDohMSxsb2NhbFN0b3JhZ2U6ITEsbG9jYXRpb246ITEsbWF0Y2hNZWRpYTohMSxNZXNzYWdlQ2hhbm5lbDohMSxNZXNzYWdlRXZlbnQ6ITEsTWVzc2FnZVBvcnQ6ITEsTW91c2VFdmVudDohMSxtb3ZlQnk6ITEsbW92ZVRvOiExLE11dGF0aW9uT2JzZXJ2ZXI6ITEsbmFtZTohMSxOb2RlOiExLE5vZGVGaWx0ZXI6ITEsTm9kZUxpc3Q6ITEsbmF2aWdhdG9yOiExLG9uYmVmb3JldW5sb2FkOiEwLG9uYmx1cjohMCxvbmVycm9yOiEwLG9uZm9jdXM6ITAsb25sb2FkOiEwLG9ucmVzaXplOiEwLG9udW5sb2FkOiEwLG9wZW46ITEsb3BlbkRhdGFiYXNlOiExLG9wZW5lcjohMSxPcHRpb246ITEscGFyZW50OiExLHByaW50OiExLHJlbW92ZUV2ZW50TGlzdGVuZXI6ITEscmVzaXplQnk6ITEscmVzaXplVG86ITEsc2NyZWVuOiExLHNjcm9sbDohMSxzY3JvbGxCeTohMSxzY3JvbGxUbzohMSxzZXNzaW9uU3RvcmFnZTohMSxzZXRJbnRlcnZhbDohMSxzZXRUaW1lb3V0OiExLFNoYXJlZFdvcmtlcjohMSxzdGF0dXM6ITEsU1ZHQUVsZW1lbnQ6ITEsU1ZHQWx0R2x5cGhEZWZFbGVtZW50OiExLFNWR0FsdEdseXBoRWxlbWVudDohMSxTVkdBbHRHbHlwaEl0ZW1FbGVtZW50OiExLFNWR0FuZ2xlOiExLFNWR0FuaW1hdGVDb2xvckVsZW1lbnQ6ITEsU1ZHQW5pbWF0ZUVsZW1lbnQ6ITEsU1ZHQW5pbWF0ZU1vdGlvbkVsZW1lbnQ6ITEsU1ZHQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQ6ITEsU1ZHQW5pbWF0ZWRBbmdsZTohMSxTVkdBbmltYXRlZEJvb2xlYW46ITEsU1ZHQW5pbWF0ZWRFbnVtZXJhdGlvbjohMSxTVkdBbmltYXRlZEludGVnZXI6ITEsU1ZHQW5pbWF0ZWRMZW5ndGg6ITEsU1ZHQW5pbWF0ZWRMZW5ndGhMaXN0OiExLFNWR0FuaW1hdGVkTnVtYmVyOiExLFNWR0FuaW1hdGVkTnVtYmVyTGlzdDohMSxTVkdBbmltYXRlZFBhdGhEYXRhOiExLFNWR0FuaW1hdGVkUG9pbnRzOiExLFNWR0FuaW1hdGVkUHJlc2VydmVBc3BlY3RSYXRpbzohMSxTVkdBbmltYXRlZFJlY3Q6ITEsU1ZHQW5pbWF0ZWRTdHJpbmc6ITEsU1ZHQW5pbWF0ZWRUcmFuc2Zvcm1MaXN0OiExLFNWR0FuaW1hdGlvbkVsZW1lbnQ6ITEsU1ZHQ1NTUnVsZTohMSxTVkdDaXJjbGVFbGVtZW50OiExLFNWR0NsaXBQYXRoRWxlbWVudDohMSxTVkdDb2xvcjohMSxTVkdDb2xvclByb2ZpbGVFbGVtZW50OiExLFNWR0NvbG9yUHJvZmlsZVJ1bGU6ITEsU1ZHQ29tcG9uZW50VHJhbnNmZXJGdW5jdGlvbkVsZW1lbnQ6ITEsU1ZHQ3Vyc29yRWxlbWVudDohMSxTVkdEZWZzRWxlbWVudDohMSxTVkdEZXNjRWxlbWVudDohMSxTVkdEb2N1bWVudDohMSxTVkdFbGVtZW50OiExLFNWR0VsZW1lbnRJbnN0YW5jZTohMSxTVkdFbGVtZW50SW5zdGFuY2VMaXN0OiExLFNWR0VsbGlwc2VFbGVtZW50OiExLFNWR0V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6ITEsU1ZHRkVCbGVuZEVsZW1lbnQ6ITEsU1ZHRkVDb2xvck1hdHJpeEVsZW1lbnQ6ITEsU1ZHRkVDb21wb25lbnRUcmFuc2ZlckVsZW1lbnQ6ITEsU1ZHRkVDb21wb3NpdGVFbGVtZW50OiExLFNWR0ZFQ29udm9sdmVNYXRyaXhFbGVtZW50OiExLFNWR0ZFRGlmZnVzZUxpZ2h0aW5nRWxlbWVudDohMSxTVkdGRURpc3BsYWNlbWVudE1hcEVsZW1lbnQ6ITEsU1ZHRkVEaXN0YW50TGlnaHRFbGVtZW50OiExLFNWR0ZFRmxvb2RFbGVtZW50OiExLFNWR0ZFRnVuY0FFbGVtZW50OiExLFNWR0ZFRnVuY0JFbGVtZW50OiExLFNWR0ZFRnVuY0dFbGVtZW50OiExLFNWR0ZFRnVuY1JFbGVtZW50OiExLFNWR0ZFR2F1c3NpYW5CbHVyRWxlbWVudDohMSxTVkdGRUltYWdlRWxlbWVudDohMSxTVkdGRU1lcmdlRWxlbWVudDohMSxTVkdGRU1lcmdlTm9kZUVsZW1lbnQ6ITEsU1ZHRkVNb3JwaG9sb2d5RWxlbWVudDohMSxTVkdGRU9mZnNldEVsZW1lbnQ6ITEsU1ZHRkVQb2ludExpZ2h0RWxlbWVudDohMSxTVkdGRVNwZWN1bGFyTGlnaHRpbmdFbGVtZW50OiExLFNWR0ZFU3BvdExpZ2h0RWxlbWVudDohMSxTVkdGRVRpbGVFbGVtZW50OiExLFNWR0ZFVHVyYnVsZW5jZUVsZW1lbnQ6ITEsU1ZHRmlsdGVyRWxlbWVudDohMSxTVkdGaWx0ZXJQcmltaXRpdmVTdGFuZGFyZEF0dHJpYnV0ZXM6ITEsU1ZHRml0VG9WaWV3Qm94OiExLFNWR0ZvbnRFbGVtZW50OiExLFNWR0ZvbnRGYWNlRWxlbWVudDohMSxTVkdGb250RmFjZUZvcm1hdEVsZW1lbnQ6ITEsU1ZHRm9udEZhY2VOYW1lRWxlbWVudDohMSxTVkdGb250RmFjZVNyY0VsZW1lbnQ6ITEsU1ZHRm9udEZhY2VVcmlFbGVtZW50OiExLFNWR0ZvcmVpZ25PYmplY3RFbGVtZW50OiExLFNWR0dFbGVtZW50OiExLFNWR0dseXBoRWxlbWVudDohMSxTVkdHbHlwaFJlZkVsZW1lbnQ6ITEsU1ZHR3JhZGllbnRFbGVtZW50OiExLFNWR0hLZXJuRWxlbWVudDohMSxTVkdJQ0NDb2xvcjohMSxTVkdJbWFnZUVsZW1lbnQ6ITEsU1ZHTGFuZ1NwYWNlOiExLFNWR0xlbmd0aDohMSxTVkdMZW5ndGhMaXN0OiExLFNWR0xpbmVFbGVtZW50OiExLFNWR0xpbmVhckdyYWRpZW50RWxlbWVudDohMSxTVkdMb2NhdGFibGU6ITEsU1ZHTVBhdGhFbGVtZW50OiExLFNWR01hcmtlckVsZW1lbnQ6ITEsU1ZHTWFza0VsZW1lbnQ6ITEsU1ZHTWF0cml4OiExLFNWR01ldGFkYXRhRWxlbWVudDohMSxTVkdNaXNzaW5nR2x5cGhFbGVtZW50OiExLFNWR051bWJlcjohMSxTVkdOdW1iZXJMaXN0OiExLFNWR1BhaW50OiExLFNWR1BhdGhFbGVtZW50OiExLFNWR1BhdGhTZWc6ITEsU1ZHUGF0aFNlZ0FyY0FiczohMSxTVkdQYXRoU2VnQXJjUmVsOiExLFNWR1BhdGhTZWdDbG9zZVBhdGg6ITEsU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY0FiczohMSxTVkdQYXRoU2VnQ3VydmV0b0N1YmljUmVsOiExLFNWR1BhdGhTZWdDdXJ2ZXRvQ3ViaWNTbW9vdGhBYnM6ITEsU1ZHUGF0aFNlZ0N1cnZldG9DdWJpY1Ntb290aFJlbDohMSxTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY0FiczohMSxTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1JlbDohMSxTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aEFiczohMSxTVkdQYXRoU2VnQ3VydmV0b1F1YWRyYXRpY1Ntb290aFJlbDohMSxTVkdQYXRoU2VnTGluZXRvQWJzOiExLFNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsQWJzOiExLFNWR1BhdGhTZWdMaW5ldG9Ib3Jpem9udGFsUmVsOiExLFNWR1BhdGhTZWdMaW5ldG9SZWw6ITEsU1ZHUGF0aFNlZ0xpbmV0b1ZlcnRpY2FsQWJzOiExLFNWR1BhdGhTZWdMaW5ldG9WZXJ0aWNhbFJlbDohMSxTVkdQYXRoU2VnTGlzdDohMSxTVkdQYXRoU2VnTW92ZXRvQWJzOiExLFNWR1BhdGhTZWdNb3ZldG9SZWw6ITEsU1ZHUGF0dGVybkVsZW1lbnQ6ITEsU1ZHUG9pbnQ6ITEsU1ZHUG9pbnRMaXN0OiExLFNWR1BvbHlnb25FbGVtZW50OiExLFNWR1BvbHlsaW5lRWxlbWVudDohMSxTVkdQcmVzZXJ2ZUFzcGVjdFJhdGlvOiExLFNWR1JhZGlhbEdyYWRpZW50RWxlbWVudDohMSxTVkdSZWN0OiExLFNWR1JlY3RFbGVtZW50OiExLFNWR1JlbmRlcmluZ0ludGVudDohMSxTVkdTVkdFbGVtZW50OiExLFNWR1NjcmlwdEVsZW1lbnQ6ITEsU1ZHU2V0RWxlbWVudDohMSxTVkdTdG9wRWxlbWVudDohMSxTVkdTdHJpbmdMaXN0OiExLFNWR1N0eWxhYmxlOiExLFNWR1N0eWxlRWxlbWVudDohMSxTVkdTd2l0Y2hFbGVtZW50OiExLFNWR1N5bWJvbEVsZW1lbnQ6ITEsU1ZHVFJlZkVsZW1lbnQ6ITEsU1ZHVFNwYW5FbGVtZW50OiExLFNWR1Rlc3RzOiExLFNWR1RleHRDb250ZW50RWxlbWVudDohMSxTVkdUZXh0RWxlbWVudDohMSxTVkdUZXh0UGF0aEVsZW1lbnQ6ITEsU1ZHVGV4dFBvc2l0aW9uaW5nRWxlbWVudDohMSxTVkdUaXRsZUVsZW1lbnQ6ITEsU1ZHVHJhbnNmb3JtOiExLFNWR1RyYW5zZm9ybUxpc3Q6ITEsU1ZHVHJhbnNmb3JtYWJsZTohMSxTVkdVUklSZWZlcmVuY2U6ITEsU1ZHVW5pdFR5cGVzOiExLFNWR1VzZUVsZW1lbnQ6ITEsU1ZHVktlcm5FbGVtZW50OiExLFNWR1ZpZXdFbGVtZW50OiExLFNWR1ZpZXdTcGVjOiExLFNWR1pvb21BbmRQYW46ITEsVGltZUV2ZW50OiExLHRvcDohMSxVUkw6ITEsV2ViU29ja2V0OiExLHdpbmRvdzohMSxXb3JrZXI6ITEsWE1MSHR0cFJlcXVlc3Q6ITEsWE1MU2VyaWFsaXplcjohMSxYUGF0aEV2YWx1YXRvcjohMSxYUGF0aEV4Y2VwdGlvbjohMSxYUGF0aEV4cHJlc3Npb246ITEsWFBhdGhOYW1lc3BhY2U6ITEsWFBhdGhOU1Jlc29sdmVyOiExLFhQYXRoUmVzdWx0OiExfSxleHBvcnRzLmRldmVsPXthbGVydDohMSxjb25maXJtOiExLGNvbnNvbGU6ITEsRGVidWc6ITEsb3BlcmE6ITEscHJvbXB0OiExfSxleHBvcnRzLndvcmtlcj17aW1wb3J0U2NyaXB0czohMCxwb3N0TWVzc2FnZTohMCxzZWxmOiEwfSxleHBvcnRzLm5vbnN0YW5kYXJkPXtlc2NhcGU6ITEsdW5lc2NhcGU6ITF9LGV4cG9ydHMuY291Y2g9e3JlcXVpcmU6ITEscmVzcG9uZDohMSxnZXRSb3c6ITEsZW1pdDohMSxzZW5kOiExLHN0YXJ0OiExLHN1bTohMSxsb2c6ITEsZXhwb3J0czohMSxtb2R1bGU6ITEscHJvdmlkZXM6ITF9LGV4cG9ydHMubm9kZT17X19maWxlbmFtZTohMSxfX2Rpcm5hbWU6ITEsR0xPQkFMOiExLGdsb2JhbDohMSxtb2R1bGU6ITEsYWNlcXVpcmU6ITEsQnVmZmVyOiEwLGNvbnNvbGU6ITAsZXhwb3J0czohMCxwcm9jZXNzOiEwLHNldFRpbWVvdXQ6ITAsY2xlYXJUaW1lb3V0OiEwLHNldEludGVydmFsOiEwLGNsZWFySW50ZXJ2YWw6ITAsc2V0SW1tZWRpYXRlOiEwLGNsZWFySW1tZWRpYXRlOiEwfSxleHBvcnRzLnBoYW50b209e3BoYW50b206ITAsYWNlcXVpcmU6ITAsV2ViUGFnZTohMCxjb25zb2xlOiEwLGV4cG9ydHM6ITB9LGV4cG9ydHMucXVuaXQ9e2FzeW5jVGVzdDohMSxkZWVwRXF1YWw6ITEsZXF1YWw6ITEsZXhwZWN0OiExLG1vZHVsZTohMSxub3REZWVwRXF1YWw6ITEsbm90RXF1YWw6ITEsbm90UHJvcEVxdWFsOiExLG5vdFN0cmljdEVxdWFsOiExLG9rOiExLHByb3BFcXVhbDohMSxRVW5pdDohMSxyYWlzZXM6ITEsc3RhcnQ6ITEsc3RvcDohMSxzdHJpY3RFcXVhbDohMSx0ZXN0OiExLFxcXCJ0aHJvd3NcXFwiOiExfSxleHBvcnRzLnJoaW5vPXtkZWZpbmVDbGFzczohMSxkZXNlcmlhbGl6ZTohMSxnYzohMSxoZWxwOiExLGltcG9ydENsYXNzOiExLGltcG9ydFBhY2thZ2U6ITEsamF2YTohMSxsb2FkOiExLGxvYWRDbGFzczohMSxQYWNrYWdlczohMSxwcmludDohMSxxdWl0OiExLHJlYWRGaWxlOiExLHJlYWRVcmw6ITEscnVuQ29tbWFuZDohMSxzZWFsOiExLHNlcmlhbGl6ZTohMSxzcGF3bjohMSxzeW5jOiExLHRvaW50MzI6ITEsdmVyc2lvbjohMX0sZXhwb3J0cy5zaGVsbGpzPXt0YXJnZXQ6ITEsZWNobzohMSxleGl0OiExLGNkOiExLHB3ZDohMSxsczohMSxmaW5kOiExLGNwOiExLHJtOiExLG12OiExLG1rZGlyOiExLHRlc3Q6ITEsY2F0OiExLHNlZDohMSxncmVwOiExLHdoaWNoOiExLGRpcnM6ITEscHVzaGQ6ITEscG9wZDohMSxlbnY6ITEsZXhlYzohMSxjaG1vZDohMSxjb25maWc6ITEsZXJyb3I6ITEsdGVtcGRpcjohMX0sZXhwb3J0cy50eXBlZD17QXJyYXlCdWZmZXI6ITEsQXJyYXlCdWZmZXJWaWV3OiExLERhdGFWaWV3OiExLEZsb2F0MzJBcnJheTohMSxGbG9hdDY0QXJyYXk6ITEsSW50MTZBcnJheTohMSxJbnQzMkFycmF5OiExLEludDhBcnJheTohMSxVaW50MTZBcnJheTohMSxVaW50MzJBcnJheTohMSxVaW50OEFycmF5OiExLFVpbnQ4Q2xhbXBlZEFycmF5OiExfSxleHBvcnRzLndzaD17QWN0aXZlWE9iamVjdDohMCxFbnVtZXJhdG9yOiEwLEdldE9iamVjdDohMCxTY3JpcHRFbmdpbmU6ITAsU2NyaXB0RW5naW5lQnVpbGRWZXJzaW9uOiEwLFNjcmlwdEVuZ2luZU1ham9yVmVyc2lvbjohMCxTY3JpcHRFbmdpbmVNaW5vclZlcnNpb246ITAsVkJBcnJheTohMCxXU0g6ITAsV1NjcmlwdDohMCxYRG9tYWluUmVxdWVzdDohMH0sZXhwb3J0cy5kb2pvPXtkb2pvOiExLGRpaml0OiExLGRvam94OiExLGRlZmluZTohMSxyZXF1aXJlOiExfSxleHBvcnRzLmpxdWVyeT17JDohMSxqUXVlcnk6ITF9LGV4cG9ydHMubW9vdG9vbHM9eyQ6ITEsJCQ6ITEsQXNzZXQ6ITEsQnJvd3NlcjohMSxDaGFpbjohMSxDbGFzczohMSxDb2xvcjohMSxDb29raWU6ITEsQ29yZTohMSxEb2N1bWVudDohMSxEb21SZWFkeTohMSxET01FdmVudDohMSxET01SZWFkeTohMSxEcmFnOiExLEVsZW1lbnQ6ITEsRWxlbWVudHM6ITEsRXZlbnQ6ITEsRXZlbnRzOiExLEZ4OiExLEdyb3VwOiExLEhhc2g6ITEsSHRtbFRhYmxlOiExLElGcmFtZTohMSxJZnJhbWVTaGltOiExLElucHV0VmFsaWRhdG9yOiExLGluc3RhbmNlT2Y6ITEsS2V5Ym9hcmQ6ITEsTG9jYWxlOiExLE1hc2s6ITEsTW9vVG9vbHM6ITEsTmF0aXZlOiExLE9wdGlvbnM6ITEsT3ZlclRleHQ6ITEsUmVxdWVzdDohMSxTY3JvbGxlcjohMSxTbGljazohMSxTbGlkZXI6ITEsU29ydGFibGVzOiExLFNwaW5uZXI6ITEsU3dpZmY6ITEsVGlwczohMSxUeXBlOiExLHR5cGVPZjohMSxVUkk6ITEsV2luZG93OiExfSxleHBvcnRzLnByb3RvdHlwZWpzPXskOiExLCQkOiExLCRBOiExLCRGOiExLCRIOiExLCRSOiExLCRicmVhazohMSwkY29udGludWU6ITEsJHc6ITEsQWJzdHJhY3Q6ITEsQWpheDohMSxDbGFzczohMSxFbnVtZXJhYmxlOiExLEVsZW1lbnQ6ITEsRXZlbnQ6ITEsRmllbGQ6ITEsRm9ybTohMSxIYXNoOiExLEluc2VydGlvbjohMSxPYmplY3RSYW5nZTohMSxQZXJpb2RpY2FsRXhlY3V0ZXI6ITEsUG9zaXRpb246ITEsUHJvdG90eXBlOiExLFNlbGVjdG9yOiExLFRlbXBsYXRlOiExLFRvZ2dsZTohMSxUcnk6ITEsQXV0b2NvbXBsZXRlcjohMSxCdWlsZGVyOiExLENvbnRyb2w6ITEsRHJhZ2dhYmxlOiExLERyYWdnYWJsZXM6ITEsRHJvcHBhYmxlczohMSxFZmZlY3Q6ITEsU29ydGFibGU6ITEsU29ydGFibGVPYnNlcnZlcjohMSxTb3VuZDohMSxTY3JpcHRhY3Vsb3VzOiExfSxleHBvcnRzLnl1aT17WVVJOiExLFk6ITEsWVVJX2NvbmZpZzohMX0sZXhwb3J0cy5tb2NoYT17ZGVzY3JpYmU6ITEsaXQ6ITEsYmVmb3JlOiExLGFmdGVyOiExLGJlZm9yZUVhY2g6ITEsYWZ0ZXJFYWNoOiExLHN1aXRlOiExLHRlc3Q6ITEsc2V0dXA6ITEsdGVhcmRvd246ITF9LGV4cG9ydHMuamFzbWluZT17amFzbWluZTohMSxkZXNjcmliZTohMSxpdDohMSx4aXQ6ITEsYmVmb3JlRWFjaDohMSxhZnRlckVhY2g6ITEsc2V0Rml4dHVyZXM6ITEsbG9hZEZpeHR1cmVzOiExLHNweU9uOiExLGV4cGVjdDohMSxydW5zOiExLHdhaXRzRm9yOiExLHdhaXRzOiExfX0se31dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSl7ZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCl7dGhpcy5fZXZlbnRzPXRoaXMuX2V2ZW50c3x8e30sdGhpcy5fbWF4TGlzdGVuZXJzPXRoaXMuX21heExpc3RlbmVyc3x8dm9pZCAwXFxufWZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKXtyZXR1cm5cXFwiZnVuY3Rpb25cXFwiPT10eXBlb2YgYXJnfWZ1bmN0aW9uIGlzTnVtYmVyKGFyZyl7cmV0dXJuXFxcIm51bWJlclxcXCI9PXR5cGVvZiBhcmd9ZnVuY3Rpb24gaXNPYmplY3QoYXJnKXtyZXR1cm5cXFwib2JqZWN0XFxcIj09dHlwZW9mIGFyZyYmbnVsbCE9PWFyZ31mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpe3JldHVybiB2b2lkIDA9PT1hcmd9bW9kdWxlLmV4cG9ydHM9RXZlbnRFbWl0dGVyLEV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXI9RXZlbnRFbWl0dGVyLEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cz12b2lkIDAsRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzPXZvaWQgMCxFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycz0xMCxFdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycz1mdW5jdGlvbihuKXtpZighaXNOdW1iZXIobil8fDA+bnx8aXNOYU4obikpdGhyb3cgVHlwZUVycm9yKFxcXCJuIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXJcXFwiKTtyZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzPW4sdGhpc30sRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKHR5cGUpe3ZhciBlcixoYW5kbGVyLGxlbixhcmdzLGksbGlzdGVuZXJzO2lmKHRoaXMuX2V2ZW50c3x8KHRoaXMuX2V2ZW50cz17fSksXFxcImVycm9yXFxcIj09PXR5cGUmJighdGhpcy5fZXZlbnRzLmVycm9yfHxpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpJiYhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpdGhyb3cgZXI9YXJndW1lbnRzWzFdLGVyIGluc3RhbmNlb2YgRXJyb3I/ZXI6VHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXFxcImVycm9yXFxcIiBldmVudC4nKTtpZihoYW5kbGVyPXRoaXMuX2V2ZW50c1t0eXBlXSxpc1VuZGVmaW5lZChoYW5kbGVyKSlyZXR1cm4hMTtpZihpc0Z1bmN0aW9uKGhhbmRsZXIpKXN3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtjYXNlIDE6aGFuZGxlci5jYWxsKHRoaXMpO2JyZWFrO2Nhc2UgMjpoYW5kbGVyLmNhbGwodGhpcyxhcmd1bWVudHNbMV0pO2JyZWFrO2Nhc2UgMzpoYW5kbGVyLmNhbGwodGhpcyxhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKTticmVhaztkZWZhdWx0OmZvcihsZW49YXJndW1lbnRzLmxlbmd0aCxhcmdzPUFycmF5KGxlbi0xKSxpPTE7bGVuPmk7aSsrKWFyZ3NbaS0xXT1hcmd1bWVudHNbaV07aGFuZGxlci5hcHBseSh0aGlzLGFyZ3MpfWVsc2UgaWYoaXNPYmplY3QoaGFuZGxlcikpe2ZvcihsZW49YXJndW1lbnRzLmxlbmd0aCxhcmdzPUFycmF5KGxlbi0xKSxpPTE7bGVuPmk7aSsrKWFyZ3NbaS0xXT1hcmd1bWVudHNbaV07Zm9yKGxpc3RlbmVycz1oYW5kbGVyLnNsaWNlKCksbGVuPWxpc3RlbmVycy5sZW5ndGgsaT0wO2xlbj5pO2krKylsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcyxhcmdzKX1yZXR1cm4hMH0sRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcj1mdW5jdGlvbih0eXBlLGxpc3RlbmVyKXt2YXIgbTtpZighaXNGdW5jdGlvbihsaXN0ZW5lcikpdGhyb3cgVHlwZUVycm9yKFxcXCJsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb25cXFwiKTtpZih0aGlzLl9ldmVudHN8fCh0aGlzLl9ldmVudHM9e30pLHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lciYmdGhpcy5lbWl0KFxcXCJuZXdMaXN0ZW5lclxcXCIsdHlwZSxpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKT9saXN0ZW5lci5saXN0ZW5lcjpsaXN0ZW5lciksdGhpcy5fZXZlbnRzW3R5cGVdP2lzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSk/dGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpOnRoaXMuX2V2ZW50c1t0eXBlXT1bdGhpcy5fZXZlbnRzW3R5cGVdLGxpc3RlbmVyXTp0aGlzLl9ldmVudHNbdHlwZV09bGlzdGVuZXIsaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSYmIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpe3ZhciBtO209aXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKT9FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVyczp0aGlzLl9tYXhMaXN0ZW5lcnMsbSYmbT4wJiZ0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoPm0mJih0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkPSEwLGNvbnNvbGUuZXJyb3IoXFxcIihub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuXFxcIix0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKSxjb25zb2xlLnRyYWNlKCkpfXJldHVybiB0aGlzfSxFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uPUV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIsRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlPWZ1bmN0aW9uKHR5cGUsbGlzdGVuZXIpe2Z1bmN0aW9uIGcoKXt0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsZyksZmlyZWR8fChmaXJlZD0hMCxsaXN0ZW5lci5hcHBseSh0aGlzLGFyZ3VtZW50cykpfWlmKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSl0aHJvdyBUeXBlRXJyb3IoXFxcImxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvblxcXCIpO3ZhciBmaXJlZD0hMTtyZXR1cm4gZy5saXN0ZW5lcj1saXN0ZW5lcix0aGlzLm9uKHR5cGUsZyksdGhpc30sRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbih0eXBlLGxpc3RlbmVyKXt2YXIgbGlzdCxwb3NpdGlvbixsZW5ndGgsaTtpZighaXNGdW5jdGlvbihsaXN0ZW5lcikpdGhyb3cgVHlwZUVycm9yKFxcXCJsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb25cXFwiKTtpZighdGhpcy5fZXZlbnRzfHwhdGhpcy5fZXZlbnRzW3R5cGVdKXJldHVybiB0aGlzO2lmKGxpc3Q9dGhpcy5fZXZlbnRzW3R5cGVdLGxlbmd0aD1saXN0Lmxlbmd0aCxwb3NpdGlvbj0tMSxsaXN0PT09bGlzdGVuZXJ8fGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikmJmxpc3QubGlzdGVuZXI9PT1saXN0ZW5lcilkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdLHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lciYmdGhpcy5lbWl0KFxcXCJyZW1vdmVMaXN0ZW5lclxcXCIsdHlwZSxsaXN0ZW5lcik7ZWxzZSBpZihpc09iamVjdChsaXN0KSl7Zm9yKGk9bGVuZ3RoO2ktLT4wOylpZihsaXN0W2ldPT09bGlzdGVuZXJ8fGxpc3RbaV0ubGlzdGVuZXImJmxpc3RbaV0ubGlzdGVuZXI9PT1saXN0ZW5lcil7cG9zaXRpb249aTticmVha31pZigwPnBvc2l0aW9uKXJldHVybiB0aGlzOzE9PT1saXN0Lmxlbmd0aD8obGlzdC5sZW5ndGg9MCxkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdKTpsaXN0LnNwbGljZShwb3NpdGlvbiwxKSx0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcXFwicmVtb3ZlTGlzdGVuZXJcXFwiLHR5cGUsbGlzdGVuZXIpfXJldHVybiB0aGlzfSxFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbih0eXBlKXt2YXIga2V5LGxpc3RlbmVycztpZighdGhpcy5fZXZlbnRzKXJldHVybiB0aGlzO2lmKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpcmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMuX2V2ZW50cz17fTp0aGlzLl9ldmVudHNbdHlwZV0mJmRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV0sdGhpcztpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKGtleSBpbiB0aGlzLl9ldmVudHMpXFxcInJlbW92ZUxpc3RlbmVyXFxcIiE9PWtleSYmdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtyZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXFxcInJlbW92ZUxpc3RlbmVyXFxcIiksdGhpcy5fZXZlbnRzPXt9LHRoaXN9aWYobGlzdGVuZXJzPXRoaXMuX2V2ZW50c1t0eXBlXSxpc0Z1bmN0aW9uKGxpc3RlbmVycykpdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLGxpc3RlbmVycyk7ZWxzZSBmb3IoO2xpc3RlbmVycy5sZW5ndGg7KXRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSxsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aC0xXSk7cmV0dXJuIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV0sdGhpc30sRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnM9ZnVuY3Rpb24odHlwZSl7dmFyIHJldDtyZXR1cm4gcmV0PXRoaXMuX2V2ZW50cyYmdGhpcy5fZXZlbnRzW3R5cGVdP2lzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKT9bdGhpcy5fZXZlbnRzW3R5cGVdXTp0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTpbXX0sRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24oZW1pdHRlcix0eXBlKXt2YXIgcmV0O3JldHVybiByZXQ9ZW1pdHRlci5fZXZlbnRzJiZlbWl0dGVyLl9ldmVudHNbdHlwZV0/aXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pPzE6ZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDowfX0se31dfSx7fSxbM10pKDMpfSksYWNlLmRlZmluZShcXFwiYWNlL21vZGUvamF2YXNjcmlwdF93b3JrZXJcXFwiLFtcXFwicmVxdWlyZVxcXCIsXFxcImV4cG9ydHNcXFwiLFxcXCJtb2R1bGVcXFwiLFxcXCJhY2UvbGliL29vcFxcXCIsXFxcImFjZS93b3JrZXIvbWlycm9yXFxcIixcXFwiYWNlL21vZGUvamF2YXNjcmlwdC9qc2hpbnRcXFwiXSxmdW5jdGlvbihhY2VxdWlyZSxleHBvcnRzLG1vZHVsZSl7XFxcInVzZSBzdHJpY3RcXFwiO2Z1bmN0aW9uIHN0YXJ0UmVnZXgoYXJyKXtyZXR1cm4gUmVnRXhwKFxcXCJeKFxcXCIrYXJyLmpvaW4oXFxcInxcXFwiKStcXFwiKVxcXCIpfXZhciBvb3A9YWNlcXVpcmUoXFxcIi4uL2xpYi9vb3BcXFwiKSxNaXJyb3I9YWNlcXVpcmUoXFxcIi4uL3dvcmtlci9taXJyb3JcXFwiKS5NaXJyb3IsbGludD1hY2VxdWlyZShcXFwiLi9qYXZhc2NyaXB0L2pzaGludFxcXCIpLkpTSElOVCxkaXNhYmxlZFdhcm5pbmdzUmU9c3RhcnRSZWdleChbXFxcIkJhZCBmb3IgaW4gdmFyaWFibGUgJyguKyknLlxcXCIsJ01pc3NpbmcgXFxcInVzZSBzdHJpY3RcXFwiJ10pLGVycm9yc1JlPXN0YXJ0UmVnZXgoW1xcXCJVbmV4cGVjdGVkXFxcIixcXFwiRXhwZWN0ZWQgXFxcIixcXFwiQ29uZnVzaW5nIChwbHVzfG1pbnVzKVxcXCIsXFxcIlxcXFxcXFxce2FcXFxcXFxcXH0gdW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblxcXCIsXFxcIlVuY2xvc2VkIFxcXCIsXFxcIlVubWF0Y2hlZCBcXFwiLFxcXCJVbmJlZ3VuIGNvbW1lbnRcXFwiLFxcXCJCYWQgaW52b2NhdGlvblxcXCIsXFxcIk1pc3Npbmcgc3BhY2UgYWZ0ZXJcXFwiLFxcXCJNaXNzaW5nIG9wZXJhdG9yIGF0XFxcIl0pLGluZm9SZT1zdGFydFJlZ2V4KFtcXFwiRXhwZWN0ZWQgYW4gYXNzaWdubWVudFxcXCIsXFxcIkJhZCBlc2NhcGVtZW50IG9mIEVPTFxcXCIsXFxcIlVuZXhwZWN0ZWQgY29tbWFcXFwiLFxcXCJVbmV4cGVjdGVkIHNwYWNlXFxcIixcXFwiTWlzc2luZyByYWRpeCBwYXJhbWV0ZXIuXFxcIixcXFwiQSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQgY2FuXFxcIixcXFwiXFxcXFxcXFxbJ3thfSdcXFxcXFxcXF0gaXMgYmV0dGVyIHdyaXR0ZW4gaW4gZG90IG5vdGF0aW9uLlxcXCIsXFxcIid7YX0nIHVzZWQgb3V0IG9mIHNjb3BlXFxcIl0pLEphdmFTY3JpcHRXb3JrZXI9ZXhwb3J0cy5KYXZhU2NyaXB0V29ya2VyPWZ1bmN0aW9uKHNlbmRlcil7TWlycm9yLmNhbGwodGhpcyxzZW5kZXIpLHRoaXMuc2V0VGltZW91dCg1MDApLHRoaXMuc2V0T3B0aW9ucygpfTtvb3AuaW5oZXJpdHMoSmF2YVNjcmlwdFdvcmtlcixNaXJyb3IpLGZ1bmN0aW9uKCl7dGhpcy5zZXRPcHRpb25zPWZ1bmN0aW9uKG9wdGlvbnMpe3RoaXMub3B0aW9ucz1vcHRpb25zfHx7ZXNuZXh0OiEwLG1vejohMCxkZXZlbDohMCxicm93c2VyOiEwLG5vZGU6ITAsbGF4Y29tbWE6ITAsbGF4YnJlYWs6ITAsbGFzdHNlbWljOiEwLG9uZXZhcjohMSxwYXNzZmFpbDohMSxtYXhlcnI6MTAwLGV4cHI6ITAsbXVsdGlzdHI6ITAsZ2xvYmFsc3RyaWN0OiEwfSx0aGlzLmRvYy5nZXRWYWx1ZSgpJiZ0aGlzLmRlZmVycmVkVXBkYXRlLnNjaGVkdWxlKDEwMCl9LHRoaXMuY2hhbmdlT3B0aW9ucz1mdW5jdGlvbihuZXdPcHRpb25zKXtvb3AubWl4aW4odGhpcy5vcHRpb25zLG5ld09wdGlvbnMpLHRoaXMuZG9jLmdldFZhbHVlKCkmJnRoaXMuZGVmZXJyZWRVcGRhdGUuc2NoZWR1bGUoMTAwKX0sdGhpcy5pc1ZhbGlkSlM9ZnVuY3Rpb24oc3RyKXt0cnl7ZXZhbChcXFwidGhyb3cgMDtcXFwiK3N0cil9Y2F0Y2goZSl7aWYoMD09PWUpcmV0dXJuITB9cmV0dXJuITF9LHRoaXMub25VcGRhdGU9ZnVuY3Rpb24oKXt2YXIgdmFsdWU9dGhpcy5kb2MuZ2V0VmFsdWUoKTtpZih2YWx1ZT12YWx1ZS5yZXBsYWNlKC9eIyEuKlxcXFxuLyxcXFwiXFxcXG5cXFwiKSwhdmFsdWUpcmV0dXJuIHRoaXMuc2VuZGVyLmVtaXQoXFxcImpzbGludFxcXCIsW10pLHZvaWQgMDt2YXIgZXJyb3JzPVtdLG1heEVycm9yTGV2ZWw9dGhpcy5pc1ZhbGlkSlModmFsdWUpP1xcXCJ3YXJuaW5nXFxcIjpcXFwiZXJyb3JcXFwiO2xpbnQodmFsdWUsdGhpcy5vcHRpb25zKTtmb3IodmFyIHJlc3VsdHM9bGludC5lcnJvcnMsZXJyb3JBZGRlZD0hMSxpPTA7cmVzdWx0cy5sZW5ndGg+aTtpKyspe3ZhciBlcnJvcj1yZXN1bHRzW2ldO2lmKGVycm9yKXt2YXIgcmF3PWVycm9yLnJhdyx0eXBlPVxcXCJ3YXJuaW5nXFxcIjtpZihcXFwiTWlzc2luZyBzZW1pY29sb24uXFxcIj09cmF3KXt2YXIgc3RyPWVycm9yLmV2aWRlbmNlLnN1YnN0cihlcnJvci5jaGFyYWN0ZXIpO3N0cj1zdHIuY2hhckF0KHN0ci5zZWFyY2goL1xcXFxTLykpLFxcXCJlcnJvclxcXCI9PW1heEVycm9yTGV2ZWwmJnN0ciYmL1tcXFxcd1xcXFxkeyhbJ1xcXCJdLy50ZXN0KHN0cik/KGVycm9yLnJlYXNvbj0nTWlzc2luZyBcXFwiO1xcXCIgYmVmb3JlIHN0YXRlbWVudCcsdHlwZT1cXFwiZXJyb3JcXFwiKTp0eXBlPVxcXCJpbmZvXFxcIn1lbHNle2lmKGRpc2FibGVkV2FybmluZ3NSZS50ZXN0KHJhdykpY29udGludWU7aW5mb1JlLnRlc3QocmF3KT90eXBlPVxcXCJpbmZvXFxcIjplcnJvcnNSZS50ZXN0KHJhdyk/KGVycm9yQWRkZWQ9ITAsdHlwZT1tYXhFcnJvckxldmVsKTpcXFwiJ3thfScgaXMgbm90IGRlZmluZWQuXFxcIj09cmF3P3R5cGU9XFxcIndhcm5pbmdcXFwiOlxcXCIne2F9JyBpcyBkZWZpbmVkIGJ1dCBuZXZlciB1c2VkLlxcXCI9PXJhdyYmKHR5cGU9XFxcImluZm9cXFwiKX1lcnJvcnMucHVzaCh7cm93OmVycm9yLmxpbmUtMSxjb2x1bW46ZXJyb3IuY2hhcmFjdGVyLTEsdGV4dDplcnJvci5yZWFzb24sdHlwZTp0eXBlLHJhdzpyYXd9KX19dGhpcy5zZW5kZXIuZW1pdChcXFwianNsaW50XFxcIixlcnJvcnMpfX0uY2FsbChKYXZhU2NyaXB0V29ya2VyLnByb3RvdHlwZSl9KSxhY2UuZGVmaW5lKFxcXCJhY2UvbGliL2VzNS1zaGltXFxcIixbXFxcInJlcXVpcmVcXFwiLFxcXCJleHBvcnRzXFxcIixcXFwibW9kdWxlXFxcIl0sZnVuY3Rpb24oKXtmdW5jdGlvbiBFbXB0eSgpe31mdW5jdGlvbiBkb2VzRGVmaW5lUHJvcGVydHlXb3JrKG9iamVjdCl7dHJ5e3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LFxcXCJzZW50aW5lbFxcXCIse30pLFxcXCJzZW50aW5lbFxcXCJpbiBvYmplY3R9Y2F0Y2goZXhjZXB0aW9uKXt9fWZ1bmN0aW9uIHRvSW50ZWdlcihuKXtyZXR1cm4gbj0rbixuIT09bj9uPTA6MCE9PW4mJm4hPT0xLzAmJm4hPT0tKDEvMCkmJihuPShuPjB8fC0xKSpNYXRoLmZsb29yKE1hdGguYWJzKG4pKSksbn1GdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8KEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kPWZ1bmN0aW9uKHRoYXQpe3ZhciB0YXJnZXQ9dGhpcztpZihcXFwiZnVuY3Rpb25cXFwiIT10eXBlb2YgdGFyZ2V0KXRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgXFxcIit0YXJnZXQpO3ZhciBhcmdzPXNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGJvdW5kPWZ1bmN0aW9uKCl7aWYodGhpcyBpbnN0YW5jZW9mIGJvdW5kKXt2YXIgcmVzdWx0PXRhcmdldC5hcHBseSh0aGlzLGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO3JldHVybiBPYmplY3QocmVzdWx0KT09PXJlc3VsdD9yZXN1bHQ6dGhpc31yZXR1cm4gdGFyZ2V0LmFwcGx5KHRoYXQsYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSl9O3JldHVybiB0YXJnZXQucHJvdG90eXBlJiYoRW1wdHkucHJvdG90eXBlPXRhcmdldC5wcm90b3R5cGUsYm91bmQucHJvdG90eXBlPW5ldyBFbXB0eSxFbXB0eS5wcm90b3R5cGU9bnVsbCksYm91bmR9KTt2YXIgZGVmaW5lR2V0dGVyLGRlZmluZVNldHRlcixsb29rdXBHZXR0ZXIsbG9va3VwU2V0dGVyLHN1cHBvcnRzQWNjZXNzb3JzLGNhbGw9RnVuY3Rpb24ucHJvdG90eXBlLmNhbGwscHJvdG90eXBlT2ZBcnJheT1BcnJheS5wcm90b3R5cGUscHJvdG90eXBlT2ZPYmplY3Q9T2JqZWN0LnByb3RvdHlwZSxzbGljZT1wcm90b3R5cGVPZkFycmF5LnNsaWNlLF90b1N0cmluZz1jYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QudG9TdHJpbmcpLG93bnM9Y2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Lmhhc093blByb3BlcnR5KTtpZigoc3VwcG9ydHNBY2Nlc3NvcnM9b3ducyhwcm90b3R5cGVPZk9iamVjdCxcXFwiX19kZWZpbmVHZXR0ZXJfX1xcXCIpKSYmKGRlZmluZUdldHRlcj1jYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19kZWZpbmVHZXR0ZXJfXyksZGVmaW5lU2V0dGVyPWNhbGwuYmluZChwcm90b3R5cGVPZk9iamVjdC5fX2RlZmluZVNldHRlcl9fKSxsb29rdXBHZXR0ZXI9Y2FsbC5iaW5kKHByb3RvdHlwZU9mT2JqZWN0Ll9fbG9va3VwR2V0dGVyX18pLGxvb2t1cFNldHRlcj1jYWxsLmJpbmQocHJvdG90eXBlT2ZPYmplY3QuX19sb29rdXBTZXR0ZXJfXykpLDIhPVsxLDJdLnNwbGljZSgwKS5sZW5ndGgpaWYoZnVuY3Rpb24oKXtmdW5jdGlvbiBtYWtlQXJyYXkobCl7dmFyIGE9QXJyYXkobCsyKTtyZXR1cm4gYVswXT1hWzFdPTAsYX12YXIgbGVuZ3RoQmVmb3JlLGFycmF5PVtdO3JldHVybiBhcnJheS5zcGxpY2UuYXBwbHkoYXJyYXksbWFrZUFycmF5KDIwKSksYXJyYXkuc3BsaWNlLmFwcGx5KGFycmF5LG1ha2VBcnJheSgyNikpLGxlbmd0aEJlZm9yZT1hcnJheS5sZW5ndGgsYXJyYXkuc3BsaWNlKDUsMCxcXFwiWFhYXFxcIiksbGVuZ3RoQmVmb3JlKzE9PWFycmF5Lmxlbmd0aCxsZW5ndGhCZWZvcmUrMT09YXJyYXkubGVuZ3RoPyEwOnZvaWQgMH0oKSl7dmFyIGFycmF5X3NwbGljZT1BcnJheS5wcm90b3R5cGUuc3BsaWNlO0FycmF5LnByb3RvdHlwZS5zcGxpY2U9ZnVuY3Rpb24oc3RhcnQsZGVsZXRlQ291bnQpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoP2FycmF5X3NwbGljZS5hcHBseSh0aGlzLFt2b2lkIDA9PT1zdGFydD8wOnN0YXJ0LHZvaWQgMD09PWRlbGV0ZUNvdW50P3RoaXMubGVuZ3RoLXN0YXJ0OmRlbGV0ZUNvdW50XS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsMikpKTpbXX19ZWxzZSBBcnJheS5wcm90b3R5cGUuc3BsaWNlPWZ1bmN0aW9uKHBvcyxyZW1vdmVDb3VudCl7dmFyIGxlbmd0aD10aGlzLmxlbmd0aDtwb3M+MD9wb3M+bGVuZ3RoJiYocG9zPWxlbmd0aCk6dm9pZCAwPT1wb3M/cG9zPTA6MD5wb3MmJihwb3M9TWF0aC5tYXgobGVuZ3RoK3BvcywwKSksbGVuZ3RoPnBvcytyZW1vdmVDb3VudHx8KHJlbW92ZUNvdW50PWxlbmd0aC1wb3MpO3ZhciByZW1vdmVkPXRoaXMuc2xpY2UocG9zLHBvcytyZW1vdmVDb3VudCksaW5zZXJ0PXNsaWNlLmNhbGwoYXJndW1lbnRzLDIpLGFkZD1pbnNlcnQubGVuZ3RoO2lmKHBvcz09PWxlbmd0aClhZGQmJnRoaXMucHVzaC5hcHBseSh0aGlzLGluc2VydCk7ZWxzZXt2YXIgcmVtb3ZlPU1hdGgubWluKHJlbW92ZUNvdW50LGxlbmd0aC1wb3MpLHRhaWxPbGRQb3M9cG9zK3JlbW92ZSx0YWlsTmV3UG9zPXRhaWxPbGRQb3MrYWRkLXJlbW92ZSx0YWlsQ291bnQ9bGVuZ3RoLXRhaWxPbGRQb3MsbGVuZ3RoQWZ0ZXJSZW1vdmU9bGVuZ3RoLXJlbW92ZTtpZih0YWlsT2xkUG9zPnRhaWxOZXdQb3MpZm9yKHZhciBpPTA7dGFpbENvdW50Pmk7KytpKXRoaXNbdGFpbE5ld1BvcytpXT10aGlzW3RhaWxPbGRQb3MraV07ZWxzZSBpZih0YWlsTmV3UG9zPnRhaWxPbGRQb3MpZm9yKGk9dGFpbENvdW50O2ktLTspdGhpc1t0YWlsTmV3UG9zK2ldPXRoaXNbdGFpbE9sZFBvcytpXTtpZihhZGQmJnBvcz09PWxlbmd0aEFmdGVyUmVtb3ZlKXRoaXMubGVuZ3RoPWxlbmd0aEFmdGVyUmVtb3ZlLHRoaXMucHVzaC5hcHBseSh0aGlzLGluc2VydCk7ZWxzZSBmb3IodGhpcy5sZW5ndGg9bGVuZ3RoQWZ0ZXJSZW1vdmUrYWRkLGk9MDthZGQ+aTsrK2kpdGhpc1twb3MraV09aW5zZXJ0W2ldfXJldHVybiByZW1vdmVkfTtBcnJheS5pc0FycmF5fHwoQXJyYXkuaXNBcnJheT1mdW5jdGlvbihvYmope3JldHVyblxcXCJbb2JqZWN0IEFycmF5XVxcXCI9PV90b1N0cmluZyhvYmopfSk7dmFyIGJveGVkU3RyaW5nPU9iamVjdChcXFwiYVxcXCIpLHNwbGl0U3RyaW5nPVxcXCJhXFxcIiE9Ym94ZWRTdHJpbmdbMF18fCEoMCBpbiBib3hlZFN0cmluZyk7aWYoQXJyYXkucHJvdG90eXBlLmZvckVhY2h8fChBcnJheS5wcm90b3R5cGUuZm9yRWFjaD1mdW5jdGlvbihmdW4pe3ZhciBvYmplY3Q9dG9PYmplY3QodGhpcyksc2VsZj1zcGxpdFN0cmluZyYmXFxcIltvYmplY3QgU3RyaW5nXVxcXCI9PV90b1N0cmluZyh0aGlzKT90aGlzLnNwbGl0KFxcXCJcXFwiKTpvYmplY3QsdGhpc3A9YXJndW1lbnRzWzFdLGk9LTEsbGVuZ3RoPXNlbGYubGVuZ3RoPj4+MDtpZihcXFwiW29iamVjdCBGdW5jdGlvbl1cXFwiIT1fdG9TdHJpbmcoZnVuKSl0aHJvdyBuZXcgVHlwZUVycm9yO2Zvcig7bGVuZ3RoPisraTspaSBpbiBzZWxmJiZmdW4uY2FsbCh0aGlzcCxzZWxmW2ldLGksb2JqZWN0KX0pLEFycmF5LnByb3RvdHlwZS5tYXB8fChBcnJheS5wcm90b3R5cGUubWFwPWZ1bmN0aW9uKGZ1bil7dmFyIG9iamVjdD10b09iamVjdCh0aGlzKSxzZWxmPXNwbGl0U3RyaW5nJiZcXFwiW29iamVjdCBTdHJpbmddXFxcIj09X3RvU3RyaW5nKHRoaXMpP3RoaXMuc3BsaXQoXFxcIlxcXCIpOm9iamVjdCxsZW5ndGg9c2VsZi5sZW5ndGg+Pj4wLHJlc3VsdD1BcnJheShsZW5ndGgpLHRoaXNwPWFyZ3VtZW50c1sxXTtpZihcXFwiW29iamVjdCBGdW5jdGlvbl1cXFwiIT1fdG9TdHJpbmcoZnVuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGZ1bitcXFwiIGlzIG5vdCBhIGZ1bmN0aW9uXFxcIik7Zm9yKHZhciBpPTA7bGVuZ3RoPmk7aSsrKWkgaW4gc2VsZiYmKHJlc3VsdFtpXT1mdW4uY2FsbCh0aGlzcCxzZWxmW2ldLGksb2JqZWN0KSk7cmV0dXJuIHJlc3VsdH0pLEFycmF5LnByb3RvdHlwZS5maWx0ZXJ8fChBcnJheS5wcm90b3R5cGUuZmlsdGVyPWZ1bmN0aW9uKGZ1bil7dmFyIHZhbHVlLG9iamVjdD10b09iamVjdCh0aGlzKSxzZWxmPXNwbGl0U3RyaW5nJiZcXFwiW29iamVjdCBTdHJpbmddXFxcIj09X3RvU3RyaW5nKHRoaXMpP3RoaXMuc3BsaXQoXFxcIlxcXCIpOm9iamVjdCxsZW5ndGg9c2VsZi5sZW5ndGg+Pj4wLHJlc3VsdD1bXSx0aGlzcD1hcmd1bWVudHNbMV07aWYoXFxcIltvYmplY3QgRnVuY3Rpb25dXFxcIiE9X3RvU3RyaW5nKGZ1bikpdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4rXFxcIiBpcyBub3QgYSBmdW5jdGlvblxcXCIpO2Zvcih2YXIgaT0wO2xlbmd0aD5pO2krKylpIGluIHNlbGYmJih2YWx1ZT1zZWxmW2ldLGZ1bi5jYWxsKHRoaXNwLHZhbHVlLGksb2JqZWN0KSYmcmVzdWx0LnB1c2godmFsdWUpKTtyZXR1cm4gcmVzdWx0fSksQXJyYXkucHJvdG90eXBlLmV2ZXJ5fHwoQXJyYXkucHJvdG90eXBlLmV2ZXJ5PWZ1bmN0aW9uKGZ1bil7dmFyIG9iamVjdD10b09iamVjdCh0aGlzKSxzZWxmPXNwbGl0U3RyaW5nJiZcXFwiW29iamVjdCBTdHJpbmddXFxcIj09X3RvU3RyaW5nKHRoaXMpP3RoaXMuc3BsaXQoXFxcIlxcXCIpOm9iamVjdCxsZW5ndGg9c2VsZi5sZW5ndGg+Pj4wLHRoaXNwPWFyZ3VtZW50c1sxXTtpZihcXFwiW29iamVjdCBGdW5jdGlvbl1cXFwiIT1fdG9TdHJpbmcoZnVuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGZ1bitcXFwiIGlzIG5vdCBhIGZ1bmN0aW9uXFxcIik7Zm9yKHZhciBpPTA7bGVuZ3RoPmk7aSsrKWlmKGkgaW4gc2VsZiYmIWZ1bi5jYWxsKHRoaXNwLHNlbGZbaV0saSxvYmplY3QpKXJldHVybiExO3JldHVybiEwfSksQXJyYXkucHJvdG90eXBlLnNvbWV8fChBcnJheS5wcm90b3R5cGUuc29tZT1mdW5jdGlvbihmdW4pe3ZhciBvYmplY3Q9dG9PYmplY3QodGhpcyksc2VsZj1zcGxpdFN0cmluZyYmXFxcIltvYmplY3QgU3RyaW5nXVxcXCI9PV90b1N0cmluZyh0aGlzKT90aGlzLnNwbGl0KFxcXCJcXFwiKTpvYmplY3QsbGVuZ3RoPXNlbGYubGVuZ3RoPj4+MCx0aGlzcD1hcmd1bWVudHNbMV07aWYoXFxcIltvYmplY3QgRnVuY3Rpb25dXFxcIiE9X3RvU3RyaW5nKGZ1bikpdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4rXFxcIiBpcyBub3QgYSBmdW5jdGlvblxcXCIpO2Zvcih2YXIgaT0wO2xlbmd0aD5pO2krKylpZihpIGluIHNlbGYmJmZ1bi5jYWxsKHRoaXNwLHNlbGZbaV0saSxvYmplY3QpKXJldHVybiEwO3JldHVybiExfSksQXJyYXkucHJvdG90eXBlLnJlZHVjZXx8KEFycmF5LnByb3RvdHlwZS5yZWR1Y2U9ZnVuY3Rpb24oZnVuKXt2YXIgb2JqZWN0PXRvT2JqZWN0KHRoaXMpLHNlbGY9c3BsaXRTdHJpbmcmJlxcXCJbb2JqZWN0IFN0cmluZ11cXFwiPT1fdG9TdHJpbmcodGhpcyk/dGhpcy5zcGxpdChcXFwiXFxcIik6b2JqZWN0LGxlbmd0aD1zZWxmLmxlbmd0aD4+PjA7aWYoXFxcIltvYmplY3QgRnVuY3Rpb25dXFxcIiE9X3RvU3RyaW5nKGZ1bikpdGhyb3cgbmV3IFR5cGVFcnJvcihmdW4rXFxcIiBpcyBub3QgYSBmdW5jdGlvblxcXCIpO2lmKCFsZW5ndGgmJjE9PWFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwicmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZVxcXCIpO3ZhciByZXN1bHQsaT0wO2lmKGFyZ3VtZW50cy5sZW5ndGg+PTIpcmVzdWx0PWFyZ3VtZW50c1sxXTtlbHNlIGZvcig7Oyl7aWYoaSBpbiBzZWxmKXtyZXN1bHQ9c2VsZltpKytdO2JyZWFrfWlmKCsraT49bGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcInJlZHVjZSBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWVcXFwiKX1mb3IoO2xlbmd0aD5pO2krKylpIGluIHNlbGYmJihyZXN1bHQ9ZnVuLmNhbGwodm9pZCAwLHJlc3VsdCxzZWxmW2ldLGksb2JqZWN0KSk7cmV0dXJuIHJlc3VsdH0pLEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodHx8KEFycmF5LnByb3RvdHlwZS5yZWR1Y2VSaWdodD1mdW5jdGlvbihmdW4pe3ZhciBvYmplY3Q9dG9PYmplY3QodGhpcyksc2VsZj1zcGxpdFN0cmluZyYmXFxcIltvYmplY3QgU3RyaW5nXVxcXCI9PV90b1N0cmluZyh0aGlzKT90aGlzLnNwbGl0KFxcXCJcXFwiKTpvYmplY3QsbGVuZ3RoPXNlbGYubGVuZ3RoPj4+MDtpZihcXFwiW29iamVjdCBGdW5jdGlvbl1cXFwiIT1fdG9TdHJpbmcoZnVuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGZ1bitcXFwiIGlzIG5vdCBhIGZ1bmN0aW9uXFxcIik7aWYoIWxlbmd0aCYmMT09YXJndW1lbnRzLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJyZWR1Y2VSaWdodCBvZiBlbXB0eSBhcnJheSB3aXRoIG5vIGluaXRpYWwgdmFsdWVcXFwiKTt2YXIgcmVzdWx0LGk9bGVuZ3RoLTE7aWYoYXJndW1lbnRzLmxlbmd0aD49MilyZXN1bHQ9YXJndW1lbnRzWzFdO2Vsc2UgZm9yKDs7KXtpZihpIGluIHNlbGYpe3Jlc3VsdD1zZWxmW2ktLV07YnJlYWt9aWYoMD4tLWkpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwicmVkdWNlUmlnaHQgb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlXFxcIil9ZG8gaSBpbiB0aGlzJiYocmVzdWx0PWZ1bi5jYWxsKHZvaWQgMCxyZXN1bHQsc2VsZltpXSxpLG9iamVjdCkpO3doaWxlKGktLSk7cmV0dXJuIHJlc3VsdH0pLEFycmF5LnByb3RvdHlwZS5pbmRleE9mJiYtMT09WzAsMV0uaW5kZXhPZigxLDIpfHwoQXJyYXkucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24oc291Z2h0KXt2YXIgc2VsZj1zcGxpdFN0cmluZyYmXFxcIltvYmplY3QgU3RyaW5nXVxcXCI9PV90b1N0cmluZyh0aGlzKT90aGlzLnNwbGl0KFxcXCJcXFwiKTp0b09iamVjdCh0aGlzKSxsZW5ndGg9c2VsZi5sZW5ndGg+Pj4wO2lmKCFsZW5ndGgpcmV0dXJuLTE7dmFyIGk9MDtmb3IoYXJndW1lbnRzLmxlbmd0aD4xJiYoaT10b0ludGVnZXIoYXJndW1lbnRzWzFdKSksaT1pPj0wP2k6TWF0aC5tYXgoMCxsZW5ndGgraSk7bGVuZ3RoPmk7aSsrKWlmKGkgaW4gc2VsZiYmc2VsZltpXT09PXNvdWdodClyZXR1cm4gaTtyZXR1cm4tMX0pLEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZiYmLTE9PVswLDFdLmxhc3RJbmRleE9mKDAsLTMpfHwoQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mPWZ1bmN0aW9uKHNvdWdodCl7dmFyIHNlbGY9c3BsaXRTdHJpbmcmJlxcXCJbb2JqZWN0IFN0cmluZ11cXFwiPT1fdG9TdHJpbmcodGhpcyk/dGhpcy5zcGxpdChcXFwiXFxcIik6dG9PYmplY3QodGhpcyksbGVuZ3RoPXNlbGYubGVuZ3RoPj4+MDtpZighbGVuZ3RoKXJldHVybi0xO3ZhciBpPWxlbmd0aC0xO2Zvcihhcmd1bWVudHMubGVuZ3RoPjEmJihpPU1hdGgubWluKGksdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSkpKSxpPWk+PTA/aTpsZW5ndGgtTWF0aC5hYnMoaSk7aT49MDtpLS0paWYoaSBpbiBzZWxmJiZzb3VnaHQ9PT1zZWxmW2ldKXJldHVybiBpO3JldHVybi0xfSksT2JqZWN0LmdldFByb3RvdHlwZU9mfHwoT2JqZWN0LmdldFByb3RvdHlwZU9mPWZ1bmN0aW9uKG9iamVjdCl7cmV0dXJuIG9iamVjdC5fX3Byb3RvX198fChvYmplY3QuY29uc3RydWN0b3I/b2JqZWN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTpwcm90b3R5cGVPZk9iamVjdCl9KSwhT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcil7dmFyIEVSUl9OT05fT0JKRUNUPVxcXCJPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIGNhbGxlZCBvbiBhIG5vbi1vYmplY3Q6IFxcXCI7T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcj1mdW5jdGlvbihvYmplY3QscHJvcGVydHkpe2lmKFxcXCJvYmplY3RcXFwiIT10eXBlb2Ygb2JqZWN0JiZcXFwiZnVuY3Rpb25cXFwiIT10eXBlb2Ygb2JqZWN0fHxudWxsPT09b2JqZWN0KXRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1Qrb2JqZWN0KTtpZihvd25zKG9iamVjdCxwcm9wZXJ0eSkpe3ZhciBkZXNjcmlwdG9yLGdldHRlcixzZXR0ZXI7aWYoZGVzY3JpcHRvcj17ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9LHN1cHBvcnRzQWNjZXNzb3JzKXt2YXIgcHJvdG90eXBlPW9iamVjdC5fX3Byb3RvX187b2JqZWN0Ll9fcHJvdG9fXz1wcm90b3R5cGVPZk9iamVjdDt2YXIgZ2V0dGVyPWxvb2t1cEdldHRlcihvYmplY3QscHJvcGVydHkpLHNldHRlcj1sb29rdXBTZXR0ZXIob2JqZWN0LHByb3BlcnR5KTtpZihvYmplY3QuX19wcm90b19fPXByb3RvdHlwZSxnZXR0ZXJ8fHNldHRlcilyZXR1cm4gZ2V0dGVyJiYoZGVzY3JpcHRvci5nZXQ9Z2V0dGVyKSxzZXR0ZXImJihkZXNjcmlwdG9yLnNldD1zZXR0ZXIpLGRlc2NyaXB0b3J9cmV0dXJuIGRlc2NyaXB0b3IudmFsdWU9b2JqZWN0W3Byb3BlcnR5XSxkZXNjcmlwdG9yfX19aWYoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz1mdW5jdGlvbihvYmplY3Qpe3JldHVybiBPYmplY3Qua2V5cyhvYmplY3QpfSksIU9iamVjdC5jcmVhdGUpe3ZhciBjcmVhdGVFbXB0eTtjcmVhdGVFbXB0eT1udWxsPT09T2JqZWN0LnByb3RvdHlwZS5fX3Byb3RvX18/ZnVuY3Rpb24oKXtyZXR1cm57X19wcm90b19fOm51bGx9fTpmdW5jdGlvbigpe3ZhciBlbXB0eT17fTtmb3IodmFyIGkgaW4gZW1wdHkpZW1wdHlbaV09bnVsbDtyZXR1cm4gZW1wdHkuY29uc3RydWN0b3I9ZW1wdHkuaGFzT3duUHJvcGVydHk9ZW1wdHkucHJvcGVydHlJc0VudW1lcmFibGU9ZW1wdHkuaXNQcm90b3R5cGVPZj1lbXB0eS50b0xvY2FsZVN0cmluZz1lbXB0eS50b1N0cmluZz1lbXB0eS52YWx1ZU9mPWVtcHR5Ll9fcHJvdG9fXz1udWxsLGVtcHR5fSxPYmplY3QuY3JlYXRlPWZ1bmN0aW9uKHByb3RvdHlwZSxwcm9wZXJ0aWVzKXt2YXIgb2JqZWN0O2lmKG51bGw9PT1wcm90b3R5cGUpb2JqZWN0PWNyZWF0ZUVtcHR5KCk7ZWxzZXtpZihcXFwib2JqZWN0XFxcIiE9dHlwZW9mIHByb3RvdHlwZSl0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJ0eXBlb2YgcHJvdG90eXBlW1xcXCIrdHlwZW9mIHByb3RvdHlwZStcXFwiXSAhPSAnb2JqZWN0J1xcXCIpO3ZhciBUeXBlPWZ1bmN0aW9uKCl7fTtUeXBlLnByb3RvdHlwZT1wcm90b3R5cGUsb2JqZWN0PW5ldyBUeXBlLG9iamVjdC5fX3Byb3RvX189cHJvdG90eXBlfXJldHVybiB2b2lkIDAhPT1wcm9wZXJ0aWVzJiZPYmplY3QuZGVmaW5lUHJvcGVydGllcyhvYmplY3QscHJvcGVydGllcyksb2JqZWN0fX1pZihPYmplY3QuZGVmaW5lUHJvcGVydHkpe3ZhciBkZWZpbmVQcm9wZXJ0eVdvcmtzT25PYmplY3Q9ZG9lc0RlZmluZVByb3BlcnR5V29yayh7fSksZGVmaW5lUHJvcGVydHlXb3Jrc09uRG9tPVxcXCJ1bmRlZmluZWRcXFwiPT10eXBlb2YgZG9jdW1lbnR8fGRvZXNEZWZpbmVQcm9wZXJ0eVdvcmsoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikpO2lmKCFkZWZpbmVQcm9wZXJ0eVdvcmtzT25PYmplY3R8fCFkZWZpbmVQcm9wZXJ0eVdvcmtzT25Eb20pdmFyIGRlZmluZVByb3BlcnR5RmFsbGJhY2s9T2JqZWN0LmRlZmluZVByb3BlcnR5fWlmKCFPYmplY3QuZGVmaW5lUHJvcGVydHl8fGRlZmluZVByb3BlcnR5RmFsbGJhY2spe3ZhciBFUlJfTk9OX09CSkVDVF9ERVNDUklQVE9SPVxcXCJQcm9wZXJ0eSBkZXNjcmlwdGlvbiBtdXN0IGJlIGFuIG9iamVjdDogXFxcIixFUlJfTk9OX09CSkVDVF9UQVJHRVQ9XFxcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSBjYWxsZWQgb24gbm9uLW9iamVjdDogXFxcIixFUlJfQUNDRVNTT1JTX05PVF9TVVBQT1JURUQ9XFxcImdldHRlcnMgJiBzZXR0ZXJzIGNhbiBub3QgYmUgZGVmaW5lZCBvbiB0aGlzIGphdmFzY3JpcHQgZW5naW5lXFxcIjtPYmplY3QuZGVmaW5lUHJvcGVydHk9ZnVuY3Rpb24ob2JqZWN0LHByb3BlcnR5LGRlc2NyaXB0b3Ipe2lmKFxcXCJvYmplY3RcXFwiIT10eXBlb2Ygb2JqZWN0JiZcXFwiZnVuY3Rpb25cXFwiIT10eXBlb2Ygb2JqZWN0fHxudWxsPT09b2JqZWN0KXRocm93IG5ldyBUeXBlRXJyb3IoRVJSX05PTl9PQkpFQ1RfVEFSR0VUK29iamVjdCk7aWYoXFxcIm9iamVjdFxcXCIhPXR5cGVvZiBkZXNjcmlwdG9yJiZcXFwiZnVuY3Rpb25cXFwiIT10eXBlb2YgZGVzY3JpcHRvcnx8bnVsbD09PWRlc2NyaXB0b3IpdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfTk9OX09CSkVDVF9ERVNDUklQVE9SK2Rlc2NyaXB0b3IpO2lmKGRlZmluZVByb3BlcnR5RmFsbGJhY2spdHJ5e3JldHVybiBkZWZpbmVQcm9wZXJ0eUZhbGxiYWNrLmNhbGwoT2JqZWN0LG9iamVjdCxwcm9wZXJ0eSxkZXNjcmlwdG9yKX1jYXRjaChleGNlcHRpb24pe31pZihvd25zKGRlc2NyaXB0b3IsXFxcInZhbHVlXFxcIikpaWYoc3VwcG9ydHNBY2Nlc3NvcnMmJihsb29rdXBHZXR0ZXIob2JqZWN0LHByb3BlcnR5KXx8bG9va3VwU2V0dGVyKG9iamVjdCxwcm9wZXJ0eSkpKXt2YXIgcHJvdG90eXBlPW9iamVjdC5fX3Byb3RvX187b2JqZWN0Ll9fcHJvdG9fXz1wcm90b3R5cGVPZk9iamVjdCxkZWxldGUgb2JqZWN0W3Byb3BlcnR5XSxvYmplY3RbcHJvcGVydHldPWRlc2NyaXB0b3IudmFsdWUsb2JqZWN0Ll9fcHJvdG9fXz1wcm90b3R5cGV9ZWxzZSBvYmplY3RbcHJvcGVydHldPWRlc2NyaXB0b3IudmFsdWU7ZWxzZXtpZighc3VwcG9ydHNBY2Nlc3NvcnMpdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJfQUNDRVNTT1JTX05PVF9TVVBQT1JURUQpO293bnMoZGVzY3JpcHRvcixcXFwiZ2V0XFxcIikmJmRlZmluZUdldHRlcihvYmplY3QscHJvcGVydHksZGVzY3JpcHRvci5nZXQpLG93bnMoZGVzY3JpcHRvcixcXFwic2V0XFxcIikmJmRlZmluZVNldHRlcihvYmplY3QscHJvcGVydHksZGVzY3JpcHRvci5zZXQpfXJldHVybiBvYmplY3R9fU9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzfHwoT2JqZWN0LmRlZmluZVByb3BlcnRpZXM9ZnVuY3Rpb24ob2JqZWN0LHByb3BlcnRpZXMpe2Zvcih2YXIgcHJvcGVydHkgaW4gcHJvcGVydGllcylvd25zKHByb3BlcnRpZXMscHJvcGVydHkpJiZPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LHByb3BlcnR5LHByb3BlcnRpZXNbcHJvcGVydHldKTtyZXR1cm4gb2JqZWN0fSksT2JqZWN0LnNlYWx8fChPYmplY3Quc2VhbD1mdW5jdGlvbihvYmplY3Qpe3JldHVybiBvYmplY3R9KSxPYmplY3QuZnJlZXplfHwoT2JqZWN0LmZyZWV6ZT1mdW5jdGlvbihvYmplY3Qpe3JldHVybiBvYmplY3R9KTt0cnl7T2JqZWN0LmZyZWV6ZShmdW5jdGlvbigpe30pfWNhdGNoKGV4Y2VwdGlvbil7T2JqZWN0LmZyZWV6ZT1mdW5jdGlvbihmcmVlemVPYmplY3Qpe3JldHVybiBmdW5jdGlvbihvYmplY3Qpe3JldHVyblxcXCJmdW5jdGlvblxcXCI9PXR5cGVvZiBvYmplY3Q/b2JqZWN0OmZyZWV6ZU9iamVjdChvYmplY3QpfX0oT2JqZWN0LmZyZWV6ZSl9aWYoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zfHwoT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zPWZ1bmN0aW9uKG9iamVjdCl7cmV0dXJuIG9iamVjdH0pLE9iamVjdC5pc1NlYWxlZHx8KE9iamVjdC5pc1NlYWxlZD1mdW5jdGlvbigpe3JldHVybiExfSksT2JqZWN0LmlzRnJvemVufHwoT2JqZWN0LmlzRnJvemVuPWZ1bmN0aW9uKCl7cmV0dXJuITF9KSxPYmplY3QuaXNFeHRlbnNpYmxlfHwoT2JqZWN0LmlzRXh0ZW5zaWJsZT1mdW5jdGlvbihvYmplY3Qpe2lmKE9iamVjdChvYmplY3QpPT09b2JqZWN0KXRocm93IG5ldyBUeXBlRXJyb3I7Zm9yKHZhciBuYW1lPVxcXCJcXFwiO293bnMob2JqZWN0LG5hbWUpOyluYW1lKz1cXFwiP1xcXCI7b2JqZWN0W25hbWVdPSEwO3ZhciByZXR1cm5WYWx1ZT1vd25zKG9iamVjdCxuYW1lKTtyZXR1cm4gZGVsZXRlIG9iamVjdFtuYW1lXSxyZXR1cm5WYWx1ZX0pLCFPYmplY3Qua2V5cyl7dmFyIGhhc0RvbnRFbnVtQnVnPSEwLGRvbnRFbnVtcz1bXFxcInRvU3RyaW5nXFxcIixcXFwidG9Mb2NhbGVTdHJpbmdcXFwiLFxcXCJ2YWx1ZU9mXFxcIixcXFwiaGFzT3duUHJvcGVydHlcXFwiLFxcXCJpc1Byb3RvdHlwZU9mXFxcIixcXFwicHJvcGVydHlJc0VudW1lcmFibGVcXFwiLFxcXCJjb25zdHJ1Y3RvclxcXCJdLGRvbnRFbnVtc0xlbmd0aD1kb250RW51bXMubGVuZ3RoO2Zvcih2YXIga2V5IGlue3RvU3RyaW5nOm51bGx9KWhhc0RvbnRFbnVtQnVnPSExO09iamVjdC5rZXlzPWZ1bmN0aW9uKG9iamVjdCl7aWYoXFxcIm9iamVjdFxcXCIhPXR5cGVvZiBvYmplY3QmJlxcXCJmdW5jdGlvblxcXCIhPXR5cGVvZiBvYmplY3R8fG51bGw9PT1vYmplY3QpdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiT2JqZWN0LmtleXMgY2FsbGVkIG9uIGEgbm9uLW9iamVjdFxcXCIpO3ZhciBrZXlzPVtdO2Zvcih2YXIgbmFtZSBpbiBvYmplY3Qpb3ducyhvYmplY3QsbmFtZSkmJmtleXMucHVzaChuYW1lKTtpZihoYXNEb250RW51bUJ1Zylmb3IodmFyIGk9MCxpaT1kb250RW51bXNMZW5ndGg7aWk+aTtpKyspe3ZhciBkb250RW51bT1kb250RW51bXNbaV07b3ducyhvYmplY3QsZG9udEVudW0pJiZrZXlzLnB1c2goZG9udEVudW0pfXJldHVybiBrZXlzfX1EYXRlLm5vd3x8KERhdGUubm93PWZ1bmN0aW9uKCl7cmV0dXJuKG5ldyBEYXRlKS5nZXRUaW1lKCl9KTt2YXIgd3M9XFxcIlxcdFxcXFxuXFx1MDAwYlxcXFxmXFxcXHIgwqDhmoDhoI7igIDigIHigILigIPigITigIXigIbigIfigIjigInigIrigK/igZ/jgIBcXFxcdTIwMjhcXFxcdTIwMjnvu79cXFwiO2lmKCFTdHJpbmcucHJvdG90eXBlLnRyaW18fHdzLnRyaW0oKSl7d3M9XFxcIltcXFwiK3dzK1xcXCJdXFxcIjt2YXIgdHJpbUJlZ2luUmVnZXhwPVJlZ0V4cChcXFwiXlxcXCIrd3Mrd3MrXFxcIipcXFwiKSx0cmltRW5kUmVnZXhwPVJlZ0V4cCh3cyt3cytcXFwiKiRcXFwiKTtTdHJpbmcucHJvdG90eXBlLnRyaW09ZnVuY3Rpb24oKXtyZXR1cm4odGhpcytcXFwiXFxcIikucmVwbGFjZSh0cmltQmVnaW5SZWdleHAsXFxcIlxcXCIpLnJlcGxhY2UodHJpbUVuZFJlZ2V4cCxcXFwiXFxcIil9fXZhciB0b09iamVjdD1mdW5jdGlvbihvKXtpZihudWxsPT1vKXRocm93IG5ldyBUeXBlRXJyb3IoXFxcImNhbid0IGNvbnZlcnQgXFxcIitvK1xcXCIgdG8gb2JqZWN0XFxcIik7cmV0dXJuIE9iamVjdChvKX19KTtcIjsiLCIvLyBCcm93c2VyIFJlcXVlc3Rcbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8vIFVNRCBIRUFERVIgU1RBUlQgXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb21lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgICByb290LnJldHVybkV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH1cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuLy8gVU1EIEhFQURFUiBFTkRcblxudmFyIFhIUiA9IFhNTEh0dHBSZXF1ZXN0XG5pZiAoIVhIUikgdGhyb3cgbmV3IEVycm9yKCdtaXNzaW5nIFhNTEh0dHBSZXF1ZXN0JylcbnJlcXVlc3QubG9nID0ge1xuICAndHJhY2UnOiBub29wLCAnZGVidWcnOiBub29wLCAnaW5mbyc6IG5vb3AsICd3YXJuJzogbm9vcCwgJ2Vycm9yJzogbm9vcFxufVxuXG52YXIgREVGQVVMVF9USU1FT1VUID0gMyAqIDYwICogMTAwMCAvLyAzIG1pbnV0ZXNcblxuLy9cbi8vIHJlcXVlc3Rcbi8vXG5cbmZ1bmN0aW9uIHJlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgLy8gVGhlIGVudHJ5LXBvaW50IHRvIHRoZSBBUEk6IHByZXAgdGhlIG9wdGlvbnMgb2JqZWN0IGFuZCBwYXNzIHRoZSByZWFsIHdvcmsgdG8gcnVuX3hoci5cbiAgaWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcignQmFkIGNhbGxiYWNrIGdpdmVuOiAnICsgY2FsbGJhY2spXG5cbiAgaWYoIW9wdGlvbnMpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBvcHRpb25zIGdpdmVuJylcblxuICB2YXIgb3B0aW9uc19vblJlc3BvbnNlID0gb3B0aW9ucy5vblJlc3BvbnNlOyAvLyBTYXZlIHRoaXMgZm9yIGxhdGVyLlxuXG4gIGlmKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJylcbiAgICBvcHRpb25zID0geyd1cmknOm9wdGlvbnN9O1xuICBlbHNlXG4gICAgb3B0aW9ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob3B0aW9ucykpOyAvLyBVc2UgYSBkdXBsaWNhdGUgZm9yIG11dGF0aW5nLlxuXG4gIG9wdGlvbnMub25SZXNwb25zZSA9IG9wdGlvbnNfb25SZXNwb25zZSAvLyBBbmQgcHV0IGl0IGJhY2suXG5cbiAgaWYgKG9wdGlvbnMudmVyYm9zZSkgcmVxdWVzdC5sb2cgPSBnZXRMb2dnZXIoKTtcblxuICBpZihvcHRpb25zLnVybCkge1xuICAgIG9wdGlvbnMudXJpID0gb3B0aW9ucy51cmw7XG4gICAgZGVsZXRlIG9wdGlvbnMudXJsO1xuICB9XG5cbiAgaWYoIW9wdGlvbnMudXJpICYmIG9wdGlvbnMudXJpICE9PSBcIlwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMudXJpIGlzIGEgcmVxdWlyZWQgYXJndW1lbnRcIik7XG5cbiAgaWYodHlwZW9mIG9wdGlvbnMudXJpICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy51cmkgbXVzdCBiZSBhIHN0cmluZ1wiKTtcblxuICB2YXIgdW5zdXBwb3J0ZWRfb3B0aW9ucyA9IFsncHJveHknLCAnX3JlZGlyZWN0c0ZvbGxvd2VkJywgJ21heFJlZGlyZWN0cycsICdmb2xsb3dSZWRpcmVjdCddXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdW5zdXBwb3J0ZWRfb3B0aW9ucy5sZW5ndGg7IGkrKylcbiAgICBpZihvcHRpb25zWyB1bnN1cHBvcnRlZF9vcHRpb25zW2ldIF0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLlwiICsgdW5zdXBwb3J0ZWRfb3B0aW9uc1tpXSArIFwiIGlzIG5vdCBzdXBwb3J0ZWRcIilcblxuICBvcHRpb25zLmNhbGxiYWNrID0gY2FsbGJhY2tcbiAgb3B0aW9ucy5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCAnR0VUJztcbiAgb3B0aW9ucy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICBvcHRpb25zLmJvZHkgICAgPSBvcHRpb25zLmJvZHkgfHwgbnVsbFxuICBvcHRpb25zLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgcmVxdWVzdC5ERUZBVUxUX1RJTUVPVVRcblxuICBpZihvcHRpb25zLmhlYWRlcnMuaG9zdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb25zLmhlYWRlcnMuaG9zdCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuXG4gIGlmKG9wdGlvbnMuanNvbikge1xuICAgIG9wdGlvbnMuaGVhZGVycy5hY2NlcHQgPSBvcHRpb25zLmhlYWRlcnMuYWNjZXB0IHx8ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgIGlmKG9wdGlvbnMubWV0aG9kICE9PSAnR0VUJylcbiAgICAgIG9wdGlvbnMuaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24vanNvbidcblxuICAgIGlmKHR5cGVvZiBvcHRpb25zLmpzb24gIT09ICdib29sZWFuJylcbiAgICAgIG9wdGlvbnMuYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuanNvbilcbiAgICBlbHNlIGlmKHR5cGVvZiBvcHRpb25zLmJvZHkgIT09ICdzdHJpbmcnKVxuICAgICAgb3B0aW9ucy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib2R5KVxuICB9XG4gIFxuICAvL0JFR0lOIFFTIEhhY2tcbiAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBzdHIgPSBbXTtcbiAgICBmb3IodmFyIHAgaW4gb2JqKVxuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICBzdHIucHVzaChlbmNvZGVVUklDb21wb25lbnQocCkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbcF0pKTtcbiAgICAgIH1cbiAgICByZXR1cm4gc3RyLmpvaW4oXCImXCIpO1xuICB9XG4gIFxuICBpZihvcHRpb25zLnFzKXtcbiAgICB2YXIgcXMgPSAodHlwZW9mIG9wdGlvbnMucXMgPT0gJ3N0cmluZycpPyBvcHRpb25zLnFzIDogc2VyaWFsaXplKG9wdGlvbnMucXMpO1xuICAgIGlmKG9wdGlvbnMudXJpLmluZGV4T2YoJz8nKSAhPT0gLTEpeyAvL25vIGdldCBwYXJhbXNcbiAgICAgICAgb3B0aW9ucy51cmkgPSBvcHRpb25zLnVyaSsnJicrcXM7XG4gICAgfWVsc2V7IC8vZXhpc3RpbmcgZ2V0IHBhcmFtc1xuICAgICAgICBvcHRpb25zLnVyaSA9IG9wdGlvbnMudXJpKyc/JytxcztcbiAgICB9XG4gIH1cbiAgLy9FTkQgUVMgSGFja1xuICBcbiAgLy9CRUdJTiBGT1JNIEhhY2tcbiAgdmFyIG11bHRpcGFydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIC8vdG9kbzogc3VwcG9ydCBmaWxlIHR5cGUgKHVzZWZ1bD8pXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHJlc3VsdC5ib3VuZHJ5ID0gJy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0nK01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxMDAwMDAwMDAwKTtcbiAgICB2YXIgbGluZXMgPSBbXTtcbiAgICBmb3IodmFyIHAgaW4gb2JqKXtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgICAgbGluZXMucHVzaChcbiAgICAgICAgICAgICAgICAnLS0nK3Jlc3VsdC5ib3VuZHJ5K1wiXFxuXCIrXG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtRGlzcG9zaXRpb246IGZvcm0tZGF0YTsgbmFtZT1cIicrcCsnXCInK1wiXFxuXCIrXG4gICAgICAgICAgICAgICAgXCJcXG5cIitcbiAgICAgICAgICAgICAgICBvYmpbcF0rXCJcXG5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsaW5lcy5wdXNoKCAnLS0nK3Jlc3VsdC5ib3VuZHJ5KyctLScgKTtcbiAgICByZXN1bHQuYm9keSA9IGxpbmVzLmpvaW4oJycpO1xuICAgIHJlc3VsdC5sZW5ndGggPSByZXN1bHQuYm9keS5sZW5ndGg7XG4gICAgcmVzdWx0LnR5cGUgPSAnbXVsdGlwYXJ0L2Zvcm0tZGF0YTsgYm91bmRhcnk9JytyZXN1bHQuYm91bmRyeTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIFxuICBpZihvcHRpb25zLmZvcm0pe1xuICAgIGlmKHR5cGVvZiBvcHRpb25zLmZvcm0gPT0gJ3N0cmluZycpIHRocm93KCdmb3JtIG5hbWUgdW5zdXBwb3J0ZWQnKTtcbiAgICBpZihvcHRpb25zLm1ldGhvZCA9PT0gJ1BPU1QnKXtcbiAgICAgICAgdmFyIGVuY29kaW5nID0gKG9wdGlvbnMuZW5jb2RpbmcgfHwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIG9wdGlvbnMuaGVhZGVyc1snY29udGVudC10eXBlJ10gPSBlbmNvZGluZztcbiAgICAgICAgc3dpdGNoKGVuY29kaW5nKXtcbiAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc6XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5ib2R5ID0gc2VyaWFsaXplKG9wdGlvbnMuZm9ybSkucmVwbGFjZSgvJTIwL2csIFwiK1wiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ211bHRpcGFydC9mb3JtLWRhdGEnOlxuICAgICAgICAgICAgICAgIHZhciBtdWx0aSA9IG11bHRpcGFydChvcHRpb25zLmZvcm0pO1xuICAgICAgICAgICAgICAgIC8vb3B0aW9ucy5oZWFkZXJzWydjb250ZW50LWxlbmd0aCddID0gbXVsdGkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYm9keSA9IG11bHRpLmJvZHk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IG11bHRpLnR5cGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0IDogdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBlbmNvZGluZzonK2VuY29kaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuICAvL0VORCBGT1JNIEhhY2tcblxuICAvLyBJZiBvblJlc3BvbnNlIGlzIGJvb2xlYW4gdHJ1ZSwgY2FsbCBiYWNrIGltbWVkaWF0ZWx5IHdoZW4gdGhlIHJlc3BvbnNlIGlzIGtub3duLFxuICAvLyBub3Qgd2hlbiB0aGUgZnVsbCByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICBvcHRpb25zLm9uUmVzcG9uc2UgPSBvcHRpb25zLm9uUmVzcG9uc2UgfHwgbm9vcFxuICBpZihvcHRpb25zLm9uUmVzcG9uc2UgPT09IHRydWUpIHtcbiAgICBvcHRpb25zLm9uUmVzcG9uc2UgPSBjYWxsYmFja1xuICAgIG9wdGlvbnMuY2FsbGJhY2sgPSBub29wXG4gIH1cblxuICAvLyBYWFggQnJvd3NlcnMgZG8gbm90IGxpa2UgdGhpcy5cbiAgLy9pZihvcHRpb25zLmJvZHkpXG4gIC8vICBvcHRpb25zLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gPSBvcHRpb25zLmJvZHkubGVuZ3RoO1xuXG4gIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgaWYoIW9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uICYmIG9wdGlvbnMuYXV0aClcbiAgICBvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYjY0X2VuYyhvcHRpb25zLmF1dGgudXNlcm5hbWUgKyAnOicgKyBvcHRpb25zLmF1dGgucGFzc3dvcmQpO1xuXG4gIHJldHVybiBydW5feGhyKG9wdGlvbnMpXG59XG5cbnZhciByZXFfc2VxID0gMFxuZnVuY3Rpb24gcnVuX3hocihvcHRpb25zKSB7XG4gIHZhciB4aHIgPSBuZXcgWEhSXG4gICAgLCB0aW1lZF9vdXQgPSBmYWxzZVxuICAgICwgaXNfY29ycyA9IGlzX2Nyb3NzRG9tYWluKG9wdGlvbnMudXJpKVxuICAgICwgc3VwcG9ydHNfY29ycyA9ICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpXG5cbiAgcmVxX3NlcSArPSAxXG4gIHhoci5zZXFfaWQgPSByZXFfc2VxXG4gIHhoci5pZCA9IHJlcV9zZXEgKyAnOiAnICsgb3B0aW9ucy5tZXRob2QgKyAnICcgKyBvcHRpb25zLnVyaVxuICB4aHIuX2lkID0geGhyLmlkIC8vIEkga25vdyBJIHdpbGwgdHlwZSBcIl9pZFwiIGZyb20gaGFiaXQgYWxsIHRoZSB0aW1lLlxuXG4gIGlmKGlzX2NvcnMgJiYgIXN1cHBvcnRzX2NvcnMpIHtcbiAgICB2YXIgY29yc19lcnIgPSBuZXcgRXJyb3IoJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBjcm9zcy1vcmlnaW4gcmVxdWVzdDogJyArIG9wdGlvbnMudXJpKVxuICAgIGNvcnNfZXJyLmNvcnMgPSAndW5zdXBwb3J0ZWQnXG4gICAgcmV0dXJuIG9wdGlvbnMuY2FsbGJhY2soY29yc19lcnIsIHhocilcbiAgfVxuXG4gIHhoci50aW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KHRvb19sYXRlLCBvcHRpb25zLnRpbWVvdXQpXG4gIGZ1bmN0aW9uIHRvb19sYXRlKCkge1xuICAgIHRpbWVkX291dCA9IHRydWVcbiAgICB2YXIgZXIgPSBuZXcgRXJyb3IoJ0VUSU1FRE9VVCcpXG4gICAgZXIuY29kZSA9ICdFVElNRURPVVQnXG4gICAgZXIuZHVyYXRpb24gPSBvcHRpb25zLnRpbWVvdXRcblxuICAgIHJlcXVlc3QubG9nLmVycm9yKCdUaW1lb3V0JywgeyAnaWQnOnhoci5faWQsICdtaWxsaXNlY29uZHMnOm9wdGlvbnMudGltZW91dCB9KVxuICAgIHJldHVybiBvcHRpb25zLmNhbGxiYWNrKGVyLCB4aHIpXG4gIH1cblxuICAvLyBTb21lIHN0YXRlcyBjYW4gYmUgc2tpcHBlZCBvdmVyLCBzbyByZW1lbWJlciB3aGF0IGlzIHN0aWxsIGluY29tcGxldGUuXG4gIHZhciBkaWQgPSB7J3Jlc3BvbnNlJzpmYWxzZSwgJ2xvYWRpbmcnOmZhbHNlLCAnZW5kJzpmYWxzZX1cblxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gb25fc3RhdGVfY2hhbmdlXG4gIHhoci5vcGVuKG9wdGlvbnMubWV0aG9kLCBvcHRpb25zLnVyaSwgdHJ1ZSkgLy8gYXN5bmNocm9ub3VzXG4gIGlmKGlzX2NvcnMpXG4gICAgeGhyLndpdGhDcmVkZW50aWFscyA9ICEhIG9wdGlvbnMud2l0aENyZWRlbnRpYWxzXG4gIHhoci5zZW5kKG9wdGlvbnMuYm9keSlcbiAgcmV0dXJuIHhoclxuXG4gIGZ1bmN0aW9uIG9uX3N0YXRlX2NoYW5nZShldmVudCkge1xuICAgIGlmKHRpbWVkX291dClcbiAgICAgIHJldHVybiByZXF1ZXN0LmxvZy5kZWJ1ZygnSWdub3JpbmcgdGltZWQgb3V0IHN0YXRlIGNoYW5nZScsIHsnc3RhdGUnOnhoci5yZWFkeVN0YXRlLCAnaWQnOnhoci5pZH0pXG5cbiAgICByZXF1ZXN0LmxvZy5kZWJ1ZygnU3RhdGUgY2hhbmdlJywgeydzdGF0ZSc6eGhyLnJlYWR5U3RhdGUsICdpZCc6eGhyLmlkLCAndGltZWRfb3V0Jzp0aW1lZF9vdXR9KVxuXG4gICAgaWYoeGhyLnJlYWR5U3RhdGUgPT09IFhIUi5PUEVORUQpIHtcbiAgICAgIHJlcXVlc3QubG9nLmRlYnVnKCdSZXF1ZXN0IHN0YXJ0ZWQnLCB7J2lkJzp4aHIuaWR9KVxuICAgICAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRpb25zLmhlYWRlcnNba2V5XSlcbiAgICB9XG5cbiAgICBlbHNlIGlmKHhoci5yZWFkeVN0YXRlID09PSBYSFIuSEVBREVSU19SRUNFSVZFRClcbiAgICAgIG9uX3Jlc3BvbnNlKClcblxuICAgIGVsc2UgaWYoeGhyLnJlYWR5U3RhdGUgPT09IFhIUi5MT0FESU5HKSB7XG4gICAgICBvbl9yZXNwb25zZSgpXG4gICAgICBvbl9sb2FkaW5nKClcbiAgICB9XG5cbiAgICBlbHNlIGlmKHhoci5yZWFkeVN0YXRlID09PSBYSFIuRE9ORSkge1xuICAgICAgb25fcmVzcG9uc2UoKVxuICAgICAgb25fbG9hZGluZygpXG4gICAgICBvbl9lbmQoKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uX3Jlc3BvbnNlKCkge1xuICAgIGlmKGRpZC5yZXNwb25zZSlcbiAgICAgIHJldHVyblxuXG4gICAgZGlkLnJlc3BvbnNlID0gdHJ1ZVxuICAgIHJlcXVlc3QubG9nLmRlYnVnKCdHb3QgcmVzcG9uc2UnLCB7J2lkJzp4aHIuaWQsICdzdGF0dXMnOnhoci5zdGF0dXN9KVxuICAgIGNsZWFyVGltZW91dCh4aHIudGltZW91dFRpbWVyKVxuICAgIHhoci5zdGF0dXNDb2RlID0geGhyLnN0YXR1cyAvLyBOb2RlIHJlcXVlc3QgY29tcGF0aWJpbGl0eVxuXG4gICAgLy8gRGV0ZWN0IGZhaWxlZCBDT1JTIHJlcXVlc3RzLlxuICAgIGlmKGlzX2NvcnMgJiYgeGhyLnN0YXR1c0NvZGUgPT0gMCkge1xuICAgICAgdmFyIGNvcnNfZXJyID0gbmV3IEVycm9yKCdDT1JTIHJlcXVlc3QgcmVqZWN0ZWQ6ICcgKyBvcHRpb25zLnVyaSlcbiAgICAgIGNvcnNfZXJyLmNvcnMgPSAncmVqZWN0ZWQnXG5cbiAgICAgIC8vIERvIG5vdCBwcm9jZXNzIHRoaXMgcmVxdWVzdCBmdXJ0aGVyLlxuICAgICAgZGlkLmxvYWRpbmcgPSB0cnVlXG4gICAgICBkaWQuZW5kID0gdHJ1ZVxuXG4gICAgICByZXR1cm4gb3B0aW9ucy5jYWxsYmFjayhjb3JzX2VyciwgeGhyKVxuICAgIH1cblxuICAgIG9wdGlvbnMub25SZXNwb25zZShudWxsLCB4aHIpXG4gIH1cblxuICBmdW5jdGlvbiBvbl9sb2FkaW5nKCkge1xuICAgIGlmKGRpZC5sb2FkaW5nKVxuICAgICAgcmV0dXJuXG5cbiAgICBkaWQubG9hZGluZyA9IHRydWVcbiAgICByZXF1ZXN0LmxvZy5kZWJ1ZygnUmVzcG9uc2UgYm9keSBsb2FkaW5nJywgeydpZCc6eGhyLmlkfSlcbiAgICAvLyBUT0RPOiBNYXliZSBzaW11bGF0ZSBcImRhdGFcIiBldmVudHMgYnkgd2F0Y2hpbmcgeGhyLnJlc3BvbnNlVGV4dFxuICB9XG5cbiAgZnVuY3Rpb24gb25fZW5kKCkge1xuICAgIGlmKGRpZC5lbmQpXG4gICAgICByZXR1cm5cblxuICAgIGRpZC5lbmQgPSB0cnVlXG4gICAgcmVxdWVzdC5sb2cuZGVidWcoJ1JlcXVlc3QgZG9uZScsIHsnaWQnOnhoci5pZH0pXG5cbiAgICB4aHIuYm9keSA9IHhoci5yZXNwb25zZVRleHRcbiAgICBpZihvcHRpb25zLmpzb24pIHtcbiAgICAgIHRyeSAgICAgICAgeyB4aHIuYm9keSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCkgfVxuICAgICAgY2F0Y2ggKGVyKSB7IHJldHVybiBvcHRpb25zLmNhbGxiYWNrKGVyLCB4aHIpICAgICAgICB9XG4gICAgfVxuXG4gICAgb3B0aW9ucy5jYWxsYmFjayhudWxsLCB4aHIsIHhoci5ib2R5KVxuICB9XG5cbn0gLy8gcmVxdWVzdFxuXG5yZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xucmVxdWVzdC5ERUZBVUxUX1RJTUVPVVQgPSBERUZBVUxUX1RJTUVPVVQ7XG5cbi8vXG4vLyBkZWZhdWx0c1xuLy9cblxucmVxdWVzdC5kZWZhdWx0cyA9IGZ1bmN0aW9uKG9wdGlvbnMsIHJlcXVlc3Rlcikge1xuICB2YXIgZGVmID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgIHZhciBkID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgIGlmKHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnKVxuICAgICAgICBwYXJhbXMgPSB7J3VyaSc6IHBhcmFtc307XG4gICAgICBlbHNlIHtcbiAgICAgICAgcGFyYW1zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwYXJhbXMpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAocGFyYW1zW2ldID09PSB1bmRlZmluZWQpIHBhcmFtc1tpXSA9IG9wdGlvbnNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtZXRob2QocGFyYW1zLCBjYWxsYmFjaylcbiAgICB9XG4gICAgcmV0dXJuIGRcbiAgfVxuICB2YXIgZGUgPSBkZWYocmVxdWVzdClcbiAgZGUuZ2V0ID0gZGVmKHJlcXVlc3QuZ2V0KVxuICBkZS5wb3N0ID0gZGVmKHJlcXVlc3QucG9zdClcbiAgZGUucHV0ID0gZGVmKHJlcXVlc3QucHV0KVxuICBkZS5oZWFkID0gZGVmKHJlcXVlc3QuaGVhZClcbiAgcmV0dXJuIGRlXG59XG5cbi8vXG4vLyBIVFRQIG1ldGhvZCBzaG9ydGN1dHNcbi8vXG5cbnZhciBzaG9ydGN1dHMgPSBbICdnZXQnLCAncHV0JywgJ3Bvc3QnLCAnaGVhZCcgXTtcbnNob3J0Y3V0cy5mb3JFYWNoKGZ1bmN0aW9uKHNob3J0Y3V0KSB7XG4gIHZhciBtZXRob2QgPSBzaG9ydGN1dC50b1VwcGVyQ2FzZSgpO1xuICB2YXIgZnVuYyAgID0gc2hvcnRjdXQudG9Mb3dlckNhc2UoKTtcblxuICByZXF1ZXN0W2Z1bmNdID0gZnVuY3Rpb24ob3B0cykge1xuICAgIGlmKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJylcbiAgICAgIG9wdHMgPSB7J21ldGhvZCc6bWV0aG9kLCAndXJpJzpvcHRzfTtcbiAgICBlbHNlIHtcbiAgICAgIG9wdHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdHMpKTtcbiAgICAgIG9wdHMubWV0aG9kID0gbWV0aG9kO1xuICAgIH1cblxuICAgIHZhciBhcmdzID0gW29wdHNdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJndW1lbnRzLCBbMV0pKTtcbiAgICByZXR1cm4gcmVxdWVzdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxufSlcblxuLy9cbi8vIENvdWNoREIgc2hvcnRjdXRcbi8vXG5cbnJlcXVlc3QuY291Y2ggPSBmdW5jdGlvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICBpZih0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpXG4gICAgb3B0aW9ucyA9IHsndXJpJzpvcHRpb25zfVxuXG4gIC8vIEp1c3QgdXNlIHRoZSByZXF1ZXN0IEFQSSB0byBkbyBKU09OLlxuICBvcHRpb25zLmpzb24gPSB0cnVlXG4gIGlmKG9wdGlvbnMuYm9keSlcbiAgICBvcHRpb25zLmpzb24gPSBvcHRpb25zLmJvZHlcbiAgZGVsZXRlIG9wdGlvbnMuYm9keVxuXG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcFxuXG4gIHZhciB4aHIgPSByZXF1ZXN0KG9wdGlvbnMsIGNvdWNoX2hhbmRsZXIpXG4gIHJldHVybiB4aHJcblxuICBmdW5jdGlvbiBjb3VjaF9oYW5kbGVyKGVyLCByZXNwLCBib2R5KSB7XG4gICAgaWYoZXIpXG4gICAgICByZXR1cm4gY2FsbGJhY2soZXIsIHJlc3AsIGJvZHkpXG5cbiAgICBpZigocmVzcC5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlc3Auc3RhdHVzQ29kZSA+IDI5OSkgJiYgYm9keS5lcnJvcikge1xuICAgICAgLy8gVGhlIGJvZHkgaXMgYSBDb3VjaCBKU09OIG9iamVjdCBpbmRpY2F0aW5nIHRoZSBlcnJvci5cbiAgICAgIGVyID0gbmV3IEVycm9yKCdDb3VjaERCIGVycm9yOiAnICsgKGJvZHkuZXJyb3IucmVhc29uIHx8IGJvZHkuZXJyb3IuZXJyb3IpKVxuICAgICAgZm9yICh2YXIga2V5IGluIGJvZHkpXG4gICAgICAgIGVyW2tleV0gPSBib2R5W2tleV1cbiAgICAgIHJldHVybiBjYWxsYmFjayhlciwgcmVzcCwgYm9keSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyLCByZXNwLCBib2R5KTtcbiAgfVxufVxuXG4vL1xuLy8gVXRpbGl0eVxuLy9cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGdldExvZ2dlcigpIHtcbiAgdmFyIGxvZ2dlciA9IHt9XG4gICAgLCBsZXZlbHMgPSBbJ3RyYWNlJywgJ2RlYnVnJywgJ2luZm8nLCAnd2FybicsICdlcnJvciddXG4gICAgLCBsZXZlbCwgaVxuXG4gIGZvcihpID0gMDsgaSA8IGxldmVscy5sZW5ndGg7IGkrKykge1xuICAgIGxldmVsID0gbGV2ZWxzW2ldXG5cbiAgICBsb2dnZXJbbGV2ZWxdID0gbm9vcFxuICAgIGlmKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlICYmIGNvbnNvbGVbbGV2ZWxdKVxuICAgICAgbG9nZ2VyW2xldmVsXSA9IGZvcm1hdHRlZChjb25zb2xlLCBsZXZlbClcbiAgfVxuXG4gIHJldHVybiBsb2dnZXJcbn1cblxuZnVuY3Rpb24gZm9ybWF0dGVkKG9iaiwgbWV0aG9kKSB7XG4gIHJldHVybiBmb3JtYXR0ZWRfbG9nZ2VyXG5cbiAgZnVuY3Rpb24gZm9ybWF0dGVkX2xvZ2dlcihzdHIsIGNvbnRleHQpIHtcbiAgICBpZih0eXBlb2YgY29udGV4dCA9PT0gJ29iamVjdCcpXG4gICAgICBzdHIgKz0gJyAnICsgSlNPTi5zdHJpbmdpZnkoY29udGV4dClcblxuICAgIHJldHVybiBvYmpbbWV0aG9kXS5jYWxsKG9iaiwgc3RyKVxuICB9XG59XG5cbi8vIFJldHVybiB3aGV0aGVyIGEgVVJMIGlzIGEgY3Jvc3MtZG9tYWluIHJlcXVlc3QuXG5mdW5jdGlvbiBpc19jcm9zc0RvbWFpbih1cmwpIHtcbiAgdmFyIHJ1cmwgPSAvXihbXFx3XFwrXFwuXFwtXSs6KSg/OlxcL1xcLyhbXlxcLz8jOl0qKSg/OjooXFxkKykpPyk/L1xuXG4gIC8vIGpRdWVyeSAjODEzOCwgSUUgbWF5IHRocm93IGFuIGV4Y2VwdGlvbiB3aGVuIGFjY2Vzc2luZ1xuICAvLyBhIGZpZWxkIGZyb20gd2luZG93LmxvY2F0aW9uIGlmIGRvY3VtZW50LmRvbWFpbiBoYXMgYmVlbiBzZXRcbiAgdmFyIGFqYXhMb2NhdGlvblxuICB0cnkgeyBhamF4TG9jYXRpb24gPSBsb2NhdGlvbi5ocmVmIH1cbiAgY2F0Y2ggKGUpIHtcbiAgICAvLyBVc2UgdGhlIGhyZWYgYXR0cmlidXRlIG9mIGFuIEEgZWxlbWVudCBzaW5jZSBJRSB3aWxsIG1vZGlmeSBpdCBnaXZlbiBkb2N1bWVudC5sb2NhdGlvblxuICAgIGFqYXhMb2NhdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG4gICAgYWpheExvY2F0aW9uLmhyZWYgPSBcIlwiO1xuICAgIGFqYXhMb2NhdGlvbiA9IGFqYXhMb2NhdGlvbi5ocmVmO1xuICB9XG5cbiAgdmFyIGFqYXhMb2NQYXJ0cyA9IHJ1cmwuZXhlYyhhamF4TG9jYXRpb24udG9Mb3dlckNhc2UoKSkgfHwgW11cbiAgICAsIHBhcnRzID0gcnVybC5leGVjKHVybC50b0xvd2VyQ2FzZSgpIClcblxuICB2YXIgcmVzdWx0ID0gISEoXG4gICAgcGFydHMgJiZcbiAgICAoICBwYXJ0c1sxXSAhPSBhamF4TG9jUGFydHNbMV1cbiAgICB8fCBwYXJ0c1syXSAhPSBhamF4TG9jUGFydHNbMl1cbiAgICB8fCAocGFydHNbM10gfHwgKHBhcnRzWzFdID09PSBcImh0dHA6XCIgPyA4MCA6IDQ0MykpICE9IChhamF4TG9jUGFydHNbM10gfHwgKGFqYXhMb2NQYXJ0c1sxXSA9PT0gXCJodHRwOlwiID8gODAgOiA0NDMpKVxuICAgIClcbiAgKVxuXG4gIC8vY29uc29sZS5kZWJ1ZygnaXNfY3Jvc3NEb21haW4oJyt1cmwrJykgLT4gJyArIHJlc3VsdClcbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vLyBNSVQgTGljZW5zZSBmcm9tIGh0dHA6Ly9waHBqcy5vcmcvZnVuY3Rpb25zL2Jhc2U2NF9lbmNvZGU6MzU4XG5mdW5jdGlvbiBiNjRfZW5jIChkYXRhKSB7XG4gICAgLy8gRW5jb2RlcyBzdHJpbmcgdXNpbmcgTUlNRSBiYXNlNjQgYWxnb3JpdGhtXG4gICAgdmFyIGI2NCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgICB2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLCBhYyA9IDAsIGVuYz1cIlwiLCB0bXBfYXJyID0gW107XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLy8gYXNzdW1lIHV0ZjggZGF0YVxuICAgIC8vIGRhdGEgPSB0aGlzLnV0ZjhfZW5jb2RlKGRhdGErJycpO1xuXG4gICAgZG8geyAvLyBwYWNrIHRocmVlIG9jdGV0cyBpbnRvIGZvdXIgaGV4ZXRzXG4gICAgICAgIG8xID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIG8yID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG4gICAgICAgIG8zID0gZGF0YS5jaGFyQ29kZUF0KGkrKyk7XG5cbiAgICAgICAgYml0cyA9IG8xPDwxNiB8IG8yPDw4IHwgbzM7XG5cbiAgICAgICAgaDEgPSBiaXRzPj4xOCAmIDB4M2Y7XG4gICAgICAgIGgyID0gYml0cz4+MTIgJiAweDNmO1xuICAgICAgICBoMyA9IGJpdHM+PjYgJiAweDNmO1xuICAgICAgICBoNCA9IGJpdHMgJiAweDNmO1xuXG4gICAgICAgIC8vIHVzZSBoZXhldHMgdG8gaW5kZXggaW50byBiNjQsIGFuZCBhcHBlbmQgcmVzdWx0IHRvIGVuY29kZWQgc3RyaW5nXG4gICAgICAgIHRtcF9hcnJbYWMrK10gPSBiNjQuY2hhckF0KGgxKSArIGI2NC5jaGFyQXQoaDIpICsgYjY0LmNoYXJBdChoMykgKyBiNjQuY2hhckF0KGg0KTtcbiAgICB9IHdoaWxlIChpIDwgZGF0YS5sZW5ndGgpO1xuXG4gICAgZW5jID0gdG1wX2Fyci5qb2luKCcnKTtcblxuICAgIHN3aXRjaCAoZGF0YS5sZW5ndGggJSAzKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGVuYyA9IGVuYy5zbGljZSgwLCAtMikgKyAnPT0nO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgZW5jID0gZW5jLnNsaWNlKDAsIC0xKSArICc9JztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuYztcbn1cbiAgICByZXR1cm4gcmVxdWVzdDtcbi8vVU1EIEZPT1RFUiBTVEFSVFxufSkpO1xuLy9VTUQgRk9PVEVSIEVORFxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmljZXNcbiAqL1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZSgna2luZC1vZicpO1xudmFyIGZvck93biA9IHJlcXVpcmUoJ2Zvci1vd24nKTtcbnZhciBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnaXMtcGxhaW4tb2JqZWN0Jyk7XG52YXIgbWl4aW4gPSByZXF1aXJlKCdtaXhpbi1vYmplY3QnKTtcblxuXG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNsb25lIG5hdGl2ZSB0eXBlcy5cbiAqL1xuXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsLCBpbnN0YW5jZUNsb25lKSB7XG4gIHN3aXRjaCAodHlwZU9mKHZhbCkpIHtcbiAgY2FzZSAnb2JqZWN0JzpcbiAgICByZXR1cm4gY2xvbmVPYmplY3REZWVwKHZhbCwgaW5zdGFuY2VDbG9uZSk7XG4gIGNhc2UgJ2FycmF5JzpcbiAgICByZXR1cm4gY2xvbmVBcnJheURlZXAodmFsLCBpbnN0YW5jZUNsb25lKTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gY2xvbmUodmFsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZU9iamVjdERlZXAob2JqLCBpbnN0YW5jZUNsb25lKSB7XG4gIGlmIChpc1BsYWluT2JqZWN0KG9iaikpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgZm9yT3duKG9iaiwgZnVuY3Rpb24gKG9iaiwga2V5KSB7XG4gICAgICB0aGlzW2tleV0gPSBjbG9uZURlZXAob2JqLCBpbnN0YW5jZUNsb25lKTtcbiAgICB9LCByZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH0gZWxzZSBpZiAoaW5zdGFuY2VDbG9uZSkge1xuICAgIHJldHVybiBpbnN0YW5jZUNsb25lKG9iaik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFycmF5RGVlcChhcnIsIGluc3RhbmNlQ2xvbmUpIHtcbiAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gIHZhciByZXMgPSBbXTtcbiAgdmFyIGkgPSAtMTtcblxuICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgcmVzW2ldID0gY2xvbmVEZWVwKGFycltpXSwgaW5zdGFuY2VDbG9uZSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxuZnVuY3Rpb24gY2xvbmUodmFsKSB7XG4gIHN3aXRjaCAodHlwZU9mKHZhbCkpIHtcbiAgY2FzZSAnb2JqZWN0JzpcbiAgICByZXR1cm4gY2xvbmVPYmplY3QodmFsKTtcbiAgY2FzZSAnYXJyYXknOlxuICAgIHJldHVybiBjbG9uZUFycmF5KHZhbCk7XG4gIGNhc2UgJ3JlZ2V4cCc6XG4gICAgcmV0dXJuIGNsb25lUmVnRXhwKHZhbCk7XG4gIGNhc2UgJ2RhdGUnOlxuICAgIHJldHVybiBjbG9uZURhdGUodmFsKTtcbiAgZGVmYXVsdDpcbiAgICByZXR1cm4gdmFsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lT2JqZWN0KG9iaikge1xuICBpZiAoaXNQbGFpbk9iamVjdChvYmopKSB7XG4gICAgcmV0dXJuIG1peGluKHt9LCBvYmopO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmUpIHtcbiAgdmFyIGZsYWdzID0gJyc7XG4gIGZsYWdzICs9IHJlLm11bHRpbGluZSA/ICdtJyA6ICcnO1xuICBmbGFncyArPSByZS5nbG9iYWwgPyAnZycgOiAnJztcbiAgZmxhZ3MgKz0gcmUuaWdub3JlY2FzZSA/ICdpJyA6ICcnO1xuICByZXR1cm4gbmV3IFJlZ0V4cChyZS5zb3VyY2UsIGZsYWdzKTtcbn1cblxuZnVuY3Rpb24gY2xvbmVEYXRlKGRhdGUpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKCtkYXRlKTtcbn1cblxuZnVuY3Rpb24gY2xvbmVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFyci5zbGljZSgpO1xufVxuXG4vKipcbiAqIEV4cG9zZSBgY2xvbmVEZWVwYFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEZWVwOyIsIi8qIVxuICogZm9yLW93biA8aHR0cHM6Ly9naXRodWIuY29tL2pvbnNjaGxpbmtlcnQvZm9yLW93bj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZm9ySW4gPSByZXF1aXJlKCdmb3ItaW4nKTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvck93bihvLCBmbiwgdGhpc0FyZykge1xuICBmb3JJbihvLCBmdW5jdGlvbiAodmFsLCBrZXkpIHtcbiAgICBpZiAoaGFzT3duLmNhbGwobywga2V5KSkge1xuICAgICAgcmV0dXJuIGZuLmNhbGwodGhpc0FyZywgb1trZXldLCBrZXksIG8pO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiLyohXG4gKiBmb3ItaW4gPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2Zvci1pbj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSwgSm9uIFNjaGxpbmtlcnQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckluKG8sIGZuLCB0aGlzQXJnKSB7XG4gIGZvciAodmFyIGtleSBpbiBvKSB7XG4gICAgaWYgKGZuLmNhbGwodGhpc0FyZywgb1trZXldLCBrZXksIG8pID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59OyIsIi8qIVxuICogaXMtcGxhaW4tb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wbGFpbi1vYmplY3Q+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IEpvbiBTY2hsaW5rZXJ0LCBjb250cmlidXRvcnMuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIHJldHVybiAhIW8gJiYgdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG8uY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldCB0aGUgbmF0aXZlIGB0eXBlb2ZgIGEgdmFsdWUuXG4gKlxuICogQHBhcmFtICB7Kn0gYHZhbGBcbiAqIEByZXR1cm4geyp9IE5hdGl2ZSBqYXZhc2NyaXB0IHR5cGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHR5cGVPZih2YWwpIHtcbiAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnbnVsbCc7XG4gIH1cblxuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBpZiAodHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gJ2FycmF5JztcbiAgfVxuXG4gIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHZhbClcbiAgICAuc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCk7XG59O1xuIiwiLyohXG4gKiBtaXhpbi1vYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L21peGluLW9iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgSm9uIFNjaGxpbmtlcnQsIGNvbnRyaWJ1dG9ycy5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGZvck93biA9IHJlcXVpcmUoJ2Zvci1vd24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtaXhJbihvKSB7XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG5cbiAgaWYgKG8gPT0gbnVsbCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIGlmIChsZW4gPT09IDApIHtcbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHkodmFsdWUsIGtleSkge1xuICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBvYmogPSBhcmdzW2ldO1xuICAgIGlmIChvYmogIT0gbnVsbCkge1xuICAgICAgZm9yT3duKG9iaiwgY29weSwgbyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufTsiLCIndXNlIHN0cmljdCdcclxuXHJcbi8qKlxyXG4gKiBEaWZmIE1hdGNoIGFuZCBQYXRjaFxyXG4gKlxyXG4gKiBDb3B5cmlnaHQgMjAwNiBHb29nbGUgSW5jLlxyXG4gKiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWRpZmYtbWF0Y2gtcGF0Y2gvXHJcbiAqXHJcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbiAqXHJcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbiAqXHJcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuICovXHJcblxyXG4vKipcclxuICogQGZpbGVvdmVydmlldyBDb21wdXRlcyB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byB0ZXh0cyB0byBjcmVhdGUgYSBwYXRjaC5cclxuICogQXBwbGllcyB0aGUgcGF0Y2ggb250byBhbm90aGVyIHRleHQsIGFsbG93aW5nIGZvciBlcnJvcnMuXHJcbiAqIEBhdXRob3IgZnJhc2VyQGdvb2dsZS5jb20gKE5laWwgRnJhc2VyKVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBjb250YWluaW5nIHRoZSBkaWZmLCBtYXRjaCBhbmQgcGF0Y2ggbWV0aG9kcy5cclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBkaWZmX21hdGNoX3BhdGNoKCkge1xyXG5cclxuICAvLyBEZWZhdWx0cy5cclxuICAvLyBSZWRlZmluZSB0aGVzZSBpbiB5b3VyIHByb2dyYW0gdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHRzLlxyXG5cclxuICAvLyBOdW1iZXIgb2Ygc2Vjb25kcyB0byBtYXAgYSBkaWZmIGJlZm9yZSBnaXZpbmcgdXAgKDAgZm9yIGluZmluaXR5KS5cclxuICB0aGlzLkRpZmZfVGltZW91dCA9IDEuMDtcclxuICAvLyBDb3N0IG9mIGFuIGVtcHR5IGVkaXQgb3BlcmF0aW9uIGluIHRlcm1zIG9mIGVkaXQgY2hhcmFjdGVycy5cclxuICB0aGlzLkRpZmZfRWRpdENvc3QgPSA0O1xyXG4gIC8vIEF0IHdoYXQgcG9pbnQgaXMgbm8gbWF0Y2ggZGVjbGFyZWQgKDAuMCA9IHBlcmZlY3Rpb24sIDEuMCA9IHZlcnkgbG9vc2UpLlxyXG4gIHRoaXMuTWF0Y2hfVGhyZXNob2xkID0gMC41O1xyXG4gIC8vIEhvdyBmYXIgdG8gc2VhcmNoIGZvciBhIG1hdGNoICgwID0gZXhhY3QgbG9jYXRpb24sIDEwMDArID0gYnJvYWQgbWF0Y2gpLlxyXG4gIC8vIEEgbWF0Y2ggdGhpcyBtYW55IGNoYXJhY3RlcnMgYXdheSBmcm9tIHRoZSBleHBlY3RlZCBsb2NhdGlvbiB3aWxsIGFkZFxyXG4gIC8vIDEuMCB0byB0aGUgc2NvcmUgKDAuMCBpcyBhIHBlcmZlY3QgbWF0Y2gpLlxyXG4gIHRoaXMuTWF0Y2hfRGlzdGFuY2UgPSAxMDAwO1xyXG4gIC8vIFdoZW4gZGVsZXRpbmcgYSBsYXJnZSBibG9jayBvZiB0ZXh0IChvdmVyIH42NCBjaGFyYWN0ZXJzKSwgaG93IGNsb3NlIGRvXHJcbiAgLy8gdGhlIGNvbnRlbnRzIGhhdmUgdG8gYmUgdG8gbWF0Y2ggdGhlIGV4cGVjdGVkIGNvbnRlbnRzLiAoMC4wID0gcGVyZmVjdGlvbixcclxuICAvLyAxLjAgPSB2ZXJ5IGxvb3NlKS4gIE5vdGUgdGhhdCBNYXRjaF9UaHJlc2hvbGQgY29udHJvbHMgaG93IGNsb3NlbHkgdGhlXHJcbiAgLy8gZW5kIHBvaW50cyBvZiBhIGRlbGV0ZSBuZWVkIHRvIG1hdGNoLlxyXG4gIHRoaXMuUGF0Y2hfRGVsZXRlVGhyZXNob2xkID0gMC41O1xyXG4gIC8vIENodW5rIHNpemUgZm9yIGNvbnRleHQgbGVuZ3RoLlxyXG4gIHRoaXMuUGF0Y2hfTWFyZ2luID0gNDtcclxuXHJcbiAgLy8gVGhlIG51bWJlciBvZiBiaXRzIGluIGFuIGludC5cclxuICB0aGlzLk1hdGNoX01heEJpdHMgPSAzMjtcclxufVxyXG5cclxuXHJcbi8vICBESUZGIEZVTkNUSU9OU1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGEgZGlmZiBpcyBhbiBhcnJheSBvZiB0dXBsZXM6XHJcbiAqIFtbRElGRl9ERUxFVEUsICdIZWxsbyddLCBbRElGRl9JTlNFUlQsICdHb29kYnllJ10sIFtESUZGX0VRVUFMLCAnIHdvcmxkLiddXVxyXG4gKiB3aGljaCBtZWFuczogZGVsZXRlICdIZWxsbycsIGFkZCAnR29vZGJ5ZScgYW5kIGtlZXAgJyB3b3JsZC4nXHJcbiAqL1xyXG52YXIgRElGRl9ERUxFVEUgPSAtMTtcclxudmFyIERJRkZfSU5TRVJUID0gMTtcclxudmFyIERJRkZfRVFVQUwgPSAwO1xyXG5cclxuLyoqIEB0eXBlZGVmIHt7MDogbnVtYmVyLCAxOiBzdHJpbmd9fSAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLkRpZmY7XHJcblxyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgU2ltcGxpZmllcyB0aGUgcHJvYmxlbSBieSBzdHJpcHBpbmdcclxuICogYW55IGNvbW1vbiBwcmVmaXggb3Igc3VmZml4IG9mZiB0aGUgdGV4dHMgYmVmb3JlIGRpZmZpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRfY2hlY2tsaW5lcyBPcHRpb25hbCBzcGVlZHVwIGZsYWcuIElmIHByZXNlbnQgYW5kIGZhbHNlLFxyXG4gKiAgICAgdGhlbiBkb24ndCBydW4gYSBsaW5lLWxldmVsIGRpZmYgZmlyc3QgdG8gaWRlbnRpZnkgdGhlIGNoYW5nZWQgYXJlYXMuXHJcbiAqICAgICBEZWZhdWx0cyB0byB0cnVlLCB3aGljaCBkb2VzIGEgZmFzdGVyLCBzbGlnaHRseSBsZXNzIG9wdGltYWwgZGlmZi5cclxuICogQHBhcmFtIHtudW1iZXJ9IG9wdF9kZWFkbGluZSBPcHRpb25hbCB0aW1lIHdoZW4gdGhlIGRpZmYgc2hvdWxkIGJlIGNvbXBsZXRlXHJcbiAqICAgICBieS4gIFVzZWQgaW50ZXJuYWxseSBmb3IgcmVjdXJzaXZlIGNhbGxzLiAgVXNlcnMgc2hvdWxkIHNldCBEaWZmVGltZW91dFxyXG4gKiAgICAgaW5zdGVhZC5cclxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX21haW4gPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIsIG9wdF9jaGVja2xpbmVzLFxyXG4gICAgb3B0X2RlYWRsaW5lKSB7XHJcbiAgLy8gU2V0IGEgZGVhZGxpbmUgYnkgd2hpY2ggdGltZSB0aGUgZGlmZiBtdXN0IGJlIGNvbXBsZXRlLlxyXG4gIGlmICh0eXBlb2Ygb3B0X2RlYWRsaW5lID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICBpZiAodGhpcy5EaWZmX1RpbWVvdXQgPD0gMCkge1xyXG4gICAgICBvcHRfZGVhZGxpbmUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgb3B0X2RlYWRsaW5lID0gKG5ldyBEYXRlKS5nZXRUaW1lKCkgKyB0aGlzLkRpZmZfVGltZW91dCAqIDEwMDA7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHZhciBkZWFkbGluZSA9IG9wdF9kZWFkbGluZTtcclxuXHJcbiAgLy8gQ2hlY2sgZm9yIG51bGwgaW5wdXRzLlxyXG4gIGlmICh0ZXh0MSA9PSBudWxsIHx8IHRleHQyID09IG51bGwpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTnVsbCBpbnB1dC4gKGRpZmZfbWFpbiknKTtcclxuICB9XHJcblxyXG4gIC8vIENoZWNrIGZvciBlcXVhbGl0eSAoc3BlZWR1cCkuXHJcbiAgaWYgKHRleHQxID09IHRleHQyKSB7XHJcbiAgICBpZiAodGV4dDEpIHtcclxuICAgICAgcmV0dXJuIFtbRElGRl9FUVVBTCwgdGV4dDFdXTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2Ygb3B0X2NoZWNrbGluZXMgPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgIG9wdF9jaGVja2xpbmVzID0gdHJ1ZTtcclxuICB9XHJcbiAgdmFyIGNoZWNrbGluZXMgPSBvcHRfY2hlY2tsaW5lcztcclxuXHJcbiAgLy8gVHJpbSBvZmYgY29tbW9uIHByZWZpeCAoc3BlZWR1cCkuXHJcbiAgdmFyIGNvbW1vbmxlbmd0aCA9IHRoaXMuZGlmZl9jb21tb25QcmVmaXgodGV4dDEsIHRleHQyKTtcclxuICB2YXIgY29tbW9ucHJlZml4ID0gdGV4dDEuc3Vic3RyaW5nKDAsIGNvbW1vbmxlbmd0aCk7XHJcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcclxuICB0ZXh0MiA9IHRleHQyLnN1YnN0cmluZyhjb21tb25sZW5ndGgpO1xyXG5cclxuICAvLyBUcmltIG9mZiBjb21tb24gc3VmZml4IChzcGVlZHVwKS5cclxuICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHQxLCB0ZXh0Mik7XHJcbiAgdmFyIGNvbW1vbnN1ZmZpeCA9IHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBjb21tb25sZW5ndGgpO1xyXG4gIHRleHQxID0gdGV4dDEuc3Vic3RyaW5nKDAsIHRleHQxLmxlbmd0aCAtIGNvbW1vbmxlbmd0aCk7XHJcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcclxuXHJcbiAgLy8gQ29tcHV0ZSB0aGUgZGlmZiBvbiB0aGUgbWlkZGxlIGJsb2NrLlxyXG4gIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9jb21wdXRlXyh0ZXh0MSwgdGV4dDIsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcclxuXHJcbiAgLy8gUmVzdG9yZSB0aGUgcHJlZml4IGFuZCBzdWZmaXguXHJcbiAgaWYgKGNvbW1vbnByZWZpeCkge1xyXG4gICAgZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgY29tbW9ucHJlZml4XSk7XHJcbiAgfVxyXG4gIGlmIChjb21tb25zdWZmaXgpIHtcclxuICAgIGRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGNvbW1vbnN1ZmZpeF0pO1xyXG4gIH1cclxuICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcclxuICByZXR1cm4gZGlmZnM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdHdvIHRleHRzLiAgQXNzdW1lcyB0aGF0IHRoZSB0ZXh0cyBkbyBub3RcclxuICogaGF2ZSBhbnkgY29tbW9uIHByZWZpeCBvciBzdWZmaXguXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrbGluZXMgU3BlZWR1cCBmbGFnLiAgSWYgZmFsc2UsIHRoZW4gZG9uJ3QgcnVuIGFcclxuICogICAgIGxpbmUtbGV2ZWwgZGlmZiBmaXJzdCB0byBpZGVudGlmeSB0aGUgY2hhbmdlZCBhcmVhcy5cclxuICogICAgIElmIHRydWUsIHRoZW4gcnVuIGEgZmFzdGVyLCBzbGlnaHRseSBsZXNzIG9wdGltYWwgZGlmZi5cclxuICogQHBhcmFtIHtudW1iZXJ9IGRlYWRsaW5lIFRpbWUgd2hlbiB0aGUgZGlmZiBzaG91bGQgYmUgY29tcGxldGUgYnkuXHJcbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21wdXRlXyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0MiwgY2hlY2tsaW5lcyxcclxuICAgIGRlYWRsaW5lKSB7XHJcbiAgdmFyIGRpZmZzO1xyXG5cclxuICBpZiAoIXRleHQxKSB7XHJcbiAgICAvLyBKdXN0IGFkZCBzb21lIHRleHQgKHNwZWVkdXApLlxyXG4gICAgcmV0dXJuIFtbRElGRl9JTlNFUlQsIHRleHQyXV07XHJcbiAgfVxyXG5cclxuICBpZiAoIXRleHQyKSB7XHJcbiAgICAvLyBKdXN0IGRlbGV0ZSBzb21lIHRleHQgKHNwZWVkdXApLlxyXG4gICAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXV07XHJcbiAgfVxyXG5cclxuICB2YXIgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xyXG4gIHZhciBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xyXG4gIHZhciBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xyXG4gIGlmIChpICE9IC0xKSB7XHJcbiAgICAvLyBTaG9ydGVyIHRleHQgaXMgaW5zaWRlIHRoZSBsb25nZXIgdGV4dCAoc3BlZWR1cCkuXHJcbiAgICBkaWZmcyA9IFtbRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZygwLCBpKV0sXHJcbiAgICAgICAgICAgICBbRElGRl9FUVVBTCwgc2hvcnR0ZXh0XSxcclxuICAgICAgICAgICAgIFtESUZGX0lOU0VSVCwgbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBzaG9ydHRleHQubGVuZ3RoKV1dO1xyXG4gICAgLy8gU3dhcCBpbnNlcnRpb25zIGZvciBkZWxldGlvbnMgaWYgZGlmZiBpcyByZXZlcnNlZC5cclxuICAgIGlmICh0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGgpIHtcclxuICAgICAgZGlmZnNbMF1bMF0gPSBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpZmZzO1xyXG4gIH1cclxuXHJcbiAgaWYgKHNob3J0dGV4dC5sZW5ndGggPT0gMSkge1xyXG4gICAgLy8gU2luZ2xlIGNoYXJhY3RlciBzdHJpbmcuXHJcbiAgICAvLyBBZnRlciB0aGUgcHJldmlvdXMgc3BlZWR1cCwgdGhlIGNoYXJhY3RlciBjYW4ndCBiZSBhbiBlcXVhbGl0eS5cclxuICAgIHJldHVybiBbW0RJRkZfREVMRVRFLCB0ZXh0MV0sIFtESUZGX0lOU0VSVCwgdGV4dDJdXTtcclxuICB9XHJcblxyXG4gIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgcHJvYmxlbSBjYW4gYmUgc3BsaXQgaW4gdHdvLlxyXG4gIHZhciBobSA9IHRoaXMuZGlmZl9oYWxmTWF0Y2hfKHRleHQxLCB0ZXh0Mik7XHJcbiAgaWYgKGhtKSB7XHJcbiAgICAvLyBBIGhhbGYtbWF0Y2ggd2FzIGZvdW5kLCBzb3J0IG91dCB0aGUgcmV0dXJuIGRhdGEuXHJcbiAgICB2YXIgdGV4dDFfYSA9IGhtWzBdO1xyXG4gICAgdmFyIHRleHQxX2IgPSBobVsxXTtcclxuICAgIHZhciB0ZXh0Ml9hID0gaG1bMl07XHJcbiAgICB2YXIgdGV4dDJfYiA9IGhtWzNdO1xyXG4gICAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcclxuICAgIC8vIFNlbmQgYm90aCBwYWlycyBvZmYgZm9yIHNlcGFyYXRlIHByb2Nlc3NpbmcuXHJcbiAgICB2YXIgZGlmZnNfYSA9IHRoaXMuZGlmZl9tYWluKHRleHQxX2EsIHRleHQyX2EsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcclxuICAgIHZhciBkaWZmc19iID0gdGhpcy5kaWZmX21haW4odGV4dDFfYiwgdGV4dDJfYiwgY2hlY2tsaW5lcywgZGVhZGxpbmUpO1xyXG4gICAgLy8gTWVyZ2UgdGhlIHJlc3VsdHMuXHJcbiAgICByZXR1cm4gZGlmZnNfYS5jb25jYXQoW1tESUZGX0VRVUFMLCBtaWRfY29tbW9uXV0sIGRpZmZzX2IpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNoZWNrbGluZXMgJiYgdGV4dDEubGVuZ3RoID4gMTAwICYmIHRleHQyLmxlbmd0aCA+IDEwMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZGlmZl9saW5lTW9kZV8odGV4dDEsIHRleHQyLCBkZWFkbGluZSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcy5kaWZmX2Jpc2VjdF8odGV4dDEsIHRleHQyLCBkZWFkbGluZSk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIERvIGEgcXVpY2sgbGluZS1sZXZlbCBkaWZmIG9uIGJvdGggc3RyaW5ncywgdGhlbiByZWRpZmYgdGhlIHBhcnRzIGZvclxyXG4gKiBncmVhdGVyIGFjY3VyYWN5LlxyXG4gKiBUaGlzIHNwZWVkdXAgY2FuIHByb2R1Y2Ugbm9uLW1pbmltYWwgZGlmZnMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVhZGxpbmUgVGltZSB3aGVuIHRoZSBkaWZmIHNob3VsZCBiZSBjb21wbGV0ZSBieS5cclxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2xpbmVNb2RlXyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0MiwgZGVhZGxpbmUpIHtcclxuICAvLyBTY2FuIHRoZSB0ZXh0IG9uIGEgbGluZS1ieS1saW5lIGJhc2lzIGZpcnN0LlxyXG4gIHZhciBhID0gdGhpcy5kaWZmX2xpbmVzVG9DaGFyc18odGV4dDEsIHRleHQyKTtcclxuICB0ZXh0MSA9IGEuY2hhcnMxO1xyXG4gIHRleHQyID0gYS5jaGFyczI7XHJcbiAgdmFyIGxpbmVhcnJheSA9IGEubGluZUFycmF5O1xyXG5cclxuICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIGZhbHNlLCBkZWFkbGluZSk7XHJcblxyXG4gIC8vIENvbnZlcnQgdGhlIGRpZmYgYmFjayB0byBvcmlnaW5hbCB0ZXh0LlxyXG4gIHRoaXMuZGlmZl9jaGFyc1RvTGluZXNfKGRpZmZzLCBsaW5lYXJyYXkpO1xyXG4gIC8vIEVsaW1pbmF0ZSBmcmVhayBtYXRjaGVzIChlLmcuIGJsYW5rIGxpbmVzKVxyXG4gIHRoaXMuZGlmZl9jbGVhbnVwU2VtYW50aWMoZGlmZnMpO1xyXG5cclxuICAvLyBSZWRpZmYgYW55IHJlcGxhY2VtZW50IGJsb2NrcywgdGhpcyB0aW1lIGNoYXJhY3Rlci1ieS1jaGFyYWN0ZXIuXHJcbiAgLy8gQWRkIGEgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cclxuICBkaWZmcy5wdXNoKFtESUZGX0VRVUFMLCAnJ10pO1xyXG4gIHZhciBwb2ludGVyID0gMDtcclxuICB2YXIgY291bnRfZGVsZXRlID0gMDtcclxuICB2YXIgY291bnRfaW5zZXJ0ID0gMDtcclxuICB2YXIgdGV4dF9kZWxldGUgPSAnJztcclxuICB2YXIgdGV4dF9pbnNlcnQgPSAnJztcclxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xyXG4gICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xyXG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxyXG4gICAgICAgIGNvdW50X2luc2VydCsrO1xyXG4gICAgICAgIHRleHRfaW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxyXG4gICAgICAgIGNvdW50X2RlbGV0ZSsrO1xyXG4gICAgICAgIHRleHRfZGVsZXRlICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfRVFVQUw6XHJcbiAgICAgICAgLy8gVXBvbiByZWFjaGluZyBhbiBlcXVhbGl0eSwgY2hlY2sgZm9yIHByaW9yIHJlZHVuZGFuY2llcy5cclxuICAgICAgICBpZiAoY291bnRfZGVsZXRlID49IDEgJiYgY291bnRfaW5zZXJ0ID49IDEpIHtcclxuICAgICAgICAgIC8vIERlbGV0ZSB0aGUgb2ZmZW5kaW5nIHJlY29yZHMgYW5kIGFkZCB0aGUgbWVyZ2VkIG9uZXMuXHJcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCxcclxuICAgICAgICAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQpO1xyXG4gICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQ7XHJcbiAgICAgICAgICB2YXIgYSA9IHRoaXMuZGlmZl9tYWluKHRleHRfZGVsZXRlLCB0ZXh0X2luc2VydCwgZmFsc2UsIGRlYWRsaW5lKTtcclxuICAgICAgICAgIGZvciAodmFyIGogPSBhLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBhW2pdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyICsgYS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvdW50X2luc2VydCA9IDA7XHJcbiAgICAgICAgY291bnRfZGVsZXRlID0gMDtcclxuICAgICAgICB0ZXh0X2RlbGV0ZSA9ICcnO1xyXG4gICAgICAgIHRleHRfaW5zZXJ0ID0gJyc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBwb2ludGVyKys7XHJcbiAgfVxyXG4gIGRpZmZzLnBvcCgpOyAgLy8gUmVtb3ZlIHRoZSBkdW1teSBlbnRyeSBhdCB0aGUgZW5kLlxyXG5cclxuICByZXR1cm4gZGlmZnM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEZpbmQgdGhlICdtaWRkbGUgc25ha2UnIG9mIGEgZGlmZiwgc3BsaXQgdGhlIHByb2JsZW0gaW4gdHdvXHJcbiAqIGFuZCByZXR1cm4gdGhlIHJlY3Vyc2l2ZWx5IGNvbnN0cnVjdGVkIGRpZmYuXHJcbiAqIFNlZSBNeWVycyAxOTg2IHBhcGVyOiBBbiBPKE5EKSBEaWZmZXJlbmNlIEFsZ29yaXRobSBhbmQgSXRzIFZhcmlhdGlvbnMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVhZGxpbmUgVGltZSBhdCB3aGljaCB0byBiYWlsIGlmIG5vdCB5ZXQgY29tcGxldGUuXHJcbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9iaXNlY3RfID0gZnVuY3Rpb24odGV4dDEsIHRleHQyLCBkZWFkbGluZSkge1xyXG4gIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cclxuICB2YXIgdGV4dDFfbGVuZ3RoID0gdGV4dDEubGVuZ3RoO1xyXG4gIHZhciB0ZXh0Ml9sZW5ndGggPSB0ZXh0Mi5sZW5ndGg7XHJcbiAgdmFyIG1heF9kID0gTWF0aC5jZWlsKCh0ZXh0MV9sZW5ndGggKyB0ZXh0Ml9sZW5ndGgpIC8gMik7XHJcbiAgdmFyIHZfb2Zmc2V0ID0gbWF4X2Q7XHJcbiAgdmFyIHZfbGVuZ3RoID0gMiAqIG1heF9kO1xyXG4gIHZhciB2MSA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XHJcbiAgdmFyIHYyID0gbmV3IEFycmF5KHZfbGVuZ3RoKTtcclxuICAvLyBTZXR0aW5nIGFsbCBlbGVtZW50cyB0byAtMSBpcyBmYXN0ZXIgaW4gQ2hyb21lICYgRmlyZWZveCB0aGFuIG1peGluZ1xyXG4gIC8vIGludGVnZXJzIGFuZCB1bmRlZmluZWQuXHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB2X2xlbmd0aDsgeCsrKSB7XHJcbiAgICB2MVt4XSA9IC0xO1xyXG4gICAgdjJbeF0gPSAtMTtcclxuICB9XHJcbiAgdjFbdl9vZmZzZXQgKyAxXSA9IDA7XHJcbiAgdjJbdl9vZmZzZXQgKyAxXSA9IDA7XHJcbiAgdmFyIGRlbHRhID0gdGV4dDFfbGVuZ3RoIC0gdGV4dDJfbGVuZ3RoO1xyXG4gIC8vIElmIHRoZSB0b3RhbCBudW1iZXIgb2YgY2hhcmFjdGVycyBpcyBvZGQsIHRoZW4gdGhlIGZyb250IHBhdGggd2lsbCBjb2xsaWRlXHJcbiAgLy8gd2l0aCB0aGUgcmV2ZXJzZSBwYXRoLlxyXG4gIHZhciBmcm9udCA9IChkZWx0YSAlIDIgIT0gMCk7XHJcbiAgLy8gT2Zmc2V0cyBmb3Igc3RhcnQgYW5kIGVuZCBvZiBrIGxvb3AuXHJcbiAgLy8gUHJldmVudHMgbWFwcGluZyBvZiBzcGFjZSBiZXlvbmQgdGhlIGdyaWQuXHJcbiAgdmFyIGsxc3RhcnQgPSAwO1xyXG4gIHZhciBrMWVuZCA9IDA7XHJcbiAgdmFyIGsyc3RhcnQgPSAwO1xyXG4gIHZhciBrMmVuZCA9IDA7XHJcbiAgZm9yICh2YXIgZCA9IDA7IGQgPCBtYXhfZDsgZCsrKSB7XHJcbiAgICAvLyBCYWlsIG91dCBpZiBkZWFkbGluZSBpcyByZWFjaGVkLlxyXG4gICAgaWYgKChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgPiBkZWFkbGluZSkge1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICAvLyBXYWxrIHRoZSBmcm9udCBwYXRoIG9uZSBzdGVwLlxyXG4gICAgZm9yICh2YXIgazEgPSAtZCArIGsxc3RhcnQ7IGsxIDw9IGQgLSBrMWVuZDsgazEgKz0gMikge1xyXG4gICAgICB2YXIgazFfb2Zmc2V0ID0gdl9vZmZzZXQgKyBrMTtcclxuICAgICAgdmFyIHgxO1xyXG4gICAgICBpZiAoazEgPT0gLWQgfHwgKGsxICE9IGQgJiYgdjFbazFfb2Zmc2V0IC0gMV0gPCB2MVtrMV9vZmZzZXQgKyAxXSkpIHtcclxuICAgICAgICB4MSA9IHYxW2sxX29mZnNldCArIDFdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHgxID0gdjFbazFfb2Zmc2V0IC0gMV0gKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB5MSA9IHgxIC0gazE7XHJcbiAgICAgIHdoaWxlICh4MSA8IHRleHQxX2xlbmd0aCAmJiB5MSA8IHRleHQyX2xlbmd0aCAmJlxyXG4gICAgICAgICAgICAgdGV4dDEuY2hhckF0KHgxKSA9PSB0ZXh0Mi5jaGFyQXQoeTEpKSB7XHJcbiAgICAgICAgeDErKztcclxuICAgICAgICB5MSsrO1xyXG4gICAgICB9XHJcbiAgICAgIHYxW2sxX29mZnNldF0gPSB4MTtcclxuICAgICAgaWYgKHgxID4gdGV4dDFfbGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gUmFuIG9mZiB0aGUgcmlnaHQgb2YgdGhlIGdyYXBoLlxyXG4gICAgICAgIGsxZW5kICs9IDI7XHJcbiAgICAgIH0gZWxzZSBpZiAoeTEgPiB0ZXh0Ml9sZW5ndGgpIHtcclxuICAgICAgICAvLyBSYW4gb2ZmIHRoZSBib3R0b20gb2YgdGhlIGdyYXBoLlxyXG4gICAgICAgIGsxc3RhcnQgKz0gMjtcclxuICAgICAgfSBlbHNlIGlmIChmcm9udCkge1xyXG4gICAgICAgIHZhciBrMl9vZmZzZXQgPSB2X29mZnNldCArIGRlbHRhIC0gazE7XHJcbiAgICAgICAgaWYgKGsyX29mZnNldCA+PSAwICYmIGsyX29mZnNldCA8IHZfbGVuZ3RoICYmIHYyW2syX29mZnNldF0gIT0gLTEpIHtcclxuICAgICAgICAgIC8vIE1pcnJvciB4MiBvbnRvIHRvcC1sZWZ0IGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAgICAgICAgdmFyIHgyID0gdGV4dDFfbGVuZ3RoIC0gdjJbazJfb2Zmc2V0XTtcclxuICAgICAgICAgIGlmICh4MSA+PSB4Mikge1xyXG4gICAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFdhbGsgdGhlIHJldmVyc2UgcGF0aCBvbmUgc3RlcC5cclxuICAgIGZvciAodmFyIGsyID0gLWQgKyBrMnN0YXJ0OyBrMiA8PSBkIC0gazJlbmQ7IGsyICs9IDIpIHtcclxuICAgICAgdmFyIGsyX29mZnNldCA9IHZfb2Zmc2V0ICsgazI7XHJcbiAgICAgIHZhciB4MjtcclxuICAgICAgaWYgKGsyID09IC1kIHx8IChrMiAhPSBkICYmIHYyW2syX29mZnNldCAtIDFdIDwgdjJbazJfb2Zmc2V0ICsgMV0pKSB7XHJcbiAgICAgICAgeDIgPSB2MltrMl9vZmZzZXQgKyAxXTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4MiA9IHYyW2syX29mZnNldCAtIDFdICsgMTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgeTIgPSB4MiAtIGsyO1xyXG4gICAgICB3aGlsZSAoeDIgPCB0ZXh0MV9sZW5ndGggJiYgeTIgPCB0ZXh0Ml9sZW5ndGggJiZcclxuICAgICAgICAgICAgIHRleHQxLmNoYXJBdCh0ZXh0MV9sZW5ndGggLSB4MiAtIDEpID09XHJcbiAgICAgICAgICAgICB0ZXh0Mi5jaGFyQXQodGV4dDJfbGVuZ3RoIC0geTIgLSAxKSkge1xyXG4gICAgICAgIHgyKys7XHJcbiAgICAgICAgeTIrKztcclxuICAgICAgfVxyXG4gICAgICB2MltrMl9vZmZzZXRdID0geDI7XHJcbiAgICAgIGlmICh4MiA+IHRleHQxX2xlbmd0aCkge1xyXG4gICAgICAgIC8vIFJhbiBvZmYgdGhlIGxlZnQgb2YgdGhlIGdyYXBoLlxyXG4gICAgICAgIGsyZW5kICs9IDI7XHJcbiAgICAgIH0gZWxzZSBpZiAoeTIgPiB0ZXh0Ml9sZW5ndGgpIHtcclxuICAgICAgICAvLyBSYW4gb2ZmIHRoZSB0b3Agb2YgdGhlIGdyYXBoLlxyXG4gICAgICAgIGsyc3RhcnQgKz0gMjtcclxuICAgICAgfSBlbHNlIGlmICghZnJvbnQpIHtcclxuICAgICAgICB2YXIgazFfb2Zmc2V0ID0gdl9vZmZzZXQgKyBkZWx0YSAtIGsyO1xyXG4gICAgICAgIGlmIChrMV9vZmZzZXQgPj0gMCAmJiBrMV9vZmZzZXQgPCB2X2xlbmd0aCAmJiB2MVtrMV9vZmZzZXRdICE9IC0xKSB7XHJcbiAgICAgICAgICB2YXIgeDEgPSB2MVtrMV9vZmZzZXRdO1xyXG4gICAgICAgICAgdmFyIHkxID0gdl9vZmZzZXQgKyB4MSAtIGsxX29mZnNldDtcclxuICAgICAgICAgIC8vIE1pcnJvciB4MiBvbnRvIHRvcC1sZWZ0IGNvb3JkaW5hdGUgc3lzdGVtLlxyXG4gICAgICAgICAgeDIgPSB0ZXh0MV9sZW5ndGggLSB4MjtcclxuICAgICAgICAgIGlmICh4MSA+PSB4Mikge1xyXG4gICAgICAgICAgICAvLyBPdmVybGFwIGRldGVjdGVkLlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaWZmX2Jpc2VjdFNwbGl0Xyh0ZXh0MSwgdGV4dDIsIHgxLCB5MSwgZGVhZGxpbmUpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICAvLyBEaWZmIHRvb2sgdG9vIGxvbmcgYW5kIGhpdCB0aGUgZGVhZGxpbmUgb3JcclxuICAvLyBudW1iZXIgb2YgZGlmZnMgZXF1YWxzIG51bWJlciBvZiBjaGFyYWN0ZXJzLCBubyBjb21tb25hbGl0eSBhdCBhbGwuXHJcbiAgcmV0dXJuIFtbRElGRl9ERUxFVEUsIHRleHQxXSwgW0RJRkZfSU5TRVJULCB0ZXh0Ml1dO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiB0aGUgbG9jYXRpb24gb2YgdGhlICdtaWRkbGUgc25ha2UnLCBzcGxpdCB0aGUgZGlmZiBpbiB0d28gcGFydHNcclxuICogYW5kIHJlY3Vyc2UuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBPbGQgc3RyaW5nIHRvIGJlIGRpZmZlZC5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIE5ldyBzdHJpbmcgdG8gYmUgZGlmZmVkLlxyXG4gKiBAcGFyYW0ge251bWJlcn0geCBJbmRleCBvZiBzcGxpdCBwb2ludCBpbiB0ZXh0MS5cclxuICogQHBhcmFtIHtudW1iZXJ9IHkgSW5kZXggb2Ygc3BsaXQgcG9pbnQgaW4gdGV4dDIuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWFkbGluZSBUaW1lIGF0IHdoaWNoIHRvIGJhaWwgaWYgbm90IHlldCBjb21wbGV0ZS5cclxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2Jpc2VjdFNwbGl0XyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0MiwgeCwgeSxcclxuICAgIGRlYWRsaW5lKSB7XHJcbiAgdmFyIHRleHQxYSA9IHRleHQxLnN1YnN0cmluZygwLCB4KTtcclxuICB2YXIgdGV4dDJhID0gdGV4dDIuc3Vic3RyaW5nKDAsIHkpO1xyXG4gIHZhciB0ZXh0MWIgPSB0ZXh0MS5zdWJzdHJpbmcoeCk7XHJcbiAgdmFyIHRleHQyYiA9IHRleHQyLnN1YnN0cmluZyh5KTtcclxuXHJcbiAgLy8gQ29tcHV0ZSBib3RoIGRpZmZzIHNlcmlhbGx5LlxyXG4gIHZhciBkaWZmcyA9IHRoaXMuZGlmZl9tYWluKHRleHQxYSwgdGV4dDJhLCBmYWxzZSwgZGVhZGxpbmUpO1xyXG4gIHZhciBkaWZmc2IgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MWIsIHRleHQyYiwgZmFsc2UsIGRlYWRsaW5lKTtcclxuXHJcbiAgcmV0dXJuIGRpZmZzLmNvbmNhdChkaWZmc2IpO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBTcGxpdCB0d28gdGV4dHMgaW50byBhbiBhcnJheSBvZiBzdHJpbmdzLiAgUmVkdWNlIHRoZSB0ZXh0cyB0byBhIHN0cmluZyBvZlxyXG4gKiBoYXNoZXMgd2hlcmUgZWFjaCBVbmljb2RlIGNoYXJhY3RlciByZXByZXNlbnRzIG9uZSBsaW5lLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cclxuICogQHJldHVybiB7e2NoYXJzMTogc3RyaW5nLCBjaGFyczI6IHN0cmluZywgbGluZUFycmF5OiAhQXJyYXkuPHN0cmluZz59fVxyXG4gKiAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVuY29kZWQgdGV4dDEsIHRoZSBlbmNvZGVkIHRleHQyIGFuZFxyXG4gKiAgICAgdGhlIGFycmF5IG9mIHVuaXF1ZSBzdHJpbmdzLlxyXG4gKiAgICAgVGhlIHplcm90aCBlbGVtZW50IG9mIHRoZSBhcnJheSBvZiB1bmlxdWUgc3RyaW5ncyBpcyBpbnRlbnRpb25hbGx5IGJsYW5rLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9saW5lc1RvQ2hhcnNfID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XHJcbiAgdmFyIGxpbmVBcnJheSA9IFtdOyAgLy8gZS5nLiBsaW5lQXJyYXlbNF0gPT0gJ0hlbGxvXFxuJ1xyXG4gIHZhciBsaW5lSGFzaCA9IHt9OyAgIC8vIGUuZy4gbGluZUhhc2hbJ0hlbGxvXFxuJ10gPT0gNFxyXG5cclxuICAvLyAnXFx4MDAnIGlzIGEgdmFsaWQgY2hhcmFjdGVyLCBidXQgdmFyaW91cyBkZWJ1Z2dlcnMgZG9uJ3QgbGlrZSBpdC5cclxuICAvLyBTbyB3ZSdsbCBpbnNlcnQgYSBqdW5rIGVudHJ5IHRvIGF2b2lkIGdlbmVyYXRpbmcgYSBudWxsIGNoYXJhY3Rlci5cclxuICBsaW5lQXJyYXlbMF0gPSAnJztcclxuXHJcbiAgLyoqXHJcbiAgICogU3BsaXQgYSB0ZXh0IGludG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy4gIFJlZHVjZSB0aGUgdGV4dHMgdG8gYSBzdHJpbmcgb2ZcclxuICAgKiBoYXNoZXMgd2hlcmUgZWFjaCBVbmljb2RlIGNoYXJhY3RlciByZXByZXNlbnRzIG9uZSBsaW5lLlxyXG4gICAqIE1vZGlmaWVzIGxpbmVhcnJheSBhbmQgbGluZWhhc2ggdGhyb3VnaCBiZWluZyBhIGNsb3N1cmUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgU3RyaW5nIHRvIGVuY29kZS5cclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEVuY29kZWQgc3RyaW5nLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8odGV4dCkge1xyXG4gICAgdmFyIGNoYXJzID0gJyc7XHJcbiAgICAvLyBXYWxrIHRoZSB0ZXh0LCBwdWxsaW5nIG91dCBhIHN1YnN0cmluZyBmb3IgZWFjaCBsaW5lLlxyXG4gICAgLy8gdGV4dC5zcGxpdCgnXFxuJykgd291bGQgd291bGQgdGVtcG9yYXJpbHkgZG91YmxlIG91ciBtZW1vcnkgZm9vdHByaW50LlxyXG4gICAgLy8gTW9kaWZ5aW5nIHRleHQgd291bGQgY3JlYXRlIG1hbnkgbGFyZ2Ugc3RyaW5ncyB0byBnYXJiYWdlIGNvbGxlY3QuXHJcbiAgICB2YXIgbGluZVN0YXJ0ID0gMDtcclxuICAgIHZhciBsaW5lRW5kID0gLTE7XHJcbiAgICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhcmlhYmxlIGlzIGZhc3RlciB0aGFuIGxvb2tpbmcgaXQgdXAuXHJcbiAgICB2YXIgbGluZUFycmF5TGVuZ3RoID0gbGluZUFycmF5Lmxlbmd0aDtcclxuICAgIHdoaWxlIChsaW5lRW5kIDwgdGV4dC5sZW5ndGggLSAxKSB7XHJcbiAgICAgIGxpbmVFbmQgPSB0ZXh0LmluZGV4T2YoJ1xcbicsIGxpbmVTdGFydCk7XHJcbiAgICAgIGlmIChsaW5lRW5kID09IC0xKSB7XHJcbiAgICAgICAgbGluZUVuZCA9IHRleHQubGVuZ3RoIC0gMTtcclxuICAgICAgfVxyXG4gICAgICB2YXIgbGluZSA9IHRleHQuc3Vic3RyaW5nKGxpbmVTdGFydCwgbGluZUVuZCArIDEpO1xyXG4gICAgICBsaW5lU3RhcnQgPSBsaW5lRW5kICsgMTtcclxuXHJcbiAgICAgIGlmIChsaW5lSGFzaC5oYXNPd25Qcm9wZXJ0eSA/IGxpbmVIYXNoLmhhc093blByb3BlcnR5KGxpbmUpIDpcclxuICAgICAgICAgIChsaW5lSGFzaFtsaW5lXSAhPT0gdW5kZWZpbmVkKSkge1xyXG4gICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUhhc2hbbGluZV0pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUFycmF5TGVuZ3RoKTtcclxuICAgICAgICBsaW5lSGFzaFtsaW5lXSA9IGxpbmVBcnJheUxlbmd0aDtcclxuICAgICAgICBsaW5lQXJyYXlbbGluZUFycmF5TGVuZ3RoKytdID0gbGluZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoYXJzO1xyXG4gIH1cclxuXHJcbiAgdmFyIGNoYXJzMSA9IGRpZmZfbGluZXNUb0NoYXJzTXVuZ2VfKHRleHQxKTtcclxuICB2YXIgY2hhcnMyID0gZGlmZl9saW5lc1RvQ2hhcnNNdW5nZV8odGV4dDIpO1xyXG4gIHJldHVybiB7Y2hhcnMxOiBjaGFyczEsIGNoYXJzMjogY2hhcnMyLCBsaW5lQXJyYXk6IGxpbmVBcnJheX07XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFJlaHlkcmF0ZSB0aGUgdGV4dCBpbiBhIGRpZmYgZnJvbSBhIHN0cmluZyBvZiBsaW5lIGhhc2hlcyB0byByZWFsIGxpbmVzIG9mXHJcbiAqIHRleHQuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjxzdHJpbmc+fSBsaW5lQXJyYXkgQXJyYXkgb2YgdW5pcXVlIHN0cmluZ3MuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NoYXJzVG9MaW5lc18gPSBmdW5jdGlvbihkaWZmcywgbGluZUFycmF5KSB7XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xyXG4gICAgdmFyIGNoYXJzID0gZGlmZnNbeF1bMV07XHJcbiAgICB2YXIgdGV4dCA9IFtdO1xyXG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjaGFycy5sZW5ndGg7IHkrKykge1xyXG4gICAgICB0ZXh0W3ldID0gbGluZUFycmF5W2NoYXJzLmNoYXJDb2RlQXQoeSldO1xyXG4gICAgfVxyXG4gICAgZGlmZnNbeF1bMV0gPSB0ZXh0LmpvaW4oJycpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lIHRoZSBjb21tb24gcHJlZml4IG9mIHR3byBzdHJpbmdzLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDEgRmlyc3Qgc3RyaW5nLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dDIgU2Vjb25kIHN0cmluZy5cclxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgY29tbW9uIHRvIHRoZSBzdGFydCBvZiBlYWNoXHJcbiAqICAgICBzdHJpbmcuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NvbW1vblByZWZpeCA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xyXG4gIC8vIFF1aWNrIGNoZWNrIGZvciBjb21tb24gbnVsbCBjYXNlcy5cclxuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MS5jaGFyQXQoMCkgIT0gdGV4dDIuY2hhckF0KDApKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgLy8gQmluYXJ5IHNlYXJjaC5cclxuICAvLyBQZXJmb3JtYW5jZSBhbmFseXNpczogaHR0cDovL25laWwuZnJhc2VyLm5hbWUvbmV3cy8yMDA3LzEwLzA5L1xyXG4gIHZhciBwb2ludGVybWluID0gMDtcclxuICB2YXIgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcclxuICB2YXIgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XHJcbiAgdmFyIHBvaW50ZXJzdGFydCA9IDA7XHJcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XHJcbiAgICBpZiAodGV4dDEuc3Vic3RyaW5nKHBvaW50ZXJzdGFydCwgcG9pbnRlcm1pZCkgPT1cclxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSkge1xyXG4gICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcclxuICAgICAgcG9pbnRlcnN0YXJ0ID0gcG9pbnRlcm1pbjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBvaW50ZXJtYXggPSBwb2ludGVybWlkO1xyXG4gICAgfVxyXG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcclxuICB9XHJcbiAgcmV0dXJuIHBvaW50ZXJtaWQ7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSB0aGUgY29tbW9uIHN1ZmZpeCBvZiB0d28gc3RyaW5ncy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXHJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGNvbW1vbiB0byB0aGUgZW5kIG9mIGVhY2ggc3RyaW5nLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25TdWZmaXggPSBmdW5jdGlvbih0ZXh0MSwgdGV4dDIpIHtcclxuICAvLyBRdWljayBjaGVjayBmb3IgY29tbW9uIG51bGwgY2FzZXMuXHJcbiAgaWYgKCF0ZXh0MSB8fCAhdGV4dDIgfHxcclxuICAgICAgdGV4dDEuY2hhckF0KHRleHQxLmxlbmd0aCAtIDEpICE9IHRleHQyLmNoYXJBdCh0ZXh0Mi5sZW5ndGggLSAxKSkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIC8vIEJpbmFyeSBzZWFyY2guXHJcbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAwNy8xMC8wOS9cclxuICB2YXIgcG9pbnRlcm1pbiA9IDA7XHJcbiAgdmFyIHBvaW50ZXJtYXggPSBNYXRoLm1pbih0ZXh0MS5sZW5ndGgsIHRleHQyLmxlbmd0aCk7XHJcbiAgdmFyIHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xyXG4gIHZhciBwb2ludGVyZW5kID0gMDtcclxuICB3aGlsZSAocG9pbnRlcm1pbiA8IHBvaW50ZXJtaWQpIHtcclxuICAgIGlmICh0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDEubGVuZ3RoIC0gcG9pbnRlcmVuZCkgPT1cclxuICAgICAgICB0ZXh0Mi5zdWJzdHJpbmcodGV4dDIubGVuZ3RoIC0gcG9pbnRlcm1pZCwgdGV4dDIubGVuZ3RoIC0gcG9pbnRlcmVuZCkpIHtcclxuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XHJcbiAgICAgIHBvaW50ZXJlbmQgPSBwb2ludGVybWluO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcG9pbnRlcm1heCA9IHBvaW50ZXJtaWQ7XHJcbiAgICB9XHJcbiAgICBwb2ludGVybWlkID0gTWF0aC5mbG9vcigocG9pbnRlcm1heCAtIHBvaW50ZXJtaW4pIC8gMiArIHBvaW50ZXJtaW4pO1xyXG4gIH1cclxuICByZXR1cm4gcG9pbnRlcm1pZDtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lIGlmIHRoZSBzdWZmaXggb2Ygb25lIHN0cmluZyBpcyB0aGUgcHJlZml4IG9mIGFub3RoZXIuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBGaXJzdCBzdHJpbmcuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MiBTZWNvbmQgc3RyaW5nLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyBjb21tb24gdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3RcclxuICogICAgIHN0cmluZyBhbmQgdGhlIHN0YXJ0IG9mIHRoZSBzZWNvbmQgc3RyaW5nLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jb21tb25PdmVybGFwXyA9IGZ1bmN0aW9uKHRleHQxLCB0ZXh0Mikge1xyXG4gIC8vIENhY2hlIHRoZSB0ZXh0IGxlbmd0aHMgdG8gcHJldmVudCBtdWx0aXBsZSBjYWxscy5cclxuICB2YXIgdGV4dDFfbGVuZ3RoID0gdGV4dDEubGVuZ3RoO1xyXG4gIHZhciB0ZXh0Ml9sZW5ndGggPSB0ZXh0Mi5sZW5ndGg7XHJcbiAgLy8gRWxpbWluYXRlIHRoZSBudWxsIGNhc2UuXHJcbiAgaWYgKHRleHQxX2xlbmd0aCA9PSAwIHx8IHRleHQyX2xlbmd0aCA9PSAwKSB7XHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcbiAgLy8gVHJ1bmNhdGUgdGhlIGxvbmdlciBzdHJpbmcuXHJcbiAgaWYgKHRleHQxX2xlbmd0aCA+IHRleHQyX2xlbmd0aCkge1xyXG4gICAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDFfbGVuZ3RoIC0gdGV4dDJfbGVuZ3RoKTtcclxuICB9IGVsc2UgaWYgKHRleHQxX2xlbmd0aCA8IHRleHQyX2xlbmd0aCkge1xyXG4gICAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDFfbGVuZ3RoKTtcclxuICB9XHJcbiAgdmFyIHRleHRfbGVuZ3RoID0gTWF0aC5taW4odGV4dDFfbGVuZ3RoLCB0ZXh0Ml9sZW5ndGgpO1xyXG4gIC8vIFF1aWNrIGNoZWNrIGZvciB0aGUgd29yc3QgY2FzZS5cclxuICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcclxuICAgIHJldHVybiB0ZXh0X2xlbmd0aDtcclxuICB9XHJcblxyXG4gIC8vIFN0YXJ0IGJ5IGxvb2tpbmcgZm9yIGEgc2luZ2xlIGNoYXJhY3RlciBtYXRjaFxyXG4gIC8vIGFuZCBpbmNyZWFzZSBsZW5ndGggdW50aWwgbm8gbWF0Y2ggaXMgZm91bmQuXHJcbiAgLy8gUGVyZm9ybWFuY2UgYW5hbHlzaXM6IGh0dHA6Ly9uZWlsLmZyYXNlci5uYW1lL25ld3MvMjAxMC8xMS8wNC9cclxuICB2YXIgYmVzdCA9IDA7XHJcbiAgdmFyIGxlbmd0aCA9IDE7XHJcbiAgd2hpbGUgKHRydWUpIHtcclxuICAgIHZhciBwYXR0ZXJuID0gdGV4dDEuc3Vic3RyaW5nKHRleHRfbGVuZ3RoIC0gbGVuZ3RoKTtcclxuICAgIHZhciBmb3VuZCA9IHRleHQyLmluZGV4T2YocGF0dGVybik7XHJcbiAgICBpZiAoZm91bmQgPT0gLTEpIHtcclxuICAgICAgcmV0dXJuIGJlc3Q7XHJcbiAgICB9XHJcbiAgICBsZW5ndGggKz0gZm91bmQ7XHJcbiAgICBpZiAoZm91bmQgPT0gMCB8fCB0ZXh0MS5zdWJzdHJpbmcodGV4dF9sZW5ndGggLSBsZW5ndGgpID09XHJcbiAgICAgICAgdGV4dDIuc3Vic3RyaW5nKDAsIGxlbmd0aCkpIHtcclxuICAgICAgYmVzdCA9IGxlbmd0aDtcclxuICAgICAgbGVuZ3RoKys7XHJcbiAgICB9XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBEbyB0aGUgdHdvIHRleHRzIHNoYXJlIGEgc3Vic3RyaW5nIHdoaWNoIGlzIGF0IGxlYXN0IGhhbGYgdGhlIGxlbmd0aCBvZiB0aGVcclxuICogbG9uZ2VyIHRleHQ/XHJcbiAqIFRoaXMgc3BlZWR1cCBjYW4gcHJvZHVjZSBub24tbWluaW1hbCBkaWZmcy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQxIEZpcnN0IHN0cmluZy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQyIFNlY29uZCBzdHJpbmcuXHJcbiAqIEByZXR1cm4ge0FycmF5LjxzdHJpbmc+fSBGaXZlIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlIHByZWZpeCBvZlxyXG4gKiAgICAgdGV4dDEsIHRoZSBzdWZmaXggb2YgdGV4dDEsIHRoZSBwcmVmaXggb2YgdGV4dDIsIHRoZSBzdWZmaXggb2ZcclxuICogICAgIHRleHQyIGFuZCB0aGUgY29tbW9uIG1pZGRsZS4gIE9yIG51bGwgaWYgdGhlcmUgd2FzIG5vIG1hdGNoLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9oYWxmTWF0Y2hfID0gZnVuY3Rpb24odGV4dDEsIHRleHQyKSB7XHJcbiAgaWYgKHRoaXMuRGlmZl9UaW1lb3V0IDw9IDApIHtcclxuICAgIC8vIERvbid0IHJpc2sgcmV0dXJuaW5nIGEgbm9uLW9wdGltYWwgZGlmZiBpZiB3ZSBoYXZlIHVubGltaXRlZCB0aW1lLlxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHZhciBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XHJcbiAgdmFyIHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XHJcbiAgaWYgKGxvbmd0ZXh0Lmxlbmd0aCA8IDQgfHwgc2hvcnR0ZXh0Lmxlbmd0aCAqIDIgPCBsb25ndGV4dC5sZW5ndGgpIHtcclxuICAgIHJldHVybiBudWxsOyAgLy8gUG9pbnRsZXNzLlxyXG4gIH1cclxuICB2YXIgZG1wID0gdGhpczsgIC8vICd0aGlzJyBiZWNvbWVzICd3aW5kb3cnIGluIGEgY2xvc3VyZS5cclxuXHJcbiAgLyoqXHJcbiAgICogRG9lcyBhIHN1YnN0cmluZyBvZiBzaG9ydHRleHQgZXhpc3Qgd2l0aGluIGxvbmd0ZXh0IHN1Y2ggdGhhdCB0aGUgc3Vic3RyaW5nXHJcbiAgICogaXMgYXQgbGVhc3QgaGFsZiB0aGUgbGVuZ3RoIG9mIGxvbmd0ZXh0P1xyXG4gICAqIENsb3N1cmUsIGJ1dCBkb2VzIG5vdCByZWZlcmVuY2UgYW55IGV4dGVybmFsIHZhcmlhYmxlcy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9uZ3RleHQgTG9uZ2VyIHN0cmluZy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2hvcnR0ZXh0IFNob3J0ZXIgc3RyaW5nLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpIFN0YXJ0IGluZGV4IG9mIHF1YXJ0ZXIgbGVuZ3RoIHN1YnN0cmluZyB3aXRoaW4gbG9uZ3RleHQuXHJcbiAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59IEZpdmUgZWxlbWVudCBBcnJheSwgY29udGFpbmluZyB0aGUgcHJlZml4IG9mXHJcbiAgICogICAgIGxvbmd0ZXh0LCB0aGUgc3VmZml4IG9mIGxvbmd0ZXh0LCB0aGUgcHJlZml4IG9mIHNob3J0dGV4dCwgdGhlIHN1ZmZpeFxyXG4gICAqICAgICBvZiBzaG9ydHRleHQgYW5kIHRoZSBjb21tb24gbWlkZGxlLiAgT3IgbnVsbCBpZiB0aGVyZSB3YXMgbm8gbWF0Y2guXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBmdW5jdGlvbiBkaWZmX2hhbGZNYXRjaElfKGxvbmd0ZXh0LCBzaG9ydHRleHQsIGkpIHtcclxuICAgIC8vIFN0YXJ0IHdpdGggYSAxLzQgbGVuZ3RoIHN1YnN0cmluZyBhdCBwb3NpdGlvbiBpIGFzIGEgc2VlZC5cclxuICAgIHZhciBzZWVkID0gbG9uZ3RleHQuc3Vic3RyaW5nKGksIGkgKyBNYXRoLmZsb29yKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpKTtcclxuICAgIHZhciBqID0gLTE7XHJcbiAgICB2YXIgYmVzdF9jb21tb24gPSAnJztcclxuICAgIHZhciBiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYiwgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYjtcclxuICAgIHdoaWxlICgoaiA9IHNob3J0dGV4dC5pbmRleE9mKHNlZWQsIGogKyAxKSkgIT0gLTEpIHtcclxuICAgICAgdmFyIHByZWZpeExlbmd0aCA9IGRtcC5kaWZmX2NvbW1vblByZWZpeChsb25ndGV4dC5zdWJzdHJpbmcoaSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZyhqKSk7XHJcbiAgICAgIHZhciBzdWZmaXhMZW5ndGggPSBkbXAuZGlmZl9jb21tb25TdWZmaXgobG9uZ3RleHQuc3Vic3RyaW5nKDAsIGkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3J0dGV4dC5zdWJzdHJpbmcoMCwgaikpO1xyXG4gICAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoIDwgc3VmZml4TGVuZ3RoICsgcHJlZml4TGVuZ3RoKSB7XHJcbiAgICAgICAgYmVzdF9jb21tb24gPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogLSBzdWZmaXhMZW5ndGgsIGopICtcclxuICAgICAgICAgICAgc2hvcnR0ZXh0LnN1YnN0cmluZyhqLCBqICsgcHJlZml4TGVuZ3RoKTtcclxuICAgICAgICBiZXN0X2xvbmd0ZXh0X2EgPSBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSAtIHN1ZmZpeExlbmd0aCk7XHJcbiAgICAgICAgYmVzdF9sb25ndGV4dF9iID0gbG9uZ3RleHQuc3Vic3RyaW5nKGkgKyBwcmVmaXhMZW5ndGgpO1xyXG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EgPSBzaG9ydHRleHQuc3Vic3RyaW5nKDAsIGogLSBzdWZmaXhMZW5ndGgpO1xyXG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2IgPSBzaG9ydHRleHQuc3Vic3RyaW5nKGogKyBwcmVmaXhMZW5ndGgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoICogMiA+PSBsb25ndGV4dC5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuIFtiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYixcclxuICAgICAgICAgICAgICBiZXN0X3Nob3J0dGV4dF9hLCBiZXN0X3Nob3J0dGV4dF9iLCBiZXN0X2NvbW1vbl07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSBzZWNvbmQgcXVhcnRlciBpcyB0aGUgc2VlZCBmb3IgYSBoYWxmLW1hdGNoLlxyXG4gIHZhciBobTEgPSBkaWZmX2hhbGZNYXRjaElfKGxvbmd0ZXh0LCBzaG9ydHRleHQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKGxvbmd0ZXh0Lmxlbmd0aCAvIDQpKTtcclxuICAvLyBDaGVjayBhZ2FpbiBiYXNlZCBvbiB0aGUgdGhpcmQgcXVhcnRlci5cclxuICB2YXIgaG0yID0gZGlmZl9oYWxmTWF0Y2hJXyhsb25ndGV4dCwgc2hvcnR0ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyAyKSk7XHJcbiAgdmFyIGhtO1xyXG4gIGlmICghaG0xICYmICFobTIpIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0gZWxzZSBpZiAoIWhtMikge1xyXG4gICAgaG0gPSBobTE7XHJcbiAgfSBlbHNlIGlmICghaG0xKSB7XHJcbiAgICBobSA9IGhtMjtcclxuICB9IGVsc2Uge1xyXG4gICAgLy8gQm90aCBtYXRjaGVkLiAgU2VsZWN0IHRoZSBsb25nZXN0LlxyXG4gICAgaG0gPSBobTFbNF0ubGVuZ3RoID4gaG0yWzRdLmxlbmd0aCA/IGhtMSA6IGhtMjtcclxuICB9XHJcblxyXG4gIC8vIEEgaGFsZi1tYXRjaCB3YXMgZm91bmQsIHNvcnQgb3V0IHRoZSByZXR1cm4gZGF0YS5cclxuICB2YXIgdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYjtcclxuICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKSB7XHJcbiAgICB0ZXh0MV9hID0gaG1bMF07XHJcbiAgICB0ZXh0MV9iID0gaG1bMV07XHJcbiAgICB0ZXh0Ml9hID0gaG1bMl07XHJcbiAgICB0ZXh0Ml9iID0gaG1bM107XHJcbiAgfSBlbHNlIHtcclxuICAgIHRleHQyX2EgPSBobVswXTtcclxuICAgIHRleHQyX2IgPSBobVsxXTtcclxuICAgIHRleHQxX2EgPSBobVsyXTtcclxuICAgIHRleHQxX2IgPSBobVszXTtcclxuICB9XHJcbiAgdmFyIG1pZF9jb21tb24gPSBobVs0XTtcclxuICByZXR1cm4gW3RleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2IsIG1pZF9jb21tb25dO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBSZWR1Y2UgdGhlIG51bWJlciBvZiBlZGl0cyBieSBlbGltaW5hdGluZyBzZW1hbnRpY2FsbHkgdHJpdmlhbCBlcXVhbGl0aWVzLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9jbGVhbnVwU2VtYW50aWMgPSBmdW5jdGlvbihkaWZmcykge1xyXG4gIHZhciBjaGFuZ2VzID0gZmFsc2U7XHJcbiAgdmFyIGVxdWFsaXRpZXMgPSBbXTsgIC8vIFN0YWNrIG9mIGluZGljZXMgd2hlcmUgZXF1YWxpdGllcyBhcmUgZm91bmQuXHJcbiAgdmFyIGVxdWFsaXRpZXNMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxyXG4gIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cclxuICB2YXIgbGFzdGVxdWFsaXR5ID0gbnVsbDtcclxuICAvLyBBbHdheXMgZXF1YWwgdG8gZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV1dWzFdXHJcbiAgdmFyIHBvaW50ZXIgPSAwOyAgLy8gSW5kZXggb2YgY3VycmVudCBwb3NpdGlvbi5cclxuICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGNoYW5nZWQgcHJpb3IgdG8gdGhlIGVxdWFsaXR5LlxyXG4gIHZhciBsZW5ndGhfaW5zZXJ0aW9uczEgPSAwO1xyXG4gIHZhciBsZW5ndGhfZGVsZXRpb25zMSA9IDA7XHJcbiAgLy8gTnVtYmVyIG9mIGNoYXJhY3RlcnMgdGhhdCBjaGFuZ2VkIGFmdGVyIHRoZSBlcXVhbGl0eS5cclxuICB2YXIgbGVuZ3RoX2luc2VydGlvbnMyID0gMDtcclxuICB2YXIgbGVuZ3RoX2RlbGV0aW9uczIgPSAwO1xyXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XHJcbiAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9FUVVBTCkgeyAgLy8gRXF1YWxpdHkgZm91bmQuXHJcbiAgICAgIGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCsrXSA9IHBvaW50ZXI7XHJcbiAgICAgIGxlbmd0aF9pbnNlcnRpb25zMSA9IGxlbmd0aF9pbnNlcnRpb25zMjtcclxuICAgICAgbGVuZ3RoX2RlbGV0aW9uczEgPSBsZW5ndGhfZGVsZXRpb25zMjtcclxuICAgICAgbGVuZ3RoX2luc2VydGlvbnMyID0gMDtcclxuICAgICAgbGVuZ3RoX2RlbGV0aW9uczIgPSAwO1xyXG4gICAgICBsYXN0ZXF1YWxpdHkgPSBkaWZmc1twb2ludGVyXVsxXTtcclxuICAgIH0gZWxzZSB7ICAvLyBBbiBpbnNlcnRpb24gb3IgZGVsZXRpb24uXHJcbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PSBESUZGX0lOU0VSVCkge1xyXG4gICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczIgKz0gZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIEVsaW1pbmF0ZSBhbiBlcXVhbGl0eSB0aGF0IGlzIHNtYWxsZXIgb3IgZXF1YWwgdG8gdGhlIGVkaXRzIG9uIGJvdGhcclxuICAgICAgLy8gc2lkZXMgb2YgaXQuXHJcbiAgICAgIGlmIChsYXN0ZXF1YWxpdHkgJiYgKGxhc3RlcXVhbGl0eS5sZW5ndGggPD1cclxuICAgICAgICAgIE1hdGgubWF4KGxlbmd0aF9pbnNlcnRpb25zMSwgbGVuZ3RoX2RlbGV0aW9uczEpKSAmJlxyXG4gICAgICAgICAgKGxhc3RlcXVhbGl0eS5sZW5ndGggPD0gTWF0aC5tYXgobGVuZ3RoX2luc2VydGlvbnMyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczIpKSkge1xyXG4gICAgICAgIC8vIER1cGxpY2F0ZSByZWNvcmQuXHJcbiAgICAgICAgZGlmZnMuc3BsaWNlKGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdLCAwLFxyXG4gICAgICAgICAgICAgICAgICAgICBbRElGRl9ERUxFVEUsIGxhc3RlcXVhbGl0eV0pO1xyXG4gICAgICAgIC8vIENoYW5nZSBzZWNvbmQgY29weSB0byBpbnNlcnQuXHJcbiAgICAgICAgZGlmZnNbZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gKyAxXVswXSA9IERJRkZfSU5TRVJUO1xyXG4gICAgICAgIC8vIFRocm93IGF3YXkgdGhlIGVxdWFsaXR5IHdlIGp1c3QgZGVsZXRlZC5cclxuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XHJcbiAgICAgICAgLy8gVGhyb3cgYXdheSB0aGUgcHJldmlvdXMgZXF1YWxpdHkgKGl0IG5lZWRzIHRvIGJlIHJlZXZhbHVhdGVkKS5cclxuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XHJcbiAgICAgICAgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID8gZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0gOiAtMTtcclxuICAgICAgICBsZW5ndGhfaW5zZXJ0aW9uczEgPSAwOyAgLy8gUmVzZXQgdGhlIGNvdW50ZXJzLlxyXG4gICAgICAgIGxlbmd0aF9kZWxldGlvbnMxID0gMDtcclxuICAgICAgICBsZW5ndGhfaW5zZXJ0aW9uczIgPSAwO1xyXG4gICAgICAgIGxlbmd0aF9kZWxldGlvbnMyID0gMDtcclxuICAgICAgICBsYXN0ZXF1YWxpdHkgPSBudWxsO1xyXG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBwb2ludGVyKys7XHJcbiAgfVxyXG5cclxuICAvLyBOb3JtYWxpemUgdGhlIGRpZmYuXHJcbiAgaWYgKGNoYW5nZXMpIHtcclxuICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xyXG4gIH1cclxuICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xyXG5cclxuICAvLyBGaW5kIGFueSBvdmVybGFwcyBiZXR3ZWVuIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucy5cclxuICAvLyBlLmc6IDxkZWw+YWJjeHh4PC9kZWw+PGlucz54eHhkZWY8L2lucz5cclxuICAvLyAgIC0+IDxkZWw+YWJjPC9kZWw+eHh4PGlucz5kZWY8L2lucz5cclxuICAvLyBlLmc6IDxkZWw+eHh4YWJjPC9kZWw+PGlucz5kZWZ4eHg8L2lucz5cclxuICAvLyAgIC0+IDxpbnM+ZGVmPC9pbnM+eHh4PGRlbD5hYmM8L2RlbD5cclxuICAvLyBPbmx5IGV4dHJhY3QgYW4gb3ZlcmxhcCBpZiBpdCBpcyBhcyBiaWcgYXMgdGhlIGVkaXQgYWhlYWQgb3IgYmVoaW5kIGl0LlxyXG4gIHBvaW50ZXIgPSAxO1xyXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XHJcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfREVMRVRFICYmXHJcbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9JTlNFUlQpIHtcclxuICAgICAgdmFyIGRlbGV0aW9uID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdO1xyXG4gICAgICB2YXIgaW5zZXJ0aW9uID0gZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICAgIHZhciBvdmVybGFwX2xlbmd0aDEgPSB0aGlzLmRpZmZfY29tbW9uT3ZlcmxhcF8oZGVsZXRpb24sIGluc2VydGlvbik7XHJcbiAgICAgIHZhciBvdmVybGFwX2xlbmd0aDIgPSB0aGlzLmRpZmZfY29tbW9uT3ZlcmxhcF8oaW5zZXJ0aW9uLCBkZWxldGlvbik7XHJcbiAgICAgIGlmIChvdmVybGFwX2xlbmd0aDEgPj0gb3ZlcmxhcF9sZW5ndGgyKSB7XHJcbiAgICAgICAgaWYgKG92ZXJsYXBfbGVuZ3RoMSA+PSBkZWxldGlvbi5sZW5ndGggLyAyIHx8XHJcbiAgICAgICAgICAgIG92ZXJsYXBfbGVuZ3RoMSA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikge1xyXG4gICAgICAgICAgLy8gT3ZlcmxhcCBmb3VuZC4gIEluc2VydCBhbiBlcXVhbGl0eSBhbmQgdHJpbSB0aGUgc3Vycm91bmRpbmcgZWRpdHMuXHJcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCxcclxuICAgICAgICAgICAgICBbRElGRl9FUVVBTCwgaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwX2xlbmd0aDEpXSk7XHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gPVxyXG4gICAgICAgICAgICAgIGRlbGV0aW9uLnN1YnN0cmluZygwLCBkZWxldGlvbi5sZW5ndGggLSBvdmVybGFwX2xlbmd0aDEpO1xyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gaW5zZXJ0aW9uLnN1YnN0cmluZyhvdmVybGFwX2xlbmd0aDEpO1xyXG4gICAgICAgICAgcG9pbnRlcisrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAob3ZlcmxhcF9sZW5ndGgyID49IGRlbGV0aW9uLmxlbmd0aCAvIDIgfHxcclxuICAgICAgICAgICAgb3ZlcmxhcF9sZW5ndGgyID49IGluc2VydGlvbi5sZW5ndGggLyAyKSB7XHJcbiAgICAgICAgICAvLyBSZXZlcnNlIG92ZXJsYXAgZm91bmQuXHJcbiAgICAgICAgICAvLyBJbnNlcnQgYW4gZXF1YWxpdHkgYW5kIHN3YXAgYW5kIHRyaW0gdGhlIHN1cnJvdW5kaW5nIGVkaXRzLlxyXG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsXHJcbiAgICAgICAgICAgICAgW0RJRkZfRVFVQUwsIGRlbGV0aW9uLnN1YnN0cmluZygwLCBvdmVybGFwX2xlbmd0aDIpXSk7XHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMF0gPSBESUZGX0lOU0VSVDtcclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9XHJcbiAgICAgICAgICAgICAgaW5zZXJ0aW9uLnN1YnN0cmluZygwLCBpbnNlcnRpb24ubGVuZ3RoIC0gb3ZlcmxhcF9sZW5ndGgyKTtcclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9IERJRkZfREVMRVRFO1xyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID1cclxuICAgICAgICAgICAgICBkZWxldGlvbi5zdWJzdHJpbmcob3ZlcmxhcF9sZW5ndGgyKTtcclxuICAgICAgICAgIHBvaW50ZXIrKztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcG9pbnRlcisrO1xyXG4gICAgfVxyXG4gICAgcG9pbnRlcisrO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogTG9vayBmb3Igc2luZ2xlIGVkaXRzIHN1cnJvdW5kZWQgb24gYm90aCBzaWRlcyBieSBlcXVhbGl0aWVzXHJcbiAqIHdoaWNoIGNhbiBiZSBzaGlmdGVkIHNpZGV3YXlzIHRvIGFsaWduIHRoZSBlZGl0IHRvIGEgd29yZCBib3VuZGFyeS5cclxuICogZS5nOiBUaGUgYzxpbnM+YXQgYzwvaW5zPmFtZS4gLT4gVGhlIDxpbnM+Y2F0IDwvaW5zPmNhbWUuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBTZW1hbnRpY0xvc3NsZXNzID0gZnVuY3Rpb24oZGlmZnMpIHtcclxuICAvKipcclxuICAgKiBHaXZlbiB0d28gc3RyaW5ncywgY29tcHV0ZSBhIHNjb3JlIHJlcHJlc2VudGluZyB3aGV0aGVyIHRoZSBpbnRlcm5hbFxyXG4gICAqIGJvdW5kYXJ5IGZhbGxzIG9uIGxvZ2ljYWwgYm91bmRhcmllcy5cclxuICAgKiBTY29yZXMgcmFuZ2UgZnJvbSA2IChiZXN0KSB0byAwICh3b3JzdCkuXHJcbiAgICogQ2xvc3VyZSwgYnV0IGRvZXMgbm90IHJlZmVyZW5jZSBhbnkgZXh0ZXJuYWwgdmFyaWFibGVzLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbmUgRmlyc3Qgc3RyaW5nLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0d28gU2Vjb25kIHN0cmluZy5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBzY29yZS5cclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKG9uZSwgdHdvKSB7XHJcbiAgICBpZiAoIW9uZSB8fCAhdHdvKSB7XHJcbiAgICAgIC8vIEVkZ2VzIGFyZSB0aGUgYmVzdC5cclxuICAgICAgcmV0dXJuIDY7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRWFjaCBwb3J0IG9mIHRoaXMgZnVuY3Rpb24gYmVoYXZlcyBzbGlnaHRseSBkaWZmZXJlbnRseSBkdWUgdG9cclxuICAgIC8vIHN1YnRsZSBkaWZmZXJlbmNlcyBpbiBlYWNoIGxhbmd1YWdlJ3MgZGVmaW5pdGlvbiBvZiB0aGluZ3MgbGlrZVxyXG4gICAgLy8gJ3doaXRlc3BhY2UnLiAgU2luY2UgdGhpcyBmdW5jdGlvbidzIHB1cnBvc2UgaXMgbGFyZ2VseSBjb3NtZXRpYyxcclxuICAgIC8vIHRoZSBjaG9pY2UgaGFzIGJlZW4gbWFkZSB0byB1c2UgZWFjaCBsYW5ndWFnZSdzIG5hdGl2ZSBmZWF0dXJlc1xyXG4gICAgLy8gcmF0aGVyIHRoYW4gZm9yY2UgdG90YWwgY29uZm9ybWl0eS5cclxuICAgIHZhciBjaGFyMSA9IG9uZS5jaGFyQXQob25lLmxlbmd0aCAtIDEpO1xyXG4gICAgdmFyIGNoYXIyID0gdHdvLmNoYXJBdCgwKTtcclxuICAgIHZhciBub25BbHBoYU51bWVyaWMxID0gY2hhcjEubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5ub25BbHBoYU51bWVyaWNSZWdleF8pO1xyXG4gICAgdmFyIG5vbkFscGhhTnVtZXJpYzIgPSBjaGFyMi5tYXRjaChkaWZmX21hdGNoX3BhdGNoLm5vbkFscGhhTnVtZXJpY1JlZ2V4Xyk7XHJcbiAgICB2YXIgd2hpdGVzcGFjZTEgPSBub25BbHBoYU51bWVyaWMxICYmXHJcbiAgICAgICAgY2hhcjEubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC53aGl0ZXNwYWNlUmVnZXhfKTtcclxuICAgIHZhciB3aGl0ZXNwYWNlMiA9IG5vbkFscGhhTnVtZXJpYzIgJiZcclxuICAgICAgICBjaGFyMi5tYXRjaChkaWZmX21hdGNoX3BhdGNoLndoaXRlc3BhY2VSZWdleF8pO1xyXG4gICAgdmFyIGxpbmVCcmVhazEgPSB3aGl0ZXNwYWNlMSAmJlxyXG4gICAgICAgIGNoYXIxLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2gubGluZWJyZWFrUmVnZXhfKTtcclxuICAgIHZhciBsaW5lQnJlYWsyID0gd2hpdGVzcGFjZTIgJiZcclxuICAgICAgICBjaGFyMi5tYXRjaChkaWZmX21hdGNoX3BhdGNoLmxpbmVicmVha1JlZ2V4Xyk7XHJcbiAgICB2YXIgYmxhbmtMaW5lMSA9IGxpbmVCcmVhazEgJiZcclxuICAgICAgICBvbmUubWF0Y2goZGlmZl9tYXRjaF9wYXRjaC5ibGFua2xpbmVFbmRSZWdleF8pO1xyXG4gICAgdmFyIGJsYW5rTGluZTIgPSBsaW5lQnJlYWsyICYmXHJcbiAgICAgICAgdHdvLm1hdGNoKGRpZmZfbWF0Y2hfcGF0Y2guYmxhbmtsaW5lU3RhcnRSZWdleF8pO1xyXG5cclxuICAgIGlmIChibGFua0xpbmUxIHx8IGJsYW5rTGluZTIpIHtcclxuICAgICAgLy8gRml2ZSBwb2ludHMgZm9yIGJsYW5rIGxpbmVzLlxyXG4gICAgICByZXR1cm4gNTtcclxuICAgIH0gZWxzZSBpZiAobGluZUJyZWFrMSB8fCBsaW5lQnJlYWsyKSB7XHJcbiAgICAgIC8vIEZvdXIgcG9pbnRzIGZvciBsaW5lIGJyZWFrcy5cclxuICAgICAgcmV0dXJuIDQ7XHJcbiAgICB9IGVsc2UgaWYgKG5vbkFscGhhTnVtZXJpYzEgJiYgIXdoaXRlc3BhY2UxICYmIHdoaXRlc3BhY2UyKSB7XHJcbiAgICAgIC8vIFRocmVlIHBvaW50cyBmb3IgZW5kIG9mIHNlbnRlbmNlcy5cclxuICAgICAgcmV0dXJuIDM7XHJcbiAgICB9IGVsc2UgaWYgKHdoaXRlc3BhY2UxIHx8IHdoaXRlc3BhY2UyKSB7XHJcbiAgICAgIC8vIFR3byBwb2ludHMgZm9yIHdoaXRlc3BhY2UuXHJcbiAgICAgIHJldHVybiAyO1xyXG4gICAgfSBlbHNlIGlmIChub25BbHBoYU51bWVyaWMxIHx8IG5vbkFscGhhTnVtZXJpYzIpIHtcclxuICAgICAgLy8gT25lIHBvaW50IGZvciBub24tYWxwaGFudW1lcmljLlxyXG4gICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgdmFyIHBvaW50ZXIgPSAxO1xyXG4gIC8vIEludGVudGlvbmFsbHkgaWdub3JlIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50IChkb24ndCBuZWVkIGNoZWNraW5nKS5cclxuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCAtIDEpIHtcclxuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT0gRElGRl9FUVVBTCAmJlxyXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVswXSA9PSBESUZGX0VRVUFMKSB7XHJcbiAgICAgIC8vIFRoaXMgaXMgYSBzaW5nbGUgZWRpdCBzdXJyb3VuZGVkIGJ5IGVxdWFsaXRpZXMuXHJcbiAgICAgIHZhciBlcXVhbGl0eTEgPSBkaWZmc1twb2ludGVyIC0gMV1bMV07XHJcbiAgICAgIHZhciBlZGl0ID0gZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICAgIHZhciBlcXVhbGl0eTIgPSBkaWZmc1twb2ludGVyICsgMV1bMV07XHJcblxyXG4gICAgICAvLyBGaXJzdCwgc2hpZnQgdGhlIGVkaXQgYXMgZmFyIGxlZnQgYXMgcG9zc2libGUuXHJcbiAgICAgIHZhciBjb21tb25PZmZzZXQgPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KGVxdWFsaXR5MSwgZWRpdCk7XHJcbiAgICAgIGlmIChjb21tb25PZmZzZXQpIHtcclxuICAgICAgICB2YXIgY29tbW9uU3RyaW5nID0gZWRpdC5zdWJzdHJpbmcoZWRpdC5sZW5ndGggLSBjb21tb25PZmZzZXQpO1xyXG4gICAgICAgIGVxdWFsaXR5MSA9IGVxdWFsaXR5MS5zdWJzdHJpbmcoMCwgZXF1YWxpdHkxLmxlbmd0aCAtIGNvbW1vbk9mZnNldCk7XHJcbiAgICAgICAgZWRpdCA9IGNvbW1vblN0cmluZyArIGVkaXQuc3Vic3RyaW5nKDAsIGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcclxuICAgICAgICBlcXVhbGl0eTIgPSBjb21tb25TdHJpbmcgKyBlcXVhbGl0eTI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNlY29uZCwgc3RlcCBjaGFyYWN0ZXIgYnkgY2hhcmFjdGVyIHJpZ2h0LCBsb29raW5nIGZvciB0aGUgYmVzdCBmaXQuXHJcbiAgICAgIHZhciBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxO1xyXG4gICAgICB2YXIgYmVzdEVkaXQgPSBlZGl0O1xyXG4gICAgICB2YXIgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MjtcclxuICAgICAgdmFyIGJlc3RTY29yZSA9IGRpZmZfY2xlYW51cFNlbWFudGljU2NvcmVfKGVxdWFsaXR5MSwgZWRpdCkgK1xyXG4gICAgICAgICAgZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZV8oZWRpdCwgZXF1YWxpdHkyKTtcclxuICAgICAgd2hpbGUgKGVkaXQuY2hhckF0KDApID09PSBlcXVhbGl0eTIuY2hhckF0KDApKSB7XHJcbiAgICAgICAgZXF1YWxpdHkxICs9IGVkaXQuY2hhckF0KDApO1xyXG4gICAgICAgIGVkaXQgPSBlZGl0LnN1YnN0cmluZygxKSArIGVxdWFsaXR5Mi5jaGFyQXQoMCk7XHJcbiAgICAgICAgZXF1YWxpdHkyID0gZXF1YWxpdHkyLnN1YnN0cmluZygxKTtcclxuICAgICAgICB2YXIgc2NvcmUgPSBkaWZmX2NsZWFudXBTZW1hbnRpY1Njb3JlXyhlcXVhbGl0eTEsIGVkaXQpICtcclxuICAgICAgICAgICAgZGlmZl9jbGVhbnVwU2VtYW50aWNTY29yZV8oZWRpdCwgZXF1YWxpdHkyKTtcclxuICAgICAgICAvLyBUaGUgPj0gZW5jb3VyYWdlcyB0cmFpbGluZyByYXRoZXIgdGhhbiBsZWFkaW5nIHdoaXRlc3BhY2Ugb24gZWRpdHMuXHJcbiAgICAgICAgaWYgKHNjb3JlID49IGJlc3RTY29yZSkge1xyXG4gICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XHJcbiAgICAgICAgICBiZXN0RXF1YWxpdHkxID0gZXF1YWxpdHkxO1xyXG4gICAgICAgICAgYmVzdEVkaXQgPSBlZGl0O1xyXG4gICAgICAgICAgYmVzdEVxdWFsaXR5MiA9IGVxdWFsaXR5MjtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMV0gIT0gYmVzdEVxdWFsaXR5MSkge1xyXG4gICAgICAgIC8vIFdlIGhhdmUgYW4gaW1wcm92ZW1lbnQsIHNhdmUgaXQgYmFjayB0byB0aGUgZGlmZi5cclxuICAgICAgICBpZiAoYmVzdEVxdWFsaXR5MSkge1xyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdID0gYmVzdEVxdWFsaXR5MTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKTtcclxuICAgICAgICAgIHBvaW50ZXItLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBiZXN0RWRpdDtcclxuICAgICAgICBpZiAoYmVzdEVxdWFsaXR5Mikge1xyXG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gYmVzdEVxdWFsaXR5MjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKTtcclxuICAgICAgICAgIHBvaW50ZXItLTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHBvaW50ZXIrKztcclxuICB9XHJcbn07XHJcblxyXG4vLyBEZWZpbmUgc29tZSByZWdleCBwYXR0ZXJucyBmb3IgbWF0Y2hpbmcgYm91bmRhcmllcy5cclxuZGlmZl9tYXRjaF9wYXRjaC5ub25BbHBoYU51bWVyaWNSZWdleF8gPSAvW15hLXpBLVowLTldLztcclxuZGlmZl9tYXRjaF9wYXRjaC53aGl0ZXNwYWNlUmVnZXhfID0gL1xccy87XHJcbmRpZmZfbWF0Y2hfcGF0Y2gubGluZWJyZWFrUmVnZXhfID0gL1tcXHJcXG5dLztcclxuZGlmZl9tYXRjaF9wYXRjaC5ibGFua2xpbmVFbmRSZWdleF8gPSAvXFxuXFxyP1xcbiQvO1xyXG5kaWZmX21hdGNoX3BhdGNoLmJsYW5rbGluZVN0YXJ0UmVnZXhfID0gL15cXHI/XFxuXFxyP1xcbi87XHJcblxyXG4vKipcclxuICogUmVkdWNlIHRoZSBudW1iZXIgb2YgZWRpdHMgYnkgZWxpbWluYXRpbmcgb3BlcmF0aW9uYWxseSB0cml2aWFsIGVxdWFsaXRpZXMuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBFZmZpY2llbmN5ID0gZnVuY3Rpb24oZGlmZnMpIHtcclxuICB2YXIgY2hhbmdlcyA9IGZhbHNlO1xyXG4gIHZhciBlcXVhbGl0aWVzID0gW107ICAvLyBTdGFjayBvZiBpbmRpY2VzIHdoZXJlIGVxdWFsaXRpZXMgYXJlIGZvdW5kLlxyXG4gIHZhciBlcXVhbGl0aWVzTGVuZ3RoID0gMDsgIC8vIEtlZXBpbmcgb3VyIG93biBsZW5ndGggdmFyIGlzIGZhc3RlciBpbiBKUy5cclxuICAvKiogQHR5cGUgez9zdHJpbmd9ICovXHJcbiAgdmFyIGxhc3RlcXVhbGl0eSA9IG51bGw7XHJcbiAgLy8gQWx3YXlzIGVxdWFsIHRvIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdXVsxXVxyXG4gIHZhciBwb2ludGVyID0gMDsgIC8vIEluZGV4IG9mIGN1cnJlbnQgcG9zaXRpb24uXHJcbiAgLy8gSXMgdGhlcmUgYW4gaW5zZXJ0aW9uIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGxhc3QgZXF1YWxpdHkuXHJcbiAgdmFyIHByZV9pbnMgPSBmYWxzZTtcclxuICAvLyBJcyB0aGVyZSBhIGRlbGV0aW9uIG9wZXJhdGlvbiBiZWZvcmUgdGhlIGxhc3QgZXF1YWxpdHkuXHJcbiAgdmFyIHByZV9kZWwgPSBmYWxzZTtcclxuICAvLyBJcyB0aGVyZSBhbiBpbnNlcnRpb24gb3BlcmF0aW9uIGFmdGVyIHRoZSBsYXN0IGVxdWFsaXR5LlxyXG4gIHZhciBwb3N0X2lucyA9IGZhbHNlO1xyXG4gIC8vIElzIHRoZXJlIGEgZGVsZXRpb24gb3BlcmF0aW9uIGFmdGVyIHRoZSBsYXN0IGVxdWFsaXR5LlxyXG4gIHZhciBwb3N0X2RlbCA9IGZhbHNlO1xyXG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XHJcbiAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMF0gPT0gRElGRl9FUVVBTCkgeyAgLy8gRXF1YWxpdHkgZm91bmQuXHJcbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggPCB0aGlzLkRpZmZfRWRpdENvc3QgJiZcclxuICAgICAgICAgIChwb3N0X2lucyB8fCBwb3N0X2RlbCkpIHtcclxuICAgICAgICAvLyBDYW5kaWRhdGUgZm91bmQuXHJcbiAgICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcclxuICAgICAgICBwcmVfaW5zID0gcG9zdF9pbnM7XHJcbiAgICAgICAgcHJlX2RlbCA9IHBvc3RfZGVsO1xyXG4gICAgICAgIGxhc3RlcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIE5vdCBhIGNhbmRpZGF0ZSwgYW5kIGNhbiBuZXZlciBiZWNvbWUgb25lLlxyXG4gICAgICAgIGVxdWFsaXRpZXNMZW5ndGggPSAwO1xyXG4gICAgICAgIGxhc3RlcXVhbGl0eSA9IG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xyXG4gICAgfSBlbHNlIHsgIC8vIEFuIGluc2VydGlvbiBvciBkZWxldGlvbi5cclxuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09IERJRkZfREVMRVRFKSB7XHJcbiAgICAgICAgcG9zdF9kZWwgPSB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHBvc3RfaW5zID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgICAvKlxyXG4gICAgICAgKiBGaXZlIHR5cGVzIHRvIGJlIHNwbGl0OlxyXG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YWTxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxyXG4gICAgICAgKiA8aW5zPkE8L2lucz5YPGlucz5DPC9pbnM+PGRlbD5EPC9kZWw+XHJcbiAgICAgICAqIDxpbnM+QTwvaW5zPjxkZWw+QjwvZGVsPlg8aW5zPkM8L2lucz5cclxuICAgICAgICogPGlucz5BPC9kZWw+WDxpbnM+QzwvaW5zPjxkZWw+RDwvZGVsPlxyXG4gICAgICAgKiA8aW5zPkE8L2lucz48ZGVsPkI8L2RlbD5YPGRlbD5DPC9kZWw+XHJcbiAgICAgICAqL1xyXG4gICAgICBpZiAobGFzdGVxdWFsaXR5ICYmICgocHJlX2lucyAmJiBwcmVfZGVsICYmIHBvc3RfaW5zICYmIHBvc3RfZGVsKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKGxhc3RlcXVhbGl0eS5sZW5ndGggPCB0aGlzLkRpZmZfRWRpdENvc3QgLyAyKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHByZV9pbnMgKyBwcmVfZGVsICsgcG9zdF9pbnMgKyBwb3N0X2RlbCkgPT0gMykpKSB7XHJcbiAgICAgICAgLy8gRHVwbGljYXRlIHJlY29yZC5cclxuICAgICAgICBkaWZmcy5zcGxpY2UoZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoIC0gMV0sIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgIFtESUZGX0RFTEVURSwgbGFzdGVxdWFsaXR5XSk7XHJcbiAgICAgICAgLy8gQ2hhbmdlIHNlY29uZCBjb3B5IHRvIGluc2VydC5cclxuICAgICAgICBkaWZmc1tlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSArIDFdWzBdID0gRElGRl9JTlNFUlQ7XHJcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tOyAgLy8gVGhyb3cgYXdheSB0aGUgZXF1YWxpdHkgd2UganVzdCBkZWxldGVkO1xyXG4gICAgICAgIGxhc3RlcXVhbGl0eSA9IG51bGw7XHJcbiAgICAgICAgaWYgKHByZV9pbnMgJiYgcHJlX2RlbCkge1xyXG4gICAgICAgICAgLy8gTm8gY2hhbmdlcyBtYWRlIHdoaWNoIGNvdWxkIGFmZmVjdCBwcmV2aW91cyBlbnRyeSwga2VlcCBnb2luZy5cclxuICAgICAgICAgIHBvc3RfaW5zID0gcG9zdF9kZWwgPSB0cnVlO1xyXG4gICAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGVxdWFsaXRpZXNMZW5ndGgtLTsgIC8vIFRocm93IGF3YXkgdGhlIHByZXZpb3VzIGVxdWFsaXR5LlxyXG4gICAgICAgICAgcG9pbnRlciA9IGVxdWFsaXRpZXNMZW5ndGggPiAwID9cclxuICAgICAgICAgICAgICBlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSA6IC0xO1xyXG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9pbnRlcisrO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNoYW5nZXMpIHtcclxuICAgIHRoaXMuZGlmZl9jbGVhbnVwTWVyZ2UoZGlmZnMpO1xyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogUmVvcmRlciBhbmQgbWVyZ2UgbGlrZSBlZGl0IHNlY3Rpb25zLiAgTWVyZ2UgZXF1YWxpdGllcy5cclxuICogQW55IGVkaXQgc2VjdGlvbiBjYW4gbW92ZSBhcyBsb25nIGFzIGl0IGRvZXNuJ3QgY3Jvc3MgYW4gZXF1YWxpdHkuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gZGlmZnMgQXJyYXkgb2YgZGlmZiB0dXBsZXMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2NsZWFudXBNZXJnZSA9IGZ1bmN0aW9uKGRpZmZzKSB7XHJcbiAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgJyddKTsgIC8vIEFkZCBhIGR1bW15IGVudHJ5IGF0IHRoZSBlbmQuXHJcbiAgdmFyIHBvaW50ZXIgPSAwO1xyXG4gIHZhciBjb3VudF9kZWxldGUgPSAwO1xyXG4gIHZhciBjb3VudF9pbnNlcnQgPSAwO1xyXG4gIHZhciB0ZXh0X2RlbGV0ZSA9ICcnO1xyXG4gIHZhciB0ZXh0X2luc2VydCA9ICcnO1xyXG4gIHZhciBjb21tb25sZW5ndGg7XHJcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcclxuICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcclxuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcclxuICAgICAgICBjb3VudF9pbnNlcnQrKztcclxuICAgICAgICB0ZXh0X2luc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcclxuICAgICAgICBwb2ludGVyKys7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XHJcbiAgICAgICAgY291bnRfZGVsZXRlKys7XHJcbiAgICAgICAgdGV4dF9kZWxldGUgKz0gZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICAgICAgcG9pbnRlcisrO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfRVFVQUw6XHJcbiAgICAgICAgLy8gVXBvbiByZWFjaGluZyBhbiBlcXVhbGl0eSwgY2hlY2sgZm9yIHByaW9yIHJlZHVuZGFuY2llcy5cclxuICAgICAgICBpZiAoY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0ID4gMSkge1xyXG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSAhPT0gMCAmJiBjb3VudF9pbnNlcnQgIT09IDApIHtcclxuICAgICAgICAgICAgLy8gRmFjdG9yIG91dCBhbnkgY29tbW9uIHByZWZpeGllcy5cclxuICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gdGhpcy5kaWZmX2NvbW1vblByZWZpeCh0ZXh0X2luc2VydCwgdGV4dF9kZWxldGUpO1xyXG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgaWYgKChwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0KSA+IDAgJiZcclxuICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzBdID09XHJcbiAgICAgICAgICAgICAgICAgIERJRkZfRVFVQUwpIHtcclxuICAgICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSBjb3VudF9kZWxldGUgLSBjb3VudF9pbnNlcnQgLSAxXVsxXSArPVxyXG4gICAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkaWZmcy5zcGxpY2UoMCwgMCwgW0RJRkZfRVFVQUwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpXSk7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyKys7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBGYWN0b3Igb3V0IGFueSBjb21tb24gc3VmZml4aWVzLlxyXG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSB0aGlzLmRpZmZfY29tbW9uU3VmZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XHJcbiAgICAgICAgICAgIGlmIChjb21tb25sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IHRleHRfaW5zZXJ0LnN1YnN0cmluZyh0ZXh0X2luc2VydC5sZW5ndGggLVxyXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpICsgZGlmZnNbcG9pbnRlcl1bMV07XHJcbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgdGV4dF9pbnNlcnQubGVuZ3RoIC1cclxuICAgICAgICAgICAgICAgICAgY29tbW9ubGVuZ3RoKTtcclxuICAgICAgICAgICAgICB0ZXh0X2RlbGV0ZSA9IHRleHRfZGVsZXRlLnN1YnN0cmluZygwLCB0ZXh0X2RlbGV0ZS5sZW5ndGggLVxyXG4gICAgICAgICAgICAgICAgICBjb21tb25sZW5ndGgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICAvLyBEZWxldGUgdGhlIG9mZmVuZGluZyByZWNvcmRzIGFuZCBhZGQgdGhlIG1lcmdlZCBvbmVzLlxyXG4gICAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciAtIGNvdW50X2luc2VydCxcclxuICAgICAgICAgICAgICAgIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCwgW0RJRkZfSU5TRVJULCB0ZXh0X2luc2VydF0pO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjb3VudF9pbnNlcnQgPT09IDApIHtcclxuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSBjb3VudF9kZWxldGUsXHJcbiAgICAgICAgICAgICAgICBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQsIFtESUZGX0RFTEVURSwgdGV4dF9kZWxldGVdKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LFxyXG4gICAgICAgICAgICAgICAgY291bnRfZGVsZXRlICsgY291bnRfaW5zZXJ0LCBbRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlXSxcclxuICAgICAgICAgICAgICAgIFtESUZGX0lOU0VSVCwgdGV4dF9pbnNlcnRdKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0ICtcclxuICAgICAgICAgICAgICAgICAgICAoY291bnRfZGVsZXRlID8gMSA6IDApICsgKGNvdW50X2luc2VydCA/IDEgOiAwKSArIDE7XHJcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludGVyICE9PSAwICYmIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9PSBESUZGX0VRVUFMKSB7XHJcbiAgICAgICAgICAvLyBNZXJnZSB0aGlzIGVxdWFsaXR5IHdpdGggdGhlIHByZXZpb3VzIG9uZS5cclxuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyXVsxXTtcclxuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAxKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcG9pbnRlcisrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xyXG4gICAgICAgIGNvdW50X2RlbGV0ZSA9IDA7XHJcbiAgICAgICAgdGV4dF9kZWxldGUgPSAnJztcclxuICAgICAgICB0ZXh0X2luc2VydCA9ICcnO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICBpZiAoZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gPT09ICcnKSB7XHJcbiAgICBkaWZmcy5wb3AoKTsgIC8vIFJlbW92ZSB0aGUgZHVtbXkgZW50cnkgYXQgdGhlIGVuZC5cclxuICB9XHJcblxyXG4gIC8vIFNlY29uZCBwYXNzOiBsb29rIGZvciBzaW5nbGUgZWRpdHMgc3Vycm91bmRlZCBvbiBib3RoIHNpZGVzIGJ5IGVxdWFsaXRpZXNcclxuICAvLyB3aGljaCBjYW4gYmUgc2hpZnRlZCBzaWRld2F5cyB0byBlbGltaW5hdGUgYW4gZXF1YWxpdHkuXHJcbiAgLy8gZS5nOiBBPGlucz5CQTwvaW5zPkMgLT4gPGlucz5BQjwvaW5zPkFDXHJcbiAgdmFyIGNoYW5nZXMgPSBmYWxzZTtcclxuICBwb2ludGVyID0gMTtcclxuICAvLyBJbnRlbnRpb25hbGx5IGlnbm9yZSB0aGUgZmlyc3QgYW5kIGxhc3QgZWxlbWVudCAoZG9uJ3QgbmVlZCBjaGVja2luZykuXHJcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGggLSAxKSB7XHJcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09IERJRkZfRVFVQUwgJiZcclxuICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMF0gPT0gRElGRl9FUVVBTCkge1xyXG4gICAgICAvLyBUaGlzIGlzIGEgc2luZ2xlIGVkaXQgc3Vycm91bmRlZCBieSBlcXVhbGl0aWVzLlxyXG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtXHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0ubGVuZ3RoKSA9PSBkaWZmc1twb2ludGVyIC0gMV1bMV0pIHtcclxuICAgICAgICAvLyBTaGlmdCB0aGUgZWRpdCBvdmVyIHRoZSBwcmV2aW91cyBlcXVhbGl0eS5cclxuICAgICAgICBkaWZmc1twb2ludGVyXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArXHJcbiAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGggLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCk7XHJcbiAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdICsgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xyXG4gICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XHJcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKDAsIGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpID09XHJcbiAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV0pIHtcclxuICAgICAgICAvLyBTaGlmdCB0aGUgZWRpdCBvdmVyIHRoZSBuZXh0IGVxdWFsaXR5LlxyXG4gICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV07XHJcbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPVxyXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoZGlmZnNbcG9pbnRlciArIDFdWzFdLmxlbmd0aCkgK1xyXG4gICAgICAgICAgICBkaWZmc1twb2ludGVyICsgMV1bMV07XHJcbiAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgKyAxLCAxKTtcclxuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9pbnRlcisrO1xyXG4gIH1cclxuICAvLyBJZiBzaGlmdHMgd2VyZSBtYWRlLCB0aGUgZGlmZiBuZWVkcyByZW9yZGVyaW5nIGFuZCBhbm90aGVyIHNoaWZ0IHN3ZWVwLlxyXG4gIGlmIChjaGFuZ2VzKSB7XHJcbiAgICB0aGlzLmRpZmZfY2xlYW51cE1lcmdlKGRpZmZzKTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIGxvYyBpcyBhIGxvY2F0aW9uIGluIHRleHQxLCBjb21wdXRlIGFuZCByZXR1cm4gdGhlIGVxdWl2YWxlbnQgbG9jYXRpb24gaW5cclxuICogdGV4dDIuXHJcbiAqIGUuZy4gJ1RoZSBjYXQnIHZzICdUaGUgYmlnIGNhdCcsIDEtPjEsIDUtPjhcclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHBhcmFtIHtudW1iZXJ9IGxvYyBMb2NhdGlvbiB3aXRoaW4gdGV4dDEuXHJcbiAqIEByZXR1cm4ge251bWJlcn0gTG9jYXRpb24gd2l0aGluIHRleHQyLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl94SW5kZXggPSBmdW5jdGlvbihkaWZmcywgbG9jKSB7XHJcbiAgdmFyIGNoYXJzMSA9IDA7XHJcbiAgdmFyIGNoYXJzMiA9IDA7XHJcbiAgdmFyIGxhc3RfY2hhcnMxID0gMDtcclxuICB2YXIgbGFzdF9jaGFyczIgPSAwO1xyXG4gIHZhciB4O1xyXG4gIGZvciAoeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xyXG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0lOU0VSVCkgeyAgLy8gRXF1YWxpdHkgb3IgZGVsZXRpb24uXHJcbiAgICAgIGNoYXJzMSArPSBkaWZmc1t4XVsxXS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfREVMRVRFKSB7ICAvLyBFcXVhbGl0eSBvciBpbnNlcnRpb24uXHJcbiAgICAgIGNoYXJzMiArPSBkaWZmc1t4XVsxXS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBpZiAoY2hhcnMxID4gbG9jKSB7ICAvLyBPdmVyc2hvdCB0aGUgbG9jYXRpb24uXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgbGFzdF9jaGFyczEgPSBjaGFyczE7XHJcbiAgICBsYXN0X2NoYXJzMiA9IGNoYXJzMjtcclxuICB9XHJcbiAgLy8gV2FzIHRoZSBsb2NhdGlvbiB3YXMgZGVsZXRlZD9cclxuICBpZiAoZGlmZnMubGVuZ3RoICE9IHggJiYgZGlmZnNbeF1bMF0gPT09IERJRkZfREVMRVRFKSB7XHJcbiAgICByZXR1cm4gbGFzdF9jaGFyczI7XHJcbiAgfVxyXG4gIC8vIEFkZCB0aGUgcmVtYWluaW5nIGNoYXJhY3RlciBsZW5ndGguXHJcbiAgcmV0dXJuIGxhc3RfY2hhcnMyICsgKGxvYyAtIGxhc3RfY2hhcnMxKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ29udmVydCBhIGRpZmYgYXJyYXkgaW50byBhIHByZXR0eSBIVE1MIHJlcG9ydC5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHJldHVybiB7c3RyaW5nfSBIVE1MIHJlcHJlc2VudGF0aW9uLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl9wcmV0dHlIdG1sID0gZnVuY3Rpb24oZGlmZnMpIHtcclxuICB2YXIgaHRtbCA9IFtdO1xyXG4gIHZhciBwYXR0ZXJuX2FtcCA9IC8mL2c7XHJcbiAgdmFyIHBhdHRlcm5fbHQgPSAvPC9nO1xyXG4gIHZhciBwYXR0ZXJuX2d0ID0gLz4vZztcclxuICB2YXIgcGF0dGVybl9wYXJhID0gL1xcbi9nO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcclxuICAgIHZhciBvcCA9IGRpZmZzW3hdWzBdOyAgICAvLyBPcGVyYXRpb24gKGluc2VydCwgZGVsZXRlLCBlcXVhbClcclxuICAgIHZhciBkYXRhID0gZGlmZnNbeF1bMV07ICAvLyBUZXh0IG9mIGNoYW5nZS5cclxuICAgIHZhciB0ZXh0ID0gZGF0YS5yZXBsYWNlKHBhdHRlcm5fYW1wLCAnJmFtcDsnKS5yZXBsYWNlKHBhdHRlcm5fbHQsICcmbHQ7JylcclxuICAgICAgICAucmVwbGFjZShwYXR0ZXJuX2d0LCAnJmd0OycpLnJlcGxhY2UocGF0dGVybl9wYXJhLCAnJnBhcmE7PGJyPicpO1xyXG4gICAgc3dpdGNoIChvcCkge1xyXG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxyXG4gICAgICAgIGh0bWxbeF0gPSAnPGlucyBzdHlsZT1cImJhY2tncm91bmQ6I2U2ZmZlNjtcIj4nICsgdGV4dCArICc8L2lucz4nO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxyXG4gICAgICAgIGh0bWxbeF0gPSAnPGRlbCBzdHlsZT1cImJhY2tncm91bmQ6I2ZmZTZlNjtcIj4nICsgdGV4dCArICc8L2RlbD4nO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfRVFVQUw6XHJcbiAgICAgICAgaHRtbFt4XSA9ICc8c3Bhbj4nICsgdGV4dCArICc8L3NwYW4+JztcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIGh0bWwuam9pbignJyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgYW5kIHJldHVybiB0aGUgc291cmNlIHRleHQgKGFsbCBlcXVhbGl0aWVzIGFuZCBkZWxldGlvbnMpLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFNvdXJjZSB0ZXh0LlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUuZGlmZl90ZXh0MSA9IGZ1bmN0aW9uKGRpZmZzKSB7XHJcbiAgdmFyIHRleHQgPSBbXTtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XHJcbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUKSB7XHJcbiAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIHRleHQuam9pbignJyk7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbXB1dGUgYW5kIHJldHVybiB0aGUgZGVzdGluYXRpb24gdGV4dCAoYWxsIGVxdWFsaXRpZXMgYW5kIGluc2VydGlvbnMpLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERlc3RpbmF0aW9uIHRleHQuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RleHQyID0gZnVuY3Rpb24oZGlmZnMpIHtcclxuICB2YXIgdGV4dCA9IFtdO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcclxuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUpIHtcclxuICAgICAgdGV4dFt4XSA9IGRpZmZzW3hdWzFdO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGV4dC5qb2luKCcnKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ29tcHV0ZSB0aGUgTGV2ZW5zaHRlaW4gZGlzdGFuY2U7IHRoZSBudW1iZXIgb2YgaW5zZXJ0ZWQsIGRlbGV0ZWQgb3JcclxuICogc3Vic3RpdHV0ZWQgY2hhcmFjdGVycy5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBkaWZmcyBBcnJheSBvZiBkaWZmIHR1cGxlcy5cclxuICogQHJldHVybiB7bnVtYmVyfSBOdW1iZXIgb2YgY2hhbmdlcy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLmRpZmZfbGV2ZW5zaHRlaW4gPSBmdW5jdGlvbihkaWZmcykge1xyXG4gIHZhciBsZXZlbnNodGVpbiA9IDA7XHJcbiAgdmFyIGluc2VydGlvbnMgPSAwO1xyXG4gIHZhciBkZWxldGlvbnMgPSAwO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcclxuICAgIHZhciBvcCA9IGRpZmZzW3hdWzBdO1xyXG4gICAgdmFyIGRhdGEgPSBkaWZmc1t4XVsxXTtcclxuICAgIHN3aXRjaCAob3ApIHtcclxuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcclxuICAgICAgICBpbnNlcnRpb25zICs9IGRhdGEubGVuZ3RoO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxyXG4gICAgICAgIGRlbGV0aW9ucyArPSBkYXRhLmxlbmd0aDtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0VRVUFMOlxyXG4gICAgICAgIC8vIEEgZGVsZXRpb24gYW5kIGFuIGluc2VydGlvbiBpcyBvbmUgc3Vic3RpdHV0aW9uLlxyXG4gICAgICAgIGxldmVuc2h0ZWluICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyk7XHJcbiAgICAgICAgaW5zZXJ0aW9ucyA9IDA7XHJcbiAgICAgICAgZGVsZXRpb25zID0gMDtcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgbGV2ZW5zaHRlaW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKTtcclxuICByZXR1cm4gbGV2ZW5zaHRlaW47XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIENydXNoIHRoZSBkaWZmIGludG8gYW4gZW5jb2RlZCBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZSBvcGVyYXRpb25zXHJcbiAqIHJlcXVpcmVkIHRvIHRyYW5zZm9ybSB0ZXh0MSBpbnRvIHRleHQyLlxyXG4gKiBFLmcuID0zXFx0LTJcXHQraW5nICAtPiBLZWVwIDMgY2hhcnMsIGRlbGV0ZSAyIGNoYXJzLCBpbnNlcnQgJ2luZycuXHJcbiAqIE9wZXJhdGlvbnMgYXJlIHRhYi1zZXBhcmF0ZWQuICBJbnNlcnRlZCB0ZXh0IGlzIGVzY2FwZWQgdXNpbmcgJXh4IG5vdGF0aW9uLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGRpZmZzIEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IERlbHRhIHRleHQuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX3RvRGVsdGEgPSBmdW5jdGlvbihkaWZmcykge1xyXG4gIHZhciB0ZXh0ID0gW107XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xyXG4gICAgc3dpdGNoIChkaWZmc1t4XVswXSkge1xyXG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxyXG4gICAgICAgIHRleHRbeF0gPSAnKycgKyBlbmNvZGVVUkkoZGlmZnNbeF1bMV0pO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxyXG4gICAgICAgIHRleHRbeF0gPSAnLScgKyBkaWZmc1t4XVsxXS5sZW5ndGg7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcclxuICAgICAgICB0ZXh0W3hdID0gJz0nICsgZGlmZnNbeF1bMV0ubGVuZ3RoO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGV4dC5qb2luKCdcXHQnKS5yZXBsYWNlKC8lMjAvZywgJyAnKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gdGhlIG9yaWdpbmFsIHRleHQxLCBhbmQgYW4gZW5jb2RlZCBzdHJpbmcgd2hpY2ggZGVzY3JpYmVzIHRoZVxyXG4gKiBvcGVyYXRpb25zIHJlcXVpcmVkIHRvIHRyYW5zZm9ybSB0ZXh0MSBpbnRvIHRleHQyLCBjb21wdXRlIHRoZSBmdWxsIGRpZmYuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0MSBTb3VyY2Ugc3RyaW5nIGZvciB0aGUgZGlmZi5cclxuICogQHBhcmFtIHtzdHJpbmd9IGRlbHRhIERlbHRhIHRleHQuXHJcbiAqIEByZXR1cm4geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IEFycmF5IG9mIGRpZmYgdHVwbGVzLlxyXG4gKiBAdGhyb3dzIHshRXJyb3J9IElmIGludmFsaWQgaW5wdXQuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5kaWZmX2Zyb21EZWx0YSA9IGZ1bmN0aW9uKHRleHQxLCBkZWx0YSkge1xyXG4gIHZhciBkaWZmcyA9IFtdO1xyXG4gIHZhciBkaWZmc0xlbmd0aCA9IDA7ICAvLyBLZWVwaW5nIG91ciBvd24gbGVuZ3RoIHZhciBpcyBmYXN0ZXIgaW4gSlMuXHJcbiAgdmFyIHBvaW50ZXIgPSAwOyAgLy8gQ3Vyc29yIGluIHRleHQxXHJcbiAgdmFyIHRva2VucyA9IGRlbHRhLnNwbGl0KC9cXHQvZyk7XHJcbiAgZm9yICh2YXIgeCA9IDA7IHggPCB0b2tlbnMubGVuZ3RoOyB4KyspIHtcclxuICAgIC8vIEVhY2ggdG9rZW4gYmVnaW5zIHdpdGggYSBvbmUgY2hhcmFjdGVyIHBhcmFtZXRlciB3aGljaCBzcGVjaWZpZXMgdGhlXHJcbiAgICAvLyBvcGVyYXRpb24gb2YgdGhpcyB0b2tlbiAoZGVsZXRlLCBpbnNlcnQsIGVxdWFsaXR5KS5cclxuICAgIHZhciBwYXJhbSA9IHRva2Vuc1t4XS5zdWJzdHJpbmcoMSk7XHJcbiAgICBzd2l0Y2ggKHRva2Vuc1t4XS5jaGFyQXQoMCkpIHtcclxuICAgICAgY2FzZSAnKyc6XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gW0RJRkZfSU5TRVJULCBkZWNvZGVVUkkocGFyYW0pXTtcclxuICAgICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgICAgLy8gTWFsZm9ybWVkIFVSSSBzZXF1ZW5jZS5cclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBlc2NhcGUgaW4gZGlmZl9mcm9tRGVsdGE6ICcgKyBwYXJhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICctJzpcclxuICAgICAgICAvLyBGYWxsIHRocm91Z2guXHJcbiAgICAgIGNhc2UgJz0nOlxyXG4gICAgICAgIHZhciBuID0gcGFyc2VJbnQocGFyYW0sIDEwKTtcclxuICAgICAgICBpZiAoaXNOYU4obikgfHwgbiA8IDApIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgaW4gZGlmZl9mcm9tRGVsdGE6ICcgKyBwYXJhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB0ZXh0ID0gdGV4dDEuc3Vic3RyaW5nKHBvaW50ZXIsIHBvaW50ZXIgKz0gbik7XHJcbiAgICAgICAgaWYgKHRva2Vuc1t4XS5jaGFyQXQoMCkgPT0gJz0nKSB7XHJcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IFtESUZGX0VRVUFMLCB0ZXh0XTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGlmZnNbZGlmZnNMZW5ndGgrK10gPSBbRElGRl9ERUxFVEUsIHRleHRdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgZGVmYXVsdDpcclxuICAgICAgICAvLyBCbGFuayB0b2tlbnMgYXJlIG9rIChmcm9tIGEgdHJhaWxpbmcgXFx0KS5cclxuICAgICAgICAvLyBBbnl0aGluZyBlbHNlIGlzIGFuIGVycm9yLlxyXG4gICAgICAgIGlmICh0b2tlbnNbeF0pIHtcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkaWZmIG9wZXJhdGlvbiBpbiBkaWZmX2Zyb21EZWx0YTogJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zW3hdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChwb2ludGVyICE9IHRleHQxLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdEZWx0YSBsZW5ndGggKCcgKyBwb2ludGVyICtcclxuICAgICAgICAnKSBkb2VzIG5vdCBlcXVhbCBzb3VyY2UgdGV4dCBsZW5ndGggKCcgKyB0ZXh0MS5sZW5ndGggKyAnKS4nKTtcclxuICB9XHJcbiAgcmV0dXJuIGRpZmZzO1xyXG59O1xyXG5cclxuXHJcbi8vICBNQVRDSCBGVU5DVElPTlNcclxuXHJcblxyXG4vKipcclxuICogTG9jYXRlIHRoZSBiZXN0IGluc3RhbmNlIG9mICdwYXR0ZXJuJyBpbiAndGV4dCcgbmVhciAnbG9jJy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gc2VhcmNoLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byBzZWFyY2ggZm9yLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIFRoZSBsb2NhdGlvbiB0byBzZWFyY2ggYXJvdW5kLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEJlc3QgbWF0Y2ggaW5kZXggb3IgLTEuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5tYXRjaF9tYWluID0gZnVuY3Rpb24odGV4dCwgcGF0dGVybiwgbG9jKSB7XHJcbiAgLy8gQ2hlY2sgZm9yIG51bGwgaW5wdXRzLlxyXG4gIGlmICh0ZXh0ID09IG51bGwgfHwgcGF0dGVybiA9PSBudWxsIHx8IGxvYyA9PSBudWxsKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ051bGwgaW5wdXQuIChtYXRjaF9tYWluKScpO1xyXG4gIH1cclxuXHJcbiAgbG9jID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obG9jLCB0ZXh0Lmxlbmd0aCkpO1xyXG4gIGlmICh0ZXh0ID09IHBhdHRlcm4pIHtcclxuICAgIC8vIFNob3J0Y3V0IChwb3RlbnRpYWxseSBub3QgZ3VhcmFudGVlZCBieSB0aGUgYWxnb3JpdGhtKVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfSBlbHNlIGlmICghdGV4dC5sZW5ndGgpIHtcclxuICAgIC8vIE5vdGhpbmcgdG8gbWF0Y2guXHJcbiAgICByZXR1cm4gLTE7XHJcbiAgfSBlbHNlIGlmICh0ZXh0LnN1YnN0cmluZyhsb2MsIGxvYyArIHBhdHRlcm4ubGVuZ3RoKSA9PSBwYXR0ZXJuKSB7XHJcbiAgICAvLyBQZXJmZWN0IG1hdGNoIGF0IHRoZSBwZXJmZWN0IHNwb3QhICAoSW5jbHVkZXMgY2FzZSBvZiBudWxsIHBhdHRlcm4pXHJcbiAgICByZXR1cm4gbG9jO1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyBEbyBhIGZ1enp5IGNvbXBhcmUuXHJcbiAgICByZXR1cm4gdGhpcy5tYXRjaF9iaXRhcF8odGV4dCwgcGF0dGVybiwgbG9jKTtcclxuICB9XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIExvY2F0ZSB0aGUgYmVzdCBpbnN0YW5jZSBvZiAncGF0dGVybicgaW4gJ3RleHQnIG5lYXIgJ2xvYycgdXNpbmcgdGhlXHJcbiAqIEJpdGFwIGFsZ29yaXRobS5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGhlIHRleHQgdG8gc2VhcmNoLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0dGVybiBUaGUgcGF0dGVybiB0byBzZWFyY2ggZm9yLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gbG9jIFRoZSBsb2NhdGlvbiB0byBzZWFyY2ggYXJvdW5kLlxyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEJlc3QgbWF0Y2ggaW5kZXggb3IgLTEuXHJcbiAqIEBwcml2YXRlXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5tYXRjaF9iaXRhcF8gPSBmdW5jdGlvbih0ZXh0LCBwYXR0ZXJuLCBsb2MpIHtcclxuICBpZiAocGF0dGVybi5sZW5ndGggPiB0aGlzLk1hdGNoX01heEJpdHMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignUGF0dGVybiB0b28gbG9uZyBmb3IgdGhpcyBicm93c2VyLicpO1xyXG4gIH1cclxuXHJcbiAgLy8gSW5pdGlhbGlzZSB0aGUgYWxwaGFiZXQuXHJcbiAgdmFyIHMgPSB0aGlzLm1hdGNoX2FscGhhYmV0XyhwYXR0ZXJuKTtcclxuXHJcbiAgdmFyIGRtcCA9IHRoaXM7ICAvLyAndGhpcycgYmVjb21lcyAnd2luZG93JyBpbiBhIGNsb3N1cmUuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXB1dGUgYW5kIHJldHVybiB0aGUgc2NvcmUgZm9yIGEgbWF0Y2ggd2l0aCBlIGVycm9ycyBhbmQgeCBsb2NhdGlvbi5cclxuICAgKiBBY2Nlc3NlcyBsb2MgYW5kIHBhdHRlcm4gdGhyb3VnaCBiZWluZyBhIGNsb3N1cmUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGUgTnVtYmVyIG9mIGVycm9ycyBpbiBtYXRjaC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geCBMb2NhdGlvbiBvZiBtYXRjaC5cclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IE92ZXJhbGwgc2NvcmUgZm9yIG1hdGNoICgwLjAgPSBnb29kLCAxLjAgPSBiYWQpLlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbWF0Y2hfYml0YXBTY29yZV8oZSwgeCkge1xyXG4gICAgdmFyIGFjY3VyYWN5ID0gZSAvIHBhdHRlcm4ubGVuZ3RoO1xyXG4gICAgdmFyIHByb3hpbWl0eSA9IE1hdGguYWJzKGxvYyAtIHgpO1xyXG4gICAgaWYgKCFkbXAuTWF0Y2hfRGlzdGFuY2UpIHtcclxuICAgICAgLy8gRG9kZ2UgZGl2aWRlIGJ5IHplcm8gZXJyb3IuXHJcbiAgICAgIHJldHVybiBwcm94aW1pdHkgPyAxLjAgOiBhY2N1cmFjeTtcclxuICAgIH1cclxuICAgIHJldHVybiBhY2N1cmFjeSArIChwcm94aW1pdHkgLyBkbXAuTWF0Y2hfRGlzdGFuY2UpO1xyXG4gIH1cclxuXHJcbiAgLy8gSGlnaGVzdCBzY29yZSBiZXlvbmQgd2hpY2ggd2UgZ2l2ZSB1cC5cclxuICB2YXIgc2NvcmVfdGhyZXNob2xkID0gdGhpcy5NYXRjaF9UaHJlc2hvbGQ7XHJcbiAgLy8gSXMgdGhlcmUgYSBuZWFyYnkgZXhhY3QgbWF0Y2g/IChzcGVlZHVwKVxyXG4gIHZhciBiZXN0X2xvYyA9IHRleHQuaW5kZXhPZihwYXR0ZXJuLCBsb2MpO1xyXG4gIGlmIChiZXN0X2xvYyAhPSAtMSkge1xyXG4gICAgc2NvcmVfdGhyZXNob2xkID0gTWF0aC5taW4obWF0Y2hfYml0YXBTY29yZV8oMCwgYmVzdF9sb2MpLCBzY29yZV90aHJlc2hvbGQpO1xyXG4gICAgLy8gV2hhdCBhYm91dCBpbiB0aGUgb3RoZXIgZGlyZWN0aW9uPyAoc3BlZWR1cClcclxuICAgIGJlc3RfbG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCk7XHJcbiAgICBpZiAoYmVzdF9sb2MgIT0gLTEpIHtcclxuICAgICAgc2NvcmVfdGhyZXNob2xkID1cclxuICAgICAgICAgIE1hdGgubWluKG1hdGNoX2JpdGFwU2NvcmVfKDAsIGJlc3RfbG9jKSwgc2NvcmVfdGhyZXNob2xkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIEluaXRpYWxpc2UgdGhlIGJpdCBhcnJheXMuXHJcbiAgdmFyIG1hdGNobWFzayA9IDEgPDwgKHBhdHRlcm4ubGVuZ3RoIC0gMSk7XHJcbiAgYmVzdF9sb2MgPSAtMTtcclxuXHJcbiAgdmFyIGJpbl9taW4sIGJpbl9taWQ7XHJcbiAgdmFyIGJpbl9tYXggPSBwYXR0ZXJuLmxlbmd0aCArIHRleHQubGVuZ3RoO1xyXG4gIHZhciBsYXN0X3JkO1xyXG4gIGZvciAodmFyIGQgPSAwOyBkIDwgcGF0dGVybi5sZW5ndGg7IGQrKykge1xyXG4gICAgLy8gU2NhbiBmb3IgdGhlIGJlc3QgbWF0Y2g7IGVhY2ggaXRlcmF0aW9uIGFsbG93cyBmb3Igb25lIG1vcmUgZXJyb3IuXHJcbiAgICAvLyBSdW4gYSBiaW5hcnkgc2VhcmNoIHRvIGRldGVybWluZSBob3cgZmFyIGZyb20gJ2xvYycgd2UgY2FuIHN0cmF5IGF0IHRoaXNcclxuICAgIC8vIGVycm9yIGxldmVsLlxyXG4gICAgYmluX21pbiA9IDA7XHJcbiAgICBiaW5fbWlkID0gYmluX21heDtcclxuICAgIHdoaWxlIChiaW5fbWluIDwgYmluX21pZCkge1xyXG4gICAgICBpZiAobWF0Y2hfYml0YXBTY29yZV8oZCwgbG9jICsgYmluX21pZCkgPD0gc2NvcmVfdGhyZXNob2xkKSB7XHJcbiAgICAgICAgYmluX21pbiA9IGJpbl9taWQ7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYmluX21heCA9IGJpbl9taWQ7XHJcbiAgICAgIH1cclxuICAgICAgYmluX21pZCA9IE1hdGguZmxvb3IoKGJpbl9tYXggLSBiaW5fbWluKSAvIDIgKyBiaW5fbWluKTtcclxuICAgIH1cclxuICAgIC8vIFVzZSB0aGUgcmVzdWx0IGZyb20gdGhpcyBpdGVyYXRpb24gYXMgdGhlIG1heGltdW0gZm9yIHRoZSBuZXh0LlxyXG4gICAgYmluX21heCA9IGJpbl9taWQ7XHJcbiAgICB2YXIgc3RhcnQgPSBNYXRoLm1heCgxLCBsb2MgLSBiaW5fbWlkICsgMSk7XHJcbiAgICB2YXIgZmluaXNoID0gTWF0aC5taW4obG9jICsgYmluX21pZCwgdGV4dC5sZW5ndGgpICsgcGF0dGVybi5sZW5ndGg7XHJcblxyXG4gICAgdmFyIHJkID0gQXJyYXkoZmluaXNoICsgMik7XHJcbiAgICByZFtmaW5pc2ggKyAxXSA9ICgxIDw8IGQpIC0gMTtcclxuICAgIGZvciAodmFyIGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgKHMpIGlzIGEgc3BhcnNlIGhhc2gsIHNvIHRoZSBmb2xsb3dpbmcgbGluZSBnZW5lcmF0ZXNcclxuICAgICAgLy8gd2FybmluZ3MuXHJcbiAgICAgIHZhciBjaGFyTWF0Y2ggPSBzW3RleHQuY2hhckF0KGogLSAxKV07XHJcbiAgICAgIGlmIChkID09PSAwKSB7ICAvLyBGaXJzdCBwYXNzOiBleGFjdCBtYXRjaC5cclxuICAgICAgICByZFtqXSA9ICgocmRbaiArIDFdIDw8IDEpIHwgMSkgJiBjaGFyTWF0Y2g7XHJcbiAgICAgIH0gZWxzZSB7ICAvLyBTdWJzZXF1ZW50IHBhc3NlczogZnV6enkgbWF0Y2guXHJcbiAgICAgICAgcmRbal0gPSAoKChyZFtqICsgMV0gPDwgMSkgfCAxKSAmIGNoYXJNYXRjaCkgfFxyXG4gICAgICAgICAgICAgICAgKCgobGFzdF9yZFtqICsgMV0gfCBsYXN0X3JkW2pdKSA8PCAxKSB8IDEpIHxcclxuICAgICAgICAgICAgICAgIGxhc3RfcmRbaiArIDFdO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChyZFtqXSAmIG1hdGNobWFzaykge1xyXG4gICAgICAgIHZhciBzY29yZSA9IG1hdGNoX2JpdGFwU2NvcmVfKGQsIGogLSAxKTtcclxuICAgICAgICAvLyBUaGlzIG1hdGNoIHdpbGwgYWxtb3N0IGNlcnRhaW5seSBiZSBiZXR0ZXIgdGhhbiBhbnkgZXhpc3RpbmcgbWF0Y2guXHJcbiAgICAgICAgLy8gQnV0IGNoZWNrIGFueXdheS5cclxuICAgICAgICBpZiAoc2NvcmUgPD0gc2NvcmVfdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAvLyBUb2xkIHlvdSBzby5cclxuICAgICAgICAgIHNjb3JlX3RocmVzaG9sZCA9IHNjb3JlO1xyXG4gICAgICAgICAgYmVzdF9sb2MgPSBqIC0gMTtcclxuICAgICAgICAgIGlmIChiZXN0X2xvYyA+IGxvYykge1xyXG4gICAgICAgICAgICAvLyBXaGVuIHBhc3NpbmcgbG9jLCBkb24ndCBleGNlZWQgb3VyIGN1cnJlbnQgZGlzdGFuY2UgZnJvbSBsb2MuXHJcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGxvYyAtIGJlc3RfbG9jKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEFscmVhZHkgcGFzc2VkIGxvYywgZG93bmhpbGwgZnJvbSBoZXJlIG9uIGluLlxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIE5vIGhvcGUgZm9yIGEgKGJldHRlcikgbWF0Y2ggYXQgZ3JlYXRlciBlcnJvciBsZXZlbHMuXHJcbiAgICBpZiAobWF0Y2hfYml0YXBTY29yZV8oZCArIDEsIGxvYykgPiBzY29yZV90aHJlc2hvbGQpIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBsYXN0X3JkID0gcmQ7XHJcbiAgfVxyXG4gIHJldHVybiBiZXN0X2xvYztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogSW5pdGlhbGlzZSB0aGUgYWxwaGFiZXQgZm9yIHRoZSBCaXRhcCBhbGdvcml0aG0uXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXR0ZXJuIFRoZSB0ZXh0IHRvIGVuY29kZS5cclxuICogQHJldHVybiB7IU9iamVjdH0gSGFzaCBvZiBjaGFyYWN0ZXIgbG9jYXRpb25zLlxyXG4gKiBAcHJpdmF0ZVxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUubWF0Y2hfYWxwaGFiZXRfID0gZnVuY3Rpb24ocGF0dGVybikge1xyXG4gIHZhciBzID0ge307XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBzW3BhdHRlcm4uY2hhckF0KGkpXSA9IDA7XHJcbiAgfVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0dGVybi5sZW5ndGg7IGkrKykge1xyXG4gICAgc1twYXR0ZXJuLmNoYXJBdChpKV0gfD0gMSA8PCAocGF0dGVybi5sZW5ndGggLSBpIC0gMSk7XHJcbiAgfVxyXG4gIHJldHVybiBzO1xyXG59O1xyXG5cclxuXHJcbi8vICBQQVRDSCBGVU5DVElPTlNcclxuXHJcblxyXG4vKipcclxuICogSW5jcmVhc2UgdGhlIGNvbnRleHQgdW50aWwgaXQgaXMgdW5pcXVlLFxyXG4gKiBidXQgZG9uJ3QgbGV0IHRoZSBwYXR0ZXJuIGV4cGFuZCBiZXlvbmQgTWF0Y2hfTWF4Qml0cy5cclxuICogQHBhcmFtIHshZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmp9IHBhdGNoIFRoZSBwYXRjaCB0byBncm93LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBTb3VyY2UgdGV4dC5cclxuICogQHByaXZhdGVcclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX2FkZENvbnRleHRfID0gZnVuY3Rpb24ocGF0Y2gsIHRleHQpIHtcclxuICBpZiAodGV4dC5sZW5ndGggPT0gMCkge1xyXG4gICAgcmV0dXJuO1xyXG4gIH1cclxuICB2YXIgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiwgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSk7XHJcbiAgdmFyIHBhZGRpbmcgPSAwO1xyXG5cclxuICAvLyBMb29rIGZvciB0aGUgZmlyc3QgYW5kIGxhc3QgbWF0Y2hlcyBvZiBwYXR0ZXJuIGluIHRleHQuICBJZiB0d28gZGlmZmVyZW50XHJcbiAgLy8gbWF0Y2hlcyBhcmUgZm91bmQsIGluY3JlYXNlIHRoZSBwYXR0ZXJuIGxlbmd0aC5cclxuICB3aGlsZSAodGV4dC5pbmRleE9mKHBhdHRlcm4pICE9IHRleHQubGFzdEluZGV4T2YocGF0dGVybikgJiZcclxuICAgICAgICAgcGF0dGVybi5sZW5ndGggPCB0aGlzLk1hdGNoX01heEJpdHMgLSB0aGlzLlBhdGNoX01hcmdpbiAtXHJcbiAgICAgICAgIHRoaXMuUGF0Y2hfTWFyZ2luKSB7XHJcbiAgICBwYWRkaW5nICs9IHRoaXMuUGF0Y2hfTWFyZ2luO1xyXG4gICAgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiAtIHBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSArIHBhZGRpbmcpO1xyXG4gIH1cclxuICAvLyBBZGQgb25lIGNodW5rIGZvciBnb29kIGx1Y2suXHJcbiAgcGFkZGluZyArPSB0aGlzLlBhdGNoX01hcmdpbjtcclxuXHJcbiAgLy8gQWRkIHRoZSBwcmVmaXguXHJcbiAgdmFyIHByZWZpeCA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiAtIHBhZGRpbmcsIHBhdGNoLnN0YXJ0Mik7XHJcbiAgaWYgKHByZWZpeCkge1xyXG4gICAgcGF0Y2guZGlmZnMudW5zaGlmdChbRElGRl9FUVVBTCwgcHJlZml4XSk7XHJcbiAgfVxyXG4gIC8vIEFkZCB0aGUgc3VmZml4LlxyXG4gIHZhciBzdWZmaXggPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XHJcbiAgaWYgKHN1ZmZpeCkge1xyXG4gICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgc3VmZml4XSk7XHJcbiAgfVxyXG5cclxuICAvLyBSb2xsIGJhY2sgdGhlIHN0YXJ0IHBvaW50cy5cclxuICBwYXRjaC5zdGFydDEgLT0gcHJlZml4Lmxlbmd0aDtcclxuICBwYXRjaC5zdGFydDIgLT0gcHJlZml4Lmxlbmd0aDtcclxuICAvLyBFeHRlbmQgdGhlIGxlbmd0aHMuXHJcbiAgcGF0Y2gubGVuZ3RoMSArPSBwcmVmaXgubGVuZ3RoICsgc3VmZml4Lmxlbmd0aDtcclxuICBwYXRjaC5sZW5ndGgyICs9IHByZWZpeC5sZW5ndGggKyBzdWZmaXgubGVuZ3RoO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21wdXRlIGEgbGlzdCBvZiBwYXRjaGVzIHRvIHR1cm4gdGV4dDEgaW50byB0ZXh0Mi5cclxuICogVXNlIGRpZmZzIGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgY29tcHV0ZSBpdCBvdXJzZWx2ZXMuXHJcbiAqIFRoZXJlIGFyZSBmb3VyIHdheXMgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uLCBkZXBlbmRpbmcgb24gd2hhdCBkYXRhIGlzXHJcbiAqIGF2YWlsYWJsZSB0byB0aGUgY2FsbGVyOlxyXG4gKiBNZXRob2QgMTpcclxuICogYSA9IHRleHQxLCBiID0gdGV4dDJcclxuICogTWV0aG9kIDI6XHJcbiAqIGEgPSBkaWZmc1xyXG4gKiBNZXRob2QgMyAob3B0aW1hbCk6XHJcbiAqIGEgPSB0ZXh0MSwgYiA9IGRpZmZzXHJcbiAqIE1ldGhvZCA0IChkZXByZWNhdGVkLCB1c2UgbWV0aG9kIDMpOlxyXG4gKiBhID0gdGV4dDEsIGIgPSB0ZXh0MiwgYyA9IGRpZmZzXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfCFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59IGEgdGV4dDEgKG1ldGhvZHMgMSwzLDQpIG9yXHJcbiAqIEFycmF5IG9mIGRpZmYgdHVwbGVzIGZvciB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDIpLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3whQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBvcHRfYiB0ZXh0MiAobWV0aG9kcyAxLDQpIG9yXHJcbiAqIEFycmF5IG9mIGRpZmYgdHVwbGVzIGZvciB0ZXh0MSB0byB0ZXh0MiAobWV0aG9kIDMpIG9yIHVuZGVmaW5lZCAobWV0aG9kIDIpLlxyXG4gKiBAcGFyYW0ge3N0cmluZ3whQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSBvcHRfYyBBcnJheSBvZiBkaWZmIHR1cGxlc1xyXG4gKiBmb3IgdGV4dDEgdG8gdGV4dDIgKG1ldGhvZCA0KSBvciB1bmRlZmluZWQgKG1ldGhvZHMgMSwyLDMpLlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9tYWtlID0gZnVuY3Rpb24oYSwgb3B0X2IsIG9wdF9jKSB7XHJcbiAgdmFyIHRleHQxLCBkaWZmcztcclxuICBpZiAodHlwZW9mIGEgPT0gJ3N0cmluZycgJiYgdHlwZW9mIG9wdF9iID09ICdzdHJpbmcnICYmXHJcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgLy8gTWV0aG9kIDE6IHRleHQxLCB0ZXh0MlxyXG4gICAgLy8gQ29tcHV0ZSBkaWZmcyBmcm9tIHRleHQxIGFuZCB0ZXh0Mi5cclxuICAgIHRleHQxID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovKGEpO1xyXG4gICAgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgLyoqIEB0eXBlIHtzdHJpbmd9ICovKG9wdF9iKSwgdHJ1ZSk7XHJcbiAgICBpZiAoZGlmZnMubGVuZ3RoID4gMikge1xyXG4gICAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljKGRpZmZzKTtcclxuICAgICAgdGhpcy5kaWZmX2NsZWFudXBFZmZpY2llbmN5KGRpZmZzKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGEgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wdF9iID09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgIHR5cGVvZiBvcHRfYyA9PSAndW5kZWZpbmVkJykge1xyXG4gICAgLy8gTWV0aG9kIDI6IGRpZmZzXHJcbiAgICAvLyBDb21wdXRlIHRleHQxIGZyb20gZGlmZnMuXHJcbiAgICBkaWZmcyA9IC8qKiBAdHlwZSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5EaWZmPn0gKi8oYSk7XHJcbiAgICB0ZXh0MSA9IHRoaXMuZGlmZl90ZXh0MShkaWZmcyk7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiBvcHRfYiAmJiB0eXBlb2Ygb3B0X2IgPT0gJ29iamVjdCcgJiZcclxuICAgICAgdHlwZW9mIG9wdF9jID09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyBNZXRob2QgMzogdGV4dDEsIGRpZmZzXHJcbiAgICB0ZXh0MSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhhKTtcclxuICAgIGRpZmZzID0gLyoqIEB0eXBlIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSAqLyhvcHRfYik7XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0X2IgPT0gJ3N0cmluZycgJiZcclxuICAgICAgb3B0X2MgJiYgdHlwZW9mIG9wdF9jID09ICdvYmplY3QnKSB7XHJcbiAgICAvLyBNZXRob2QgNDogdGV4dDEsIHRleHQyLCBkaWZmc1xyXG4gICAgLy8gdGV4dDIgaXMgbm90IHVzZWQuXHJcbiAgICB0ZXh0MSA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyhhKTtcclxuICAgIGRpZmZzID0gLyoqIEB0eXBlIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLkRpZmY+fSAqLyhvcHRfYyk7XHJcbiAgfSBlbHNlIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBjYWxsIGZvcm1hdCB0byBwYXRjaF9tYWtlLicpO1xyXG4gIH1cclxuXHJcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIFtdOyAgLy8gR2V0IHJpZCBvZiB0aGUgbnVsbCBjYXNlLlxyXG4gIH1cclxuICB2YXIgcGF0Y2hlcyA9IFtdO1xyXG4gIHZhciBwYXRjaCA9IG5ldyBkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaigpO1xyXG4gIHZhciBwYXRjaERpZmZMZW5ndGggPSAwOyAgLy8gS2VlcGluZyBvdXIgb3duIGxlbmd0aCB2YXIgaXMgZmFzdGVyIGluIEpTLlxyXG4gIHZhciBjaGFyX2NvdW50MSA9IDA7ICAvLyBOdW1iZXIgb2YgY2hhcmFjdGVycyBpbnRvIHRoZSB0ZXh0MSBzdHJpbmcuXHJcbiAgdmFyIGNoYXJfY291bnQyID0gMDsgIC8vIE51bWJlciBvZiBjaGFyYWN0ZXJzIGludG8gdGhlIHRleHQyIHN0cmluZy5cclxuICAvLyBTdGFydCB3aXRoIHRleHQxIChwcmVwYXRjaF90ZXh0KSBhbmQgYXBwbHkgdGhlIGRpZmZzIHVudGlsIHdlIGFycml2ZSBhdFxyXG4gIC8vIHRleHQyIChwb3N0cGF0Y2hfdGV4dCkuICBXZSByZWNyZWF0ZSB0aGUgcGF0Y2hlcyBvbmUgYnkgb25lIHRvIGRldGVybWluZVxyXG4gIC8vIGNvbnRleHQgaW5mby5cclxuICB2YXIgcHJlcGF0Y2hfdGV4dCA9IHRleHQxO1xyXG4gIHZhciBwb3N0cGF0Y2hfdGV4dCA9IHRleHQxO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcclxuICAgIHZhciBkaWZmX3R5cGUgPSBkaWZmc1t4XVswXTtcclxuICAgIHZhciBkaWZmX3RleHQgPSBkaWZmc1t4XVsxXTtcclxuXHJcbiAgICBpZiAoIXBhdGNoRGlmZkxlbmd0aCAmJiBkaWZmX3R5cGUgIT09IERJRkZfRVFVQUwpIHtcclxuICAgICAgLy8gQSBuZXcgcGF0Y2ggc3RhcnRzIGhlcmUuXHJcbiAgICAgIHBhdGNoLnN0YXJ0MSA9IGNoYXJfY291bnQxO1xyXG4gICAgICBwYXRjaC5zdGFydDIgPSBjaGFyX2NvdW50MjtcclxuICAgIH1cclxuXHJcbiAgICBzd2l0Y2ggKGRpZmZfdHlwZSkge1xyXG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxyXG4gICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xyXG4gICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgKyBkaWZmX3RleHQgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKGNoYXJfY291bnQyKTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgY2FzZSBESUZGX0RFTEVURTpcclxuICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XHJcbiAgICAgICAgcG9zdHBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoMCwgY2hhcl9jb3VudDIpICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZyhjaGFyX2NvdW50MiArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZl90ZXh0Lmxlbmd0aCk7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcclxuICAgICAgICBpZiAoZGlmZl90ZXh0Lmxlbmd0aCA8PSAyICogdGhpcy5QYXRjaF9NYXJnaW4gJiZcclxuICAgICAgICAgICAgcGF0Y2hEaWZmTGVuZ3RoICYmIGRpZmZzLmxlbmd0aCAhPSB4ICsgMSkge1xyXG4gICAgICAgICAgLy8gU21hbGwgZXF1YWxpdHkgaW5zaWRlIGEgcGF0Y2guXHJcbiAgICAgICAgICBwYXRjaC5kaWZmc1twYXRjaERpZmZMZW5ndGgrK10gPSBkaWZmc1t4XTtcclxuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRpZmZfdGV4dC5sZW5ndGggPj0gMiAqIHRoaXMuUGF0Y2hfTWFyZ2luKSB7XHJcbiAgICAgICAgICAvLyBUaW1lIGZvciBhIG5ldyBwYXRjaC5cclxuICAgICAgICAgIGlmIChwYXRjaERpZmZMZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXRjaF9hZGRDb250ZXh0XyhwYXRjaCwgcHJlcGF0Y2hfdGV4dCk7XHJcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XHJcbiAgICAgICAgICAgIHBhdGNoID0gbmV3IGRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqKCk7XHJcbiAgICAgICAgICAgIHBhdGNoRGlmZkxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIC8vIFVubGlrZSBVbmlkaWZmLCBvdXIgcGF0Y2ggbGlzdHMgaGF2ZSBhIHJvbGxpbmcgY29udGV4dC5cclxuICAgICAgICAgICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1kaWZmLW1hdGNoLXBhdGNoL3dpa2kvVW5pZGlmZlxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgcHJlcGF0Y2ggdGV4dCAmIHBvcyB0byByZWZsZWN0IHRoZSBhcHBsaWNhdGlvbiBvZiB0aGVcclxuICAgICAgICAgICAgLy8ganVzdCBjb21wbGV0ZWQgcGF0Y2guXHJcbiAgICAgICAgICAgIHByZXBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dDtcclxuICAgICAgICAgICAgY2hhcl9jb3VudDEgPSBjaGFyX2NvdW50MjtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIHRoZSBjdXJyZW50IGNoYXJhY3RlciBjb3VudC5cclxuICAgIGlmIChkaWZmX3R5cGUgIT09IERJRkZfSU5TRVJUKSB7XHJcbiAgICAgIGNoYXJfY291bnQxICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBpZiAoZGlmZl90eXBlICE9PSBESUZGX0RFTEVURSkge1xyXG4gICAgICBjaGFyX2NvdW50MiArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyBQaWNrIHVwIHRoZSBsZWZ0b3ZlciBwYXRjaCBpZiBub3QgZW1wdHkuXHJcbiAgaWYgKHBhdGNoRGlmZkxlbmd0aCkge1xyXG4gICAgdGhpcy5wYXRjaF9hZGRDb250ZXh0XyhwYXRjaCwgcHJlcGF0Y2hfdGV4dCk7XHJcbiAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBhdGNoZXM7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIGFuIGFycmF5IG9mIHBhdGNoZXMsIHJldHVybiBhbm90aGVyIGFycmF5IHRoYXQgaXMgaWRlbnRpY2FsLlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9kZWVwQ29weSA9IGZ1bmN0aW9uKHBhdGNoZXMpIHtcclxuICAvLyBNYWtpbmcgZGVlcCBjb3BpZXMgaXMgaGFyZCBpbiBKYXZhU2NyaXB0LlxyXG4gIHZhciBwYXRjaGVzQ29weSA9IFtdO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xyXG4gICAgdmFyIHBhdGNoID0gcGF0Y2hlc1t4XTtcclxuICAgIHZhciBwYXRjaENvcHkgPSBuZXcgZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmooKTtcclxuICAgIHBhdGNoQ29weS5kaWZmcyA9IFtdO1xyXG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBwYXRjaC5kaWZmcy5sZW5ndGg7IHkrKykge1xyXG4gICAgICBwYXRjaENvcHkuZGlmZnNbeV0gPSBwYXRjaC5kaWZmc1t5XS5zbGljZSgpO1xyXG4gICAgfVxyXG4gICAgcGF0Y2hDb3B5LnN0YXJ0MSA9IHBhdGNoLnN0YXJ0MTtcclxuICAgIHBhdGNoQ29weS5zdGFydDIgPSBwYXRjaC5zdGFydDI7XHJcbiAgICBwYXRjaENvcHkubGVuZ3RoMSA9IHBhdGNoLmxlbmd0aDE7XHJcbiAgICBwYXRjaENvcHkubGVuZ3RoMiA9IHBhdGNoLmxlbmd0aDI7XHJcbiAgICBwYXRjaGVzQ29weVt4XSA9IHBhdGNoQ29weTtcclxuICB9XHJcbiAgcmV0dXJuIHBhdGNoZXNDb3B5O1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBNZXJnZSBhIHNldCBvZiBwYXRjaGVzIG9udG8gdGhlIHRleHQuICBSZXR1cm4gYSBwYXRjaGVkIHRleHQsIGFzIHdlbGxcclxuICogYXMgYSBsaXN0IG9mIHRydWUvZmFsc2UgdmFsdWVzIGluZGljYXRpbmcgd2hpY2ggcGF0Y2hlcyB3ZXJlIGFwcGxpZWQuXHJcbiAqIEBwYXJhbSB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBwYXRjaGVzIEFycmF5IG9mIFBhdGNoIG9iamVjdHMuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IE9sZCB0ZXh0LlxyXG4gKiBAcmV0dXJuIHshQXJyYXkuPHN0cmluZ3whQXJyYXkuPGJvb2xlYW4+Pn0gVHdvIGVsZW1lbnQgQXJyYXksIGNvbnRhaW5pbmcgdGhlXHJcbiAqICAgICAgbmV3IHRleHQgYW5kIGFuIGFycmF5IG9mIGJvb2xlYW4gdmFsdWVzLlxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wcm90b3R5cGUucGF0Y2hfYXBwbHkgPSBmdW5jdGlvbihwYXRjaGVzLCB0ZXh0KSB7XHJcbiAgaWYgKHBhdGNoZXMubGVuZ3RoID09IDApIHtcclxuICAgIHJldHVybiBbdGV4dCwgW11dO1xyXG4gIH1cclxuXHJcbiAgLy8gRGVlcCBjb3B5IHRoZSBwYXRjaGVzIHNvIHRoYXQgbm8gY2hhbmdlcyBhcmUgbWFkZSB0byBvcmlnaW5hbHMuXHJcbiAgcGF0Y2hlcyA9IHRoaXMucGF0Y2hfZGVlcENvcHkocGF0Y2hlcyk7XHJcblxyXG4gIHZhciBudWxsUGFkZGluZyA9IHRoaXMucGF0Y2hfYWRkUGFkZGluZyhwYXRjaGVzKTtcclxuICB0ZXh0ID0gbnVsbFBhZGRpbmcgKyB0ZXh0ICsgbnVsbFBhZGRpbmc7XHJcblxyXG4gIHRoaXMucGF0Y2hfc3BsaXRNYXgocGF0Y2hlcyk7XHJcbiAgLy8gZGVsdGEga2VlcHMgdHJhY2sgb2YgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBleHBlY3RlZCBhbmQgYWN0dWFsIGxvY2F0aW9uXHJcbiAgLy8gb2YgdGhlIHByZXZpb3VzIHBhdGNoLiAgSWYgdGhlcmUgYXJlIHBhdGNoZXMgZXhwZWN0ZWQgYXQgcG9zaXRpb25zIDEwIGFuZFxyXG4gIC8vIDIwLCBidXQgdGhlIGZpcnN0IHBhdGNoIHdhcyBmb3VuZCBhdCAxMiwgZGVsdGEgaXMgMiBhbmQgdGhlIHNlY29uZCBwYXRjaFxyXG4gIC8vIGhhcyBhbiBlZmZlY3RpdmUgZXhwZWN0ZWQgcG9zaXRpb24gb2YgMjIuXHJcbiAgdmFyIGRlbHRhID0gMDtcclxuICB2YXIgcmVzdWx0cyA9IFtdO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xyXG4gICAgdmFyIGV4cGVjdGVkX2xvYyA9IHBhdGNoZXNbeF0uc3RhcnQyICsgZGVsdGE7XHJcbiAgICB2YXIgdGV4dDEgPSB0aGlzLmRpZmZfdGV4dDEocGF0Y2hlc1t4XS5kaWZmcyk7XHJcbiAgICB2YXIgc3RhcnRfbG9jO1xyXG4gICAgdmFyIGVuZF9sb2MgPSAtMTtcclxuICAgIGlmICh0ZXh0MS5sZW5ndGggPiB0aGlzLk1hdGNoX01heEJpdHMpIHtcclxuICAgICAgLy8gcGF0Y2hfc3BsaXRNYXggd2lsbCBvbmx5IHByb3ZpZGUgYW4gb3ZlcnNpemVkIHBhdHRlcm4gaW4gdGhlIGNhc2Ugb2ZcclxuICAgICAgLy8gYSBtb25zdGVyIGRlbGV0ZS5cclxuICAgICAgc3RhcnRfbG9jID0gdGhpcy5tYXRjaF9tYWluKHRleHQsIHRleHQxLnN1YnN0cmluZygwLCB0aGlzLk1hdGNoX01heEJpdHMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWRfbG9jKTtcclxuICAgICAgaWYgKHN0YXJ0X2xvYyAhPSAtMSkge1xyXG4gICAgICAgIGVuZF9sb2MgPSB0aGlzLm1hdGNoX21haW4odGV4dCxcclxuICAgICAgICAgICAgdGV4dDEuc3Vic3RyaW5nKHRleHQxLmxlbmd0aCAtIHRoaXMuTWF0Y2hfTWF4Qml0cyksXHJcbiAgICAgICAgICAgIGV4cGVjdGVkX2xvYyArIHRleHQxLmxlbmd0aCAtIHRoaXMuTWF0Y2hfTWF4Qml0cyk7XHJcbiAgICAgICAgaWYgKGVuZF9sb2MgPT0gLTEgfHwgc3RhcnRfbG9jID49IGVuZF9sb2MpIHtcclxuICAgICAgICAgIC8vIENhbid0IGZpbmQgdmFsaWQgdHJhaWxpbmcgY29udGV4dC4gIERyb3AgdGhpcyBwYXRjaC5cclxuICAgICAgICAgIHN0YXJ0X2xvYyA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RhcnRfbG9jID0gdGhpcy5tYXRjaF9tYWluKHRleHQsIHRleHQxLCBleHBlY3RlZF9sb2MpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0YXJ0X2xvYyA9PSAtMSkge1xyXG4gICAgICAvLyBObyBtYXRjaCBmb3VuZC4gIDooXHJcbiAgICAgIHJlc3VsdHNbeF0gPSBmYWxzZTtcclxuICAgICAgLy8gU3VidHJhY3QgdGhlIGRlbHRhIGZvciB0aGlzIGZhaWxlZCBwYXRjaCBmcm9tIHN1YnNlcXVlbnQgcGF0Y2hlcy5cclxuICAgICAgZGVsdGEgLT0gcGF0Y2hlc1t4XS5sZW5ndGgyIC0gcGF0Y2hlc1t4XS5sZW5ndGgxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy8gRm91bmQgYSBtYXRjaC4gIDopXHJcbiAgICAgIHJlc3VsdHNbeF0gPSB0cnVlO1xyXG4gICAgICBkZWx0YSA9IHN0YXJ0X2xvYyAtIGV4cGVjdGVkX2xvYztcclxuICAgICAgdmFyIHRleHQyO1xyXG4gICAgICBpZiAoZW5kX2xvYyA9PSAtMSkge1xyXG4gICAgICAgIHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jLCBzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jLCBlbmRfbG9jICsgdGhpcy5NYXRjaF9NYXhCaXRzKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGV4dDEgPT0gdGV4dDIpIHtcclxuICAgICAgICAvLyBQZXJmZWN0IG1hdGNoLCBqdXN0IHNob3ZlIHRoZSByZXBsYWNlbWVudCB0ZXh0IGluLlxyXG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MpICtcclxuICAgICAgICAgICAgICAgdGhpcy5kaWZmX3RleHQyKHBhdGNoZXNbeF0uZGlmZnMpICtcclxuICAgICAgICAgICAgICAgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgdGV4dDEubGVuZ3RoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBJbXBlcmZlY3QgbWF0Y2guICBSdW4gYSBkaWZmIHRvIGdldCBhIGZyYW1ld29yayBvZiBlcXVpdmFsZW50XHJcbiAgICAgICAgLy8gaW5kaWNlcy5cclxuICAgICAgICB2YXIgZGlmZnMgPSB0aGlzLmRpZmZfbWFpbih0ZXh0MSwgdGV4dDIsIGZhbHNlKTtcclxuICAgICAgICBpZiAodGV4dDEubGVuZ3RoID4gdGhpcy5NYXRjaF9NYXhCaXRzICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGlmZl9sZXZlbnNodGVpbihkaWZmcykgLyB0ZXh0MS5sZW5ndGggPlxyXG4gICAgICAgICAgICB0aGlzLlBhdGNoX0RlbGV0ZVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgLy8gVGhlIGVuZCBwb2ludHMgbWF0Y2gsIGJ1dCB0aGUgY29udGVudCBpcyB1bmFjY2VwdGFibHkgYmFkLlxyXG4gICAgICAgICAgcmVzdWx0c1t4XSA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmRpZmZfY2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xyXG4gICAgICAgICAgdmFyIGluZGV4MSA9IDA7XHJcbiAgICAgICAgICB2YXIgaW5kZXgyO1xyXG4gICAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBwYXRjaGVzW3hdLmRpZmZzLmxlbmd0aDsgeSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBtb2QgPSBwYXRjaGVzW3hdLmRpZmZzW3ldO1xyXG4gICAgICAgICAgICBpZiAobW9kWzBdICE9PSBESUZGX0VRVUFMKSB7XHJcbiAgICAgICAgICAgICAgaW5kZXgyID0gdGhpcy5kaWZmX3hJbmRleChkaWZmcywgaW5kZXgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobW9kWzBdID09PSBESUZGX0lOU0VSVCkgeyAgLy8gSW5zZXJ0aW9uXHJcbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYyArIGluZGV4MikgKyBtb2RbMV0gK1xyXG4gICAgICAgICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MgKyBpbmRleDIpO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1vZFswXSA9PT0gRElGRl9ERUxFVEUpIHsgIC8vIERlbGV0aW9uXHJcbiAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0X2xvYyArIGluZGV4MikgK1xyXG4gICAgICAgICAgICAgICAgICAgICB0ZXh0LnN1YnN0cmluZyhzdGFydF9sb2MgKyB0aGlzLmRpZmZfeEluZGV4KGRpZmZzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgxICsgbW9kWzFdLmxlbmd0aCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtb2RbMF0gIT09IERJRkZfREVMRVRFKSB7XHJcbiAgICAgICAgICAgICAgaW5kZXgxICs9IG1vZFsxXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgLy8gU3RyaXAgdGhlIHBhZGRpbmcgb2ZmLlxyXG4gIHRleHQgPSB0ZXh0LnN1YnN0cmluZyhudWxsUGFkZGluZy5sZW5ndGgsIHRleHQubGVuZ3RoIC0gbnVsbFBhZGRpbmcubGVuZ3RoKTtcclxuICByZXR1cm4gW3RleHQsIHJlc3VsdHNdO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBZGQgc29tZSBwYWRkaW5nIG9uIHRleHQgc3RhcnQgYW5kIGVuZCBzbyB0aGF0IGVkZ2VzIGNhbiBtYXRjaCBzb21ldGhpbmcuXHJcbiAqIEludGVuZGVkIHRvIGJlIGNhbGxlZCBvbmx5IGZyb20gd2l0aGluIHBhdGNoX2FwcGx5LlxyXG4gKiBAcGFyYW0geyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqPn0gcGF0Y2hlcyBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBwYWRkaW5nIHN0cmluZyBhZGRlZCB0byBlYWNoIHNpZGUuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9hZGRQYWRkaW5nID0gZnVuY3Rpb24ocGF0Y2hlcykge1xyXG4gIHZhciBwYWRkaW5nTGVuZ3RoID0gdGhpcy5QYXRjaF9NYXJnaW47XHJcbiAgdmFyIG51bGxQYWRkaW5nID0gJyc7XHJcbiAgZm9yICh2YXIgeCA9IDE7IHggPD0gcGFkZGluZ0xlbmd0aDsgeCsrKSB7XHJcbiAgICBudWxsUGFkZGluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHgpO1xyXG4gIH1cclxuXHJcbiAgLy8gQnVtcCBhbGwgdGhlIHBhdGNoZXMgZm9yd2FyZC5cclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcclxuICAgIHBhdGNoZXNbeF0uc3RhcnQxICs9IHBhZGRpbmdMZW5ndGg7XHJcbiAgICBwYXRjaGVzW3hdLnN0YXJ0MiArPSBwYWRkaW5nTGVuZ3RoO1xyXG4gIH1cclxuXHJcbiAgLy8gQWRkIHNvbWUgcGFkZGluZyBvbiBzdGFydCBvZiBmaXJzdCBkaWZmLlxyXG4gIHZhciBwYXRjaCA9IHBhdGNoZXNbMF07XHJcbiAgdmFyIGRpZmZzID0gcGF0Y2guZGlmZnM7XHJcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PSAwIHx8IGRpZmZzWzBdWzBdICE9IERJRkZfRVFVQUwpIHtcclxuICAgIC8vIEFkZCBudWxsUGFkZGluZyBlcXVhbGl0eS5cclxuICAgIGRpZmZzLnVuc2hpZnQoW0RJRkZfRVFVQUwsIG51bGxQYWRkaW5nXSk7XHJcbiAgICBwYXRjaC5zdGFydDEgLT0gcGFkZGluZ0xlbmd0aDsgIC8vIFNob3VsZCBiZSAwLlxyXG4gICAgcGF0Y2guc3RhcnQyIC09IHBhZGRpbmdMZW5ndGg7ICAvLyBTaG91bGQgYmUgMC5cclxuICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcclxuICAgIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcclxuICB9IGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1swXVsxXS5sZW5ndGgpIHtcclxuICAgIC8vIEdyb3cgZmlyc3QgZXF1YWxpdHkuXHJcbiAgICB2YXIgZXh0cmFMZW5ndGggPSBwYWRkaW5nTGVuZ3RoIC0gZGlmZnNbMF1bMV0ubGVuZ3RoO1xyXG4gICAgZGlmZnNbMF1bMV0gPSBudWxsUGFkZGluZy5zdWJzdHJpbmcoZGlmZnNbMF1bMV0ubGVuZ3RoKSArIGRpZmZzWzBdWzFdO1xyXG4gICAgcGF0Y2guc3RhcnQxIC09IGV4dHJhTGVuZ3RoO1xyXG4gICAgcGF0Y2guc3RhcnQyIC09IGV4dHJhTGVuZ3RoO1xyXG4gICAgcGF0Y2gubGVuZ3RoMSArPSBleHRyYUxlbmd0aDtcclxuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XHJcbiAgfVxyXG5cclxuICAvLyBBZGQgc29tZSBwYWRkaW5nIG9uIGVuZCBvZiBsYXN0IGRpZmYuXHJcbiAgcGF0Y2ggPSBwYXRjaGVzW3BhdGNoZXMubGVuZ3RoIC0gMV07XHJcbiAgZGlmZnMgPSBwYXRjaC5kaWZmcztcclxuICBpZiAoZGlmZnMubGVuZ3RoID09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT0gRElGRl9FUVVBTCkge1xyXG4gICAgLy8gQWRkIG51bGxQYWRkaW5nIGVxdWFsaXR5LlxyXG4gICAgZGlmZnMucHVzaChbRElGRl9FUVVBTCwgbnVsbFBhZGRpbmddKTtcclxuICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcclxuICAgIHBhdGNoLmxlbmd0aDIgKz0gcGFkZGluZ0xlbmd0aDtcclxuICB9IGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGgpIHtcclxuICAgIC8vIEdyb3cgbGFzdCBlcXVhbGl0eS5cclxuICAgIHZhciBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGg7XHJcbiAgICBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSArPSBudWxsUGFkZGluZy5zdWJzdHJpbmcoMCwgZXh0cmFMZW5ndGgpO1xyXG4gICAgcGF0Y2gubGVuZ3RoMSArPSBleHRyYUxlbmd0aDtcclxuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbnVsbFBhZGRpbmc7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIExvb2sgdGhyb3VnaCB0aGUgcGF0Y2hlcyBhbmQgYnJlYWsgdXAgYW55IHdoaWNoIGFyZSBsb25nZXIgdGhhbiB0aGUgbWF4aW11bVxyXG4gKiBsaW1pdCBvZiB0aGUgbWF0Y2ggYWxnb3JpdGhtLlxyXG4gKiBJbnRlbmRlZCB0byBiZSBjYWxsZWQgb25seSBmcm9tIHdpdGhpbiBwYXRjaF9hcHBseS5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucHJvdG90eXBlLnBhdGNoX3NwbGl0TWF4ID0gZnVuY3Rpb24ocGF0Y2hlcykge1xyXG4gIHZhciBwYXRjaF9zaXplID0gdGhpcy5NYXRjaF9NYXhCaXRzO1xyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xyXG4gICAgaWYgKHBhdGNoZXNbeF0ubGVuZ3RoMSA8PSBwYXRjaF9zaXplKSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGJpZ3BhdGNoID0gcGF0Y2hlc1t4XTtcclxuICAgIC8vIFJlbW92ZSB0aGUgYmlnIG9sZCBwYXRjaC5cclxuICAgIHBhdGNoZXMuc3BsaWNlKHgtLSwgMSk7XHJcbiAgICB2YXIgc3RhcnQxID0gYmlncGF0Y2guc3RhcnQxO1xyXG4gICAgdmFyIHN0YXJ0MiA9IGJpZ3BhdGNoLnN0YXJ0MjtcclxuICAgIHZhciBwcmVjb250ZXh0ID0gJyc7XHJcbiAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwKSB7XHJcbiAgICAgIC8vIENyZWF0ZSBvbmUgb2Ygc2V2ZXJhbCBzbWFsbGVyIHBhdGNoZXMuXHJcbiAgICAgIHZhciBwYXRjaCA9IG5ldyBkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaigpO1xyXG4gICAgICB2YXIgZW1wdHkgPSB0cnVlO1xyXG4gICAgICBwYXRjaC5zdGFydDEgPSBzdGFydDEgLSBwcmVjb250ZXh0Lmxlbmd0aDtcclxuICAgICAgcGF0Y2guc3RhcnQyID0gc3RhcnQyIC0gcHJlY29udGV4dC5sZW5ndGg7XHJcbiAgICAgIGlmIChwcmVjb250ZXh0ICE9PSAnJykge1xyXG4gICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgyID0gcHJlY29udGV4dC5sZW5ndGg7XHJcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9FUVVBTCwgcHJlY29udGV4dF0pO1xyXG4gICAgICB9XHJcbiAgICAgIHdoaWxlIChiaWdwYXRjaC5kaWZmcy5sZW5ndGggIT09IDAgJiZcclxuICAgICAgICAgICAgIHBhdGNoLmxlbmd0aDEgPCBwYXRjaF9zaXplIC0gdGhpcy5QYXRjaF9NYXJnaW4pIHtcclxuICAgICAgICB2YXIgZGlmZl90eXBlID0gYmlncGF0Y2guZGlmZnNbMF1bMF07XHJcbiAgICAgICAgdmFyIGRpZmZfdGV4dCA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdO1xyXG4gICAgICAgIGlmIChkaWZmX3R5cGUgPT09IERJRkZfSU5TRVJUKSB7XHJcbiAgICAgICAgICAvLyBJbnNlcnRpb25zIGFyZSBoYXJtbGVzcy5cclxuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgIHN0YXJ0MiArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChiaWdwYXRjaC5kaWZmcy5zaGlmdCgpKTtcclxuICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmIChkaWZmX3R5cGUgPT09IERJRkZfREVMRVRFICYmIHBhdGNoLmRpZmZzLmxlbmd0aCA9PSAxICYmXHJcbiAgICAgICAgICAgICAgICAgICBwYXRjaC5kaWZmc1swXVswXSA9PSBESUZGX0VRVUFMICYmXHJcbiAgICAgICAgICAgICAgICAgICBkaWZmX3RleHQubGVuZ3RoID4gMiAqIHBhdGNoX3NpemUpIHtcclxuICAgICAgICAgIC8vIFRoaXMgaXMgYSBsYXJnZSBkZWxldGlvbi4gIExldCBpdCBwYXNzIGluIG9uZSBjaHVuay5cclxuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgIHN0YXJ0MSArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcclxuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW2RpZmZfdHlwZSwgZGlmZl90ZXh0XSk7XHJcbiAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBEZWxldGlvbiBvciBlcXVhbGl0eS4gIE9ubHkgdGFrZSBhcyBtdWNoIGFzIHdlIGNhbiBzdG9tYWNoLlxyXG4gICAgICAgICAgZGlmZl90ZXh0ID0gZGlmZl90ZXh0LnN1YnN0cmluZygwLFxyXG4gICAgICAgICAgICAgIHBhdGNoX3NpemUgLSBwYXRjaC5sZW5ndGgxIC0gdGhpcy5QYXRjaF9NYXJnaW4pO1xyXG4gICAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBkaWZmX3RleHQubGVuZ3RoO1xyXG4gICAgICAgICAgc3RhcnQxICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICBpZiAoZGlmZl90eXBlID09PSBESUZGX0VRVUFMKSB7XHJcbiAgICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcclxuICAgICAgICAgICAgc3RhcnQyICs9IGRpZmZfdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBlbXB0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbZGlmZl90eXBlLCBkaWZmX3RleHRdKTtcclxuICAgICAgICAgIGlmIChkaWZmX3RleHQgPT0gYmlncGF0Y2guZGlmZnNbMF1bMV0pIHtcclxuICAgICAgICAgICAgYmlncGF0Y2guZGlmZnMuc2hpZnQoKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzWzBdWzFdID1cclxuICAgICAgICAgICAgICAgIGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmX3RleHQubGVuZ3RoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgLy8gQ29tcHV0ZSB0aGUgaGVhZCBjb250ZXh0IGZvciB0aGUgbmV4dCBwYXRjaC5cclxuICAgICAgcHJlY29udGV4dCA9IHRoaXMuZGlmZl90ZXh0MihwYXRjaC5kaWZmcyk7XHJcbiAgICAgIHByZWNvbnRleHQgPVxyXG4gICAgICAgICAgcHJlY29udGV4dC5zdWJzdHJpbmcocHJlY29udGV4dC5sZW5ndGggLSB0aGlzLlBhdGNoX01hcmdpbik7XHJcbiAgICAgIC8vIEFwcGVuZCB0aGUgZW5kIGNvbnRleHQgZm9yIHRoaXMgcGF0Y2guXHJcbiAgICAgIHZhciBwb3N0Y29udGV4dCA9IHRoaXMuZGlmZl90ZXh0MShiaWdwYXRjaC5kaWZmcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJzdHJpbmcoMCwgdGhpcy5QYXRjaF9NYXJnaW4pO1xyXG4gICAgICBpZiAocG9zdGNvbnRleHQgIT09ICcnKSB7XHJcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBwb3N0Y29udGV4dC5sZW5ndGg7XHJcbiAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBwb3N0Y29udGV4dC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHBhdGNoLmRpZmZzLmxlbmd0aCAhPT0gMCAmJlxyXG4gICAgICAgICAgICBwYXRjaC5kaWZmc1twYXRjaC5kaWZmcy5sZW5ndGggLSAxXVswXSA9PT0gRElGRl9FUVVBTCkge1xyXG4gICAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2guZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gcG9zdGNvbnRleHQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIHBvc3Rjb250ZXh0XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmICghZW1wdHkpIHtcclxuICAgICAgICBwYXRjaGVzLnNwbGljZSgrK3gsIDAsIHBhdGNoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufTtcclxuXHJcblxyXG4vKipcclxuICogVGFrZSBhIGxpc3Qgb2YgcGF0Y2hlcyBhbmQgcmV0dXJuIGEgdGV4dHVhbCByZXByZXNlbnRhdGlvbi5cclxuICogQHBhcmFtIHshQXJyYXkuPCFkaWZmX21hdGNoX3BhdGNoLnBhdGNoX29iaj59IHBhdGNoZXMgQXJyYXkgb2YgUGF0Y2ggb2JqZWN0cy5cclxuICogQHJldHVybiB7c3RyaW5nfSBUZXh0IHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF90b1RleHQgPSBmdW5jdGlvbihwYXRjaGVzKSB7XHJcbiAgdmFyIHRleHQgPSBbXTtcclxuICBmb3IgKHZhciB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspIHtcclxuICAgIHRleHRbeF0gPSBwYXRjaGVzW3hdO1xyXG4gIH1cclxuICByZXR1cm4gdGV4dC5qb2luKCcnKTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogUGFyc2UgYSB0ZXh0dWFsIHJlcHJlc2VudGF0aW9uIG9mIHBhdGNoZXMgYW5kIHJldHVybiBhIGxpc3Qgb2YgUGF0Y2ggb2JqZWN0cy5cclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRsaW5lIFRleHQgcmVwcmVzZW50YXRpb24gb2YgcGF0Y2hlcy5cclxuICogQHJldHVybiB7IUFycmF5LjwhZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmo+fSBBcnJheSBvZiBQYXRjaCBvYmplY3RzLlxyXG4gKiBAdGhyb3dzIHshRXJyb3J9IElmIGludmFsaWQgaW5wdXQuXHJcbiAqL1xyXG5kaWZmX21hdGNoX3BhdGNoLnByb3RvdHlwZS5wYXRjaF9mcm9tVGV4dCA9IGZ1bmN0aW9uKHRleHRsaW5lKSB7XHJcbiAgdmFyIHBhdGNoZXMgPSBbXTtcclxuICBpZiAoIXRleHRsaW5lKSB7XHJcbiAgICByZXR1cm4gcGF0Y2hlcztcclxuICB9XHJcbiAgdmFyIHRleHQgPSB0ZXh0bGluZS5zcGxpdCgnXFxuJyk7XHJcbiAgdmFyIHRleHRQb2ludGVyID0gMDtcclxuICB2YXIgcGF0Y2hIZWFkZXIgPSAvXkBAIC0oXFxkKyksPyhcXGQqKSBcXCsoXFxkKyksPyhcXGQqKSBAQCQvO1xyXG4gIHdoaWxlICh0ZXh0UG9pbnRlciA8IHRleHQubGVuZ3RoKSB7XHJcbiAgICB2YXIgbSA9IHRleHRbdGV4dFBvaW50ZXJdLm1hdGNoKHBhdGNoSGVhZGVyKTtcclxuICAgIGlmICghbSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGF0Y2ggc3RyaW5nOiAnICsgdGV4dFt0ZXh0UG9pbnRlcl0pO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhdGNoID0gbmV3IGRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqKCk7XHJcbiAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xyXG4gICAgcGF0Y2guc3RhcnQxID0gcGFyc2VJbnQobVsxXSwgMTApO1xyXG4gICAgaWYgKG1bMl0gPT09ICcnKSB7XHJcbiAgICAgIHBhdGNoLnN0YXJ0MS0tO1xyXG4gICAgICBwYXRjaC5sZW5ndGgxID0gMTtcclxuICAgIH0gZWxzZSBpZiAobVsyXSA9PSAnMCcpIHtcclxuICAgICAgcGF0Y2gubGVuZ3RoMSA9IDA7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBwYXRjaC5zdGFydDEtLTtcclxuICAgICAgcGF0Y2gubGVuZ3RoMSA9IHBhcnNlSW50KG1bMl0sIDEwKTtcclxuICAgIH1cclxuXHJcbiAgICBwYXRjaC5zdGFydDIgPSBwYXJzZUludChtWzNdLCAxMCk7XHJcbiAgICBpZiAobVs0XSA9PT0gJycpIHtcclxuICAgICAgcGF0Y2guc3RhcnQyLS07XHJcbiAgICAgIHBhdGNoLmxlbmd0aDIgPSAxO1xyXG4gICAgfSBlbHNlIGlmIChtWzRdID09ICcwJykge1xyXG4gICAgICBwYXRjaC5sZW5ndGgyID0gMDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHBhdGNoLnN0YXJ0Mi0tO1xyXG4gICAgICBwYXRjaC5sZW5ndGgyID0gcGFyc2VJbnQobVs0XSwgMTApO1xyXG4gICAgfVxyXG4gICAgdGV4dFBvaW50ZXIrKztcclxuXHJcbiAgICB3aGlsZSAodGV4dFBvaW50ZXIgPCB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgICB2YXIgc2lnbiA9IHRleHRbdGV4dFBvaW50ZXJdLmNoYXJBdCgwKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB2YXIgbGluZSA9IGRlY29kZVVSSSh0ZXh0W3RleHRQb2ludGVyXS5zdWJzdHJpbmcoMSkpO1xyXG4gICAgICB9IGNhdGNoIChleCkge1xyXG4gICAgICAgIC8vIE1hbGZvcm1lZCBVUkkgc2VxdWVuY2UuXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGVzY2FwZSBpbiBwYXRjaF9mcm9tVGV4dDogJyArIGxpbmUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzaWduID09ICctJykge1xyXG4gICAgICAgIC8vIERlbGV0aW9uLlxyXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfREVMRVRFLCBsaW5lXSk7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PSAnKycpIHtcclxuICAgICAgICAvLyBJbnNlcnRpb24uXHJcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChbRElGRl9JTlNFUlQsIGxpbmVdKTtcclxuICAgICAgfSBlbHNlIGlmIChzaWduID09ICcgJykge1xyXG4gICAgICAgIC8vIE1pbm9yIGVxdWFsaXR5LlxyXG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goW0RJRkZfRVFVQUwsIGxpbmVdKTtcclxuICAgICAgfSBlbHNlIGlmIChzaWduID09ICdAJykge1xyXG4gICAgICAgIC8vIFN0YXJ0IG9mIG5leHQgcGF0Y2guXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PT0gJycpIHtcclxuICAgICAgICAvLyBCbGFuayBsaW5lPyAgV2hhdGV2ZXIuXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gV1RGP1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXRjaCBtb2RlIFwiJyArIHNpZ24gKyAnXCIgaW46ICcgKyBsaW5lKTtcclxuICAgICAgfVxyXG4gICAgICB0ZXh0UG9pbnRlcisrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcGF0Y2hlcztcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ2xhc3MgcmVwcmVzZW50aW5nIG9uZSBwYXRjaCBvcGVyYXRpb24uXHJcbiAqIEBjb25zdHJ1Y3RvclxyXG4gKi9cclxuZGlmZl9tYXRjaF9wYXRjaC5wYXRjaF9vYmogPSBmdW5jdGlvbigpIHtcclxuICAvKiogQHR5cGUgeyFBcnJheS48IWRpZmZfbWF0Y2hfcGF0Y2guRGlmZj59ICovXHJcbiAgdGhpcy5kaWZmcyA9IFtdO1xyXG4gIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cclxuICB0aGlzLnN0YXJ0MSA9IG51bGw7XHJcbiAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xyXG4gIHRoaXMuc3RhcnQyID0gbnVsbDtcclxuICAvKiogQHR5cGUge251bWJlcn0gKi9cclxuICB0aGlzLmxlbmd0aDEgPSAwO1xyXG4gIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xyXG4gIHRoaXMubGVuZ3RoMiA9IDA7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIEVtbXVsYXRlIEdOVSBkaWZmJ3MgZm9ybWF0LlxyXG4gKiBIZWFkZXI6IEBAIC0zODIsOCArNDgxLDkgQEBcclxuICogSW5kaWNpZXMgYXJlIHByaW50ZWQgYXMgMS1iYXNlZCwgbm90IDAtYmFzZWQuXHJcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEdOVSBkaWZmIHN0cmluZy5cclxuICovXHJcbmRpZmZfbWF0Y2hfcGF0Y2gucGF0Y2hfb2JqLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG4gIHZhciBjb29yZHMxLCBjb29yZHMyO1xyXG4gIGlmICh0aGlzLmxlbmd0aDEgPT09IDApIHtcclxuICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArICcsMCc7XHJcbiAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aDEgPT0gMSkge1xyXG4gICAgY29vcmRzMSA9IHRoaXMuc3RhcnQxICsgMTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29vcmRzMSA9ICh0aGlzLnN0YXJ0MSArIDEpICsgJywnICsgdGhpcy5sZW5ndGgxO1xyXG4gIH1cclxuICBpZiAodGhpcy5sZW5ndGgyID09PSAwKSB7XHJcbiAgICBjb29yZHMyID0gdGhpcy5zdGFydDIgKyAnLDAnO1xyXG4gIH0gZWxzZSBpZiAodGhpcy5sZW5ndGgyID09IDEpIHtcclxuICAgIGNvb3JkczIgPSB0aGlzLnN0YXJ0MiArIDE7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvb3JkczIgPSAodGhpcy5zdGFydDIgKyAxKSArICcsJyArIHRoaXMubGVuZ3RoMjtcclxuICB9XHJcbiAgdmFyIHRleHQgPSBbJ0BAIC0nICsgY29vcmRzMSArICcgKycgKyBjb29yZHMyICsgJyBAQFxcbiddO1xyXG4gIHZhciBvcDtcclxuICAvLyBFc2NhcGUgdGhlIGJvZHkgb2YgdGhlIHBhdGNoIHdpdGggJXh4IG5vdGF0aW9uLlxyXG4gIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5kaWZmcy5sZW5ndGg7IHgrKykge1xyXG4gICAgc3dpdGNoICh0aGlzLmRpZmZzW3hdWzBdKSB7XHJcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XHJcbiAgICAgICAgb3AgPSAnKyc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XHJcbiAgICAgICAgb3AgPSAnLSc7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcclxuICAgICAgICBvcCA9ICcgJztcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHRleHRbeCArIDFdID0gb3AgKyBlbmNvZGVVUkkodGhpcy5kaWZmc1t4XVsxXSkgKyAnXFxuJztcclxuICB9XHJcbiAgcmV0dXJuIHRleHQuam9pbignJykucmVwbGFjZSgvJTIwL2csICcgJyk7XHJcbn07XHJcblxyXG5cclxuLy8gVGhlIGZvbGxvd2luZyBleHBvcnQgY29kZSB3YXMgYWRkZWQgYnkgQEZvcmJlc0xpbmRlc2F5XHJcbm1vZHVsZS5leHBvcnRzID0gZGlmZl9tYXRjaF9wYXRjaDtcclxubW9kdWxlLmV4cG9ydHNbJ2RpZmZfbWF0Y2hfcGF0Y2gnXSA9IGRpZmZfbWF0Y2hfcGF0Y2g7XHJcbm1vZHVsZS5leHBvcnRzWydESUZGX0RFTEVURSddID0gRElGRl9ERUxFVEU7XHJcbm1vZHVsZS5leHBvcnRzWydESUZGX0lOU0VSVCddID0gRElGRl9JTlNFUlQ7XHJcbm1vZHVsZS5leHBvcnRzWydESUZGX0VRVUFMJ10gPSBESUZGX0VRVUFMO1xyXG4iLCJcbi8qKlxuICogRXhwb3NlIGBwYXJzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwYXJzZTtcblxuLyoqXG4gKiBUZXN0cyBmb3IgYnJvd3NlciBzdXBwb3J0LlxuICovXG5cbnZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbi8vIFNldHVwXG5kaXYuaW5uZXJIVE1MID0gJyAgPGxpbmsvPjx0YWJsZT48L3RhYmxlPjxhIGhyZWY9XCIvYVwiPmE8L2E+PGlucHV0IHR5cGU9XCJjaGVja2JveFwiLz4nO1xuLy8gTWFrZSBzdXJlIHRoYXQgbGluayBlbGVtZW50cyBnZXQgc2VyaWFsaXplZCBjb3JyZWN0bHkgYnkgaW5uZXJIVE1MXG4vLyBUaGlzIHJlcXVpcmVzIGEgd3JhcHBlciBlbGVtZW50IGluIElFXG52YXIgaW5uZXJIVE1MQnVnID0gIWRpdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGluaycpLmxlbmd0aDtcbmRpdiA9IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBXcmFwIG1hcCBmcm9tIGpxdWVyeS5cbiAqL1xuXG52YXIgbWFwID0ge1xuICBsZWdlbmQ6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICB0cjogWzIsICc8dGFibGU+PHRib2R5PicsICc8L3Rib2R5PjwvdGFibGU+J10sXG4gIGNvbDogWzIsICc8dGFibGU+PHRib2R5PjwvdGJvZHk+PGNvbGdyb3VwPicsICc8L2NvbGdyb3VwPjwvdGFibGU+J10sXG4gIC8vIGZvciBzY3JpcHQvbGluay9zdHlsZSB0YWdzIHRvIHdvcmsgaW4gSUU2LTgsIHlvdSBoYXZlIHRvIHdyYXBcbiAgLy8gaW4gYSBkaXYgd2l0aCBhIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlciBpbiBmcm9udCwgaGEhXG4gIF9kZWZhdWx0OiBpbm5lckhUTUxCdWcgPyBbMSwgJ1g8ZGl2PicsICc8L2Rpdj4nXSA6IFswLCAnJywgJyddXG59O1xuXG5tYXAudGQgPVxubWFwLnRoID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbm1hcC5vcHRpb24gPVxubWFwLm9wdGdyb3VwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwibXVsdGlwbGVcIj4nLCAnPC9zZWxlY3Q+J107XG5cbm1hcC50aGVhZCA9XG5tYXAudGJvZHkgPVxubWFwLmNvbGdyb3VwID1cbm1hcC5jYXB0aW9uID1cbm1hcC50Zm9vdCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xuXG5tYXAucG9seWxpbmUgPVxubWFwLmVsbGlwc2UgPVxubWFwLnBvbHlnb24gPVxubWFwLmNpcmNsZSA9XG5tYXAudGV4dCA9XG5tYXAubGluZSA9XG5tYXAucGF0aCA9XG5tYXAucmVjdCA9XG5tYXAuZyA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmVyc2lvbj1cIjEuMVwiPicsJzwvc3ZnPiddO1xuXG4vKipcbiAqIFBhcnNlIGBodG1sYCBhbmQgcmV0dXJuIGEgRE9NIE5vZGUgaW5zdGFuY2UsIHdoaWNoIGNvdWxkIGJlIGEgVGV4dE5vZGUsXG4gKiBIVE1MIERPTSBOb2RlIG9mIHNvbWUga2luZCAoPGRpdj4gZm9yIGV4YW1wbGUpLCBvciBhIERvY3VtZW50RnJhZ21lbnRcbiAqIGluc3RhbmNlLCBkZXBlbmRpbmcgb24gdGhlIGNvbnRlbnRzIG9mIHRoZSBgaHRtbGAgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBodG1sIC0gSFRNTCBzdHJpbmcgdG8gXCJkb21pZnlcIlxuICogQHBhcmFtIHtEb2N1bWVudH0gZG9jIC0gVGhlIGBkb2N1bWVudGAgaW5zdGFuY2UgdG8gY3JlYXRlIHRoZSBOb2RlIGZvclxuICogQHJldHVybiB7RE9NTm9kZX0gdGhlIFRleHROb2RlLCBET00gTm9kZSwgb3IgRG9jdW1lbnRGcmFnbWVudCBpbnN0YW5jZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UoaHRtbCwgZG9jKSB7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgaHRtbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkJyk7XG5cbiAgLy8gZGVmYXVsdCB0byB0aGUgZ2xvYmFsIGBkb2N1bWVudGAgb2JqZWN0XG4gIGlmICghZG9jKSBkb2MgPSBkb2N1bWVudDtcblxuICAvLyB0YWcgbmFtZVxuICB2YXIgbSA9IC88KFtcXHc6XSspLy5leGVjKGh0bWwpO1xuICBpZiAoIW0pIHJldHVybiBkb2MuY3JlYXRlVGV4dE5vZGUoaHRtbCk7XG5cbiAgaHRtbCA9IGh0bWwucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpOyAvLyBSZW1vdmUgbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlXG5cbiAgdmFyIHRhZyA9IG1bMV07XG5cbiAgLy8gYm9keSBzdXBwb3J0XG4gIGlmICh0YWcgPT0gJ2JvZHknKSB7XG4gICAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2h0bWwnKTtcbiAgICBlbC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBlbC5yZW1vdmVDaGlsZChlbC5sYXN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gd3JhcCBtYXBcbiAgdmFyIHdyYXAgPSBtYXBbdGFnXSB8fCBtYXAuX2RlZmF1bHQ7XG4gIHZhciBkZXB0aCA9IHdyYXBbMF07XG4gIHZhciBwcmVmaXggPSB3cmFwWzFdO1xuICB2YXIgc3VmZml4ID0gd3JhcFsyXTtcbiAgdmFyIGVsID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbC5pbm5lckhUTUwgPSBwcmVmaXggKyBodG1sICsgc3VmZml4O1xuICB3aGlsZSAoZGVwdGgtLSkgZWwgPSBlbC5sYXN0Q2hpbGQ7XG5cbiAgLy8gb25lIGVsZW1lbnRcbiAgaWYgKGVsLmZpcnN0Q2hpbGQgPT0gZWwubGFzdENoaWxkKSB7XG4gICAgcmV0dXJuIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gc2V2ZXJhbCBlbGVtZW50c1xuICB2YXIgZnJhZ21lbnQgPSBkb2MuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICB3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xuICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpKTtcbiAgfVxuXG4gIHJldHVybiBmcmFnbWVudDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIGZpbGVzaXplXG4gKlxuICogQGF1dGhvciBKYXNvbiBNdWxsaWdhbiA8amFzb24ubXVsbGlnYW5AYXZvaWR3b3JrLmNvbT5cbiAqIEBjb3B5cmlnaHQgMjAxNSBKYXNvbiBNdWxsaWdhblxuICogQGxpY2Vuc2UgQlNELTMgPGh0dHBzOi8vcmF3LmdpdGh1Yi5jb20vYXZvaWR3b3JrL2ZpbGVzaXplLmpzL21hc3Rlci9MSUNFTlNFPlxuICogQGxpbmsgaHR0cDovL2ZpbGVzaXplanMuY29tXG4gKiBAbW9kdWxlIGZpbGVzaXplXG4gKiBAdmVyc2lvbiAzLjEuMlxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCkge1xuXHR2YXIgYml0ID0gL2IkLztcblx0dmFyIHNpID0ge1xuXHRcdGJpdHM6IFtcIkJcIiwgXCJrYlwiLCBcIk1iXCIsIFwiR2JcIiwgXCJUYlwiLCBcIlBiXCIsIFwiRWJcIiwgXCJaYlwiLCBcIlliXCJdLFxuXHRcdGJ5dGVzOiBbXCJCXCIsIFwia0JcIiwgXCJNQlwiLCBcIkdCXCIsIFwiVEJcIiwgXCJQQlwiLCBcIkVCXCIsIFwiWkJcIiwgXCJZQlwiXVxuXHR9O1xuXG5cdC8qKlxuICAqIGZpbGVzaXplXG4gICpcbiAgKiBAbWV0aG9kIGZpbGVzaXplXG4gICogQHBhcmFtICB7TWl4ZWR9ICAgYXJnICAgICAgICBTdHJpbmcsIEludCBvciBGbG9hdCB0byB0cmFuc2Zvcm1cbiAgKiBAcGFyYW0gIHtPYmplY3R9ICBkZXNjcmlwdG9yIFtPcHRpb25hbF0gRmxhZ3NcbiAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgIFJlYWRhYmxlIGZpbGUgc2l6ZSBTdHJpbmdcbiAgKi9cblx0dmFyIGZpbGVzaXplID0gZnVuY3Rpb24gKGFyZykge1xuXHRcdHZhciBkZXNjcmlwdG9yID0gYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1sxXTtcblxuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR2YXIgc2tpcCA9IGZhbHNlO1xuXHRcdHZhciB2YWwgPSAwO1xuXHRcdHZhciBlID0gdW5kZWZpbmVkLFxuXHRcdCAgICBiYXNlID0gdW5kZWZpbmVkLFxuXHRcdCAgICBiaXRzID0gdW5kZWZpbmVkLFxuXHRcdCAgICBjZWlsID0gdW5kZWZpbmVkLFxuXHRcdCAgICBuZWcgPSB1bmRlZmluZWQsXG5cdFx0ICAgIG51bSA9IHVuZGVmaW5lZCxcblx0XHQgICAgb3V0cHV0ID0gdW5kZWZpbmVkLFxuXHRcdCAgICByb3VuZCA9IHVuZGVmaW5lZCxcblx0XHQgICAgdW5peCA9IHVuZGVmaW5lZCxcblx0XHQgICAgc3BhY2VyID0gdW5kZWZpbmVkLFxuXHRcdCAgICBzdWZmaXhlcyA9IHVuZGVmaW5lZDtcblxuXHRcdGlmIChpc05hTihhcmcpKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50c1wiKTtcblx0XHR9XG5cblx0XHRiaXRzID0gZGVzY3JpcHRvci5iaXRzID09PSB0cnVlO1xuXHRcdHVuaXggPSBkZXNjcmlwdG9yLnVuaXggPT09IHRydWU7XG5cdFx0YmFzZSA9IGRlc2NyaXB0b3IuYmFzZSAhPT0gdW5kZWZpbmVkID8gZGVzY3JpcHRvci5iYXNlIDogMjtcblx0XHRyb3VuZCA9IGRlc2NyaXB0b3Iucm91bmQgIT09IHVuZGVmaW5lZCA/IGRlc2NyaXB0b3Iucm91bmQgOiB1bml4ID8gMSA6IDI7XG5cdFx0c3BhY2VyID0gZGVzY3JpcHRvci5zcGFjZXIgIT09IHVuZGVmaW5lZCA/IGRlc2NyaXB0b3Iuc3BhY2VyIDogdW5peCA/IFwiXCIgOiBcIiBcIjtcblx0XHRzdWZmaXhlcyA9IGRlc2NyaXB0b3Iuc3VmZml4ZXMgIT09IHVuZGVmaW5lZCA/IGRlc2NyaXB0b3Iuc3VmZml4ZXMgOiB7fTtcblx0XHRvdXRwdXQgPSBkZXNjcmlwdG9yLm91dHB1dCAhPT0gdW5kZWZpbmVkID8gZGVzY3JpcHRvci5vdXRwdXQgOiBcInN0cmluZ1wiO1xuXHRcdGUgPSBkZXNjcmlwdG9yLmV4cG9uZW50ICE9PSB1bmRlZmluZWQgPyBkZXNjcmlwdG9yLmV4cG9uZW50IDogLTE7XG5cdFx0bnVtID0gTnVtYmVyKGFyZyk7XG5cdFx0bmVnID0gbnVtIDwgMDtcblx0XHRjZWlsID0gYmFzZSA+IDIgPyAxMDAwIDogMTAyNDtcblxuXHRcdC8vIEZsaXBwaW5nIGEgbmVnYXRpdmUgbnVtYmVyIHRvIGRldGVybWluZSB0aGUgc2l6ZVxuXHRcdGlmIChuZWcpIHtcblx0XHRcdG51bSA9IC1udW07XG5cdFx0fVxuXG5cdFx0Ly8gWmVybyBpcyBub3cgYSBzcGVjaWFsIGNhc2UgYmVjYXVzZSBieXRlcyBkaXZpZGUgYnkgMVxuXHRcdGlmIChudW0gPT09IDApIHtcblx0XHRcdHJlc3VsdFswXSA9IDA7XG5cblx0XHRcdGlmICh1bml4KSB7XG5cdFx0XHRcdHJlc3VsdFsxXSA9IFwiXCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHRbMV0gPSBcIkJcIjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRGV0ZXJtaW5pbmcgdGhlIGV4cG9uZW50XG5cdFx0XHRpZiAoZSA9PT0gLTEgfHwgaXNOYU4oZSkpIHtcblx0XHRcdFx0ZSA9IE1hdGguZmxvb3IoTWF0aC5sb2cobnVtKSAvIE1hdGgubG9nKGNlaWwpKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRXhjZWVkaW5nIHN1cHBvcnRlZCBsZW5ndGgsIHRpbWUgdG8gcmVkdWNlICYgbXVsdGlwbHlcblx0XHRcdGlmIChlID4gOCkge1xuXHRcdFx0XHR2YWwgPSB2YWwgKiAoMTAwMCAqIChlIC0gOCkpO1xuXHRcdFx0XHRlID0gODtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGJhc2UgPT09IDIpIHtcblx0XHRcdFx0dmFsID0gbnVtIC8gTWF0aC5wb3coMiwgZSAqIDEwKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IG51bSAvIE1hdGgucG93KDEwMDAsIGUpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYml0cykge1xuXHRcdFx0XHR2YWwgPSB2YWwgKiA4O1xuXG5cdFx0XHRcdGlmICh2YWwgPiBjZWlsKSB7XG5cdFx0XHRcdFx0dmFsID0gdmFsIC8gY2VpbDtcblx0XHRcdFx0XHRlKys7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmVzdWx0WzBdID0gTnVtYmVyKHZhbC50b0ZpeGVkKGUgPiAwID8gcm91bmQgOiAwKSk7XG5cdFx0XHRyZXN1bHRbMV0gPSBzaVtiaXRzID8gXCJiaXRzXCIgOiBcImJ5dGVzXCJdW2VdO1xuXG5cdFx0XHRpZiAoIXNraXAgJiYgdW5peCkge1xuXHRcdFx0XHRpZiAoYml0cyAmJiBiaXQudGVzdChyZXN1bHRbMV0pKSB7XG5cdFx0XHRcdFx0cmVzdWx0WzFdID0gcmVzdWx0WzFdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXN1bHRbMV0gPSByZXN1bHRbMV0uY2hhckF0KDApO1xuXG5cdFx0XHRcdGlmIChyZXN1bHRbMV0gPT09IFwiQlwiKSB7XG5cdFx0XHRcdFx0cmVzdWx0WzBdID0gTWF0aC5mbG9vcihyZXN1bHRbMF0pO1xuXHRcdFx0XHRcdHJlc3VsdFsxXSA9IFwiXCI7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWJpdHMgJiYgcmVzdWx0WzFdID09PSBcImtcIikge1xuXHRcdFx0XHRcdHJlc3VsdFsxXSA9IFwiS1wiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRGVjb3JhdGluZyBhICdkaWZmJ1xuXHRcdGlmIChuZWcpIHtcblx0XHRcdHJlc3VsdFswXSA9IC1yZXN1bHRbMF07XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHlpbmcgY3VzdG9tIHN1ZmZpeFxuXHRcdHJlc3VsdFsxXSA9IHN1ZmZpeGVzW3Jlc3VsdFsxXV0gfHwgcmVzdWx0WzFdO1xuXG5cdFx0Ly8gUmV0dXJuaW5nIEFycmF5LCBPYmplY3QsIG9yIFN0cmluZyAoZGVmYXVsdClcblx0XHRpZiAob3V0cHV0ID09PSBcImFycmF5XCIpIHtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXG5cdFx0aWYgKG91dHB1dCA9PT0gXCJleHBvbmVudFwiKSB7XG5cdFx0XHRyZXR1cm4gZTtcblx0XHR9XG5cblx0XHRpZiAob3V0cHV0ID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRyZXR1cm4geyB2YWx1ZTogcmVzdWx0WzBdLCBzdWZmaXg6IHJlc3VsdFsxXSB9O1xuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQuam9pbihzcGFjZXIpO1xuXHR9O1xuXG5cdC8vIENvbW1vbkpTLCBBTUQsIHNjcmlwdCB0YWdcblx0aWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmaWxlc2l6ZTtcblx0fSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIGZpbGVzaXplO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdGdsb2JhbC5maWxlc2l6ZSA9IGZpbGVzaXplO1xuXHR9XG59KSh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogd2luZG93KTsiLCJcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoIChvYmosIGZuLCBjdHgpIHtcbiAgICBpZiAodG9TdHJpbmcuY2FsbChmbikgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIHZhciBsID0gb2JqLmxlbmd0aDtcbiAgICBpZiAobCA9PT0gK2wpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGZuLmNhbGwoY3R4LCBvYmpbaV0sIGksIG9iaik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKG9iaiwgaykpIHtcbiAgICAgICAgICAgICAgICBmbi5jYWxsKGN0eCwgb2JqW2tdLCBrLCBvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuIiwidmFyIFJFQURZID0gLTEsXHJcblx0Q09NUExFVEUgPSAwLFxyXG5cdEZBSUxFRCA9IDEsXHJcblx0R2F0aGVyZXIsXHJcblx0Y2hlY2tUYXNrcztcclxuXHJcbmZ1bmN0aW9uIEdhdGhlcmVyKCl7XHJcblxyXG5cdHRoaXMucmVzZXQoKTtcclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrVGFza3MoKXtcclxuXHJcblx0dmFyIGNvbXBsZXRlZCA9IHRoaXMudGFza3NDb21wbGV0ZSArIHRoaXMudGFza3NGYWlsZWQ7XHJcblx0dmFyIGNvdW50ID0gdGhpcy50YXNrcy5sZW5ndGg7XHJcblxyXG5cdC8vIHBvc3QgdGhlIHBlcmNlbnQgY29tcGxldGUuLlxyXG5cdHRoaXMuZm4udXBkYXRlKCBNYXRoLmNlaWwoMTAwICogKGNvbXBsZXRlZCAvIGNvdW50KSkpO1xyXG5cclxuXHQvLyBhbmQgZmlyZSB0aGUgY29tcGxldGUgY2FsbGJhY2sgd2hlbiBkb25lLCByZWdhcmRsZXNzIG9mIG91dGNvbWVcclxuXHRpZihjb21wbGV0ZWQgPj0gY291bnQpe1xyXG5cclxuXHRcdHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XHJcblxyXG5cdFx0dGhpcy5mbi5jb21wbGV0ZSggdGhpcy50YXNrc0ZhaWxlZCA/IHRoaXMuZXJyb3JzIDogbnVsbCApO1xyXG5cdFx0XHJcblx0fVxyXG5cclxuXHRyZXR1cm47XHJcbn07XHJcblxyXG5HYXRoZXJlci5wcm90b3R5cGUgPSB7XHJcblxyXG5cdHJlc2V0IDogZnVuY3Rpb24gcmVzZXRHYXRoZXJpbmcoKXtcclxuXHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG5cdFx0dGhpcy50YXNrcyA9IFtdO1xyXG5cdFx0dGhpcy5mbiA9IHtcclxuXHRcdFx0Y29tcGxldGUgOiBmdW5jdGlvbigpe30sXHJcblx0XHRcdHVwZGF0ZSA6IGZ1bmN0aW9uKCl7fVxyXG5cdFx0fVxyXG5cdFx0dGhpcy5pc0NvbXBsZXRlID0gZmFsc2U7XHJcblx0XHR0aGlzLnRhc2tzQ29tcGxldGUgPSAwO1xyXG5cdFx0dGhpcy50YXNrc0ZhaWxlZCA9IDA7XHJcblx0XHR0aGlzLmVycm9ycyA9IFtdO1xyXG5cclxuXHRcdHJldHVybjtcclxuXHJcblx0fSxcclxuXHJcblx0dGFzayA6IGZ1bmN0aW9uIGNyZWF0ZVRhc2soIGNhbGxiYWNrICl7XHJcblxyXG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxyXG5cdFx0XHR0YXNrID0geyBzdGF0dXMgOiBSRUFEWSB9LFxyXG5cdFx0XHRkb25lID0gZnVuY3Rpb24oKXtcclxuXHRcdFx0XHR0YXNrLnN0YXR1cyA9IENPTVBMRVRFO1xyXG5cdFx0XHRcdHNlbGYudGFza3NDb21wbGV0ZSsrO1xyXG5cdFx0XHRcdGNoZWNrVGFza3MuY2FsbChzZWxmKTtcdFxyXG5cdFx0XHR9LFxyXG5cdFx0XHRlcnJvciA9IGZ1bmN0aW9uKGVycil7XHJcblx0XHRcdFx0dGFzay5zdGF0dXMgPSBGQUlMRUQ7XHJcblx0XHRcdFx0c2VsZi50YXNrc0ZhaWxlZCsrO1xyXG5cdFx0XHRcdHNlbGYuZXJyb3JzLnB1c2goZXJyKTtcclxuXHRcdFx0XHRjaGVja1Rhc2tzLmNhbGwoc2VsZik7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0dGFzay5mbiA9IGZ1bmN0aW9uKCl7XHJcblxyXG5cdFx0XHRjYWxsYmFjayhkb25lLCBlcnJvcik7XHJcblxyXG5cdFx0fVxyXG5cdFx0c2VsZi50YXNrcy5wdXNoKHRhc2spO1xyXG5cdFx0cmV0dXJuIHNlbGY7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJ1biA6IGZ1bmN0aW9uIHJ1blRhc2tzKCBjYWxsYmFjaywgdGltZW91dCApe1xyXG5cclxuXHRcdHZhciBzZWxmID0gdGhpcztcclxuXHJcblx0XHRpZiAodGltZW91dCl7XHJcblxyXG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcblxyXG5cdFx0XHRcdGlmICghc2VsZi5pc0NvbXBsZXRlKXtcclxuXHJcblx0XHRcdFx0XHRzZWxmLmZuLmNvbXBsZXRlKCdFcnJvcjogVGltZWQgb3V0Jyk7XHJcblx0XHRcdFx0XHRzZWxmLmZuLmNvbXBsZXRlID0gZnVuY3Rpb24oKXt9O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0fSwgdGltZW91dCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNlbGYuZm4uY29tcGxldGUgPSBjYWxsYmFjaztcclxuXHJcblx0XHQvLyBydW4gdGhlIHRhc2sgY2FsbGJhY2tzLi4uXHJcblx0XHRmb3IgKHZhciBpID0gMCwgaWwgPSBzZWxmLnRhc2tzLmxlbmd0aDsgaSA8IGlsOyBpKyspe1xyXG5cdFx0XHRzZWxmLnRhc2tzW2ldLmZuKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHNlbGY7XHJcblxyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZSA6IGZ1bmN0aW9uIHNldFVwZGF0ZUNhbGxiYWNrKCBjYWxsYmFjayApe1xyXG5cdFx0dGhpcy5mbi51cGRhdGUgPSBjYWxsYmFjaztcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gR2F0aGVyZXI7IiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBtYXRjaGVzID0gcmVxdWlyZSgnbWF0Y2hlcy1zZWxlY3RvcicpO1xudmFyIGRlbGVnYXRlID0gcmVxdWlyZSgnZGVsZWdhdGUnKTtcbnZhciBjbGFzc2VzID0gcmVxdWlyZSgnY2xhc3NlcycpO1xudmFyIHRyYXZlcnNlID0gcmVxdWlyZSgndHJhdmVyc2UnKTtcbnZhciBpbmRleG9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIGRvbWlmeSA9IHJlcXVpcmUoJ2RvbWlmeScpO1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50Jyk7XG52YXIgdmFsdWUgPSByZXF1aXJlKCd2YWx1ZScpO1xudmFyIHF1ZXJ5ID0gcmVxdWlyZSgncXVlcnknKTtcbnZhciB0eXBlID0gcmVxdWlyZSgndHlwZScpO1xudmFyIHRyaW0gPSByZXF1aXJlKCd0cmltJyk7XG52YXIgY3NzID0gcmVxdWlyZSgnY3NzJyk7XG5cbnZhciBldmVudFJlZnMgPSB7fTtcbnZhciBleHBhbmRvID0gMDtcblxuLyoqXG4gKiBBdHRyaWJ1dGVzIHN1cHBvcnRlZC5cbiAqL1xuXG52YXIgYXR0cnMgPSBbXG4gICdpZCcsXG4gICdzcmMnLFxuICAncmVsJyxcbiAgJ2NvbHMnLFxuICAncm93cycsXG4gICd0eXBlJyxcbiAgJ25hbWUnLFxuICAnaHJlZicsXG4gICd0aXRsZScsXG4gICdzdHlsZScsXG4gICd3aWR0aCcsXG4gICdoZWlnaHQnLFxuICAnYWN0aW9uJyxcbiAgJ21ldGhvZCcsXG4gICd0YWJpbmRleCcsXG4gICdwbGFjZWhvbGRlcidcbl07XG5cbi8qKlxuICogRXhwb3NlIGBkb20oKWAuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZG9tO1xuXG4vKipcbiAqIEV4cG9zZSBzdXBwb3J0ZWQgYXR0cnMuXG4gKi9cblxuZXhwb3J0cy5hdHRycyA9IGF0dHJzO1xuXG4vKipcbiAqIFJldHVybiBhIGRvbSBgTGlzdGAgZm9yIHRoZSBnaXZlblxuICogYGh0bWxgLCBzZWxlY3Rvciwgb3IgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fExpc3R9XG4gKiBAcmV0dXJuIHtMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkb20oc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgLy8gYXJyYXlcbiAgaWYgKEFycmF5LmlzQXJyYXkoc2VsZWN0b3IpKSB7XG4gICAgcmV0dXJuIG5ldyBMaXN0KHNlbGVjdG9yKTtcbiAgfVxuXG4gIC8vIExpc3RcbiAgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgTGlzdCkge1xuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfVxuXG4gIC8vIG5vZGVcbiAgaWYgKHNlbGVjdG9yLm5vZGVOYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBMaXN0KFtzZWxlY3Rvcl0pO1xuICB9XG5cbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBzZWxlY3Rvcikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgc2VsZWN0b3InKTtcbiAgfVxuXG4gIC8vIGh0bWxcbiAgdmFyIGh0bWxzZWxlY3RvciA9IHRyaW0ubGVmdChzZWxlY3Rvcik7XG4gIGlmICgnPCcgPT0gaHRtbHNlbGVjdG9yLmNoYXJBdCgwKSkge1xuICAgIHJldHVybiBuZXcgTGlzdChbZG9taWZ5KGh0bWxzZWxlY3RvcildLCBodG1sc2VsZWN0b3IpO1xuICB9XG5cbiAgLy8gc2VsZWN0b3JcbiAgdmFyIGN0eCA9IGNvbnRleHRcbiAgICA/IChjb250ZXh0LmVscyA/IGNvbnRleHQuZWxzWzBdIDogY29udGV4dClcbiAgICA6IGRvY3VtZW50O1xuXG4gIHJldHVybiBuZXcgTGlzdChxdWVyeS5hbGwoc2VsZWN0b3IsIGN0eCksIHNlbGVjdG9yKTtcbn1cblxuLyoqXG4gKiBFeHBvc2UgYExpc3RgIGNvbnN0cnVjdG9yLlxuICovXG5cbmV4cG9ydHMuTGlzdCA9IExpc3Q7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgTGlzdGAgd2l0aCB0aGVcbiAqIGdpdmVuIGFycmF5LWlzaCBvZiBgZWxzYCBhbmQgYHNlbGVjdG9yYFxuICogc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IGVsc1xuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBMaXN0KGVscywgc2VsZWN0b3IpIHtcbiAgdGhpcy5lbHMgPSBlbHMgfHwgW107XG4gIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcbn1cblxuLyoqXG4gKiBFbnVtZXJhYmxlIGl0ZXJhdG9yLlxuICovXG5cbkxpc3QucHJvdG90eXBlLl9faXRlcmF0ZV9fID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXR1cm4ge1xuICAgIGxlbmd0aDogZnVuY3Rpb24oKXsgcmV0dXJuIHNlbGYuZWxzLmxlbmd0aCB9LFxuICAgIGdldDogZnVuY3Rpb24oaSl7IHJldHVybiBuZXcgTGlzdChbc2VsZi5lbHNbaV1dKSB9XG4gIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIERPTS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKCl7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsc1tpXTtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7IC8vIGhpZGUgaXQsIGlmIG5vdGhpbmcgZWxzZS5cbiAgICB3YWxrRE9NKGVsLCBmdW5jdGlvbiggbm9kZSApe1xuICAgICAgdmFyIGlkO1xuICAgICAgaWYoaWQgPSBub2RlLl9fZXhwYW5kbyl7XG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBldmVudFJlZnNbaWRdLmxlbmd0aDsgKytqKXtcbiAgICAgICAgICBldmVudHMudW5iaW5kKG5vZGUsIGV2ZW50UmVmc1tpZF1bal0uZXZ0LCBldmVudFJlZnNbaWRdW2pdLmZuKTtcbiAgICAgICAgICBkZWxldGUgZXZlbnRSZWZzW2lkXVtqXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgdmFyIHBhcmVudCA9IGVsLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LnJlbW92ZUNoaWxkKGVsKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZXQgYXR0cmlidXRlIGBuYW1lYCB0byBgdmFsYCwgb3IgZ2V0IGF0dHIgYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gW3ZhbF1cbiAqIEByZXR1cm4ge1N0cmluZ3xMaXN0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLmF0dHIgPSBmdW5jdGlvbihuYW1lLCB2YWwpe1xuXG4gIC8vIHNldCB2aWEgb2JqZWN0XG4gIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBuYW1lKXtcbiAgICBmb3IgKHZhciBhdHRyIGluIG5hbWUpIHtcbiAgICAgIHRoaXMuYXR0cihhdHRyLCBuYW1lW2F0dHJdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBnZXRcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLmVsc1swXSAmJiB0aGlzLmVsc1swXS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gIH1cblxuICAvLyByZW1vdmVcbiAgaWYgKG51bGwgPT0gdmFsKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlQXR0cihuYW1lKTtcbiAgfVxuXG4gIC8vIHNldFxuICByZXR1cm4gdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGVsKXtcbiAgICBlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhdHRyaWJ1dGUgYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtMaXN0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLnJlbW92ZUF0dHIgPSBmdW5jdGlvbihuYW1lKXtcbiAgcmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbihlbCl7XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9KTtcbn07XG5cbi8qKlxuICogU2V0IHByb3BlcnR5IGBuYW1lYCB0byBgdmFsYCwgb3IgZ2V0IHByb3BlcnR5IGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IFt2YWxdXG4gKiBAcmV0dXJuIHtPYmplY3R8TGlzdH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaXN0LnByb3RvdHlwZS5wcm9wID0gZnVuY3Rpb24obmFtZSwgdmFsKXtcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLmVsc1swXSAmJiB0aGlzLmVsc1swXVtuYW1lXTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24oZWwpe1xuICAgIGVsW25hbWVdID0gdmFsO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBmaXJzdCBlbGVtZW50J3MgdmFsdWUgb3Igc2V0IHNlbGVjdGVkXG4gKiBlbGVtZW50IHZhbHVlcyB0byBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSBbdmFsXVxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLnZhbCA9XG5MaXN0LnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5lbHNbMF1cbiAgICAgID8gdmFsdWUodGhpcy5lbHNbMF0pXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmZvckVhY2goZnVuY3Rpb24oZWwpe1xuICAgIHZhbHVlKGVsLCB2YWwpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgY2xvbmVkIGBMaXN0YCB3aXRoIGFsbCBlbGVtZW50cyBjbG9uZWQuXG4gKlxuICogQHJldHVybiB7TGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpe1xuICB2YXIgYXJyID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmVscy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGFyci5wdXNoKHRoaXMuZWxzW2ldLmNsb25lTm9kZSh0cnVlKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBMaXN0KGFycik7XG59O1xuXG4vKipcbiAqIFByZXBlbmQgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxMaXN0fSB2YWxcbiAqIEByZXR1cm4ge0xpc3R9IG5ldyBsaXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbih2YWwpe1xuICB2YXIgZWwgPSB0aGlzLmVsc1swXTtcbiAgaWYgKCFlbCkgcmV0dXJuIHRoaXM7XG4gIHZhbCA9IGRvbSh2YWwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoZWwuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICBlbC5pbnNlcnRCZWZvcmUodmFsLmVsc1tpXSwgZWwuZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFwcGVuZENoaWxkKHZhbC5lbHNbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuLyoqXG4gKiBBcHBlbmQgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxMaXN0fSB2YWxcbiAqIEByZXR1cm4ge0xpc3R9IG5ldyBsaXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKHZhbCl7XG4gIHZhciBlbCA9IHRoaXMuZWxzWzBdO1xuICBpZiAoIWVsKSByZXR1cm4gdGhpcztcbiAgdmFsID0gZG9tKHZhbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmVscy5sZW5ndGg7ICsraSkge1xuICAgIGVsLmFwcGVuZENoaWxkKHZhbC5lbHNbaV0pO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG4vKipcbiAqIEFwcGVuZCBzZWxmJ3MgYGVsYCB0byBgdmFsYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8TGlzdH0gdmFsXG4gKiBAcmV0dXJuIHtMaXN0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLmFwcGVuZFRvID0gZnVuY3Rpb24odmFsKXtcbiAgZG9tKHZhbCkuYXBwZW5kKHRoaXMpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW5zZXJ0IHNlbGYncyBgZWxzYCBhZnRlciBgdmFsYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEVsZW1lbnR8TGlzdH0gdmFsXG4gKiBAcmV0dXJuIHtMaXN0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLmluc2VydEFmdGVyID0gZnVuY3Rpb24odmFsKXtcbiAgdmFsID0gZG9tKHZhbCkuZWxzWzBdO1xuICBpZiAoIXZhbCB8fCAhdmFsLnBhcmVudE5vZGUpIHJldHVybiB0aGlzO1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24oZWwpe1xuICAgIHZhbC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgdmFsLm5leHRTaWJsaW5nKTtcbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBgTGlzdGAgY29udGFpbmluZyB0aGUgZWxlbWVudCBhdCBgaWAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24oaSl7XG4gIHJldHVybiBuZXcgTGlzdChbdGhpcy5lbHNbaV1dLCB0aGlzLnNlbGVjdG9yKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGEgYExpc3RgIGNvbnRhaW5pbmcgdGhlIGZpcnN0IGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLmZpcnN0ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBMaXN0KFt0aGlzLmVsc1swXV0sIHRoaXMuc2VsZWN0b3IpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYSBgTGlzdGAgY29udGFpbmluZyB0aGUgbGFzdCBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaXN0LnByb3RvdHlwZS5sYXN0ID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIG5ldyBMaXN0KFt0aGlzLmVsc1t0aGlzLmVscy5sZW5ndGggLSAxXV0sIHRoaXMuc2VsZWN0b3IpO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYEVsZW1lbnRgIGF0IGBpYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7RWxlbWVudH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oaSl7XG4gIHJldHVybiB0aGlzLmVsc1tpIHx8IDBdO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gbGlzdCBsZW5ndGguXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaXN0LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpe1xuICByZXR1cm4gdGhpcy5lbHMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gZWxlbWVudCB0ZXh0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1N0cmluZ3xMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaXN0LnByb3RvdHlwZS50ZXh0ID0gZnVuY3Rpb24oc3RyKXtcbiAgLy8gVE9ETzogcmVhbCBpbXBsXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oZWwpe1xuICAgICAgZWwudGV4dENvbnRlbnQgPSBzdHI7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgc3RyID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICBzdHIgKz0gdGhpcy5lbHNbaV0udGV4dENvbnRlbnQ7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUmV0dXJuIGVsZW1lbnQgaHRtbC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGh0bWxcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlzdC5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uKGh0bWwpe1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yRWFjaChmdW5jdGlvbihlbCl7XG4gICAgICBlbC5pbm5lckhUTUwgPSBodG1sO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVE9ETzogcmVhbCBpbXBsXG4gIHJldHVybiB0aGlzLmVsc1swXSAmJiB0aGlzLmVsc1swXS5pbm5lckhUTUw7XG59O1xuXG4vKipcbiAqIEJpbmQgdG8gYGV2ZW50YCBhbmQgaW52b2tlIGBmbihlKWAuIFdoZW5cbiAqIGEgYHNlbGVjdG9yYCBpcyBnaXZlbiB0aGVuIGV2ZW50cyBhcmUgZGVsZWdhdGVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3Rvcl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAqIEByZXR1cm4ge0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnQsIHNlbGVjdG9yLCBmbiwgY2FwdHVyZSl7XG4gIHZhciBpZCwgY3VyO1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHNlbGVjdG9yKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgZm4uX2RlbGVnYXRlID0gZGVsZWdhdGUuYmluZCh0aGlzLmVsc1tpXSwgc2VsZWN0b3IsIGV2ZW50LCBmbiwgY2FwdHVyZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2FwdHVyZSA9IGZuO1xuICBmbiA9IHNlbGVjdG9yO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoaWQgPSB0aGlzLmVsc1tpXS5fX2V4cGFuZG8pe1xuICAgIH0gZWxzZSB7XG4gICAgICBpZCA9ICsrZXhwYW5kbztcbiAgICAgIHRoaXMuZWxzW2ldLl9fZXhwYW5kbyA9IGlkO1xuICAgIH1cbiAgICBpZighZXZlbnRSZWZzW2lkXSl7XG4gICAgICBldmVudFJlZnNbaWRdID0gW107XG4gICAgfVxuICAgIGN1ciA9IGV2ZW50UmVmc1tpZF0ubGVuZ3RoO1xuICAgIGV2ZW50UmVmc1tpZF1bY3VyXSA9IHtcbiAgICAgIGV2dCA6IGV2ZW50LFxuICAgICAgZm4gOiBmblxuICAgIH07XG4gICAgZXZlbnRzLmJpbmQodGhpcy5lbHNbaV0sIGV2ZW50UmVmc1tpZF1bY3VyXS5ldnQsIGV2ZW50UmVmc1tpZF1bY3VyXS5mbiwgY2FwdHVyZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogVW5iaW5kIHRvIGBldmVudGAgYW5kIGludm9rZSBgZm4oZSlgLiBXaGVuXG4gKiBhIGBzZWxlY3RvcmAgaXMgZ2l2ZW4gdGhlbiBkZWxlZ2F0ZWQgZXZlbnRcbiAqIGhhbmRsZXJzIGFyZSB1bmJvdW5kLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IFtzZWxlY3Rvcl1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAqIEByZXR1cm4ge0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKGV2ZW50LCBzZWxlY3RvciwgZm4sIGNhcHR1cmUpe1xuICB2YXIgaWQsIGk7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygc2VsZWN0b3IpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgIC8vIFRPRE86IGFkZCBzZWxlY3RvciBzdXBwb3J0IGJhY2tcbiAgICAgIGRlbGVnYXRlLnVuYmluZCh0aGlzLmVsc1tpXSwgZXZlbnQsIGZuLl9kZWxlZ2F0ZSwgY2FwdHVyZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2FwdHVyZSA9IGZuO1xuICBmbiA9IHNlbGVjdG9yO1xuXG4gIGlmICghc2VsZWN0b3Ipe1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgaWQgPSB0aGlzLmVsc1tpXS5fX2V4cGFuZG87XG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgZXZlbnRSZWZzW2lkXS5sZW5ndGg7ICsrail7XG4gICAgICAgIGV2ZW50cy51bmJpbmQodGhpcy5lbHNbaV0sIGV2ZW50UmVmc1tpZF1bal0uZXZ0LCBldmVudFJlZnNbaWRdW2pdLmZuKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICBldmVudHMudW5iaW5kKHRoaXMuZWxzW2ldLCBldmVudCwgZm4sIGNhcHR1cmUpO1xuICAgIH1cbiAgfVxuICBcbiAgcmV0dXJuIHRoaXM7XG59O1xuLyoqXG4gKiBJdGVyYXRlIGVsZW1lbnRzIGFuZCBpbnZva2UgYGZuKGxpc3QsIGkpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7TGlzdH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaXN0LnByb3RvdHlwZS5lYWNoID0gZnVuY3Rpb24oZm4pe1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgZm4obmV3IExpc3QoW3RoaXMuZWxzW2ldXSwgdGhpcy5zZWxlY3RvciksIGkpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBJdGVyYXRlIGVsZW1lbnRzIGFuZCBpbnZva2UgYGZuKGVsLCBpKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0xpc3R9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGZuKXtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVscy5sZW5ndGg7ICsraSkge1xuICAgIGZuKHRoaXMuZWxzW2ldLCBpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWFwIGVsZW1lbnRzIGludm9raW5nIGBmbihsaXN0LCBpKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihmbil7XG4gIHZhciBhcnIgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVscy5sZW5ndGg7ICsraSkge1xuICAgIGFyci5wdXNoKGZuKG5ldyBMaXN0KFt0aGlzLmVsc1tpXV0sIHRoaXMuc2VsZWN0b3IpLCBpKSk7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICogRmlsdGVyIGVsZW1lbnRzIGludm9raW5nIGBmbihsaXN0LCBpKWAsIHJldHVybmluZ1xuICogYSBuZXcgYExpc3RgIG9mIGVsZW1lbnRzIHdoZW4gYSB0cnV0aHkgdmFsdWUgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLnNlbGVjdCA9XG5MaXN0LnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbihmbil7XG4gIHZhciBlbDtcbiAgdmFyIGxpc3QgPSBuZXcgTGlzdChbXSwgdGhpcy5zZWxlY3Rvcik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICBlbCA9IHRoaXMuZWxzW2ldO1xuICAgIGlmIChmbihuZXcgTGlzdChbZWxdLCB0aGlzLnNlbGVjdG9yKSwgaSkpIGxpc3QuZWxzLnB1c2goZWwpO1xuICB9XG4gIHJldHVybiBsaXN0O1xufTtcblxuLyoqXG4gKiBGaWx0ZXIgZWxlbWVudHMgaW52b2tpbmcgYGZuKGxpc3QsIGkpYCwgcmV0dXJuaW5nXG4gKiBhIG5ldyBgTGlzdGAgb2YgZWxlbWVudHMgd2hlbiBhIGZhbHNleSB2YWx1ZSBpcyByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7TGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlzdC5wcm90b3R5cGUucmVqZWN0ID0gZnVuY3Rpb24oZm4pe1xuICB2YXIgZWw7XG4gIHZhciBsaXN0ID0gbmV3IExpc3QoW10sIHRoaXMuc2VsZWN0b3IpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgZWwgPSB0aGlzLmVsc1tpXTtcbiAgICBpZiAoIWZuKG5ldyBMaXN0KFtlbF0sIHRoaXMuc2VsZWN0b3IpLCBpKSkgbGlzdC5lbHMucHVzaChlbCk7XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG4vKipcbiAqIEFkZCB0aGUgZ2l2ZW4gY2xhc3MgYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtMaXN0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24obmFtZSl7XG4gIHZhciBlbDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVscy5sZW5ndGg7ICsraSkge1xuICAgIGVsID0gdGhpcy5lbHNbaV07XG4gICAgZWwuX2NsYXNzZXMgPSBlbC5fY2xhc3NlcyB8fCBjbGFzc2VzKGVsKTtcbiAgICBlbC5fY2xhc3Nlcy5hZGQobmFtZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2xhc3MgYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gbmFtZVxuICogQHJldHVybiB7TGlzdH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaXN0LnByb3RvdHlwZS5yZW1vdmVDbGFzcyA9IGZ1bmN0aW9uKG5hbWUpe1xuICB2YXIgZWw7XG5cbiAgaWYgKCdyZWdleHAnID09IHR5cGUobmFtZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICBlbCA9IHRoaXMuZWxzW2ldO1xuICAgICAgZWwuX2NsYXNzZXMgPSBlbC5fY2xhc3NlcyB8fCBjbGFzc2VzKGVsKTtcbiAgICAgIHZhciBhcnIgPSBlbC5fY2xhc3Nlcy5hcnJheSgpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKG5hbWUudGVzdChhcnJbal0pKSB7XG4gICAgICAgICAgZWwuX2NsYXNzZXMucmVtb3ZlKGFycltqXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgZWwgPSB0aGlzLmVsc1tpXTtcbiAgICBlbC5fY2xhc3NlcyA9IGVsLl9jbGFzc2VzIHx8IGNsYXNzZXMoZWwpO1xuICAgIGVsLl9jbGFzc2VzLnJlbW92ZShuYW1lKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgdGhlIGdpdmVuIGNsYXNzIGBuYW1lYCxcbiAqIG9wdGlvbmFsbHkgYSBgYm9vbGAgbWF5IGJlIGdpdmVuXG4gKiB0byBpbmRpY2F0ZSB0aGF0IHRoZSBjbGFzcyBzaG91bGRcbiAqIGJlIGFkZGVkIHdoZW4gdHJ1dGh5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGJvb2xcbiAqIEByZXR1cm4ge0xpc3R9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlzdC5wcm90b3R5cGUudG9nZ2xlQ2xhc3MgPSBmdW5jdGlvbihuYW1lLCBib29sKXtcbiAgdmFyIGVsO1xuICB2YXIgZm4gPSAndG9nZ2xlJztcblxuICAvLyB0b2dnbGUgd2l0aCBib29sZWFuXG4gIGlmICgyID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBmbiA9IGJvb2wgPyAnYWRkJyA6ICdyZW1vdmUnO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVscy5sZW5ndGg7ICsraSkge1xuICAgIGVsID0gdGhpcy5lbHNbaV07XG4gICAgZWwuX2NsYXNzZXMgPSBlbC5fY2xhc3NlcyB8fCBjbGFzc2VzKGVsKTtcbiAgICBlbC5fY2xhc3Nlc1tmbl0obmFtZSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGNsYXNzIGBuYW1lYCBpcyBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaXN0LnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uKG5hbWUpe1xuICB2YXIgZWw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICBlbCA9IHRoaXMuZWxzW2ldO1xuICAgIGVsLl9jbGFzc2VzID0gZWwuX2NsYXNzZXMgfHwgY2xhc3NlcyhlbCk7XG4gICAgaWYgKGVsLl9jbGFzc2VzLmhhcyhuYW1lKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBTZXQgQ1NTIGBwcm9wYCB0byBgdmFsYCBvciBnZXQgYHByb3BgIHZhbHVlLlxuICogQWxzbyBhY2NlcHRzIGFuIG9iamVjdCAoYHByb3BgOiBgdmFsYClcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcFxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtMaXN0fFN0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlzdC5wcm90b3R5cGUuY3NzID0gZnVuY3Rpb24ocHJvcCwgdmFsKXtcbiAgaWYgKDIgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHZhciBvYmogPSB7fTtcbiAgICBvYmpbcHJvcF0gPSB2YWw7XG4gICAgcmV0dXJuIHRoaXMuc2V0U3R5bGUob2JqKTtcbiAgfVxuXG4gIGlmICgnb2JqZWN0JyA9PSB0eXBlKHByb3ApKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0U3R5bGUocHJvcCk7XG4gIH1cblxuICByZXR1cm4gdGhpcy5nZXRTdHlsZShwcm9wKTtcbn07XG5cbi8qKlxuICogU2V0IENTUyBgcHJvcHNgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wc1xuICogQHJldHVybiB7TGlzdH0gc2VsZlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTGlzdC5wcm90b3R5cGUuc2V0U3R5bGUgPSBmdW5jdGlvbihwcm9wcyl7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbHMubGVuZ3RoOyArK2kpIHtcbiAgICBjc3ModGhpcy5lbHNbaV0sIHByb3BzKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0IENTUyBgcHJvcGAgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkxpc3QucHJvdG90eXBlLmdldFN0eWxlID0gZnVuY3Rpb24ocHJvcCl7XG4gIHZhciBlbCA9IHRoaXMuZWxzWzBdO1xuICBpZiAoZWwpIHJldHVybiBlbC5zdHlsZVtwcm9wXTtcbn07XG5cbi8qKlxuICogRmluZCBjaGlsZHJlbiBtYXRjaGluZyB0aGUgZ2l2ZW4gYHNlbGVjdG9yYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihzZWxlY3Rvcil7XG4gIHJldHVybiBkb20oc2VsZWN0b3IsIHRoaXMpO1xufTtcblxuLyoqXG4gKiBFbXB0eSB0aGUgZG9tIGxpc3RcbiAqXG4gKiBAcmV0dXJuIHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlzdC5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbigpe1xuICB2YXIgZWxlbSwgZWw7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmVscy5sZW5ndGg7ICsraSkge1xuICAgIGVsID0gdGhpcy5lbHNbaV07XG4gICAgd2hpbGUgKGVsLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBmaXJzdCBlbGVtZW50IG1hdGNoZXMgYHNlbGVjdG9yYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLmlzID0gZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICByZXR1cm4gbWF0Y2hlcyh0aGlzLmdldCgwKSwgc2VsZWN0b3IpO1xufTtcblxuLyoqXG4gKiBHZXQgcGFyZW50KHMpIHdpdGggb3B0aW9uYWwgYHNlbGVjdG9yYCBhbmQgYGxpbWl0YFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IGxpbWl0XG4gKiBAcmV0dXJuIHtMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5MaXN0LnByb3RvdHlwZS5wYXJlbnQgPSBmdW5jdGlvbihzZWxlY3RvciwgbGltaXQpe1xuICByZXR1cm4gbmV3IExpc3QodHJhdmVyc2UoJ3BhcmVudE5vZGUnLFxuICAgIHRoaXMuZ2V0KDApLFxuICAgIHNlbGVjdG9yLFxuICAgIGxpbWl0XG4gICAgfHwgMSkpO1xufTtcblxuLyoqXG4gKiBHZXQgbmV4dCBlbGVtZW50KHMpIHdpdGggb3B0aW9uYWwgYHNlbGVjdG9yYCBhbmQgYGxpbWl0YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdFxuICogQHJldHJ1biB7TGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTGlzdC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBsaW1pdCl7XG4gIHJldHVybiBuZXcgTGlzdCh0cmF2ZXJzZSgnbmV4dFNpYmxpbmcnLFxuICAgIHRoaXMuZ2V0KDApLFxuICAgIHNlbGVjdG9yLFxuICAgIGxpbWl0XG4gICAgfHwgMSkpO1xufTtcblxuLyoqXG4gKiBHZXQgcHJldmlvdXMgZWxlbWVudChzKSB3aXRoIG9wdGlvbmFsIGBzZWxlY3RvcmAgYW5kIGBsaW1pdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gbGltaXRcbiAqIEByZXR1cm4ge0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkxpc3QucHJvdG90eXBlLnByZXYgPVxuTGlzdC5wcm90b3R5cGUucHJldmlvdXMgPSBmdW5jdGlvbihzZWxlY3RvciwgbGltaXQpe1xuICByZXR1cm4gbmV3IExpc3QodHJhdmVyc2UoJ3ByZXZpb3VzU2libGluZycsXG4gICAgdGhpcy5nZXQoMCksXG4gICAgc2VsZWN0b3IsXG4gICAgbGltaXRcbiAgICB8fCAxKSk7XG59O1xuXG4vKipcbiAqIEF0dHJpYnV0ZSBhY2Nlc3NvcnMuXG4gKi9cblxuYXR0cnMuZm9yRWFjaChmdW5jdGlvbihuYW1lKXtcbiAgTGlzdC5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbih2YWwpe1xuICAgIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLmF0dHIobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuYXR0cihuYW1lLCB2YWwpO1xuICB9O1xufSk7XG5cbi8qKlxuICogV2FsayBEb20gYG5vZGVgIGFuZCBjYWxsIGBmdW5jYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZG9tTm9kZSwge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiBudWxsXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB3YWxrRE9NKG5vZGUsIGZ1bmMpe1xuICB2YXIgZ28gPSBmdW5jKG5vZGUpO1xuICBpZihnbyl7XG4gICAgbm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAobm9kZSl7XG4gICAgICB3YWxrRE9NKG5vZGUsIGZ1bmMpO1xuICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICB9XG59O1xuXG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xuXG4vKipcbiAqIFdoaXRlc3BhY2UgcmVnZXhwLlxuICovXG5cbnZhciByZSA9IC9cXHMrLztcblxuLyoqXG4gKiB0b1N0cmluZyByZWZlcmVuY2UuXG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBXcmFwIGBlbGAgaW4gYSBgQ2xhc3NMaXN0YC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWwpe1xuICByZXR1cm4gbmV3IENsYXNzTGlzdChlbCk7XG59O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgQ2xhc3NMaXN0IGZvciBgZWxgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIENsYXNzTGlzdChlbCkge1xuICBpZiAoIWVsKSB0aHJvdyBuZXcgRXJyb3IoJ0EgRE9NIGVsZW1lbnQgcmVmZXJlbmNlIGlzIHJlcXVpcmVkJyk7XG4gIHRoaXMuZWwgPSBlbDtcbiAgdGhpcy5saXN0ID0gZWwuY2xhc3NMaXN0O1xufVxuXG4vKipcbiAqIEFkZCBjbGFzcyBgbmFtZWAgaWYgbm90IGFscmVhZHkgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG5hbWUpe1xuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIHRoaXMubGlzdC5hZGQobmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICB2YXIgaSA9IGluZGV4KGFyciwgbmFtZSk7XG4gIGlmICghfmkpIGFyci5wdXNoKG5hbWUpO1xuICB0aGlzLmVsLmNsYXNzTmFtZSA9IGFyci5qb2luKCcgJyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgY2xhc3MgYG5hbWVgIHdoZW4gcHJlc2VudCwgb3JcbiAqIHBhc3MgYSByZWd1bGFyIGV4cHJlc3Npb24gdG8gcmVtb3ZlXG4gKiBhbnkgd2hpY2ggbWF0Y2guXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBuYW1lXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNsYXNzTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24obmFtZSl7XG4gIGlmICgnW29iamVjdCBSZWdFeHBdJyA9PSB0b1N0cmluZy5jYWxsKG5hbWUpKSB7XG4gICAgcmV0dXJuIHRoaXMucmVtb3ZlTWF0Y2hpbmcobmFtZSk7XG4gIH1cblxuICAvLyBjbGFzc0xpc3RcbiAgaWYgKHRoaXMubGlzdCkge1xuICAgIHRoaXMubGlzdC5yZW1vdmUobmFtZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBmYWxsYmFja1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICB2YXIgaSA9IGluZGV4KGFyciwgbmFtZSk7XG4gIGlmICh+aSkgYXJyLnNwbGljZShpLCAxKTtcbiAgdGhpcy5lbC5jbGFzc05hbWUgPSBhcnIuam9pbignICcpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBjbGFzc2VzIG1hdGNoaW5nIGByZWAuXG4gKlxuICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gKiBAcmV0dXJuIHtDbGFzc0xpc3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLnJlbW92ZU1hdGNoaW5nID0gZnVuY3Rpb24ocmUpe1xuICB2YXIgYXJyID0gdGhpcy5hcnJheSgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChyZS50ZXN0KGFycltpXSkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKGFycltpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBUb2dnbGUgY2xhc3MgYG5hbWVgLCBjYW4gZm9yY2Ugc3RhdGUgdmlhIGBmb3JjZWAuXG4gKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBjbGFzc0xpc3QsIGJ1dCBkbyBub3Qgc3VwcG9ydCBgZm9yY2VgIHlldCxcbiAqIHRoZSBtaXN0YWtlIHdpbGwgYmUgZGV0ZWN0ZWQgYW5kIGNvcnJlY3RlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtCb29sZWFufSBmb3JjZVxuICogQHJldHVybiB7Q2xhc3NMaXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uKG5hbWUsIGZvcmNlKXtcbiAgLy8gY2xhc3NMaXN0XG4gIGlmICh0aGlzLmxpc3QpIHtcbiAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPT0gdHlwZW9mIGZvcmNlKSB7XG4gICAgICBpZiAoZm9yY2UgIT09IHRoaXMubGlzdC50b2dnbGUobmFtZSwgZm9yY2UpKSB7XG4gICAgICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7IC8vIHRvZ2dsZSBhZ2FpbiB0byBjb3JyZWN0XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGlzdC50b2dnbGUobmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZmFsbGJhY2tcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHR5cGVvZiBmb3JjZSkge1xuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIHRoaXMucmVtb3ZlKG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChuYW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuaGFzKG5hbWUpKSB7XG4gICAgICB0aGlzLnJlbW92ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGQobmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBvZiBjbGFzc2VzLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5DbGFzc0xpc3QucHJvdG90eXBlLmFycmF5ID0gZnVuY3Rpb24oKXtcbiAgdmFyIHN0ciA9IHRoaXMuZWwuY2xhc3NOYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKTtcbiAgdmFyIGFyciA9IHN0ci5zcGxpdChyZSk7XG4gIGlmICgnJyA9PT0gYXJyWzBdKSBhcnIuc2hpZnQoKTtcbiAgcmV0dXJuIGFycjtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgY2xhc3MgYG5hbWVgIGlzIHByZXNlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ2xhc3NMaXN0LnByb3RvdHlwZS5oYXMgPVxuQ2xhc3NMaXN0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKG5hbWUpe1xuICByZXR1cm4gdGhpcy5saXN0XG4gICAgPyB0aGlzLmxpc3QuY29udGFpbnMobmFtZSlcbiAgICA6ICEhIH5pbmRleCh0aGlzLmFycmF5KCksIG5hbWUpO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgY2xvc2VzdCA9IHJlcXVpcmUoJ2Nsb3Nlc3QnKVxuICAsIGV2ZW50ID0gcmVxdWlyZSgnZXZlbnQnKTtcblxuLyoqXG4gKiBEZWxlZ2F0ZSBldmVudCBgdHlwZWAgdG8gYHNlbGVjdG9yYFxuICogYW5kIGludm9rZSBgZm4oZSlgLiBBIGNhbGxiYWNrIGZ1bmN0aW9uXG4gKiBpcyByZXR1cm5lZCB3aGljaCBtYXkgYmUgcGFzc2VkIHRvIGAudW5iaW5kKClgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmJpbmQgPSBmdW5jdGlvbihlbCwgc2VsZWN0b3IsIHR5cGUsIGZuLCBjYXB0dXJlKXtcbiAgcmV0dXJuIGV2ZW50LmJpbmQoZWwsIHR5cGUsIGZ1bmN0aW9uKGUpe1xuICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQ7XG4gICAgZS5kZWxlZ2F0ZVRhcmdldCA9IGNsb3Nlc3QodGFyZ2V0LCBzZWxlY3RvciwgdHJ1ZSwgZWwpO1xuICAgIGlmIChlLmRlbGVnYXRlVGFyZ2V0KSBmbi5jYWxsKGVsLCBlKTtcbiAgfSwgY2FwdHVyZSk7XG59O1xuXG4vKipcbiAqIFVuYmluZCBldmVudCBgdHlwZWAncyBjYWxsYmFjayBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudW5iaW5kID0gZnVuY3Rpb24oZWwsIHR5cGUsIGZuLCBjYXB0dXJlKXtcbiAgZXZlbnQudW5iaW5kKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSk7XG59O1xuIiwidmFyIG1hdGNoZXMgPSByZXF1aXJlKCdtYXRjaGVzLXNlbGVjdG9yJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IsIGNoZWNrWW9TZWxmLCByb290KSB7XG4gIGVsZW1lbnQgPSBjaGVja1lvU2VsZiA/IHtwYXJlbnROb2RlOiBlbGVtZW50fSA6IGVsZW1lbnRcblxuICByb290ID0gcm9vdCB8fCBkb2N1bWVudFxuXG4gIC8vIE1ha2Ugc3VyZSBgZWxlbWVudCAhPT0gZG9jdW1lbnRgIGFuZCBgZWxlbWVudCAhPSBudWxsYFxuICAvLyBvdGhlcndpc2Ugd2UgZ2V0IGFuIGlsbGVnYWwgaW52b2NhdGlvblxuICB3aGlsZSAoKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUpICYmIGVsZW1lbnQgIT09IGRvY3VtZW50KSB7XG4gICAgaWYgKG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpKVxuICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICAvLyBBZnRlciBgbWF0Y2hlc2Agb24gdGhlIGVkZ2UgY2FzZSB0aGF0XG4gICAgLy8gdGhlIHNlbGVjdG9yIG1hdGNoZXMgdGhlIHJvb3RcbiAgICAvLyAod2hlbiB0aGUgcm9vdCBpcyBub3QgdGhlIGRvY3VtZW50KVxuICAgIGlmIChlbGVtZW50ID09PSByb290KVxuICAgICAgcmV0dXJuICBcbiAgfVxufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHByb3RvID0gRWxlbWVudC5wcm90b3R5cGU7XG52YXIgdmVuZG9yID0gcHJvdG8ubWF0Y2hlc1xuICB8fCBwcm90by5tYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ud2Via2l0TWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm1vek1hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by5tc01hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by5vTWF0Y2hlc1NlbGVjdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoO1xuXG4vKipcbiAqIE1hdGNoIGBlbGAgdG8gYHNlbGVjdG9yYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG1hdGNoKGVsLCBzZWxlY3Rvcikge1xuICBpZiAodmVuZG9yKSByZXR1cm4gdmVuZG9yLmNhbGwoZWwsIHNlbGVjdG9yKTtcbiAgdmFyIG5vZGVzID0gZWwucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXSA9PSBlbCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufSIsIlxuLyoqXG4gKiBFeHBvc2UgYHBhcnNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlO1xuXG4vKipcbiAqIFdyYXAgbWFwIGZyb20ganF1ZXJ5LlxuICovXG5cbnZhciBtYXAgPSB7XG4gIGxlZ2VuZDogWzEsICc8ZmllbGRzZXQ+JywgJzwvZmllbGRzZXQ+J10sXG4gIHRyOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcbiAgY29sOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgX2RlZmF1bHQ6IFswLCAnJywgJyddXG59O1xuXG5tYXAudGQgPVxubWFwLnRoID0gWzMsICc8dGFibGU+PHRib2R5Pjx0cj4nLCAnPC90cj48L3Rib2R5PjwvdGFibGU+J107XG5cbm1hcC5vcHRpb24gPVxubWFwLm9wdGdyb3VwID0gWzEsICc8c2VsZWN0IG11bHRpcGxlPVwibXVsdGlwbGVcIj4nLCAnPC9zZWxlY3Q+J107XG5cbm1hcC50aGVhZCA9XG5tYXAudGJvZHkgPVxubWFwLmNvbGdyb3VwID1cbm1hcC5jYXB0aW9uID1cbm1hcC50Zm9vdCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xuXG5tYXAudGV4dCA9XG5tYXAuY2lyY2xlID1cbm1hcC5lbGxpcHNlID1cbm1hcC5saW5lID1cbm1hcC5wYXRoID1cbm1hcC5wb2x5Z29uID1cbm1hcC5wb2x5bGluZSA9XG5tYXAucmVjdCA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgdmVyc2lvbj1cIjEuMVwiPicsJzwvc3ZnPiddO1xuXG4vKipcbiAqIFBhcnNlIGBodG1sYCBhbmQgcmV0dXJuIHRoZSBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShodG1sKSB7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgaHRtbCkgdGhyb3cgbmV3IFR5cGVFcnJvcignU3RyaW5nIGV4cGVjdGVkJyk7XG4gIFxuICAvLyB0YWcgbmFtZVxuICB2YXIgbSA9IC88KFtcXHc6XSspLy5leGVjKGh0bWwpO1xuICBpZiAoIW0pIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShodG1sKTtcblxuICBodG1sID0gaHRtbC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7IC8vIFJlbW92ZSBsZWFkaW5nL3RyYWlsaW5nIHdoaXRlc3BhY2VcblxuICB2YXIgdGFnID0gbVsxXTtcblxuICAvLyBib2R5IHN1cHBvcnRcbiAgaWYgKHRhZyA9PSAnYm9keScpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdodG1sJyk7XG4gICAgZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gZWwucmVtb3ZlQ2hpbGQoZWwubGFzdENoaWxkKTtcbiAgfVxuXG4gIC8vIHdyYXAgbWFwXG4gIHZhciB3cmFwID0gbWFwW3RhZ10gfHwgbWFwLl9kZWZhdWx0O1xuICB2YXIgZGVwdGggPSB3cmFwWzBdO1xuICB2YXIgcHJlZml4ID0gd3JhcFsxXTtcbiAgdmFyIHN1ZmZpeCA9IHdyYXBbMl07XG4gIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBlbC5pbm5lckhUTUwgPSBwcmVmaXggKyBodG1sICsgc3VmZml4O1xuICB3aGlsZSAoZGVwdGgtLSkgZWwgPSBlbC5sYXN0Q2hpbGQ7XG5cbiAgLy8gb25lIGVsZW1lbnRcbiAgaWYgKGVsLmZpcnN0Q2hpbGQgPT0gZWwubGFzdENoaWxkKSB7XG4gICAgcmV0dXJuIGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgLy8gc2V2ZXJhbCBlbGVtZW50c1xuICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gIHdoaWxlIChlbC5maXJzdENoaWxkKSB7XG4gICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCkpO1xuICB9XG5cbiAgcmV0dXJuIGZyYWdtZW50O1xufVxuIiwidmFyIGJpbmQgPSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdhdHRhY2hFdmVudCcsXG4gICAgdW5iaW5kID0gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgPyAncmVtb3ZlRXZlbnRMaXN0ZW5lcicgOiAnZGV0YWNoRXZlbnQnLFxuICAgIHByZWZpeCA9IGJpbmQgIT09ICdhZGRFdmVudExpc3RlbmVyJyA/ICdvbicgOiAnJztcblxuLyoqXG4gKiBCaW5kIGBlbGAgZXZlbnQgYHR5cGVgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmJpbmQgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4sIGNhcHR1cmUpe1xuICBlbFtiaW5kXShwcmVmaXggKyB0eXBlLCBmbiwgY2FwdHVyZSB8fCBmYWxzZSk7XG4gIHJldHVybiBmbjtcbn07XG5cbi8qKlxuICogVW5iaW5kIGBlbGAgZXZlbnQgYHR5cGVgJ3MgY2FsbGJhY2sgYGZuYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudW5iaW5kID0gZnVuY3Rpb24oZWwsIHR5cGUsIGZuLCBjYXB0dXJlKXtcbiAgZWxbdW5iaW5kXShwcmVmaXggKyB0eXBlLCBmbiwgY2FwdHVyZSB8fCBmYWxzZSk7XG4gIHJldHVybiBmbjtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChhcnIuaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcXVlcnkgPSByZXF1aXJlKCdxdWVyeScpO1xuXG4vKipcbiAqIEVsZW1lbnQgcHJvdG90eXBlLlxuICovXG5cbnZhciBwcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xuXG4vKipcbiAqIFZlbmRvciBmdW5jdGlvbi5cbiAqL1xuXG52YXIgdmVuZG9yID0gcHJvdG8ubWF0Y2hlc1xuICB8fCBwcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm9NYXRjaGVzU2VsZWN0b3I7XG5cbi8qKlxuICogRXhwb3NlIGBtYXRjaCgpYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoO1xuXG4vKipcbiAqIE1hdGNoIGBlbGAgdG8gYHNlbGVjdG9yYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG1hdGNoKGVsLCBzZWxlY3Rvcikge1xuICBpZiAodmVuZG9yKSByZXR1cm4gdmVuZG9yLmNhbGwoZWwsIHNlbGVjdG9yKTtcbiAgdmFyIG5vZGVzID0gcXVlcnkuYWxsKHNlbGVjdG9yLCBlbC5wYXJlbnROb2RlKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChub2Rlc1tpXSA9PSBlbCkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuIiwiZnVuY3Rpb24gb25lKHNlbGVjdG9yLCBlbCkge1xuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG59XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBlbCl7XG4gIGVsID0gZWwgfHwgZG9jdW1lbnQ7XG4gIHJldHVybiBvbmUoc2VsZWN0b3IsIGVsKTtcbn07XG5cbmV4cG9ydHMuYWxsID0gZnVuY3Rpb24oc2VsZWN0b3IsIGVsKXtcbiAgZWwgPSBlbCB8fCBkb2N1bWVudDtcbiAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xufTtcblxuZXhwb3J0cy5lbmdpbmUgPSBmdW5jdGlvbihvYmope1xuICBpZiAoIW9iai5vbmUpIHRocm93IG5ldyBFcnJvcignLm9uZSBjYWxsYmFjayByZXF1aXJlZCcpO1xuICBpZiAoIW9iai5hbGwpIHRocm93IG5ldyBFcnJvcignLmFsbCBjYWxsYmFjayByZXF1aXJlZCcpO1xuICBvbmUgPSBvYmoub25lO1xuICBleHBvcnRzLmFsbCA9IG9iai5hbGw7XG4gIHJldHVybiBleHBvcnRzO1xufTtcbiIsIlxuLyoqXG4gKiB0b1N0cmluZyByZWYuXG4gKi9cblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHR5cGUgb2YgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsKXtcbiAgc3dpdGNoICh0b1N0cmluZy5jYWxsKHZhbCkpIHtcbiAgICBjYXNlICdbb2JqZWN0IEZ1bmN0aW9uXSc6IHJldHVybiAnZnVuY3Rpb24nO1xuICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOiByZXR1cm4gJ2RhdGUnO1xuICAgIGNhc2UgJ1tvYmplY3QgUmVnRXhwXSc6IHJldHVybiAncmVnZXhwJztcbiAgICBjYXNlICdbb2JqZWN0IEFyZ3VtZW50c10nOiByZXR1cm4gJ2FyZ3VtZW50cyc7XG4gICAgY2FzZSAnW29iamVjdCBBcnJheV0nOiByZXR1cm4gJ2FycmF5JztcbiAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOiByZXR1cm4gJ3N0cmluZyc7XG4gIH1cblxuICBpZiAodmFsID09PSBudWxsKSByZXR1cm4gJ251bGwnO1xuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHJldHVybiAndW5kZWZpbmVkJztcbiAgaWYgKHZhbCAmJiB2YWwubm9kZVR5cGUgPT09IDEpIHJldHVybiAnZWxlbWVudCc7XG4gIGlmICh2YWwgPT09IE9iamVjdCh2YWwpKSByZXR1cm4gJ29iamVjdCc7XG5cbiAgcmV0dXJuIHR5cGVvZiB2YWw7XG59O1xuIiwiXG4vKipcbiAqIFByb3BlcnRpZXMgdG8gaWdub3JlIGFwcGVuZGluZyBcInB4XCIuXG4gKi9cblxudmFyIGlnbm9yZSA9IHtcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZVxufTtcblxuLyoqXG4gKiBTZXQgYGVsYCBjc3MgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWwsIG9iail7XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICB2YXIgdmFsID0gb2JqW2tleV07XG4gICAgaWYgKCdudW1iZXInID09IHR5cGVvZiB2YWwgJiYgIWlnbm9yZVtrZXldKSB2YWwgKz0gJ3B4JztcbiAgICBlbC5zdHlsZVtrZXldID0gdmFsO1xuICB9XG4gIHJldHVybiBlbDtcbn07XG4iLCJcbi8qKlxuICogZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIG1hdGNoZXMgPSByZXF1aXJlKCdtYXRjaGVzLXNlbGVjdG9yJyk7XG5cbi8qKlxuICogVHJhdmVyc2Ugd2l0aCB0aGUgZ2l2ZW4gYGVsYCwgYHNlbGVjdG9yYCBhbmQgYGxlbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IGxlblxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odHlwZSwgZWwsIHNlbGVjdG9yLCBsZW4pe1xuICB2YXIgZWwgPSBlbFt0eXBlXVxuICAgICwgbiA9IGxlbiB8fCAxXG4gICAgLCByZXQgPSBbXTtcblxuICBpZiAoIWVsKSByZXR1cm4gcmV0O1xuXG4gIGRvIHtcbiAgICBpZiAobiA9PSByZXQubGVuZ3RoKSBicmVhaztcbiAgICBpZiAoMSAhPSBlbC5ub2RlVHlwZSkgY29udGludWU7XG4gICAgaWYgKG1hdGNoZXMoZWwsIHNlbGVjdG9yKSkgcmV0LnB1c2goZWwpO1xuICAgIGlmICghc2VsZWN0b3IpIHJldC5wdXNoKGVsKTtcbiAgfSB3aGlsZSAoZWwgPSBlbFt0eXBlXSk7XG5cbiAgcmV0dXJuIHJldDtcbn1cbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHlwZU9mID0gcmVxdWlyZSgndHlwZScpO1xuXG4vKipcbiAqIFNldCBvciBnZXQgYGVsYCdzJyB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVsLCB2YWwpe1xuICBpZiAoMiA9PSBhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gc2V0KGVsLCB2YWwpO1xuICByZXR1cm4gZ2V0KGVsKTtcbn07XG5cbi8qKlxuICogR2V0IGBlbGAncyB2YWx1ZS5cbiAqL1xuXG5mdW5jdGlvbiBnZXQoZWwpIHtcbiAgc3dpdGNoICh0eXBlKGVsKSkge1xuICAgIGNhc2UgJ2NoZWNrYm94JzpcbiAgICBjYXNlICdyYWRpbyc6XG4gICAgICBpZiAoZWwuY2hlY2tlZCkge1xuICAgICAgICB2YXIgYXR0ciA9IGVsLmdldEF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgICAgcmV0dXJuIG51bGwgPT0gYXR0ciA/IHRydWUgOiBhdHRyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIGNhc2UgJ3JhZGlvZ3JvdXAnOlxuICAgICAgZm9yICh2YXIgaSA9IDAsIHJhZGlvOyByYWRpbyA9IGVsW2ldOyBpKyspIHtcbiAgICAgICAgaWYgKHJhZGlvLmNoZWNrZWQpIHJldHVybiByYWRpby52YWx1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICB2YXIgdmFscyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG9wdGlvbjsgb3B0aW9uID0gZWwub3B0aW9uc1tpXTsgaSsrKSB7XG4gICAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQpIHZhbHMucHVzaChvcHRpb24udmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuICh2YWxzLmxlbmd0aD09PTEgPyB2YWxzWzBdIDogdmFscyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGVsLnZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogU2V0IGBlbGAncyB2YWx1ZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldChlbCwgdmFsKSB7XG4gIHN3aXRjaCAodHlwZShlbCkpIHtcbiAgICBjYXNlICdjaGVja2JveCc6XG4gICAgY2FzZSAncmFkaW8nOlxuICAgICAgZWwuY2hlY2tlZCA9ICh2YWwgPT09IHRydWUgPyB0cnVlIDogKHZhbCA9PSBlbC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JhZGlvZ3JvdXAnOlxuICAgICAgZm9yICh2YXIgaSA9IDAsIHJhZGlvOyByYWRpbyA9IGVsW2ldOyBpKyspIHtcbiAgICAgICAgcmFkaW8uY2hlY2tlZCA9IHJhZGlvLnZhbHVlID09PSB2YWw7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgdmFyIHZhbHMgPSAoJ2FycmF5JyA9PSB0eXBlT2YodmFsKSA/IHZhbCA6IFt2YWxdKSwgZm91bmQ7XG4gICAgICBmb3IgKHZhciBpID0gMCwgb3B0aW9uOyBvcHRpb24gPSBlbC5vcHRpb25zW2ldOyBpKyspIHtcbiAgICAgICAgZm91bmQgPSAwO1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgdjsgdiA9IHZhbHNbal07IGorKyl7XG4gICAgICAgICAgZm91bmQgfD0gdiA9PT0gb3B0aW9uLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IChmb3VuZCA9PT0gMSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZWwudmFsdWUgPSB2YWw7XG4gIH1cbn1cblxuLyoqXG4gKiBFbGVtZW50IHR5cGUuXG4gKi9cblxuZnVuY3Rpb24gdHlwZShlbCkge1xuICB2YXIgZ3JvdXAgPSAnYXJyYXknID09IHR5cGVPZihlbCkgfHwgJ29iamVjdCcgPT0gdHlwZU9mKGVsKTtcbiAgaWYgKGdyb3VwKSBlbCA9IGVsWzBdO1xuICB2YXIgbmFtZSA9IGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHZhciB0eXBlID0gZWwuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cbiAgaWYgKGdyb3VwICYmIHR5cGUgJiYgJ3JhZGlvJyA9PSB0eXBlLnRvTG93ZXJDYXNlKCkpIHJldHVybiAncmFkaW9ncm91cCc7XG4gIGlmICgnaW5wdXQnID09IG5hbWUgJiYgdHlwZSAmJiAnY2hlY2tib3gnID09IHR5cGUudG9Mb3dlckNhc2UoKSkgcmV0dXJuICdjaGVja2JveCc7XG4gIGlmICgnaW5wdXQnID09IG5hbWUgJiYgdHlwZSAmJiAncmFkaW8nID09IHR5cGUudG9Mb3dlckNhc2UoKSkgcmV0dXJuICdyYWRpbyc7XG4gIGlmICgnc2VsZWN0JyA9PSBuYW1lKSByZXR1cm4gJ3NlbGVjdCc7XG4gIHJldHVybiBuYW1lO1xufVxuIiwiXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0cmltO1xuXG5mdW5jdGlvbiB0cmltKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpO1xufTtcblxuZXhwb3J0cy5yaWdodCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59O1xuIixudWxsLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXMtYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxudmFyIGtNYXhMZW5ndGggPSAweDNmZmZmZmZmXG52YXIgcm9vdFBhcmVudCA9IHt9XG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIE5vdGU6XG4gKlxuICogLSBJbXBsZW1lbnRhdGlvbiBtdXN0IHN1cHBvcnQgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMuXG4gKiAgIEZpcmVmb3ggNC0yOSBsYWNrZWQgc3VwcG9ydCwgZml4ZWQgaW4gRmlyZWZveCAzMCsuXG4gKiAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG4gKlxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBCdWZmZXIpKSByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG4gIHZhciBsZW5ndGhcblxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICBsZW5ndGggPSArc3ViamVjdFxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbCkge1xuICAgIC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSkgc3ViamVjdCA9IHN1YmplY3QuZGF0YVxuICAgIGxlbmd0aCA9ICtzdWJqZWN0Lmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3Qgc3RhcnQgd2l0aCBudW1iZXIsIGJ1ZmZlciwgYXJyYXkgb3Igc3RyaW5nJylcbiAgfVxuXG4gIGlmIChsZW5ndGggPiBrTWF4TGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHgnICtcbiAgICAgIGtNYXhMZW5ndGgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkgbGVuZ3RoID0gMFxuICBlbHNlIGxlbmd0aCA+Pj49IDAgLy8gY29lcmNlIHRvIHVpbnQzMlxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBzZWxmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC10aGlzXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBzZWxmLmxlbmd0aCA9IGxlbmd0aFxuICAgIHNlbGYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBzZWxmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc2VsZi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgaWYgKGxlbmd0aCA+IDAgJiYgbGVuZ3RoIDw9IEJ1ZmZlci5wb29sU2l6ZSkgc2VsZi5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHNlbGZcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNsb3dCdWZmZXIpKSByZXR1cm4gbmV3IFNsb3dCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGRlbGV0ZSBidWYucGFyZW50XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW4gJiYgYVtpXSA9PT0gYltpXTsgaSsrKSB7fVxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgdG90YWxMZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKHRvdGFsTGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICB0b3RhbExlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdG90YWxMZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcih0b3RhbExlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IGxpc3RbaV1cbiAgICBpdGVtLmNvcHkoYnVmLCBwb3MpXG4gICAgcG9zICs9IGl0ZW0ubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCA+Pj4gMVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4vLyB0b1N0cmluZyhlbmNvZGluZywgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIDBcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCkge1xuICBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIGJ5dGVPZmZzZXQgPj49IDBcblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAtMVxuICBpZiAoYnl0ZU9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuIC0xXG5cbiAgLy8gTmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBNYXRoLm1heCh0aGlzLmxlbmd0aCArIGJ5dGVPZmZzZXQsIDApXG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHJldHVybiAtMSAvLyBzcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZyBhbHdheXMgZmFpbHNcbiAgICByZXR1cm4gU3RyaW5nLnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0KVxuICB9XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZih0aGlzLCBbIHZhbCBdLCBieXRlT2Zmc2V0KVxuICB9XG5cbiAgZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCkge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKHZhciBpID0gMDsgYnl0ZU9mZnNldCArIGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJbYnl0ZU9mZnNldCArIGldID09PSB2YWxbZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXhdKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsLmxlbmd0aCkgcmV0dXJuIGJ5dGVPZmZzZXQgKyBmb3VuZEluZGV4XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9mZnNldCkge1xuICBjb25zb2xlLmxvZygnLmdldCgpIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB1c2luZyBhcnJheSBpbmRleGVzIGluc3RlYWQuJylcbiAgcmV0dXJuIHRoaXMucmVhZFVJbnQ4KG9mZnNldClcbn1cblxuLy8gYHNldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0ICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG5cbiAgaWYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBiaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICBpZiAobmV3QnVmLmxlbmd0aCkgbmV3QnVmLnBhcmVudCA9IHRoaXMucGFyZW50IHx8IHRoaXNcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdidWZmZXIgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgPj4+IDAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCksIDApXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpID4+PiAwICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSW50KFxuICAgICAgdGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCxcbiAgICAgIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSkgLSAxLFxuICAgICAgLU1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcbiAgICApXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJbnQoXG4gICAgICB0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLFxuICAgICAgTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKSAtIDEsXG4gICAgICAtTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuICAgIClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0X3N0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldF9zdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRfc3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5pbmRleE9mID0gQlAuaW5kZXhPZlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50TEUgPSBCUC5yZWFkVUludExFXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxuICBhcnIucmVhZEludEJFID0gQlAucmVhZEludEJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcbiAgYXJyLndyaXRlVUludEJFID0gQlAud3JpdGVVSW50QkVcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxuICBhcnIud3JpdGVJbnRCRSA9IEJQLndyaXRlSW50QkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XFwtXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG4gIHZhciBpID0gMFxuXG4gIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICBjb2RlUG9pbnQgPSBsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwIHwgMHgxMDAwMFxuICAgICAgICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG5cbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgICB9XG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDIwMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cbiIsInZhciBsb29rdXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG5cbjsoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG4gIHZhciBBcnIgPSAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKVxuICAgID8gVWludDhBcnJheVxuICAgIDogQXJyYXlcblxuXHR2YXIgUExVUyAgID0gJysnLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIICA9ICcvJy5jaGFyQ29kZUF0KDApXG5cdHZhciBOVU1CRVIgPSAnMCcuY2hhckNvZGVBdCgwKVxuXHR2YXIgTE9XRVIgID0gJ2EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFVQUEVSICA9ICdBJy5jaGFyQ29kZUF0KDApXG5cdHZhciBQTFVTX1VSTF9TQUZFID0gJy0nLmNoYXJDb2RlQXQoMClcblx0dmFyIFNMQVNIX1VSTF9TQUZFID0gJ18nLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUyB8fFxuXHRcdCAgICBjb2RlID09PSBQTFVTX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSCB8fFxuXHRcdCAgICBjb2RlID09PSBTTEFTSF9VUkxfU0FGRSlcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG4iLCJcbi8qKlxuICogaXNBcnJheVxuICovXG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiB0b1N0cmluZ1xuICovXG5cbnZhciBzdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBgdmFsYFxuICogaXMgYW4gYXJyYXkuXG4gKlxuICogZXhhbXBsZTpcbiAqXG4gKiAgICAgICAgaXNBcnJheShbXSk7XG4gKiAgICAgICAgLy8gPiB0cnVlXG4gKiAgICAgICAgaXNBcnJheShhcmd1bWVudHMpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqICAgICAgICBpc0FycmF5KCcnKTtcbiAqICAgICAgICAvLyA+IGZhbHNlXG4gKlxuICogQHBhcmFtIHttaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheSB8fCBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiAhISB2YWwgJiYgJ1tvYmplY3QgQXJyYXldJyA9PSBzdHIuY2FsbCh2YWwpO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50UXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtpXSgpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgcXVldWUucHVzaChmdW4pO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qISBodHRwOi8vbXRocy5iZS9wdW55Y29kZSB2MS4yLjQgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXiAtfl0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvXFx4MkV8XFx1MzAwMnxcXHVGRjBFfFxcdUZGNjEvZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRhcnJheVtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiBhcnJheTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3MuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0cmV0dXJuIG1hcChzdHJpbmcuc3BsaXQocmVnZXhTZXBhcmF0b3JzKSwgZm4pLmpvaW4oJy4nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyB0byBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5XG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSB0byBVbmljb2RlLiBPbmx5IHRoZVxuXHQgKiBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLCBpLmUuIGl0IGRvZXNuJ3Rcblx0ICogbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgdG9cblx0ICogVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIFB1bnljb2RlIGRvbWFpbiBuYW1lIHRvIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShkb21haW4pIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGRvbWFpbiwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgdG8gUHVueWNvZGUuIE9ubHkgdGhlXG5cdCAqIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS4gaXQgZG9lc24ndFxuXHQgKiBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpbiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIHRvIGNvbnZlcnQsIGFzIGEgVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGRvbWFpbikge1xuXHRcdHJldHVybiBtYXBEb21haW4oZG9tYWluLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4yLjQnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiBpc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIWlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnkgY29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgdGhlIHBhcnQgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhcyBub24gQVNDSUkgY2hhcmFjdGVycy4gSS5lLiBpdCBkb3NlbnQgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBpbiBBU0NJSS5cbiAgICAgIHZhciBkb21haW5BcnJheSA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgIHZhciBuZXdPdXQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9tYWluQXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHMgPSBkb21haW5BcnJheVtpXTtcbiAgICAgICAgbmV3T3V0LnB1c2gocy5tYXRjaCgvW15BLVphLXowLTlfLV0vKSA/XG4gICAgICAgICAgICAneG4tLScgKyBwdW55Y29kZS5lbmNvZGUocykgOiBzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBuZXdPdXQuam9pbignLicpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAoaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKGlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICBPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICByZXN1bHRba10gPSB0aGlzW2tdO1xuICB9LCB0aGlzKTtcblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgIGlmIChrICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICB9KTtcblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfSk7XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCFpc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0KSAmJiAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8XG4gICAgICBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCFpc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiAgYXJnID09IG51bGw7XG59XG4iLCIvKipcbiAqIG1hcmtlZCAtIGEgbWFya2Rvd24gcGFyc2VyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxNCwgQ2hyaXN0b3BoZXIgSmVmZnJleS4gKE1JVCBMaWNlbnNlZClcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGpqL21hcmtlZFxuICovXG5cbjsoZnVuY3Rpb24oKSB7XG5cbi8qKlxuICogQmxvY2stTGV2ZWwgR3JhbW1hclxuICovXG5cbnZhciBibG9jayA9IHtcbiAgbmV3bGluZTogL15cXG4rLyxcbiAgY29kZTogL14oIHs0fVteXFxuXStcXG4qKSsvLFxuICBmZW5jZXM6IG5vb3AsXG4gIGhyOiAvXiggKlstKl9dKXszLH0gKig/Olxcbit8JCkvLFxuICBoZWFkaW5nOiAvXiAqKCN7MSw2fSkgKihbXlxcbl0rPykgKiMqICooPzpcXG4rfCQpLyxcbiAgbnB0YWJsZTogbm9vcCxcbiAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuICooPXwtKXsyLH0gKig/Olxcbit8JCkvLFxuICBibG9ja3F1b3RlOiAvXiggKj5bXlxcbl0rKFxcbig/IWRlZilbXlxcbl0rKSpcXG4qKSsvLFxuICBsaXN0OiAvXiggKikoYnVsbCkgW1xcc1xcU10rPyg/OmhyfGRlZnxcXG57Mix9KD8hICkoPyFcXDFidWxsIClcXG4qfFxccyokKS8sXG4gIGh0bWw6IC9eICooPzpjb21tZW50ICooPzpcXG58XFxzKiQpfGNsb3NlZCAqKD86XFxuezIsfXxcXHMqJCl8Y2xvc2luZyAqKD86XFxuezIsfXxcXHMqJCkpLyxcbiAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogK1tcIihdKFteXFxuXSspW1wiKV0pPyAqKD86XFxuK3wkKS8sXG4gIHRhYmxlOiBub29wLFxuICBwYXJhZ3JhcGg6IC9eKCg/OlteXFxuXStcXG4/KD8haHJ8aGVhZGluZ3xsaGVhZGluZ3xibG9ja3F1b3RlfHRhZ3xkZWYpKSspXFxuKi8sXG4gIHRleHQ6IC9eW15cXG5dKy9cbn07XG5cbmJsb2NrLmJ1bGxldCA9IC8oPzpbKistXXxcXGQrXFwuKS87XG5ibG9jay5pdGVtID0gL14oICopKGJ1bGwpIFteXFxuXSooPzpcXG4oPyFcXDFidWxsIClbXlxcbl0qKSovO1xuYmxvY2suaXRlbSA9IHJlcGxhY2UoYmxvY2suaXRlbSwgJ2dtJylcbiAgKC9idWxsL2csIGJsb2NrLmJ1bGxldClcbiAgKCk7XG5cbmJsb2NrLmxpc3QgPSByZXBsYWNlKGJsb2NrLmxpc3QpXG4gICgvYnVsbC9nLCBibG9jay5idWxsZXQpXG4gICgnaHInLCAnXFxcXG4rKD89XFxcXDE/KD86Wy0qX10gKil7Myx9KD86XFxcXG4rfCQpKScpXG4gICgnZGVmJywgJ1xcXFxuKyg/PScgKyBibG9jay5kZWYuc291cmNlICsgJyknKVxuICAoKTtcblxuYmxvY2suYmxvY2txdW90ZSA9IHJlcGxhY2UoYmxvY2suYmxvY2txdW90ZSlcbiAgKCdkZWYnLCBibG9jay5kZWYpXG4gICgpO1xuXG5ibG9jay5fdGFnID0gJyg/ISg/OidcbiAgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGUnXG4gICsgJ3x2YXJ8c2FtcHxrYmR8c3VifHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkbydcbiAgKyAnfHNwYW58YnJ8d2JyfGluc3xkZWx8aW1nKVxcXFxiKVxcXFx3Kyg/ITovfFteXFxcXHdcXFxcc0BdKkApXFxcXGInO1xuXG5ibG9jay5odG1sID0gcmVwbGFjZShibG9jay5odG1sKVxuICAoJ2NvbW1lbnQnLCAvPCEtLVtcXHNcXFNdKj8tLT4vKVxuICAoJ2Nsb3NlZCcsIC88KHRhZylbXFxzXFxTXSs/PFxcL1xcMT4vKVxuICAoJ2Nsb3NpbmcnLCAvPHRhZyg/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXidcIj5dKSo/Pi8pXG4gICgvdGFnL2csIGJsb2NrLl90YWcpXG4gICgpO1xuXG5ibG9jay5wYXJhZ3JhcGggPSByZXBsYWNlKGJsb2NrLnBhcmFncmFwaClcbiAgKCdocicsIGJsb2NrLmhyKVxuICAoJ2hlYWRpbmcnLCBibG9jay5oZWFkaW5nKVxuICAoJ2xoZWFkaW5nJywgYmxvY2subGhlYWRpbmcpXG4gICgnYmxvY2txdW90ZScsIGJsb2NrLmJsb2NrcXVvdGUpXG4gICgndGFnJywgJzwnICsgYmxvY2suX3RhZylcbiAgKCdkZWYnLCBibG9jay5kZWYpXG4gICgpO1xuXG4vKipcbiAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gKi9cblxuYmxvY2subm9ybWFsID0gbWVyZ2Uoe30sIGJsb2NrKTtcblxuLyoqXG4gKiBHRk0gQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLmdmbSA9IG1lcmdlKHt9LCBibG9jay5ub3JtYWwsIHtcbiAgZmVuY2VzOiAvXiAqKGB7Myx9fH57Myx9KSAqKFxcUyspPyAqXFxuKFtcXHNcXFNdKz8pXFxzKlxcMSAqKD86XFxuK3wkKS8sXG4gIHBhcmFncmFwaDogL14vXG59KTtcblxuYmxvY2suZ2ZtLnBhcmFncmFwaCA9IHJlcGxhY2UoYmxvY2sucGFyYWdyYXBoKVxuICAoJyg/IScsICcoPyEnXG4gICAgKyBibG9jay5nZm0uZmVuY2VzLnNvdXJjZS5yZXBsYWNlKCdcXFxcMScsICdcXFxcMicpICsgJ3wnXG4gICAgKyBibG9jay5saXN0LnNvdXJjZS5yZXBsYWNlKCdcXFxcMScsICdcXFxcMycpICsgJ3wnKVxuICAoKTtcblxuLyoqXG4gKiBHRk0gKyBUYWJsZXMgQmxvY2sgR3JhbW1hclxuICovXG5cbmJsb2NrLnRhYmxlcyA9IG1lcmdlKHt9LCBibG9jay5nZm0sIHtcbiAgbnB0YWJsZTogL14gKihcXFMuKlxcfC4qKVxcbiAqKFstOl0rICpcXHxbLXwgOl0qKVxcbigoPzouKlxcfC4qKD86XFxufCQpKSopXFxuKi8sXG4gIHRhYmxlOiAvXiAqXFx8KC4rKVxcbiAqXFx8KCAqWy06XStbLXwgOl0qKVxcbigoPzogKlxcfC4qKD86XFxufCQpKSopXFxuKi9cbn0pO1xuXG4vKipcbiAqIEJsb2NrIExleGVyXG4gKi9cblxuZnVuY3Rpb24gTGV4ZXIob3B0aW9ucykge1xuICB0aGlzLnRva2VucyA9IFtdO1xuICB0aGlzLnRva2Vucy5saW5rcyA9IHt9O1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5ydWxlcyA9IGJsb2NrLm5vcm1hbDtcblxuICBpZiAodGhpcy5vcHRpb25zLmdmbSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGFibGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzID0gYmxvY2sudGFibGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJ1bGVzID0gYmxvY2suZ2ZtO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEV4cG9zZSBCbG9jayBSdWxlc1xuICovXG5cbkxleGVyLnJ1bGVzID0gYmxvY2s7XG5cbi8qKlxuICogU3RhdGljIExleCBNZXRob2RcbiAqL1xuXG5MZXhlci5sZXggPSBmdW5jdGlvbihzcmMsIG9wdGlvbnMpIHtcbiAgdmFyIGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICByZXR1cm4gbGV4ZXIubGV4KHNyYyk7XG59O1xuXG4vKipcbiAqIFByZXByb2Nlc3NpbmdcbiAqL1xuXG5MZXhlci5wcm90b3R5cGUubGV4ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHNyYyA9IHNyY1xuICAgIC5yZXBsYWNlKC9cXHJcXG58XFxyL2csICdcXG4nKVxuICAgIC5yZXBsYWNlKC9cXHQvZywgJyAgICAnKVxuICAgIC5yZXBsYWNlKC9cXHUwMGEwL2csICcgJylcbiAgICAucmVwbGFjZSgvXFx1MjQyNC9nLCAnXFxuJyk7XG5cbiAgcmV0dXJuIHRoaXMudG9rZW4oc3JjLCB0cnVlKTtcbn07XG5cbi8qKlxuICogTGV4aW5nXG4gKi9cblxuTGV4ZXIucHJvdG90eXBlLnRva2VuID0gZnVuY3Rpb24oc3JjLCB0b3AsIGJxKSB7XG4gIHZhciBzcmMgPSBzcmMucmVwbGFjZSgvXiArJC9nbSwgJycpXG4gICAgLCBuZXh0XG4gICAgLCBsb29zZVxuICAgICwgY2FwXG4gICAgLCBidWxsXG4gICAgLCBiXG4gICAgLCBpdGVtXG4gICAgLCBzcGFjZVxuICAgICwgaVxuICAgICwgbDtcblxuICB3aGlsZSAoc3JjKSB7XG4gICAgLy8gbmV3bGluZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLm5ld2xpbmUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgaWYgKGNhcFswXS5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdzcGFjZSdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29kZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmNvZGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gezR9L2dtLCAnJyk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICB0ZXh0OiAhdGhpcy5vcHRpb25zLnBlZGFudGljXG4gICAgICAgICAgPyBjYXAucmVwbGFjZSgvXFxuKyQvLCAnJylcbiAgICAgICAgICA6IGNhcFxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBmZW5jZXMgKGdmbSlcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5mZW5jZXMuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgbGFuZzogY2FwWzJdLFxuICAgICAgICB0ZXh0OiBjYXBbM11cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gaGVhZGluZ1xuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmhlYWRpbmcuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgZGVwdGg6IGNhcFsxXS5sZW5ndGgsXG4gICAgICAgIHRleHQ6IGNhcFsyXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWJsZSBubyBsZWFkaW5nIHBpcGUgKGdmbSlcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLm5wdGFibGUuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgaGVhZGVyOiBjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGNlbGxzOiBjYXBbM10ucmVwbGFjZSgvXFxuJC8sICcnKS5zcGxpdCgnXFxuJylcbiAgICAgIH07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmFsaWduLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbS5jZWxsc1tpXSA9IGl0ZW0uY2VsbHNbaV0uc3BsaXQoLyAqXFx8ICovKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaChpdGVtKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gbGhlYWRpbmdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5saGVhZGluZy5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2hlYWRpbmcnLFxuICAgICAgICBkZXB0aDogY2FwWzJdID09PSAnPScgPyAxIDogMixcbiAgICAgICAgdGV4dDogY2FwWzFdXG4gICAgICB9KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGhyXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaHIuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdocidcbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gYmxvY2txdW90ZVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrcXVvdGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2Jsb2NrcXVvdGVfc3RhcnQnXG4gICAgICB9KTtcblxuICAgICAgY2FwID0gY2FwWzBdLnJlcGxhY2UoL14gKj4gPy9nbSwgJycpO1xuXG4gICAgICAvLyBQYXNzIGB0b3BgIHRvIGtlZXAgdGhlIGN1cnJlbnRcbiAgICAgIC8vIFwidG9wbGV2ZWxcIiBzdGF0ZS4gVGhpcyBpcyBleGFjdGx5XG4gICAgICAvLyBob3cgbWFya2Rvd24ucGwgd29ya3MuXG4gICAgICB0aGlzLnRva2VuKGNhcCwgdG9wLCB0cnVlKTtcblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdibG9ja3F1b3RlX2VuZCdcbiAgICAgIH0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaXN0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGlzdC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBidWxsID0gY2FwWzJdO1xuXG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2xpc3Rfc3RhcnQnLFxuICAgICAgICBvcmRlcmVkOiBidWxsLmxlbmd0aCA+IDFcbiAgICAgIH0pO1xuXG4gICAgICAvLyBHZXQgZWFjaCB0b3AtbGV2ZWwgaXRlbS5cbiAgICAgIGNhcCA9IGNhcFswXS5tYXRjaCh0aGlzLnJ1bGVzLml0ZW0pO1xuXG4gICAgICBuZXh0ID0gZmFsc2U7XG4gICAgICBsID0gY2FwLmxlbmd0aDtcbiAgICAgIGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpdGVtID0gY2FwW2ldO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGlzdCBpdGVtJ3MgYnVsbGV0XG4gICAgICAgIC8vIHNvIGl0IGlzIHNlZW4gYXMgdGhlIG5leHQgdG9rZW4uXG4gICAgICAgIHNwYWNlID0gaXRlbS5sZW5ndGg7XG4gICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL14gKihbKistXXxcXGQrXFwuKSArLywgJycpO1xuXG4gICAgICAgIC8vIE91dGRlbnQgd2hhdGV2ZXIgdGhlXG4gICAgICAgIC8vIGxpc3QgaXRlbSBjb250YWlucy4gSGFja3kuXG4gICAgICAgIGlmICh+aXRlbS5pbmRleE9mKCdcXG4gJykpIHtcbiAgICAgICAgICBzcGFjZSAtPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICBpdGVtID0gIXRoaXMub3B0aW9ucy5wZWRhbnRpY1xuICAgICAgICAgICAgPyBpdGVtLnJlcGxhY2UobmV3IFJlZ0V4cCgnXiB7MSwnICsgc3BhY2UgKyAnfScsICdnbScpLCAnJylcbiAgICAgICAgICAgIDogaXRlbS5yZXBsYWNlKC9eIHsxLDR9L2dtLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbmV4dCBsaXN0IGl0ZW0gYmVsb25ncyBoZXJlLlxuICAgICAgICAvLyBCYWNrcGVkYWwgaWYgaXQgZG9lcyBub3QgYmVsb25nIGluIHRoaXMgbGlzdC5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbWFydExpc3RzICYmIGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgYiA9IGJsb2NrLmJ1bGxldC5leGVjKGNhcFtpICsgMV0pWzBdO1xuICAgICAgICAgIGlmIChidWxsICE9PSBiICYmICEoYnVsbC5sZW5ndGggPiAxICYmIGIubGVuZ3RoID4gMSkpIHtcbiAgICAgICAgICAgIHNyYyA9IGNhcC5zbGljZShpICsgMSkuam9pbignXFxuJykgKyBzcmM7XG4gICAgICAgICAgICBpID0gbCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgaXRlbSBpcyBsb29zZSBvciBub3QuXG4gICAgICAgIC8vIFVzZTogLyhefFxcbikoPyEgKVteXFxuXStcXG5cXG4oPyFcXHMqJCkvXG4gICAgICAgIC8vIGZvciBkaXNjb3VudCBiZWhhdmlvci5cbiAgICAgICAgbG9vc2UgPSBuZXh0IHx8IC9cXG5cXG4oPyFcXHMqJCkvLnRlc3QoaXRlbSk7XG4gICAgICAgIGlmIChpICE9PSBsIC0gMSkge1xuICAgICAgICAgIG5leHQgPSBpdGVtLmNoYXJBdChpdGVtLmxlbmd0aCAtIDEpID09PSAnXFxuJztcbiAgICAgICAgICBpZiAoIWxvb3NlKSBsb29zZSA9IG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBsb29zZVxuICAgICAgICAgICAgPyAnbG9vc2VfaXRlbV9zdGFydCdcbiAgICAgICAgICAgIDogJ2xpc3RfaXRlbV9zdGFydCdcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gUmVjdXJzZS5cbiAgICAgICAgdGhpcy50b2tlbihpdGVtLCBmYWxzZSwgYnEpO1xuXG4gICAgICAgIHRoaXMudG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICdsaXN0X2l0ZW1fZW5kJ1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdsaXN0X2VuZCdcbiAgICAgIH0pO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBodG1sXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuaHRtbC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgICAgPyAncGFyYWdyYXBoJ1xuICAgICAgICAgIDogJ2h0bWwnLFxuICAgICAgICBwcmU6IGNhcFsxXSA9PT0gJ3ByZScgfHwgY2FwWzFdID09PSAnc2NyaXB0JyB8fCBjYXBbMV0gPT09ICdzdHlsZScsXG4gICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBkZWZcbiAgICBpZiAoKCFicSAmJiB0b3ApICYmIChjYXAgPSB0aGlzLnJ1bGVzLmRlZi5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMubGlua3NbY2FwWzFdLnRvTG93ZXJDYXNlKCldID0ge1xuICAgICAgICBocmVmOiBjYXBbMl0sXG4gICAgICAgIHRpdGxlOiBjYXBbM11cbiAgICAgIH07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWJsZSAoZ2ZtKVxuICAgIGlmICh0b3AgJiYgKGNhcCA9IHRoaXMucnVsZXMudGFibGUuZXhlYyhzcmMpKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcblxuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZTogJ3RhYmxlJyxcbiAgICAgICAgaGVhZGVyOiBjYXBbMV0ucmVwbGFjZSgvXiAqfCAqXFx8ICokL2csICcnKS5zcGxpdCgvICpcXHwgKi8pLFxuICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgIGNlbGxzOiBjYXBbM10ucmVwbGFjZSgvKD86ICpcXHwgKik/XFxuJC8sICcnKS5zcGxpdCgnXFxuJylcbiAgICAgIH07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpdGVtLmFsaWduLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICgvXiAqLSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2NlbnRlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGl0ZW0uY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlbS5jZWxsc1tpXSA9IGl0ZW0uY2VsbHNbaV1cbiAgICAgICAgICAucmVwbGFjZSgvXiAqXFx8ICp8ICpcXHwgKiQvZywgJycpXG4gICAgICAgICAgLnNwbGl0KC8gKlxcfCAqLyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5zLnB1c2goaXRlbSk7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcbiAgICBpZiAodG9wICYmIChjYXAgPSB0aGlzLnJ1bGVzLnBhcmFncmFwaC5leGVjKHNyYykpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgdGhpcy50b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICdwYXJhZ3JhcGgnLFxuICAgICAgICB0ZXh0OiBjYXBbMV0uY2hhckF0KGNhcFsxXS5sZW5ndGggLSAxKSA9PT0gJ1xcbidcbiAgICAgICAgICA/IGNhcFsxXS5zbGljZSgwLCAtMSlcbiAgICAgICAgICA6IGNhcFsxXVxuICAgICAgfSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0ZXh0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGV4dC5leGVjKHNyYykpIHtcbiAgICAgIC8vIFRvcC1sZXZlbCBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZS5cbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLnRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgIH0pO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNyYykge1xuICAgICAgdGhyb3cgbmV3XG4gICAgICAgIEVycm9yKCdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMudG9rZW5zO1xufTtcblxuLyoqXG4gKiBJbmxpbmUtTGV2ZWwgR3JhbW1hclxuICovXG5cbnZhciBpbmxpbmUgPSB7XG4gIGVzY2FwZTogL15cXFxcKFtcXFxcYCp7fVxcW1xcXSgpIytcXC0uIV8+XSkvLFxuICBhdXRvbGluazogL148KFteID5dKyhAfDpcXC8pW14gPl0rKT4vLFxuICB1cmw6IG5vb3AsXG4gIHRhZzogL148IS0tW1xcc1xcU10qPy0tPnxePFxcLz9cXHcrKD86XCJbXlwiXSpcInwnW14nXSonfFteJ1wiPl0pKj8+LyxcbiAgbGluazogL14hP1xcWyhpbnNpZGUpXFxdXFwoaHJlZlxcKS8sXG4gIHJlZmxpbms6IC9eIT9cXFsoaW5zaWRlKVxcXVxccypcXFsoW15cXF1dKilcXF0vLFxuICBub2xpbms6IC9eIT9cXFsoKD86XFxbW15cXF1dKlxcXXxbXlxcW1xcXV0pKilcXF0vLFxuICBzdHJvbmc6IC9eX18oW1xcc1xcU10rPylfXyg/IV8pfF5cXCpcXCooW1xcc1xcU10rPylcXCpcXCooPyFcXCopLyxcbiAgZW06IC9eXFxiXygoPzpfX3xbXFxzXFxTXSkrPylfXFxifF5cXCooKD86XFwqXFwqfFtcXHNcXFNdKSs/KVxcKig/IVxcKikvLFxuICBjb2RlOiAvXihgKylcXHMqKFtcXHNcXFNdKj9bXmBdKVxccypcXDEoPyFgKS8sXG4gIGJyOiAvXiB7Mix9XFxuKD8hXFxzKiQpLyxcbiAgZGVsOiBub29wLFxuICB0ZXh0OiAvXltcXHNcXFNdKz8oPz1bXFxcXDwhXFxbXypgXXwgezIsfVxcbnwkKS9cbn07XG5cbmlubGluZS5faW5zaWRlID0gLyg/OlxcW1teXFxdXSpcXF18W15cXFtcXF1dfFxcXSg/PVteXFxbXSpcXF0pKSovO1xuaW5saW5lLl9ocmVmID0gL1xccyo8PyhbXFxzXFxTXSo/KT4/KD86XFxzK1snXCJdKFtcXHNcXFNdKj8pWydcIl0pP1xccyovO1xuXG5pbmxpbmUubGluayA9IHJlcGxhY2UoaW5saW5lLmxpbmspXG4gICgnaW5zaWRlJywgaW5saW5lLl9pbnNpZGUpXG4gICgnaHJlZicsIGlubGluZS5faHJlZilcbiAgKCk7XG5cbmlubGluZS5yZWZsaW5rID0gcmVwbGFjZShpbmxpbmUucmVmbGluaylcbiAgKCdpbnNpZGUnLCBpbmxpbmUuX2luc2lkZSlcbiAgKCk7XG5cbi8qKlxuICogTm9ybWFsIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLm5vcm1hbCA9IG1lcmdlKHt9LCBpbmxpbmUpO1xuXG4vKipcbiAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLnBlZGFudGljID0gbWVyZ2Uoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgc3Ryb25nOiAvXl9fKD89XFxTKShbXFxzXFxTXSo/XFxTKV9fKD8hXyl8XlxcKlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCpcXCooPyFcXCopLyxcbiAgZW06IC9eXyg/PVxcUykoW1xcc1xcU10qP1xcUylfKD8hXyl8XlxcKig/PVxcUykoW1xcc1xcU10qP1xcUylcXCooPyFcXCopL1xufSk7XG5cbi8qKlxuICogR0ZNIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmdmbSA9IG1lcmdlKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gIGVzY2FwZTogcmVwbGFjZShpbmxpbmUuZXNjYXBlKSgnXSknLCAnfnxdKScpKCksXG4gIHVybDogL14oaHR0cHM/OlxcL1xcL1teXFxzPF0rW148Liw6O1wiJylcXF1cXHNdKS8sXG4gIGRlbDogL15+fig/PVxcUykoW1xcc1xcU10qP1xcUyl+fi8sXG4gIHRleHQ6IHJlcGxhY2UoaW5saW5lLnRleHQpXG4gICAgKCddfCcsICd+XXwnKVxuICAgICgnfCcsICd8aHR0cHM/Oi8vfCcpXG4gICAgKClcbn0pO1xuXG4vKipcbiAqIEdGTSArIExpbmUgQnJlYWtzIElubGluZSBHcmFtbWFyXG4gKi9cblxuaW5saW5lLmJyZWFrcyA9IG1lcmdlKHt9LCBpbmxpbmUuZ2ZtLCB7XG4gIGJyOiByZXBsYWNlKGlubGluZS5icikoJ3syLH0nLCAnKicpKCksXG4gIHRleHQ6IHJlcGxhY2UoaW5saW5lLmdmbS50ZXh0KSgnezIsfScsICcqJykoKVxufSk7XG5cbi8qKlxuICogSW5saW5lIExleGVyICYgQ29tcGlsZXJcbiAqL1xuXG5mdW5jdGlvbiBJbmxpbmVMZXhlcihsaW5rcywgb3B0aW9ucykge1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IG1hcmtlZC5kZWZhdWx0cztcbiAgdGhpcy5saW5rcyA9IGxpbmtzO1xuICB0aGlzLnJ1bGVzID0gaW5saW5lLm5vcm1hbDtcbiAgdGhpcy5yZW5kZXJlciA9IHRoaXMub3B0aW9ucy5yZW5kZXJlciB8fCBuZXcgUmVuZGVyZXI7XG4gIHRoaXMucmVuZGVyZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICBpZiAoIXRoaXMubGlua3MpIHtcbiAgICB0aHJvdyBuZXdcbiAgICAgIEVycm9yKCdUb2tlbnMgYXJyYXkgcmVxdWlyZXMgYSBgbGlua3NgIHByb3BlcnR5LicpO1xuICB9XG5cbiAgaWYgKHRoaXMub3B0aW9ucy5nZm0pIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLmJyZWFrcykge1xuICAgICAgdGhpcy5ydWxlcyA9IGlubGluZS5icmVha3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucnVsZXMgPSBpbmxpbmUuZ2ZtO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICB0aGlzLnJ1bGVzID0gaW5saW5lLnBlZGFudGljO1xuICB9XG59XG5cbi8qKlxuICogRXhwb3NlIElubGluZSBSdWxlc1xuICovXG5cbklubGluZUxleGVyLnJ1bGVzID0gaW5saW5lO1xuXG4vKipcbiAqIFN0YXRpYyBMZXhpbmcvQ29tcGlsaW5nIE1ldGhvZFxuICovXG5cbklubGluZUxleGVyLm91dHB1dCA9IGZ1bmN0aW9uKHNyYywgbGlua3MsIG9wdGlvbnMpIHtcbiAgdmFyIGlubGluZSA9IG5ldyBJbmxpbmVMZXhlcihsaW5rcywgb3B0aW9ucyk7XG4gIHJldHVybiBpbmxpbmUub3V0cHV0KHNyYyk7XG59O1xuXG4vKipcbiAqIExleGluZy9Db21waWxpbmdcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24oc3JjKSB7XG4gIHZhciBvdXQgPSAnJ1xuICAgICwgbGlua1xuICAgICwgdGV4dFxuICAgICwgaHJlZlxuICAgICwgY2FwO1xuXG4gIHdoaWxlIChzcmMpIHtcbiAgICAvLyBlc2NhcGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5lc2NhcGUuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IGNhcFsxXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGF1dG9saW5rXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYXV0b2xpbmsuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgIHRleHQgPSBjYXBbMV0uY2hhckF0KDYpID09PSAnOidcbiAgICAgICAgICA/IHRoaXMubWFuZ2xlKGNhcFsxXS5zdWJzdHJpbmcoNykpXG4gICAgICAgICAgOiB0aGlzLm1hbmdsZShjYXBbMV0pO1xuICAgICAgICBocmVmID0gdGhpcy5tYW5nbGUoJ21haWx0bzonKSArIHRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgfVxuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIubGluayhocmVmLCBudWxsLCB0ZXh0KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHVybCAoZ2ZtKVxuICAgIGlmICghdGhpcy5pbkxpbmsgJiYgKGNhcCA9IHRoaXMucnVsZXMudXJsLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0ZXh0ID0gZXNjYXBlKGNhcFsxXSk7XG4gICAgICBocmVmID0gdGV4dDtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpbmsoaHJlZiwgbnVsbCwgdGV4dCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0YWdcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy50YWcuZXhlYyhzcmMpKSB7XG4gICAgICBpZiAoIXRoaXMuaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgIHRoaXMuaW5MaW5rID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5vcHRpb25zLnNhbml0aXplXG4gICAgICAgID8gZXNjYXBlKGNhcFswXSlcbiAgICAgICAgOiBjYXBbMF07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsaW5rXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMubGluay5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICB0aGlzLmluTGluayA9IHRydWU7XG4gICAgICBvdXQgKz0gdGhpcy5vdXRwdXRMaW5rKGNhcCwge1xuICAgICAgICBocmVmOiBjYXBbMl0sXG4gICAgICAgIHRpdGxlOiBjYXBbM11cbiAgICAgIH0pO1xuICAgICAgdGhpcy5pbkxpbmsgPSBmYWxzZTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIHJlZmxpbmssIG5vbGlua1xuICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5yZWZsaW5rLmV4ZWMoc3JjKSlcbiAgICAgICAgfHwgKGNhcCA9IHRoaXMucnVsZXMubm9saW5rLmV4ZWMoc3JjKSkpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBsaW5rID0gKGNhcFsyXSB8fCBjYXBbMV0pLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgIGxpbmsgPSB0aGlzLmxpbmtzW2xpbmsudG9Mb3dlckNhc2UoKV07XG4gICAgICBpZiAoIWxpbmsgfHwgIWxpbmsuaHJlZikge1xuICAgICAgICBvdXQgKz0gY2FwWzBdLmNoYXJBdCgwKTtcbiAgICAgICAgc3JjID0gY2FwWzBdLnN1YnN0cmluZygxKSArIHNyYztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmluTGluayA9IHRydWU7XG4gICAgICBvdXQgKz0gdGhpcy5vdXRwdXRMaW5rKGNhcCwgbGluayk7XG4gICAgICB0aGlzLmluTGluayA9IGZhbHNlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gc3Ryb25nXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuc3Ryb25nLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLnN0cm9uZyh0aGlzLm91dHB1dChjYXBbMl0gfHwgY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBlbVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmVtLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmVtKHRoaXMub3V0cHV0KGNhcFsyXSB8fCBjYXBbMV0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGNvZGVcbiAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5jb2RlLmV4ZWMoc3JjKSkge1xuICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyhjYXBbMF0ubGVuZ3RoKTtcbiAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmNvZGVzcGFuKGVzY2FwZShjYXBbMl0sIHRydWUpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGJyXG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMuYnIuZXhlYyhzcmMpKSB7XG4gICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKGNhcFswXS5sZW5ndGgpO1xuICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuYnIoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGRlbCAoZ2ZtKVxuICAgIGlmIChjYXAgPSB0aGlzLnJ1bGVzLmRlbC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5kZWwodGhpcy5vdXRwdXQoY2FwWzFdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyB0ZXh0XG4gICAgaWYgKGNhcCA9IHRoaXMucnVsZXMudGV4dC5leGVjKHNyYykpIHtcbiAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcoY2FwWzBdLmxlbmd0aCk7XG4gICAgICBvdXQgKz0gZXNjYXBlKHRoaXMuc21hcnR5cGFudHMoY2FwWzBdKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoc3JjKSB7XG4gICAgICB0aHJvdyBuZXdcbiAgICAgICAgRXJyb3IoJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb21waWxlIExpbmtcbiAqL1xuXG5JbmxpbmVMZXhlci5wcm90b3R5cGUub3V0cHV0TGluayA9IGZ1bmN0aW9uKGNhcCwgbGluaykge1xuICB2YXIgaHJlZiA9IGVzY2FwZShsaW5rLmhyZWYpXG4gICAgLCB0aXRsZSA9IGxpbmsudGl0bGUgPyBlc2NhcGUobGluay50aXRsZSkgOiBudWxsO1xuXG4gIHJldHVybiBjYXBbMF0uY2hhckF0KDApICE9PSAnISdcbiAgICA/IHRoaXMucmVuZGVyZXIubGluayhocmVmLCB0aXRsZSwgdGhpcy5vdXRwdXQoY2FwWzFdKSlcbiAgICA6IHRoaXMucmVuZGVyZXIuaW1hZ2UoaHJlZiwgdGl0bGUsIGVzY2FwZShjYXBbMV0pKTtcbn07XG5cbi8qKlxuICogU21hcnR5cGFudHMgVHJhbnNmb3JtYXRpb25zXG4gKi9cblxuSW5saW5lTGV4ZXIucHJvdG90eXBlLnNtYXJ0eXBhbnRzID0gZnVuY3Rpb24odGV4dCkge1xuICBpZiAoIXRoaXMub3B0aW9ucy5zbWFydHlwYW50cykgcmV0dXJuIHRleHQ7XG4gIHJldHVybiB0ZXh0XG4gICAgLy8gZW0tZGFzaGVzXG4gICAgLnJlcGxhY2UoLy0tL2csICdcXHUyMDE0JylcbiAgICAvLyBvcGVuaW5nIHNpbmdsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XCJcXHNdKScvZywgJyQxXFx1MjAxOCcpXG4gICAgLy8gY2xvc2luZyBzaW5nbGVzICYgYXBvc3Ryb3BoZXNcbiAgICAucmVwbGFjZSgvJy9nLCAnXFx1MjAxOScpXG4gICAgLy8gb3BlbmluZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoLyhefFstXFx1MjAxNC8oXFxbe1xcdTIwMThcXHNdKVwiL2csICckMVxcdTIwMWMnKVxuICAgIC8vIGNsb3NpbmcgZG91Ymxlc1xuICAgIC5yZXBsYWNlKC9cIi9nLCAnXFx1MjAxZCcpXG4gICAgLy8gZWxsaXBzZXNcbiAgICAucmVwbGFjZSgvXFwuezN9L2csICdcXHUyMDI2Jyk7XG59O1xuXG4vKipcbiAqIE1hbmdsZSBMaW5rc1xuICovXG5cbklubGluZUxleGVyLnByb3RvdHlwZS5tYW5nbGUgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHZhciBvdXQgPSAnJ1xuICAgICwgbCA9IHRleHQubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgY2g7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBjaCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgY2ggPSAneCcgKyBjaC50b1N0cmluZygxNik7XG4gICAgfVxuICAgIG91dCArPSAnJiMnICsgY2ggKyAnOyc7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZW5kZXJlclxuICovXG5cbmZ1bmN0aW9uIFJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbn1cblxuUmVuZGVyZXIucHJvdG90eXBlLmNvZGUgPSBmdW5jdGlvbihjb2RlLCBsYW5nLCBlc2NhcGVkKSB7XG4gIGlmICh0aGlzLm9wdGlvbnMuaGlnaGxpZ2h0KSB7XG4gICAgdmFyIG91dCA9IHRoaXMub3B0aW9ucy5oaWdobGlnaHQoY29kZSwgbGFuZyk7XG4gICAgaWYgKG91dCAhPSBudWxsICYmIG91dCAhPT0gY29kZSkge1xuICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICBjb2RlID0gb3V0O1xuICAgIH1cbiAgfVxuXG4gIGlmICghbGFuZykge1xuICAgIHJldHVybiAnPHByZT48Y29kZT4nXG4gICAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICAgICsgJ1xcbjwvY29kZT48L3ByZT4nO1xuICB9XG5cbiAgcmV0dXJuICc8cHJlPjxjb2RlIGNsYXNzPVwiJ1xuICAgICsgdGhpcy5vcHRpb25zLmxhbmdQcmVmaXhcbiAgICArIGVzY2FwZShsYW5nLCB0cnVlKVxuICAgICsgJ1wiPidcbiAgICArIChlc2NhcGVkID8gY29kZSA6IGVzY2FwZShjb2RlLCB0cnVlKSlcbiAgICArICdcXG48L2NvZGU+PC9wcmU+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5ibG9ja3F1b3RlID0gZnVuY3Rpb24ocXVvdGUpIHtcbiAgcmV0dXJuICc8YmxvY2txdW90ZT5cXG4nICsgcXVvdGUgKyAnPC9ibG9ja3F1b3RlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaHRtbCA9IGZ1bmN0aW9uKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWw7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaGVhZGluZyA9IGZ1bmN0aW9uKHRleHQsIGxldmVsLCByYXcpIHtcbiAgcmV0dXJuICc8aCdcbiAgICArIGxldmVsXG4gICAgKyAnIGlkPVwiJ1xuICAgICsgdGhpcy5vcHRpb25zLmhlYWRlclByZWZpeFxuICAgICsgcmF3LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvW15cXHddKy9nLCAnLScpXG4gICAgKyAnXCI+J1xuICAgICsgdGV4dFxuICAgICsgJzwvaCdcbiAgICArIGxldmVsXG4gICAgKyAnPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuaHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8aHIvPlxcbicgOiAnPGhyPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKGJvZHksIG9yZGVyZWQpIHtcbiAgdmFyIHR5cGUgPSBvcmRlcmVkID8gJ29sJyA6ICd1bCc7XG4gIHJldHVybiAnPCcgKyB0eXBlICsgJz5cXG4nICsgYm9keSArICc8LycgKyB0eXBlICsgJz5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmxpc3RpdGVtID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxsaT4nICsgdGV4dCArICc8L2xpPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUucGFyYWdyYXBoID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxwPicgKyB0ZXh0ICsgJzwvcD5cXG4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLnRhYmxlID0gZnVuY3Rpb24oaGVhZGVyLCBib2R5KSB7XG4gIHJldHVybiAnPHRhYmxlPlxcbidcbiAgICArICc8dGhlYWQ+XFxuJ1xuICAgICsgaGVhZGVyXG4gICAgKyAnPC90aGVhZD5cXG4nXG4gICAgKyAnPHRib2R5PlxcbidcbiAgICArIGJvZHlcbiAgICArICc8L3Rib2R5PlxcbidcbiAgICArICc8L3RhYmxlPlxcbic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUudGFibGVyb3cgPSBmdW5jdGlvbihjb250ZW50KSB7XG4gIHJldHVybiAnPHRyPlxcbicgKyBjb250ZW50ICsgJzwvdHI+XFxuJztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS50YWJsZWNlbGwgPSBmdW5jdGlvbihjb250ZW50LCBmbGFncykge1xuICB2YXIgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICB2YXIgdGFnID0gZmxhZ3MuYWxpZ25cbiAgICA/ICc8JyArIHR5cGUgKyAnIHN0eWxlPVwidGV4dC1hbGlnbjonICsgZmxhZ3MuYWxpZ24gKyAnXCI+J1xuICAgIDogJzwnICsgdHlwZSArICc+JztcbiAgcmV0dXJuIHRhZyArIGNvbnRlbnQgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbn07XG5cbi8vIHNwYW4gbGV2ZWwgcmVuZGVyZXJcblJlbmRlcmVyLnByb3RvdHlwZS5zdHJvbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPHN0cm9uZz4nICsgdGV4dCArICc8L3N0cm9uZz4nO1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmVtID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxlbT4nICsgdGV4dCArICc8L2VtPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuY29kZXNwYW4gPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiAnPGNvZGU+JyArIHRleHQgKyAnPC9jb2RlPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuYnIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMub3B0aW9ucy54aHRtbCA/ICc8YnIvPicgOiAnPGJyPic7XG59O1xuXG5SZW5kZXJlci5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24odGV4dCkge1xuICByZXR1cm4gJzxkZWw+JyArIHRleHQgKyAnPC9kZWw+Jztcbn07XG5cblJlbmRlcmVyLnByb3RvdHlwZS5saW5rID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZShocmVmKSlcbiAgICAgICAgLnJlcGxhY2UoL1teXFx3Ol0vZywgJycpXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHByb3QuaW5kZXhPZignamF2YXNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ3Zic2NyaXB0OicpID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICB9XG4gIHZhciBvdXQgPSAnPGEgaHJlZj1cIicgKyBocmVmICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuUmVuZGVyZXIucHJvdG90eXBlLmltYWdlID0gZnVuY3Rpb24oaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgdmFyIG91dCA9ICc8aW1nIHNyYz1cIicgKyBocmVmICsgJ1wiIGFsdD1cIicgKyB0ZXh0ICsgJ1wiJztcbiAgaWYgKHRpdGxlKSB7XG4gICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICB9XG4gIG91dCArPSB0aGlzLm9wdGlvbnMueGh0bWwgPyAnLz4nIDogJz4nO1xuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQYXJzaW5nICYgQ29tcGlsaW5nXG4gKi9cblxuZnVuY3Rpb24gUGFyc2VyKG9wdGlvbnMpIHtcbiAgdGhpcy50b2tlbnMgPSBbXTtcbiAgdGhpcy50b2tlbiA9IG51bGw7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgbWFya2VkLmRlZmF1bHRzO1xuICB0aGlzLm9wdGlvbnMucmVuZGVyZXIgPSB0aGlzLm9wdGlvbnMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICB0aGlzLnJlbmRlcmVyLm9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG59XG5cbi8qKlxuICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICovXG5cblBhcnNlci5wYXJzZSA9IGZ1bmN0aW9uKHNyYywgb3B0aW9ucywgcmVuZGVyZXIpIHtcbiAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucywgcmVuZGVyZXIpO1xuICByZXR1cm4gcGFyc2VyLnBhcnNlKHNyYyk7XG59O1xuXG4vKipcbiAqIFBhcnNlIExvb3BcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3JjKSB7XG4gIHRoaXMuaW5saW5lID0gbmV3IElubGluZUxleGVyKHNyYy5saW5rcywgdGhpcy5vcHRpb25zLCB0aGlzLnJlbmRlcmVyKTtcbiAgdGhpcy50b2tlbnMgPSBzcmMucmV2ZXJzZSgpO1xuXG4gIHZhciBvdXQgPSAnJztcbiAgd2hpbGUgKHRoaXMubmV4dCgpKSB7XG4gICAgb3V0ICs9IHRoaXMudG9rKCk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOZXh0IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnRva2VuID0gdGhpcy50b2tlbnMucG9wKCk7XG59O1xuXG4vKipcbiAqIFByZXZpZXcgTmV4dCBUb2tlblxuICovXG5cblBhcnNlci5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gfHwgMDtcbn07XG5cbi8qKlxuICogUGFyc2UgVGV4dCBUb2tlbnNcbiAqL1xuXG5QYXJzZXIucHJvdG90eXBlLnBhcnNlVGV4dCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYm9keSA9IHRoaXMudG9rZW4udGV4dDtcblxuICB3aGlsZSAodGhpcy5wZWVrKCkudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgYm9keSArPSAnXFxuJyArIHRoaXMubmV4dCgpLnRleHQ7XG4gIH1cblxuICByZXR1cm4gdGhpcy5pbmxpbmUub3V0cHV0KGJvZHkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBDdXJyZW50IFRva2VuXG4gKi9cblxuUGFyc2VyLnByb3RvdHlwZS50b2sgPSBmdW5jdGlvbigpIHtcbiAgc3dpdGNoICh0aGlzLnRva2VuLnR5cGUpIHtcbiAgICBjYXNlICdzcGFjZSc6IHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgY2FzZSAnaHInOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ocigpO1xuICAgIH1cbiAgICBjYXNlICdoZWFkaW5nJzoge1xuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuaGVhZGluZyhcbiAgICAgICAgdGhpcy5pbmxpbmUub3V0cHV0KHRoaXMudG9rZW4udGV4dCksXG4gICAgICAgIHRoaXMudG9rZW4uZGVwdGgsXG4gICAgICAgIHRoaXMudG9rZW4udGV4dCk7XG4gICAgfVxuICAgIGNhc2UgJ2NvZGUnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5jb2RlKHRoaXMudG9rZW4udGV4dCxcbiAgICAgICAgdGhpcy50b2tlbi5sYW5nLFxuICAgICAgICB0aGlzLnRva2VuLmVzY2FwZWQpO1xuICAgIH1cbiAgICBjYXNlICd0YWJsZSc6IHtcbiAgICAgIHZhciBoZWFkZXIgPSAnJ1xuICAgICAgICAsIGJvZHkgPSAnJ1xuICAgICAgICAsIGlcbiAgICAgICAgLCByb3dcbiAgICAgICAgLCBjZWxsXG4gICAgICAgICwgZmxhZ3NcbiAgICAgICAgLCBqO1xuXG4gICAgICAvLyBoZWFkZXJcbiAgICAgIGNlbGwgPSAnJztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRva2VuLmhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBmbGFncyA9IHsgaGVhZGVyOiB0cnVlLCBhbGlnbjogdGhpcy50b2tlbi5hbGlnbltpXSB9O1xuICAgICAgICBjZWxsICs9IHRoaXMucmVuZGVyZXIudGFibGVjZWxsKFxuICAgICAgICAgIHRoaXMuaW5saW5lLm91dHB1dCh0aGlzLnRva2VuLmhlYWRlcltpXSksXG4gICAgICAgICAgeyBoZWFkZXI6IHRydWUsIGFsaWduOiB0aGlzLnRva2VuLmFsaWduW2ldIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy50b2tlbi5jZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICByb3cgPSB0aGlzLnRva2VuLmNlbGxzW2ldO1xuXG4gICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHJvdy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNlbGwgKz0gdGhpcy5yZW5kZXJlci50YWJsZWNlbGwoXG4gICAgICAgICAgICB0aGlzLmlubGluZS5vdXRwdXQocm93W2pdKSxcbiAgICAgICAgICAgIHsgaGVhZGVyOiBmYWxzZSwgYWxpZ246IHRoaXMudG9rZW4uYWxpZ25bal0gfVxuICAgICAgICAgICk7XG4gICAgICAgIH1cblxuICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci50YWJsZShoZWFkZXIsIGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdibG9ja3F1b3RlX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdibG9ja3F1b3RlX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5ibG9ja3F1b3RlKGJvZHkpO1xuICAgIH1cbiAgICBjYXNlICdsaXN0X3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJ1xuICAgICAgICAsIG9yZGVyZWQgPSB0aGlzLnRva2VuLm9yZGVyZWQ7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9lbmQnKSB7XG4gICAgICAgIGJvZHkgKz0gdGhpcy50b2soKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIubGlzdChib2R5LCBvcmRlcmVkKTtcbiAgICB9XG4gICAgY2FzZSAnbGlzdF9pdGVtX3N0YXJ0Jzoge1xuICAgICAgdmFyIGJvZHkgPSAnJztcblxuICAgICAgd2hpbGUgKHRoaXMubmV4dCgpLnR5cGUgIT09ICdsaXN0X2l0ZW1fZW5kJykge1xuICAgICAgICBib2R5ICs9IHRoaXMudG9rZW4udHlwZSA9PT0gJ3RleHQnXG4gICAgICAgICAgPyB0aGlzLnBhcnNlVGV4dCgpXG4gICAgICAgICAgOiB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0aXRlbShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnbG9vc2VfaXRlbV9zdGFydCc6IHtcbiAgICAgIHZhciBib2R5ID0gJyc7XG5cbiAgICAgIHdoaWxlICh0aGlzLm5leHQoKS50eXBlICE9PSAnbGlzdF9pdGVtX2VuZCcpIHtcbiAgICAgICAgYm9keSArPSB0aGlzLnRvaygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5saXN0aXRlbShib2R5KTtcbiAgICB9XG4gICAgY2FzZSAnaHRtbCc6IHtcbiAgICAgIHZhciBodG1sID0gIXRoaXMudG9rZW4ucHJlICYmICF0aGlzLm9wdGlvbnMucGVkYW50aWNcbiAgICAgICAgPyB0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KVxuICAgICAgICA6IHRoaXMudG9rZW4udGV4dDtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmh0bWwoaHRtbCk7XG4gICAgfVxuICAgIGNhc2UgJ3BhcmFncmFwaCc6IHtcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBhcmFncmFwaCh0aGlzLmlubGluZS5vdXRwdXQodGhpcy50b2tlbi50ZXh0KSk7XG4gICAgfVxuICAgIGNhc2UgJ3RleHQnOiB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgodGhpcy5wYXJzZVRleHQoKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhlbHBlcnNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gIHJldHVybiBodG1sXG4gICAgLnJlcGxhY2UoIWVuY29kZSA/IC8mKD8hIz9cXHcrOykvZyA6IC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLycvZywgJyYjMzk7Jyk7XG59XG5cbmZ1bmN0aW9uIHVuZXNjYXBlKGh0bWwpIHtcbiAgcmV0dXJuIGh0bWwucmVwbGFjZSgvJihbI1xcd10rKTsvZywgZnVuY3Rpb24oXywgbikge1xuICAgIG4gPSBuLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKG4gPT09ICdjb2xvbicpIHJldHVybiAnOic7XG4gICAgaWYgKG4uY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgIHJldHVybiBuLmNoYXJBdCgxKSA9PT0gJ3gnXG4gICAgICAgID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChuLnN1YnN0cmluZygyKSwgMTYpKVxuICAgICAgICA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZShyZWdleCwgb3B0KSB7XG4gIHJlZ2V4ID0gcmVnZXguc291cmNlO1xuICBvcHQgPSBvcHQgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbiBzZWxmKG5hbWUsIHZhbCkge1xuICAgIGlmICghbmFtZSkgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIG9wdCk7XG4gICAgdmFsID0gdmFsLnNvdXJjZSB8fCB2YWw7XG4gICAgdmFsID0gdmFsLnJlcGxhY2UoLyhefFteXFxbXSlcXF4vZywgJyQxJyk7XG4gICAgcmVnZXggPSByZWdleC5yZXBsYWNlKG5hbWUsIHZhbCk7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxubm9vcC5leGVjID0gbm9vcDtcblxuZnVuY3Rpb24gbWVyZ2Uob2JqKSB7XG4gIHZhciBpID0gMVxuICAgICwgdGFyZ2V0XG4gICAgLCBrZXk7XG5cbiAgZm9yICg7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXQgPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwga2V5KSkge1xuICAgICAgICBvYmpba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cblxuLyoqXG4gKiBNYXJrZWRcbiAqL1xuXG5mdW5jdGlvbiBtYXJrZWQoc3JjLCBvcHQsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjayB8fCB0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2sgPSBvcHQ7XG4gICAgICBvcHQgPSBudWxsO1xuICAgIH1cblxuICAgIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCB8fCB7fSk7XG5cbiAgICB2YXIgaGlnaGxpZ2h0ID0gb3B0LmhpZ2hsaWdodFxuICAgICAgLCB0b2tlbnNcbiAgICAgICwgcGVuZGluZ1xuICAgICAgLCBpID0gMDtcblxuICAgIHRyeSB7XG4gICAgICB0b2tlbnMgPSBMZXhlci5sZXgoc3JjLCBvcHQpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgIH1cblxuICAgIHBlbmRpbmcgPSB0b2tlbnMubGVuZ3RoO1xuXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgb3B0LmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIG91dCA9IFBhcnNlci5wYXJzZSh0b2tlbnMsIG9wdCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVyciA9IGU7XG4gICAgICB9XG5cbiAgICAgIG9wdC5oaWdobGlnaHQgPSBoaWdobGlnaHQ7XG5cbiAgICAgIHJldHVybiBlcnJcbiAgICAgICAgPyBjYWxsYmFjayhlcnIpXG4gICAgICAgIDogY2FsbGJhY2sobnVsbCwgb3V0KTtcbiAgICB9O1xuXG4gICAgaWYgKCFoaWdobGlnaHQgfHwgaGlnaGxpZ2h0Lmxlbmd0aCA8IDMpIHtcbiAgICAgIHJldHVybiBkb25lKCk7XG4gICAgfVxuXG4gICAgZGVsZXRlIG9wdC5oaWdobGlnaHQ7XG5cbiAgICBpZiAoIXBlbmRpbmcpIHJldHVybiBkb25lKCk7XG5cbiAgICBmb3IgKDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgKGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlICE9PSAnY29kZScpIHtcbiAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaGxpZ2h0KHRva2VuLnRleHQsIHRva2VuLmxhbmcsIGZ1bmN0aW9uKGVyciwgY29kZSkge1xuICAgICAgICAgIGlmIChlcnIpIHJldHVybiBkb25lKGVycik7XG4gICAgICAgICAgaWYgKGNvZGUgPT0gbnVsbCB8fCBjb2RlID09PSB0b2tlbi50ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9rZW4udGV4dCA9IGNvZGU7XG4gICAgICAgICAgdG9rZW4uZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgLS1wZW5kaW5nIHx8IGRvbmUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSh0b2tlbnNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGlmIChvcHQpIG9wdCA9IG1lcmdlKHt9LCBtYXJrZWQuZGVmYXVsdHMsIG9wdCk7XG4gICAgcmV0dXJuIFBhcnNlci5wYXJzZShMZXhlci5sZXgoc3JjLCBvcHQpLCBvcHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL2NoamovbWFya2VkLic7XG4gICAgaWYgKChvcHQgfHwgbWFya2VkLmRlZmF1bHRzKS5zaWxlbnQpIHtcbiAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJlZDo8L3A+PHByZT4nXG4gICAgICAgICsgZXNjYXBlKGUubWVzc2FnZSArICcnLCB0cnVlKVxuICAgICAgICArICc8L3ByZT4nO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbi8qKlxuICogT3B0aW9uc1xuICovXG5cbm1hcmtlZC5vcHRpb25zID1cbm1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24ob3B0KSB7XG4gIG1lcmdlKG1hcmtlZC5kZWZhdWx0cywgb3B0KTtcbiAgcmV0dXJuIG1hcmtlZDtcbn07XG5cbm1hcmtlZC5kZWZhdWx0cyA9IHtcbiAgZ2ZtOiB0cnVlLFxuICB0YWJsZXM6IHRydWUsXG4gIGJyZWFrczogZmFsc2UsXG4gIHBlZGFudGljOiBmYWxzZSxcbiAgc2FuaXRpemU6IGZhbHNlLFxuICBzbWFydExpc3RzOiBmYWxzZSxcbiAgc2lsZW50OiBmYWxzZSxcbiAgaGlnaGxpZ2h0OiBudWxsLFxuICBsYW5nUHJlZml4OiAnbGFuZy0nLFxuICBzbWFydHlwYW50czogZmFsc2UsXG4gIGhlYWRlclByZWZpeDogJycsXG4gIHJlbmRlcmVyOiBuZXcgUmVuZGVyZXIsXG4gIHhodG1sOiBmYWxzZVxufTtcblxuLyoqXG4gKiBFeHBvc2VcbiAqL1xuXG5tYXJrZWQuUGFyc2VyID0gUGFyc2VyO1xubWFya2VkLnBhcnNlciA9IFBhcnNlci5wYXJzZTtcblxubWFya2VkLlJlbmRlcmVyID0gUmVuZGVyZXI7XG5cbm1hcmtlZC5MZXhlciA9IExleGVyO1xubWFya2VkLmxleGVyID0gTGV4ZXIubGV4O1xuXG5tYXJrZWQuSW5saW5lTGV4ZXIgPSBJbmxpbmVMZXhlcjtcbm1hcmtlZC5pbmxpbmVMZXhlciA9IElubGluZUxleGVyLm91dHB1dDtcblxubWFya2VkLnBhcnNlID0gbWFya2VkO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbWFya2VkO1xufSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gbWFya2VkOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMubWFya2VkID0gbWFya2VkO1xufVxuXG59KS5jYWxsKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcyB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpO1xufSgpKTtcbiIsIi8vISBtb21lbnQuanNcbi8vISB2ZXJzaW9uIDogMi4xMC4yXG4vLyEgYXV0aG9ycyA6IFRpbSBXb29kLCBJc2tyZW4gQ2hlcm5ldiwgTW9tZW50LmpzIGNvbnRyaWJ1dG9yc1xuLy8hIGxpY2Vuc2UgOiBNSVRcbi8vISBtb21lbnRqcy5jb21cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgICBnbG9iYWwubW9tZW50ID0gZmFjdG9yeSgpXG59KHRoaXMsIGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIHV0aWxzX2hvb2tzX19ob29rcyAoKSB7XG4gICAgICAgIHJldHVybiBob29rQ2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGRvbmUgdG8gcmVnaXN0ZXIgdGhlIG1ldGhvZCBjYWxsZWQgd2l0aCBtb21lbnQoKVxuICAgIC8vIHdpdGhvdXQgY3JlYXRpbmcgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLlxuICAgIGZ1bmN0aW9uIHNldEhvb2tDYWxsYmFjayAoY2FsbGJhY2spIHtcbiAgICAgICAgaG9va0NhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmYXVsdFBhcnNpbmdGbGFncygpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byBkZWVwIGNsb25lIHRoaXMgb2JqZWN0LlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZW1wdHkgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICB1bnVzZWRUb2tlbnMgICAgOiBbXSxcbiAgICAgICAgICAgIHVudXNlZElucHV0ICAgICA6IFtdLFxuICAgICAgICAgICAgb3ZlcmZsb3cgICAgICAgIDogLTIsXG4gICAgICAgICAgICBjaGFyc0xlZnRPdmVyICAgOiAwLFxuICAgICAgICAgICAgbnVsbElucHV0ICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpbnZhbGlkTW9udGggICAgOiBudWxsLFxuICAgICAgICAgICAgaW52YWxpZEZvcm1hdCAgIDogZmFsc2UsXG4gICAgICAgICAgICB1c2VySW52YWxpZGF0ZWQgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzbyAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJyB8fCBpbnB1dCBpbnN0YW5jZW9mIERhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFwKGFyciwgZm4pIHtcbiAgICAgICAgdmFyIHJlcyA9IFtdLCBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXMucHVzaChmbihhcnJbaV0sIGkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc093blByb3AoYSwgYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gYikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoYiwgaSkpIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gYltpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd0b1N0cmluZycpKSB7XG4gICAgICAgICAgICBhLnRvU3RyaW5nID0gYi50b1N0cmluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKGIsICd2YWx1ZU9mJykpIHtcbiAgICAgICAgICAgIGEudmFsdWVPZiA9IGIudmFsdWVPZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV91dGNfX2NyZWF0ZVVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIHRydWUpLnV0YygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkX19pc1ZhbGlkKG0pIHtcbiAgICAgICAgaWYgKG0uX2lzVmFsaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgbS5faXNWYWxpZCA9ICFpc05hTihtLl9kLmdldFRpbWUoKSkgJiZcbiAgICAgICAgICAgICAgICBtLl9wZi5vdmVyZmxvdyA8IDAgJiZcbiAgICAgICAgICAgICAgICAhbS5fcGYuZW1wdHkgJiZcbiAgICAgICAgICAgICAgICAhbS5fcGYuaW52YWxpZE1vbnRoICYmXG4gICAgICAgICAgICAgICAgIW0uX3BmLm51bGxJbnB1dCAmJlxuICAgICAgICAgICAgICAgICFtLl9wZi5pbnZhbGlkRm9ybWF0ICYmXG4gICAgICAgICAgICAgICAgIW0uX3BmLnVzZXJJbnZhbGlkYXRlZDtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIG0uX2lzVmFsaWQgPSBtLl9pc1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIG0uX3BmLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgbS5fcGYudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBtLl9wZi5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0uX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRfX2NyZWF0ZUludmFsaWQgKGZsYWdzKSB7XG4gICAgICAgIHZhciBtID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKE5hTik7XG4gICAgICAgIGlmIChmbGFncyAhPSBudWxsKSB7XG4gICAgICAgICAgICBleHRlbmQobS5fcGYsIGZsYWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG0uX3BmLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IHV0aWxzX2hvb2tzX19ob29rcy5tb21lbnRQcm9wZXJ0aWVzID0gW107XG5cbiAgICBmdW5jdGlvbiBjb3B5Q29uZmlnKHRvLCBmcm9tKSB7XG4gICAgICAgIHZhciBpLCBwcm9wLCB2YWw7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pc0FNb21lbnRPYmplY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5faXNBTW9tZW50T2JqZWN0ID0gZnJvbS5faXNBTW9tZW50T2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5faSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9pID0gZnJvbS5faTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX2YgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fZiA9IGZyb20uX2Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9sICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX2wgPSBmcm9tLl9sO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fc3RyaWN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX3N0cmljdCA9IGZyb20uX3N0cmljdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX3R6bSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl90em0gPSBmcm9tLl90em07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9pc1VUQyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRvLl9pc1VUQyA9IGZyb20uX2lzVVRDO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZnJvbS5fb2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX29mZnNldCA9IGZyb20uX29mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZyb20uX3BmICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdG8uX3BmID0gZnJvbS5fcGY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tLl9sb2NhbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChpIGluIG1vbWVudFByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZSgrY29uZmlnLl9kKTtcbiAgICAgICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wIGluIGNhc2UgdXBkYXRlT2Zmc2V0IGNyZWF0ZXMgbmV3IG1vbWVudFxuICAgICAgICAvLyBvYmplY3RzLlxuICAgICAgICBpZiAodXBkYXRlSW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTW9tZW50IChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIE1vbWVudCB8fCAob2JqICE9IG51bGwgJiYgaGFzT3duUHJvcChvYmosICdfaXNBTW9tZW50T2JqZWN0JykpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgaWYgKGNvZXJjZWROdW1iZXIgPj0gMCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gTWF0aC5mbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmNlaWwoY29lcmNlZE51bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIExvY2FsZSgpIHtcbiAgICB9XG5cbiAgICB2YXIgbG9jYWxlcyA9IHt9O1xuICAgIHZhciBnbG9iYWxMb2NhbGU7XG5cbiAgICBmdW5jdGlvbiBub3JtYWxpemVMb2NhbGUoa2V5KSB7XG4gICAgICAgIHJldHVybiBrZXkgPyBrZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdfJywgJy0nKSA6IGtleTtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHRoZSBsb2NhbGUgZnJvbSB0aGUgYXJyYXlcbiAgICAvLyB0cnkgWydlbi1hdScsICdlbi1nYiddIGFzICdlbi1hdScsICdlbi1nYicsICdlbicsIGFzIGluIG1vdmUgdGhyb3VnaCB0aGUgbGlzdCB0cnlpbmcgZWFjaFxuICAgIC8vIHN1YnN0cmluZyBmcm9tIG1vc3Qgc3BlY2lmaWMgdG8gbGVhc3QsIGJ1dCBtb3ZlIHRvIHRoZSBuZXh0IGFycmF5IGl0ZW0gaWYgaXQncyBhIG1vcmUgc3BlY2lmaWMgdmFyaWFudCB0aGFuIHRoZSBjdXJyZW50IHJvb3RcbiAgICBmdW5jdGlvbiBjaG9vc2VMb2NhbGUobmFtZXMpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBqLCBuZXh0LCBsb2NhbGUsIHNwbGl0O1xuXG4gICAgICAgIHdoaWxlIChpIDwgbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBzcGxpdCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpXSkuc3BsaXQoJy0nKTtcbiAgICAgICAgICAgIGogPSBzcGxpdC5sZW5ndGg7XG4gICAgICAgICAgICBuZXh0ID0gbm9ybWFsaXplTG9jYWxlKG5hbWVzW2kgKyAxXSk7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dCA/IG5leHQuc3BsaXQoJy0nKSA6IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoaiA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKHNwbGl0LnNsaWNlKDAsIGopLmpvaW4oJy0nKSk7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lmxlbmd0aCA+PSBqICYmIGNvbXBhcmVBcnJheXMoc3BsaXQsIG5leHQsIHRydWUpID49IGogLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhlIG5leHQgYXJyYXkgaXRlbSBpcyBiZXR0ZXIgdGhhbiBhIHNoYWxsb3dlciBzdWJzdHJpbmcgb2YgdGhpcyBvbmVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBvbGRMb2NhbGUgPSBnbG9iYWxMb2NhbGUuX2FiYnI7XG4gICAgICAgICAgICAgICAgcmVxdWlyZSgnLi9sb2NhbGUvJyArIG5hbWUpO1xuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgZGVmaW5lTG9jYWxlIGN1cnJlbnRseSBhbHNvIHNldHMgdGhlIGdsb2JhbCBsb2NhbGUsIHdlXG4gICAgICAgICAgICAgICAgLy8gd2FudCB0byB1bmRvIHRoYXQgZm9yIGxhenkgbG9hZGVkIGxvY2FsZXNcbiAgICAgICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgbG9hZCBsb2NhbGUgYW5kIHRoZW4gc2V0IHRoZSBnbG9iYWwgbG9jYWxlLiAgSWZcbiAgICAvLyBubyBhcmd1bWVudHMgYXJlIHBhc3NlZCBpbiwgaXQgd2lsbCBzaW1wbHkgcmV0dXJuIHRoZSBjdXJyZW50IGdsb2JhbFxuICAgIC8vIGxvY2FsZSBrZXkuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSAoa2V5LCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRhID0gZGVmaW5lTG9jYWxlKGtleSwgdmFsdWVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBtb21lbnQuZHVyYXRpb24uX2xvY2FsZSA9IG1vbWVudC5fbG9jYWxlID0gZGF0YTtcbiAgICAgICAgICAgICAgICBnbG9iYWxMb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZXMuYWJiciA9IG5hbWU7XG4gICAgICAgICAgICBpZiAoIWxvY2FsZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVzW25hbWVdID0gbmV3IExvY2FsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXS5zZXQodmFsdWVzKTtcblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlKG5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJldHVybnMgbG9jYWxlIGRhdGFcbiAgICBmdW5jdGlvbiBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlIChrZXkpIHtcbiAgICAgICAgdmFyIGxvY2FsZTtcblxuICAgICAgICBpZiAoa2V5ICYmIGtleS5fbG9jYWxlICYmIGtleS5fbG9jYWxlLl9hYmJyKSB7XG4gICAgICAgICAgICBrZXkgPSBrZXkuX2xvY2FsZS5fYWJicjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsTG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0FycmF5KGtleSkpIHtcbiAgICAgICAgICAgIC8vc2hvcnQtY2lyY3VpdCBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgICAgIGxvY2FsZSA9IGxvYWRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hvb3NlTG9jYWxlKGtleSk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZ2V0X3NldF9fc2V0KHRoaXMsIHVuaXQsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MudXBkYXRlT2Zmc2V0KHRoaXMsIGtlZXBUaW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldF9zZXRfX2dldCh0aGlzLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRfc2V0X19nZXQgKG1vbSwgdW5pdCkge1xuICAgICAgICByZXR1cm4gbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0X3NldF9fc2V0IChtb20sIHVuaXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBtb20uX2RbJ3NldCcgKyAobW9tLl9pc1VUQyA/ICdVVEMnIDogJycpICsgdW5pdF0odmFsdWUpO1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldCAodW5pdHMsIHZhbHVlKSB7XG4gICAgICAgIHZhciB1bml0O1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yICh1bml0IGluIHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQodW5pdCwgdW5pdHNbdW5pdF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNbdW5pdHNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB6ZXJvRmlsbChudW1iZXIsIHRhcmdldExlbmd0aCwgZm9yY2VTaWduKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSAnJyArIE1hdGguYWJzKG51bWJlciksXG4gICAgICAgICAgICBzaWduID0gbnVtYmVyID49IDA7XG5cbiAgICAgICAgd2hpbGUgKG91dHB1dC5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9ICcwJyArIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHNpZ24gPyAoZm9yY2VTaWduID8gJysnIDogJycpIDogJy0nKSArIG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhNb3xNTT9NP00/fERvfERERG98REQ/RD9EP3xkZGQ/ZD98ZG8/fHdbb3x3XT98V1tvfFddP3xRfFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fG1tP3xzcz98U3sxLDR9fHh8WHx6ej98Wlo/fC4pL2c7XG5cbiAgICB2YXIgbG9jYWxGb3JtYXR0aW5nVG9rZW5zID0gLyhcXFtbXlxcW10qXFxdKXwoXFxcXCk/KExUU3xMVHxMTD9MP0w/fGx7MSw0fSkvZztcblxuICAgIHZhciBmb3JtYXRGdW5jdGlvbnMgPSB7fTtcblxuICAgIHZhciBmb3JtYXRUb2tlbkZ1bmN0aW9ucyA9IHt9O1xuXG4gICAgLy8gdG9rZW46ICAgICdNJ1xuICAgIC8vIHBhZGRlZDogICBbJ01NJywgMl1cbiAgICAvLyBvcmRpbmFsOiAgJ01vJ1xuICAgIC8vIGNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7IHRoaXMubW9udGgoKSArIDEgfVxuICAgIGZ1bmN0aW9uIGFkZEZvcm1hdFRva2VuICh0b2tlbiwgcGFkZGVkLCBvcmRpbmFsLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tjYWxsYmFja10oKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1t0b2tlbl0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYWRkZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW3BhZGRlZFswXV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9GaWxsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgcGFkZGVkWzFdLCBwYWRkZWRbMl0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JkaW5hbCkge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbb3JkaW5hbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm9yZGluYWwoZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLCB0b2tlbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQubWF0Y2goL1xcW1tcXHNcXFNdLykpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9eXFxbfFxcXSQvZywgJycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlRm9ybWF0RnVuY3Rpb24oZm9ybWF0KSB7XG4gICAgICAgIHZhciBhcnJheSA9IGZvcm1hdC5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSwgaSwgbGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dKSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbaV0gPSBmb3JtYXRUb2tlbkZ1bmN0aW9uc1thcnJheVtpXV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gcmVtb3ZlRm9ybWF0dGluZ1Rva2VucyhhcnJheVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1vbSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dCA9ICcnO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGFycmF5W2ldIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcnJheVtpXS5jYWxsKG1vbSwgZm9ybWF0KSA6IGFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBmb3JtYXQgZGF0ZSB1c2luZyBuYXRpdmUgZGF0ZSBvYmplY3RcbiAgICBmdW5jdGlvbiBmb3JtYXRNb21lbnQobSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICghbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbS5sb2NhbGVEYXRhKCkpO1xuXG4gICAgICAgIGlmICghZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0pIHtcbiAgICAgICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0obSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwYW5kRm9ybWF0KGZvcm1hdCwgbG9jYWxlKSB7XG4gICAgICAgIHZhciBpID0gNTtcblxuICAgICAgICBmdW5jdGlvbiByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubG9uZ0RhdGVGb3JtYXQoaW5wdXQpIHx8IGlucHV0O1xuICAgICAgICB9XG5cbiAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIHdoaWxlIChpID49IDAgJiYgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLnRlc3QoZm9ybWF0KSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZm9ybWF0LnJlcGxhY2UobG9jYWxGb3JtYXR0aW5nVG9rZW5zLCByZXBsYWNlTG9uZ0RhdGVGb3JtYXRUb2tlbnMpO1xuICAgICAgICAgICAgbG9jYWxGb3JtYXR0aW5nVG9rZW5zLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpIC09IDE7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0O1xuICAgIH1cblxuICAgIHZhciBtYXRjaDEgICAgICAgICA9IC9cXGQvOyAgICAgICAgICAgIC8vICAgICAgIDAgLSA5XG4gICAgdmFyIG1hdGNoMiAgICAgICAgID0gL1xcZFxcZC87ICAgICAgICAgIC8vICAgICAgMDAgLSA5OVxuICAgIHZhciBtYXRjaDMgICAgICAgICA9IC9cXGR7M30vOyAgICAgICAgIC8vICAgICAwMDAgLSA5OTlcbiAgICB2YXIgbWF0Y2g0ICAgICAgICAgPSAvXFxkezR9LzsgICAgICAgICAvLyAgICAwMDAwIC0gOTk5OVxuICAgIHZhciBtYXRjaDYgICAgICAgICA9IC9bKy1dP1xcZHs2fS87ICAgIC8vIC05OTk5OTkgLSA5OTk5OTlcbiAgICB2YXIgbWF0Y2gxdG8yICAgICAgPSAvXFxkXFxkPy87ICAgICAgICAgLy8gICAgICAgMCAtIDk5XG4gICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG5cbiAgICB2YXIgbWF0Y2hUaW1lc3RhbXAgPSAvWystXT9cXGQrKFxcLlxcZHsxLDN9KT8vOyAvLyAxMjM0NTY3ODkgMTIzNDU2Nzg5LjEyM1xuXG4gICAgLy8gYW55IHdvcmQgKG9yIHR3bykgY2hhcmFjdGVycyBvciBudW1iZXJzIGluY2x1ZGluZyB0d28vdGhyZWUgd29yZCBtb250aCBpbiBhcmFiaWMuXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XSpbJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0rfFtcXHUwNjAwLVxcdTA2RkZcXC9dKyhcXHMqP1tcXHUwNjAwLVxcdTA2RkZdKyl7MSwyfS9pO1xuXG4gICAgdmFyIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSB0eXBlb2YgcmVnZXggPT09ICdmdW5jdGlvbicgPyByZWdleCA6IGZ1bmN0aW9uIChpc1N0cmljdCkge1xuICAgICAgICAgICAgcmV0dXJuIChpc1N0cmljdCAmJiBzdHJpY3RSZWdleCkgPyBzdHJpY3RSZWdleCA6IHJlZ2V4O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFBhcnNlUmVnZXhGb3JUb2tlbiAodG9rZW4sIGNvbmZpZykge1xuICAgICAgICBpZiAoIWhhc093blByb3AocmVnZXhlcywgdG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh1bmVzY2FwZUZvcm1hdCh0b2tlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlZ2V4ZXNbdG9rZW5dKGNvbmZpZy5fc3RyaWN0LCBjb25maWcuX2xvY2FsZSk7XG4gICAgfVxuXG4gICAgLy8gQ29kZSBmcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzU2MTQ5My9pcy10aGVyZS1hLXJlZ2V4cC1lc2NhcGUtZnVuY3Rpb24taW4tamF2YXNjcmlwdFxuICAgIGZ1bmN0aW9uIHVuZXNjYXBlRm9ybWF0KHMpIHtcbiAgICAgICAgcmV0dXJuIHMucmVwbGFjZSgnXFxcXCcsICcnKS5yZXBsYWNlKC9cXFxcKFxcWyl8XFxcXChcXF0pfFxcWyhbXlxcXVxcW10qKVxcXXxcXFxcKC4pL2csIGZ1bmN0aW9uIChtYXRjaGVkLCBwMSwgcDIsIHAzLCBwNCkge1xuICAgICAgICAgICAgcmV0dXJuIHAxIHx8IHAyIHx8IHAzIHx8IHA0O1xuICAgICAgICB9KS5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbiAgICB9XG5cbiAgICB2YXIgdG9rZW5zID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRQYXJzZVRva2VuICh0b2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGksIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRva2VuID0gW3Rva2VuXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZnVuYyA9IGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgICAgICAgICBhcnJheVtjYWxsYmFja10gPSB0b0ludChpbnB1dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuW2ldXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrUGFyc2VUb2tlbiAodG9rZW4sIGNhbGxiYWNrKSB7XG4gICAgICAgIGFkZFBhcnNlVG9rZW4odG9rZW4sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgICAgIGNvbmZpZy5fdyA9IGNvbmZpZy5fdyB8fCB7fTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGlucHV0LCBjb25maWcuX3csIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUaW1lVG9BcnJheUZyb21Ub2tlbih0b2tlbiwgaW5wdXQsIGNvbmZpZykge1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCAmJiBoYXNPd25Qcm9wKHRva2VucywgdG9rZW4pKSB7XG4gICAgICAgICAgICB0b2tlbnNbdG9rZW5dKGlucHV0LCBjb25maWcuX2EsIGNvbmZpZywgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFlFQVIgPSAwO1xuICAgIHZhciBNT05USCA9IDE7XG4gICAgdmFyIERBVEUgPSAyO1xuICAgIHZhciBIT1VSID0gMztcbiAgICB2YXIgTUlOVVRFID0gNDtcbiAgICB2YXIgU0VDT05EID0gNTtcbiAgICB2YXIgTUlMTElTRUNPTkQgPSA2O1xuXG4gICAgZnVuY3Rpb24gZGF5c0luTW9udGgoeWVhciwgbW9udGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoICsgMSwgMCkpLmdldFVUQ0RhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignTScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU0nLCAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU0nLCAgbWF0Y2hXb3JkKTtcbiAgICBhZGRSZWdleFRva2VuKCdNTU1NJywgbWF0Y2hXb3JkKTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNJywgJ01NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbTU9OVEhdID0gdG9JbnQoaW5wdXQpIC0gMTtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydNTU0nLCAnTU1NTSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciBtb250aCA9IGNvbmZpZy5fbG9jYWxlLm1vbnRoc1BhcnNlKGlucHV0LCB0b2tlbiwgY29uZmlnLl9zdHJpY3QpO1xuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1vbnRoIG5hbWUsIG1hcmsgdGhlIGRhdGUgYXMgaW52YWxpZC5cbiAgICAgICAgaWYgKG1vbnRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGFycmF5W01PTlRIXSA9IG1vbnRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9wZi5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1ttLm1vbnRoKCldO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQgPSAnSmFuX0ZlYl9NYXJfQXByX01heV9KdW5fSnVsX0F1Z19TZXBfT2N0X05vdl9EZWMnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0W20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlTW9udGhzUGFyc2UgKG1vbnRoTmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9tb250aHNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBpZiAoc3RyaWN0ICYmICF0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgIXRoaXMuX21vbnRoc1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVnZXggPSAnXicgKyB0aGlzLm1vbnRocyhtb20sICcnKSArICd8XicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NTScgJiYgdGhpcy5fbG9uZ01vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnTU1NJyAmJiB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX21vbnRoc1BhcnNlW2ldLnRlc3QobW9udGhOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gc2V0TW9udGggKG1vbSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRheU9mTW9udGg7XG5cbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIG91dCBvZiBoZXJlIVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBtb20ubG9jYWxlRGF0YSgpLm1vbnRoc1BhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRfc2V0X19nZXQodGhpcywgJ01vbnRoJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXREYXlzSW5Nb250aCAoKSB7XG4gICAgICAgIHJldHVybiBkYXlzSW5Nb250aCh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIG0uX3BmLm92ZXJmbG93ID09PSAtMikge1xuICAgICAgICAgICAgb3ZlcmZsb3cgPVxuICAgICAgICAgICAgICAgIGFbTU9OVEhdICAgICAgIDwgMCB8fCBhW01PTlRIXSAgICAgICA+IDExICA/IE1PTlRIIDpcbiAgICAgICAgICAgICAgICBhW0RBVEVdICAgICAgICA8IDEgfHwgYVtEQVRFXSAgICAgICAgPiBkYXlzSW5Nb250aChhW1lFQVJdLCBhW01PTlRIXSkgPyBEQVRFIDpcbiAgICAgICAgICAgICAgICBhW0hPVVJdICAgICAgICA8IDAgfHwgYVtIT1VSXSAgICAgICAgPiAyNCB8fCAoYVtIT1VSXSA9PT0gMjQgJiYgKGFbTUlOVVRFXSAhPT0gMCB8fCBhW1NFQ09ORF0gIT09IDAgfHwgYVtNSUxMSVNFQ09ORF0gIT09IDApKSA/IEhPVVIgOlxuICAgICAgICAgICAgICAgIGFbTUlOVVRFXSAgICAgIDwgMCB8fCBhW01JTlVURV0gICAgICA+IDU5ICA/IE1JTlVURSA6XG4gICAgICAgICAgICAgICAgYVtTRUNPTkRdICAgICAgPCAwIHx8IGFbU0VDT05EXSAgICAgID4gNTkgID8gU0VDT05EIDpcbiAgICAgICAgICAgICAgICBhW01JTExJU0VDT05EXSA8IDAgfHwgYVtNSUxMSVNFQ09ORF0gPiA5OTkgPyBNSUxMSVNFQ09ORCA6XG4gICAgICAgICAgICAgICAgLTE7XG5cbiAgICAgICAgICAgIGlmIChtLl9wZi5fb3ZlcmZsb3dEYXlPZlllYXIgJiYgKG92ZXJmbG93IDwgWUVBUiB8fCBvdmVyZmxvdyA+IERBVEUpKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3cgPSBEQVRFO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtLl9wZi5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgICAgICAgaWYgKHV0aWxzX2hvb2tzX19ob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGVwcmVjYXRpb24gd2FybmluZzogJyArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGUobXNnLCBmbikge1xuICAgICAgICB2YXIgZmlyc3RUaW1lID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgd2Fybihtc2cpO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmICghZGVwcmVjYXRpb25zW25hbWVdKSB7XG4gICAgICAgICAgICB3YXJuKG1zZyk7XG4gICAgICAgICAgICBkZXByZWNhdGlvbnNbbmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnN1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5ncyA9IGZhbHNlO1xuXG4gICAgdmFyIGZyb21fc3RyaW5nX19pc29SZWdleCA9IC9eXFxzKig/OlsrLV1cXGR7Nn18XFxkezR9KS0oPzooXFxkXFxkLVxcZFxcZCl8KFdcXGRcXGQkKXwoV1xcZFxcZC1cXGQpfChcXGRcXGRcXGQpKSgoVHwgKShcXGRcXGQoOlxcZFxcZCg6XFxkXFxkKFxcLlxcZCspPyk/KT8pPyhbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG5cbiAgICB2YXIgaXNvRGF0ZXMgPSBbXG4gICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkezJ9LVxcZHsyfS9dLFxuICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZHsyfS1cXGR7Mn0vXSxcbiAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGR7Mn0tXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZHsyfS9dLFxuICAgICAgICBbJ1lZWVktREREJywgL1xcZHs0fS1cXGR7M30vXVxuICAgIF07XG5cbiAgICAvLyBpc28gdGltZSBmb3JtYXRzIGFuZCByZWdleGVzXG4gICAgdmFyIGlzb1RpbWVzID0gW1xuICAgICAgICBbJ0hIOm1tOnNzLlNTU1MnLCAvKFR8IClcXGRcXGQ6XFxkXFxkOlxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISDptbTpzcycsIC8oVHwgKVxcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEg6bW0nLCAvKFR8IClcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEgnLCAvKFR8IClcXGRcXGQvXVxuICAgIF07XG5cbiAgICB2YXIgYXNwTmV0SnNvblJlZ2V4ID0gL15cXC8/RGF0ZVxcKChcXC0/XFxkKykvaTtcblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUlTTyhjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGwsXG4gICAgICAgICAgICBzdHJpbmcgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBtYXRjaCA9IGZyb21fc3RyaW5nX19pc29SZWdleC5leGVjKHN0cmluZyk7XG5cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25maWcuX3BmLmlzbyA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvRGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb0RhdGVzW2ldWzFdLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFs1XSBzaG91bGQgYmUgJ1QnIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2YgPSBpc29EYXRlc1tpXVswXSArIChtYXRjaFs2XSB8fCAnICcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gaXNvVGltZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2YgKz0gaXNvVGltZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHJpbmcubWF0Y2gobWF0Y2hPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9mICs9ICdaJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXQgb3IgZmFsbGJhY2tcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tU3RyaW5nKGNvbmZpZykge1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IGFzcE5ldEpzb25SZWdleC5leGVjKGNvbmZpZy5faSk7XG5cbiAgICAgICAgaWYgKG1hdGNoZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCttYXRjaGVkWzFdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbmZpZ0Zyb21JU08oY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgICAgICB1dGlsc19ob29rc19faG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCBjb25zdHJ1Y3Rpb24gZmFsbHMgYmFjayB0byBqcyBEYXRlLiBUaGlzIGlzICcgK1xuICAgICAgICAnZGlzY291cmFnZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB1cGNvbWluZyBtYWpvciAnICtcbiAgICAgICAgJ3JlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNDA3IGZvciBtb3JlIGluZm8uJyxcbiAgICAgICAgZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoY29uZmlnLl9pICsgKGNvbmZpZy5fdXNlVVRDID8gJyBVVEMnIDogJycpKTtcbiAgICAgICAgfVxuICAgICk7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvL2Nhbid0IGp1c3QgYXBwbHkoKSB0byBjcmVhdGUgYSBkYXRlOlxuICAgICAgICAvL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTgxMzQ4L2luc3RhbnRpYXRpbmctYS1qYXZhc2NyaXB0LW9iamVjdC1ieS1jYWxsaW5nLXByb3RvdHlwZS1jb25zdHJ1Y3Rvci1hcHBseVxuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKHksIG0sIGQsIGgsIE0sIHMsIG1zKTtcblxuICAgICAgICAvL3RoZSBkYXRlIGNvbnN0cnVjdG9yIGRvZXNuJ3QgYWNjZXB0IHllYXJzIDwgMTk3MFxuICAgICAgICBpZiAoeSA8IDE5NzApIHtcbiAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgICAgICB2YXIgZGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xuICAgICAgICBpZiAoeSA8IDE5NzApIHtcbiAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1knLCAgICAgIG1hdGNoU2lnbmVkKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWScsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWScsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZJywgIG1hdGNoMXRvNiwgbWF0Y2g2KTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZWVknLCBtYXRjaDF0bzYsIG1hdGNoNik7XG5cbiAgICBhZGRQYXJzZVRva2VuKFsnWVlZWScsICdZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICB1dGlsc19ob29rc19faG9va3MucGFyc2VUd29EaWdpdFllYXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHRvSW50KGlucHV0KSArICh0b0ludChpbnB1dCkgPiA2OCA/IDE5MDAgOiAyMDAwKTtcbiAgICB9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFllYXIgPSBtYWtlR2V0U2V0KCdGdWxsWWVhcicsIGZhbHNlKTtcblxuICAgIGZ1bmN0aW9uIGdldElzTGVhcFllYXIgKCkge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih0aGlzLnllYXIoKSk7XG4gICAgfVxuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3cnLCBbJ3d3JywgMl0sICd3bycsICd3ZWVrJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oJ1cnLCBbJ1dXJywgMl0sICdXbycsICdpc29XZWVrJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ3dlZWsnLCAndycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2VlaycsICdXJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIGZpcnN0RGF5T2ZXZWVrICAgICAgIDAgPSBzdW4sIDYgPSBzYXRcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICB0aGUgZGF5IG9mIHRoZSB3ZWVrIHRoYXQgc3RhcnRzIHRoZSB3ZWVrXG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgKHVzdWFsbHkgc3VuZGF5IG9yIG1vbmRheSlcbiAgICAvLyBmaXJzdERheU9mV2Vla09mWWVhciAwID0gc3VuLCA2ID0gc2F0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAgdGhlIGZpcnN0IHdlZWsgaXMgdGhlIHdlZWsgdGhhdCBjb250YWlucyB0aGUgZmlyc3RcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICBvZiB0aGlzIGRheSBvZiB0aGUgd2Vla1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIChlZy4gSVNPIHdlZWtzIHVzZSB0aHVyc2RheSAoNCkpXG4gICAgZnVuY3Rpb24gd2Vla09mWWVhcihtb20sIGZpcnN0RGF5T2ZXZWVrLCBmaXJzdERheU9mV2Vla09mWWVhcikge1xuICAgICAgICB2YXIgZW5kID0gZmlyc3REYXlPZldlZWtPZlllYXIgLSBmaXJzdERheU9mV2VlayxcbiAgICAgICAgICAgIGRheXNUb0RheU9mV2VlayA9IGZpcnN0RGF5T2ZXZWVrT2ZZZWFyIC0gbW9tLmRheSgpLFxuICAgICAgICAgICAgYWRqdXN0ZWRNb21lbnQ7XG5cblxuICAgICAgICBpZiAoZGF5c1RvRGF5T2ZXZWVrID4gZW5kKSB7XG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgLT0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXlzVG9EYXlPZldlZWsgPCBlbmQgLSA3KSB7XG4gICAgICAgICAgICBkYXlzVG9EYXlPZldlZWsgKz0gNztcbiAgICAgICAgfVxuXG4gICAgICAgIGFkanVzdGVkTW9tZW50ID0gbG9jYWxfX2NyZWF0ZUxvY2FsKG1vbSkuYWRkKGRheXNUb0RheU9mV2VlaywgJ2QnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdlZWs6IE1hdGguY2VpbChhZGp1c3RlZE1vbWVudC5kYXlPZlllYXIoKSAvIDcpLFxuICAgICAgICAgICAgeWVhcjogYWRqdXN0ZWRNb21lbnQueWVhcigpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2VlayAobW9tKSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKG1vbSwgdGhpcy5fd2Vlay5kb3csIHRoaXMuX3dlZWsuZG95KS53ZWVrO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2VlayA9IHtcbiAgICAgICAgZG93IDogMCwgLy8gU3VuZGF5IGlzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICAgIGRveSA6IDYgIC8vIFRoZSB3ZWVrIHRoYXQgY29udGFpbnMgSmFuIDFzdCBpcyB0aGUgZmlyc3Qgd2VlayBvZiB0aGUgeWVhci5cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZldlZWsgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3c7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlRmlyc3REYXlPZlllYXIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vlay5kb3k7XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB0aGlzLmxvY2FsZURhdGEoKS53ZWVrKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2VlayAoaW5wdXQpIHtcbiAgICAgICAgdmFyIHdlZWsgPSB3ZWVrT2ZZZWFyKHRoaXMsIDEsIDQpLndlZWs7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gd2VlayA6IHRoaXMuYWRkKChpbnB1dCAtIHdlZWspICogNywgJ2QnKTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGZpcnN0RGF5T2ZXZWVrT2ZZZWFyLCBmaXJzdERheU9mV2Vlaykge1xuICAgICAgICB2YXIgZCA9IGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgMSkuZ2V0VVRDRGF5KCk7XG4gICAgICAgIHZhciBkYXlzVG9BZGQ7XG4gICAgICAgIHZhciBkYXlPZlllYXI7XG5cbiAgICAgICAgZCA9IGQgPT09IDAgPyA3IDogZDtcbiAgICAgICAgd2Vla2RheSA9IHdlZWtkYXkgIT0gbnVsbCA/IHdlZWtkYXkgOiBmaXJzdERheU9mV2VlaztcbiAgICAgICAgZGF5c1RvQWRkID0gZmlyc3REYXlPZldlZWsgLSBkICsgKGQgPiBmaXJzdERheU9mV2Vla09mWWVhciA/IDcgOiAwKSAtIChkIDwgZmlyc3REYXlPZldlZWsgPyA3IDogMCk7XG4gICAgICAgIGRheU9mWWVhciA9IDcgKiAod2VlayAtIDEpICsgKHdlZWtkYXkgLSBmaXJzdERheU9mV2VlaykgKyBkYXlzVG9BZGQgKyAxO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyICAgICAgOiBkYXlPZlllYXIgPiAwID8geWVhciAgICAgIDogeWVhciAtIDEsXG4gICAgICAgICAgICBkYXlPZlllYXIgOiBkYXlPZlllYXIgPiAwID8gZGF5T2ZZZWFyIDogZGF5c0luWWVhcih5ZWFyIC0gMSkgKyBkYXlPZlllYXJcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXREYXlPZlllYXIgKGlucHV0KSB7XG4gICAgICAgIHZhciBkYXlPZlllYXIgPSBNYXRoLnJvdW5kKCh0aGlzLmNsb25lKCkuc3RhcnRPZignZGF5JykgLSB0aGlzLmNsb25lKCkuc3RhcnRPZigneWVhcicpKSAvIDg2NGU1KSArIDE7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8gZGF5T2ZZZWFyIDogdGhpcy5hZGQoKGlucHV0IC0gZGF5T2ZZZWFyKSwgJ2QnKTtcbiAgICB9XG5cbiAgICAvLyBQaWNrIHRoZSBmaXJzdCBkZWZpbmVkIG9mIHR3byBvciB0aHJlZSBhcmd1bWVudHMuXG4gICAgZnVuY3Rpb24gZGVmYXVsdHMoYSwgYiwgYykge1xuICAgICAgICBpZiAoYSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgbm93ID0gbmV3IERhdGUoKTtcbiAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDKSB7XG4gICAgICAgICAgICByZXR1cm4gW25vdy5nZXRVVENGdWxsWWVhcigpLCBub3cuZ2V0VVRDTW9udGgoKSwgbm93LmdldFVUQ0RhdGUoKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtub3cuZ2V0RnVsbFllYXIoKSwgbm93LmdldE1vbnRoKCksIG5vdy5nZXREYXRlKCldO1xuICAgIH1cblxuICAgIC8vIGNvbnZlcnQgYW4gYXJyYXkgdG8gYSBkYXRlLlxuICAgIC8vIHRoZSBhcnJheSBzaG91bGQgbWlycm9yIHRoZSBwYXJhbWV0ZXJzIGJlbG93XG4gICAgLy8gbm90ZTogYWxsIHZhbHVlcyBwYXN0IHRoZSB5ZWFyIGFyZSBvcHRpb25hbCBhbmQgd2lsbCBkZWZhdWx0IHRvIHRoZSBsb3dlc3QgcG9zc2libGUgdmFsdWUuXG4gICAgLy8gW3llYXIsIG1vbnRoLCBkYXkgLCBob3VyLCBtaW51dGUsIHNlY29uZCwgbWlsbGlzZWNvbmRdXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbUFycmF5IChjb25maWcpIHtcbiAgICAgICAgdmFyIGksIGRhdGUsIGlucHV0ID0gW10sIGN1cnJlbnREYXRlLCB5ZWFyVG9Vc2U7XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudERhdGUgPSBjdXJyZW50RGF0ZUFycmF5KGNvbmZpZyk7XG5cbiAgICAgICAgLy9jb21wdXRlIGRheSBvZiB0aGUgeWVhciBmcm9tIHdlZWtzIGFuZCB3ZWVrZGF5c1xuICAgICAgICBpZiAoY29uZmlnLl93ICYmIGNvbmZpZy5fYVtEQVRFXSA9PSBudWxsICYmIGNvbmZpZy5fYVtNT05USF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2lmIHRoZSBkYXkgb2YgdGhlIHllYXIgaXMgc2V0LCBmaWd1cmUgb3V0IHdoYXQgaXQgaXNcbiAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi5fb3ZlcmZsb3dEYXlPZlllYXIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRlID0gY3JlYXRlVVRDRGF0ZSh5ZWFyVG9Vc2UsIDAsIGNvbmZpZy5fZGF5T2ZZZWFyKTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtNT05USF0gPSBkYXRlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICBjb25maWcuX2FbREFURV0gPSBkYXRlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCBkYXRlLlxuICAgICAgICAvLyAqIGlmIG5vIHllYXIsIG1vbnRoLCBkYXkgb2YgbW9udGggYXJlIGdpdmVuLCBkZWZhdWx0IHRvIHRvZGF5XG4gICAgICAgIC8vICogaWYgZGF5IG9mIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG1vbnRoIGFuZCB5ZWFyXG4gICAgICAgIC8vICogaWYgbW9udGggaXMgZ2l2ZW4sIGRlZmF1bHQgb25seSB5ZWFyXG4gICAgICAgIC8vICogaWYgeWVhciBpcyBnaXZlbiwgZG9uJ3QgZGVmYXVsdCBhbnl0aGluZ1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMyAmJiBjb25maWcuX2FbaV0gPT0gbnVsbDsgKytpKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IGN1cnJlbnREYXRlW2ldO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWmVybyBvdXQgd2hhdGV2ZXIgd2FzIG5vdCBkZWZhdWx0ZWQsIGluY2x1ZGluZyB0aW1lXG4gICAgICAgIGZvciAoOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBjb25maWcuX2FbaV0gPSBpbnB1dFtpXSA9IChjb25maWcuX2FbaV0gPT0gbnVsbCkgPyAoaSA9PT0gMiA/IDEgOiAwKSA6IGNvbmZpZy5fYVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGZvciAyNDowMDowMC4wMDBcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA9PT0gMjQgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbTUlOVVRFXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtTRUNPTkRdID09PSAwICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTExJU0VDT05EXSA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9uZXh0RGF5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWcuX2QgPSAoY29uZmlnLl91c2VVVEMgPyBjcmVhdGVVVENEYXRlIDogY3JlYXRlRGF0ZSkuYXBwbHkobnVsbCwgaW5wdXQpO1xuICAgICAgICAvLyBBcHBseSB0aW1lem9uZSBvZmZzZXQgZnJvbSBpbnB1dC4gVGhlIGFjdHVhbCB1dGNPZmZzZXQgY2FuIGJlIGNoYW5nZWRcbiAgICAgICAgLy8gd2l0aCBwYXJzZVpvbmUuXG4gICAgICAgIGlmIChjb25maWcuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2Quc2V0VVRDTWludXRlcyhjb25maWcuX2QuZ2V0VVRDTWludXRlcygpIC0gY29uZmlnLl90em0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5fbmV4dERheSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gMjQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkYXlPZlllYXJGcm9tV2Vla0luZm8oY29uZmlnKSB7XG4gICAgICAgIHZhciB3LCB3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3ksIHRlbXA7XG5cbiAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZG93ID0gMTtcbiAgICAgICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKCksIDEsIDQpLnllYXIpO1xuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcuVywgMSk7XG4gICAgICAgICAgICB3ZWVrZGF5ID0gZGVmYXVsdHMody5FLCAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIobG9jYWxfX2NyZWF0ZUxvY2FsKCksIGRvdywgZG95KS55ZWFyKTtcbiAgICAgICAgICAgIHdlZWsgPSBkZWZhdWx0cyh3LncsIDEpO1xuXG4gICAgICAgICAgICBpZiAody5kICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZWVrZGF5IC0tIGxvdyBkYXkgbnVtYmVycyBhcmUgY29uc2lkZXJlZCBuZXh0IHdlZWtcbiAgICAgICAgICAgICAgICB3ZWVrZGF5ID0gdy5kO1xuICAgICAgICAgICAgICAgIGlmICh3ZWVrZGF5IDwgZG93KSB7XG4gICAgICAgICAgICAgICAgICAgICsrd2VlaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZSArIGRvdztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbmluZyBvZiB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IGRvdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZW1wID0gZGF5T2ZZZWFyRnJvbVdlZWtzKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3ksIGRvdyk7XG5cbiAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICBjb25maWcuX2RheU9mWWVhciA9IHRlbXAuZGF5T2ZZZWFyO1xuICAgIH1cblxuICAgIHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IHV0aWxzX2hvb2tzX19ob29rcy5JU09fODYwMSkge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlTTyhjb25maWcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGNvbmZpZy5fcGYuZW1wdHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIFRoaXMgYXJyYXkgaXMgdXNlZCB0byBtYWtlIGEgRGF0ZSwgZWl0aGVyIHdpdGggYG5ldyBEYXRlYCBvciBgRGF0ZS5VVENgXG4gICAgICAgIHZhciBzdHJpbmcgPSAnJyArIGNvbmZpZy5faSxcbiAgICAgICAgICAgIGksIHBhcnNlZElucHV0LCB0b2tlbnMsIHRva2VuLCBza2lwcGVkLFxuICAgICAgICAgICAgc3RyaW5nTGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggPSAwO1xuXG4gICAgICAgIHRva2VucyA9IGV4cGFuZEZvcm1hdChjb25maWcuX2YsIGNvbmZpZy5fbG9jYWxlKS5tYXRjaChmb3JtYXR0aW5nVG9rZW5zKSB8fCBbXTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgIHBhcnNlZElucHV0ID0gKHN0cmluZy5tYXRjaChnZXRQYXJzZVJlZ2V4Rm9yVG9rZW4odG9rZW4sIGNvbmZpZykpIHx8IFtdKVswXTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIHNraXBwZWQgPSBzdHJpbmcuc3Vic3RyKDAsIHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSk7XG4gICAgICAgICAgICAgICAgaWYgKHNraXBwZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZElucHV0LnB1c2goc2tpcHBlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZShzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkgKyBwYXJzZWRJbnB1dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGggKz0gcGFyc2VkSW5wdXQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG9uJ3QgcGFyc2UgaWYgaXQncyBub3QgYSBrbm93biB0b2tlblxuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW3Rva2VuXSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX3BmLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIHBhcnNlZElucHV0LCBjb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnLl9zdHJpY3QgJiYgIXBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLl9wZi51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgcmVtYWluaW5nIHVucGFyc2VkIGlucHV0IGxlbmd0aCB0byB0aGUgc3RyaW5nXG4gICAgICAgIGNvbmZpZy5fcGYuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9wZi51bnVzZWRJbnB1dC5wdXNoKHN0cmluZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjbGVhciBfMTJoIGZsYWcgaWYgaG91ciBpcyA8PSAxMlxuICAgICAgICBpZiAoY29uZmlnLl9wZi5iaWdIb3VyID09PSB0cnVlICYmIGNvbmZpZy5fYVtIT1VSXSA8PSAxMikge1xuICAgICAgICAgICAgY29uZmlnLl9wZi5iaWdIb3VyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBtZXJpZGllbVxuICAgICAgICBjb25maWcuX2FbSE9VUl0gPSBtZXJpZGllbUZpeFdyYXAoY29uZmlnLl9sb2NhbGUsIGNvbmZpZy5fYVtIT1VSXSwgY29uZmlnLl9tZXJpZGllbSk7XG5cbiAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIGNoZWNrT3ZlcmZsb3coY29uZmlnKTtcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtRml4V3JhcCAobG9jYWxlLCBob3VyLCBtZXJpZGllbSkge1xuICAgICAgICB2YXIgaXNQbTtcblxuICAgICAgICBpZiAobWVyaWRpZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkb1xuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsZS5tZXJpZGllbUhvdXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsZS5tZXJpZGllbUhvdXIoaG91ciwgbWVyaWRpZW0pO1xuICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZS5pc1BNICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrXG4gICAgICAgICAgICBpc1BtID0gbG9jYWxlLmlzUE0obWVyaWRpZW0pO1xuICAgICAgICAgICAgaWYgKGlzUG0gJiYgaG91ciA8IDEyKSB7XG4gICAgICAgICAgICAgICAgaG91ciArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQbSAmJiBob3VyID09PSAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhvdXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIG5vdCBzdXBwb3NlZCB0byBoYXBwZW5cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uZmlnLl9wZi5pbnZhbGlkRm9ybWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKE5hTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29uZmlnLl9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgPSAwO1xuICAgICAgICAgICAgdGVtcENvbmZpZyA9IGNvcHlDb25maWcoe30sIGNvbmZpZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbXBDb25maWcuX3VzZVVUQyA9IGNvbmZpZy5fdXNlVVRDO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcENvbmZpZy5fcGYgPSBkZWZhdWx0UGFyc2luZ0ZsYWdzKCk7XG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9mID0gY29uZmlnLl9mW2ldO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdCh0ZW1wQ29uZmlnKTtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZF9faXNWYWxpZCh0ZW1wQ29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbnkgaW5wdXQgdGhhdCB3YXMgbm90IHBhcnNlZCBhZGQgYSBwZW5hbHR5IGZvciB0aGF0IGZvcm1hdFxuICAgICAgICAgICAgY3VycmVudFNjb3JlICs9IHRlbXBDb25maWcuX3BmLmNoYXJzTGVmdE92ZXI7XG5cbiAgICAgICAgICAgIC8vb3IgdG9rZW5zXG4gICAgICAgICAgICBjdXJyZW50U2NvcmUgKz0gdGVtcENvbmZpZy5fcGYudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICB0ZW1wQ29uZmlnLl9wZi5zY29yZSA9IGN1cnJlbnRTY29yZTtcblxuICAgICAgICAgICAgaWYgKHNjb3JlVG9CZWF0ID09IG51bGwgfHwgY3VycmVudFNjb3JlIDwgc2NvcmVUb0JlYXQpIHtcbiAgICAgICAgICAgICAgICBzY29yZVRvQmVhdCA9IGN1cnJlbnRTY29yZTtcbiAgICAgICAgICAgICAgICBiZXN0TW9tZW50ID0gdGVtcENvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGV4dGVuZChjb25maWcsIGJlc3RNb21lbnQgfHwgdGVtcENvbmZpZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbU9iamVjdChjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZy5fZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSBub3JtYWxpemVPYmplY3RVbml0cyhjb25maWcuX2kpO1xuICAgICAgICBjb25maWcuX2EgPSBbaS55ZWFyLCBpLm1vbnRoLCBpLmRheSB8fCBpLmRhdGUsIGkuaG91ciwgaS5taW51dGUsIGkuc2Vjb25kLCBpLm1pbGxpc2Vjb25kXTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pLFxuICAgICAgICAgICAgZm9ybWF0ID0gY29uZmlnLl9mLFxuICAgICAgICAgICAgcmVzO1xuXG4gICAgICAgIGNvbmZpZy5fbG9jYWxlID0gY29uZmlnLl9sb2NhbGUgfHwgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShjb25maWcuX2wpO1xuXG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCB8fCAoZm9ybWF0ID09PSB1bmRlZmluZWQgJiYgaW5wdXQgPT09ICcnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkX19jcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnRnJvbUlucHV0KGNvbmZpZyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXMgPSBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coY29uZmlnKSk7XG4gICAgICAgIGlmIChyZXMuX25leHREYXkpIHtcbiAgICAgICAgICAgIC8vIEFkZGluZyBpcyBzbWFydCBlbm91Z2ggYXJvdW5kIERTVFxuICAgICAgICAgICAgcmVzLmFkZCgxLCAnZCcpO1xuICAgICAgICAgICAgcmVzLl9uZXh0RGF5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSW5wdXQoY29uZmlnKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IGNvbmZpZy5faTtcbiAgICAgICAgaWYgKGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoK2lucHV0KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGlucHV0KSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YoaW5wdXQpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgLy8gZnJvbSBtaWxsaXNlY29uZHNcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKGlucHV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayhjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlTG9jYWxPclVUQyAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGlzVVRDKSB7XG4gICAgICAgIHZhciBjID0ge307XG5cbiAgICAgICAgaWYgKHR5cGVvZihsb2NhbGUpID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIHN0cmljdCA9IGxvY2FsZTtcbiAgICAgICAgICAgIGxvY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvYmplY3QgY29uc3RydWN0aW9uIG11c3QgYmUgZG9uZSB0aGlzIHdheS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE0MjNcbiAgICAgICAgYy5faXNBTW9tZW50T2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgYy5fdXNlVVRDID0gYy5faXNVVEMgPSBpc1VUQztcbiAgICAgICAgYy5fbCA9IGxvY2FsZTtcbiAgICAgICAgYy5faSA9IGlucHV0O1xuICAgICAgICBjLl9mID0gZm9ybWF0O1xuICAgICAgICBjLl9zdHJpY3QgPSBzdHJpY3Q7XG4gICAgICAgIGMuX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVGcm9tQ29uZmlnKGMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsX19jcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAgJ21vbWVudCgpLm1pbiBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTU0OCcsXG4gICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgdmFyIG90aGVyID0gbG9jYWxfX2NyZWF0ZUxvY2FsLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgcmV0dXJuIG90aGVyIDwgdGhpcyA/IHRoaXMgOiBvdGhlcjtcbiAgICAgICAgIH1cbiAgICAgKTtcblxuICAgIHZhciBwcm90b3R5cGVNYXggPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5tYXggaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudC5tYXggaW5zdGVhZC4gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvaXNzdWVzLzE1NDgnLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBsb2NhbF9fY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBvdGhlciA+IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgLy8gUGljayBhIG1vbWVudCBtIGZyb20gbW9tZW50cyBzbyB0aGF0IG1bZm5dKG90aGVyKSBpcyB0cnVlIGZvciBhbGxcbiAgICAvLyBvdGhlci4gVGhpcyByZWxpZXMgb24gdGhlIGZ1bmN0aW9uIGZuIHRvIGJlIHRyYW5zaXRpdmUuXG4gICAgLy9cbiAgICAvLyBtb21lbnRzIHNob3VsZCBlaXRoZXIgYmUgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMgb3IgYW4gYXJyYXksIHdob3NlXG4gICAgLy8gZmlyc3QgZWxlbWVudCBpcyBhbiBhcnJheSBvZiBtb21lbnQgb2JqZWN0cy5cbiAgICBmdW5jdGlvbiBwaWNrQnkoZm4sIG1vbWVudHMpIHtcbiAgICAgICAgdmFyIHJlcywgaTtcbiAgICAgICAgaWYgKG1vbWVudHMubGVuZ3RoID09PSAxICYmIGlzQXJyYXkobW9tZW50c1swXSkpIHtcbiAgICAgICAgICAgIG1vbWVudHMgPSBtb21lbnRzWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbW9tZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbF9fY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1vbWVudHNbaV1bZm5dKHJlcykpIHtcbiAgICAgICAgICAgICAgICByZXMgPSBtb21lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIFtdLnNvcnQgaW5zdGVhZD9cbiAgICBmdW5jdGlvbiBtaW4gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0JlZm9yZScsIGFyZ3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1heCAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuXG4gICAgICAgIHJldHVybiBwaWNrQnkoJ2lzQWZ0ZXInLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgLy8gcmVwcmVzZW50YXRpb24gZm9yIGRhdGVBZGRSZW1vdmVcbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gK21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICBzZWNvbmRzICogMWUzICsgLy8gMTAwMFxuICAgICAgICAgICAgbWludXRlcyAqIDZlNCArIC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgaG91cnMgKiAzNmU1OyAvLyAxMDAwICogNjAgKiA2MFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fYnViYmxlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBEdXJhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvZmZzZXQgKHRva2VuLCBzZXBhcmF0b3IpIHtcbiAgICAgICAgYWRkRm9ybWF0VG9rZW4odG9rZW4sIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSB0aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICAgICAgdmFyIHNpZ24gPSAnKyc7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IC1vZmZzZXQ7XG4gICAgICAgICAgICAgICAgc2lnbiA9ICctJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaWduICsgemVyb0ZpbGwofn4ob2Zmc2V0IC8gNjApLCAyKSArIHNlcGFyYXRvciArIHplcm9GaWxsKH5+KG9mZnNldCkgJSA2MCwgMik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG9mZnNldCgnWicsICc6Jyk7XG4gICAgb2Zmc2V0KCdaWicsICcnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1onLCAgbWF0Y2hPZmZzZXQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1paJywgbWF0Y2hPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoKHN0cmluZyB8fCAnJykubWF0Y2gobWF0Y2hPZmZzZXQpIHx8IFtdKTtcbiAgICAgICAgdmFyIGNodW5rICAgPSBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0gfHwgW107XG4gICAgICAgIHZhciBwYXJ0cyAgID0gKGNodW5rICsgJycpLm1hdGNoKGNodW5rT2Zmc2V0KSB8fCBbJy0nLCAwLCAwXTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgPSArKHBhcnRzWzFdICogNjApICsgdG9JbnQocGFydHNbMl0pO1xuXG4gICAgICAgIHJldHVybiBwYXJ0c1swXSA9PT0gJysnID8gbWludXRlcyA6IC1taW51dGVzO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBhIG1vbWVudCBmcm9tIGlucHV0LCB0aGF0IGlzIGxvY2FsL3V0Yy96b25lIGVxdWl2YWxlbnQgdG8gbW9kZWwuXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoT2Zmc2V0KGlucHV0LCBtb2RlbCkge1xuICAgICAgICB2YXIgcmVzLCBkaWZmO1xuICAgICAgICBpZiAobW9kZWwuX2lzVVRDKSB7XG4gICAgICAgICAgICByZXMgPSBtb2RlbC5jbG9uZSgpO1xuICAgICAgICAgICAgZGlmZiA9IChpc01vbWVudChpbnB1dCkgfHwgaXNEYXRlKGlucHV0KSA/ICtpbnB1dCA6ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpKSAtICgrcmVzKTtcbiAgICAgICAgICAgIC8vIFVzZSBsb3ctbGV2ZWwgYXBpLCBiZWNhdXNlIHRoaXMgZm4gaXMgbG93LWxldmVsIGFwaS5cbiAgICAgICAgICAgIHJlcy5fZC5zZXRUaW1lKCtyZXMuX2QgKyBkaWZmKTtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQocmVzLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbW9kZWwuX2lzVVRDID8gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS56b25lKG1vZGVsLl9vZmZzZXQgfHwgMCkgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpLmxvY2FsKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RGF0ZU9mZnNldCAobSkge1xuICAgICAgICAvLyBPbiBGaXJlZm94LjI0IERhdGUjZ2V0VGltZXpvbmVPZmZzZXQgcmV0dXJucyBhIGZsb2F0aW5nIHBvaW50LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9wdWxsLzE4NzFcbiAgICAgICAgcmV0dXJuIC1NYXRoLnJvdW5kKG0uX2QuZ2V0VGltZXpvbmVPZmZzZXQoKSAvIDE1KSAqIDE1O1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIGEgbW9tZW50IGlzIG11dGF0ZWQuXG4gICAgLy8gSXQgaXMgaW50ZW5kZWQgdG8ga2VlcCB0aGUgb2Zmc2V0IGluIHN5bmMgd2l0aCB0aGUgdGltZXpvbmUuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0IHx8IDAsXG4gICAgICAgICAgICBsb2NhbEFkanVzdDtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBvZmZzZXRGcm9tU3RyaW5nKGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhpbnB1dCkgPCAxNikge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCh0aGlzLCBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKGlucHV0IC0gb2Zmc2V0LCAnbScpLCAxLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jaGFuZ2VJblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdXRpbHNfaG9va3NfX2hvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyBvZmZzZXQgOiBnZXREYXRlT2Zmc2V0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0Wm9uZSAoaW5wdXQsIGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSAtaW5wdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KGlucHV0LCBrZWVwTG9jYWxUaW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLXRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRPZmZzZXRUb1VUQyAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICByZXR1cm4gdGhpcy51dGNPZmZzZXQoMCwga2VlcExvY2FsVGltZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9Mb2NhbCAoa2VlcExvY2FsVGltZSkge1xuICAgICAgICBpZiAodGhpcy5faXNVVEMpIHtcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnRyYWN0KGdldERhdGVPZmZzZXQodGhpcyksICdtJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9QYXJzZWRPZmZzZXQgKCkge1xuICAgICAgICBpZiAodGhpcy5fdHptKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0pO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzLl9pID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy51dGNPZmZzZXQob2Zmc2V0RnJvbVN0cmluZyh0aGlzLl9pKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzQWxpZ25lZEhvdXJPZmZzZXQgKGlucHV0KSB7XG4gICAgICAgIGlmICghaW5wdXQpIHtcbiAgICAgICAgICAgIGlucHV0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0ID0gbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KS51dGNPZmZzZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAodGhpcy5fYSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gdGhpcy5faXNVVEMgPyBjcmVhdGVfdXRjX19jcmVhdGVVVEModGhpcy5fYSkgOiBsb2NhbF9fY3JlYXRlTG9jYWwodGhpcy5fYSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgJiYgY29tcGFyZUFycmF5cyh0aGlzLl9hLCBvdGhlci50b0FycmF5KCkpID4gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xvY2FsICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9pc1VUQztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0YyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDA7XG4gICAgfVxuXG4gICAgdmFyIGFzcE5ldFJlZ2V4ID0gLyhcXC0pPyg/OihcXGQqKVxcLik/KFxcZCspXFw6KFxcZCspKD86XFw6KFxcZCspXFwuPyhcXGR7M30pPyk/LztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIHZhciBjcmVhdGVfX2lzb1JlZ2V4ID0gL14oLSk/UCg/Oig/OihbMC05LC5dKilZKT8oPzooWzAtOSwuXSopTSk/KD86KFswLTksLl0qKUQpPyg/OlQoPzooWzAtOSwuXSopSCk/KD86KFswLTksLl0qKU0pPyg/OihbMC05LC5dKilTKT8pP3woWzAtOSwuXSopVykkLztcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbltrZXldID0gaW5wdXQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uLm1pbGxpc2Vjb25kcyA9IGlucHV0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEhKG1hdGNoID0gYXNwTmV0UmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSAgOiAwLFxuICAgICAgICAgICAgICAgIGQgIDogdG9JbnQobWF0Y2hbREFURV0pICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgaCAgOiB0b0ludChtYXRjaFtIT1VSXSkgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIHMgIDogdG9JbnQobWF0Y2hbU0VDT05EXSkgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgbXMgOiB0b0ludChtYXRjaFtNSUxMSVNFQ09ORF0pICogc2lnblxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICghIShtYXRjaCA9IGNyZWF0ZV9faXNvUmVnZXguZXhlYyhpbnB1dCkpKSB7XG4gICAgICAgICAgICBzaWduID0gKG1hdGNoWzFdID09PSAnLScpID8gLTEgOiAxO1xuICAgICAgICAgICAgZHVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeSA6IHBhcnNlSXNvKG1hdGNoWzJdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBNIDogcGFyc2VJc28obWF0Y2hbM10sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGQgOiBwYXJzZUlzbyhtYXRjaFs0XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgaCA6IHBhcnNlSXNvKG1hdGNoWzVdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBtIDogcGFyc2VJc28obWF0Y2hbNl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIHMgOiBwYXJzZUlzbyhtYXRjaFs3XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzhdLCBzaWduKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7Ly8gY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZFxuICAgICAgICAgICAgZHVyYXRpb24gPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdvYmplY3QnICYmICgnZnJvbScgaW4gZHVyYXRpb24gfHwgJ3RvJyBpbiBkdXJhdGlvbikpIHtcbiAgICAgICAgICAgIGRpZmZSZXMgPSBtb21lbnRzRGlmZmVyZW5jZShsb2NhbF9fY3JlYXRlTG9jYWwoZHVyYXRpb24uZnJvbSksIGxvY2FsX19jcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlX19jcmVhdGVEdXJhdGlvbi5mbiA9IER1cmF0aW9uLnByb3RvdHlwZTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHttaWxsaXNlY29uZHM6IDAsIG1vbnRoczogMH07XG5cbiAgICAgICAgcmVzLm1vbnRocyA9IG90aGVyLm1vbnRoKCkgLSBiYXNlLm1vbnRoKCkgK1xuICAgICAgICAgICAgKG90aGVyLnllYXIoKSAtIGJhc2UueWVhcigpKSAqIDEyO1xuICAgICAgICBpZiAoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpLmlzQWZ0ZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAtLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gK290aGVyIC0gKyhiYXNlLmNsb25lKCkuYWRkKHJlcy5tb250aHMsICdNJykpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFkZGVyKGRpcmVjdGlvbiwgbmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHZhbCwgcGVyaW9kKSB7XG4gICAgICAgICAgICB2YXIgZHVyLCB0bXA7XG4gICAgICAgICAgICAvL2ludmVydCB0aGUgYXJndW1lbnRzLCBidXQgY29tcGxhaW4gYWJvdXQgaXRcbiAgICAgICAgICAgIGlmIChwZXJpb2QgIT09IG51bGwgJiYgIWlzTmFOKCtwZXJpb2QpKSB7XG4gICAgICAgICAgICAgICAgZGVwcmVjYXRlU2ltcGxlKG5hbWUsICdtb21lbnQoKS4nICsgbmFtZSAgKyAnKHBlcmlvZCwgbnVtYmVyKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIG1vbWVudCgpLicgKyBuYW1lICsgJyhudW1iZXIsIHBlcmlvZCkuJyk7XG4gICAgICAgICAgICAgICAgdG1wID0gdmFsOyB2YWwgPSBwZXJpb2Q7IHBlcmlvZCA9IHRtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsID0gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyArdmFsIDogdmFsO1xuICAgICAgICAgICAgZHVyID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbih2YWwsIHBlcmlvZCk7XG4gICAgICAgICAgICBhZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QgKG1vbSwgZHVyYXRpb24sIGlzQWRkaW5nLCB1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IGR1cmF0aW9uLl9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICBkYXlzID0gZHVyYXRpb24uX2RheXMsXG4gICAgICAgICAgICBtb250aHMgPSBkdXJhdGlvbi5fbW9udGhzO1xuICAgICAgICB1cGRhdGVPZmZzZXQgPSB1cGRhdGVPZmZzZXQgPT0gbnVsbCA/IHRydWUgOiB1cGRhdGVPZmZzZXQ7XG5cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUoK21vbS5fZCArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF5cykge1xuICAgICAgICAgICAgZ2V0X3NldF9fc2V0KG1vbSwgJ0RhdGUnLCBnZXRfc2V0X19nZXQobW9tLCAnRGF0ZScpICsgZGF5cyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldF9zZXRfX2dldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHV0aWxzX2hvb2tzX19ob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkX3N1YnRyYWN0X19hZGQgICAgICA9IGNyZWF0ZUFkZGVyKDEsICdhZGQnKTtcbiAgICB2YXIgYWRkX3N1YnRyYWN0X19zdWJ0cmFjdCA9IGNyZWF0ZUFkZGVyKC0xLCAnc3VidHJhY3QnKTtcblxuICAgIGZ1bmN0aW9uIG1vbWVudF9jYWxlbmRhcl9fY2FsZW5kYXIgKHRpbWUpIHtcbiAgICAgICAgLy8gV2Ugd2FudCB0byBjb21wYXJlIHRoZSBzdGFydCBvZiB0b2RheSwgdnMgdGhpcy5cbiAgICAgICAgLy8gR2V0dGluZyBzdGFydC1vZi10b2RheSBkZXBlbmRzIG9uIHdoZXRoZXIgd2UncmUgbG9jYWwvdXRjL29mZnNldCBvciBub3QuXG4gICAgICAgIHZhciBub3cgPSB0aW1lIHx8IGxvY2FsX19jcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmKHNvZCwgJ2RheXMnLCB0cnVlKSxcbiAgICAgICAgICAgIGZvcm1hdCA9IGRpZmYgPCAtNiA/ICdzYW1lRWxzZScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAtMSA/ICdsYXN0V2VlaycgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAwID8gJ2xhc3REYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMSA/ICdzYW1lRGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDIgPyAnbmV4dERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCA3ID8gJ25leHRXZWVrJyA6ICdzYW1lRWxzZSc7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCh0aGlzLmxvY2FsZURhdGEoKS5jYWxlbmRhcihmb3JtYXQsIHRoaXMsIGxvY2FsX19jcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGlucHV0TXM7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModHlwZW9mIHVuaXRzICE9PSAndW5kZWZpbmVkJyA/IHVuaXRzIDogJ21pbGxpc2Vjb25kJyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgaW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gK3RoaXMgPiAraW5wdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dE1zID0gaXNNb21lbnQoaW5wdXQpID8gK2lucHV0IDogK2xvY2FsX19jcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXRNcyA8ICt0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBpbnB1dE1zO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHR5cGVvZiB1bml0cyAhPT0gJ3VuZGVmaW5lZCcgPyB1bml0cyA6ICdtaWxsaXNlY29uZCcpO1xuICAgICAgICBpZiAodW5pdHMgPT09ICdtaWxsaXNlY29uZCcpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzIDwgK2lucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9IGlzTW9tZW50KGlucHV0KSA/ICtpbnB1dCA6ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICt0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpIDwgaW5wdXRNcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQWZ0ZXIoZnJvbSwgdW5pdHMpICYmIHRoaXMuaXNCZWZvcmUodG8sIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWUgKGlucHV0LCB1bml0cykge1xuICAgICAgICB2YXIgaW5wdXRNcztcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyB8fCAnbWlsbGlzZWNvbmQnKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlzTW9tZW50KGlucHV0KSA/IGlucHV0IDogbG9jYWxfX2NyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgICAgIHJldHVybiArdGhpcyA9PT0gK2lucHV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRNcyA9ICtsb2NhbF9fY3JlYXRlTG9jYWwoaW5wdXQpO1xuICAgICAgICAgICAgcmV0dXJuICsodGhpcy5jbG9uZSgpLnN0YXJ0T2YodW5pdHMpKSA8PSBpbnB1dE1zICYmIGlucHV0TXMgPD0gKyh0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKG51bWJlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpLFxuICAgICAgICAgICAgem9uZURlbHRhID0gKHRoYXQudXRjT2Zmc2V0KCkgLSB0aGlzLnV0Y09mZnNldCgpKSAqIDZlNCxcbiAgICAgICAgICAgIGRlbHRhLCBvdXRwdXQ7XG5cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG5cbiAgICAgICAgaWYgKHVuaXRzID09PSAneWVhcicgfHwgdW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpO1xuICAgICAgICAgICAgaWYgKHVuaXRzID09PSAncXVhcnRlcicpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQgLyAzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh1bml0cyA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0IC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YSA9IHRoaXMgLSB0aGF0O1xuICAgICAgICAgICAgb3V0cHV0ID0gdW5pdHMgPT09ICdzZWNvbmQnID8gZGVsdGEgLyAxZTMgOiAvLyAxMDAwXG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICdtaW51dGUnID8gZGVsdGEgLyA2ZTQgOiAvLyAxMDAwICogNjBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2hvdXInID8gZGVsdGEgLyAzNmU1IDogLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgICAgICB1bml0cyA9PT0gJ2RheScgPyAoZGVsdGEgLSB6b25lRGVsdGEpIC8gODY0ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0LCBuZWdhdGUgZHN0XG4gICAgICAgICAgICAgICAgdW5pdHMgPT09ICd3ZWVrJyA/IChkZWx0YSAtIHpvbmVEZWx0YSkgLyA2MDQ4ZTUgOiAvLyAxMDAwICogNjAgKiA2MCAqIDI0ICogNywgbmVnYXRlIGRzdFxuICAgICAgICAgICAgICAgIGRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc0Zsb2F0ID8gb3V0cHV0IDogYWJzRmxvb3Iob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb250aERpZmYgKGEsIGIpIHtcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBpbiBtb250aHNcbiAgICAgICAgdmFyIHdob2xlTW9udGhEaWZmID0gKChiLnllYXIoKSAtIGEueWVhcigpKSAqIDEyKSArIChiLm1vbnRoKCkgLSBhLm1vbnRoKCkpLFxuICAgICAgICAgICAgLy8gYiBpcyBpbiAoYW5jaG9yIC0gMSBtb250aCwgYW5jaG9yICsgMSBtb250aClcbiAgICAgICAgICAgIGFuY2hvciA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYsICdtb250aHMnKSxcbiAgICAgICAgICAgIGFuY2hvcjIsIGFkanVzdDtcblxuICAgICAgICBpZiAoYiAtIGFuY2hvciA8IDApIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmIC0gMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IgLSBhbmNob3IyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvcjIgPSBhLmNsb25lKCkuYWRkKHdob2xlTW9udGhEaWZmICsgMSwgJ21vbnRocycpO1xuICAgICAgICAgICAgLy8gbGluZWFyIGFjcm9zcyB0aGUgbW9udGhcbiAgICAgICAgICAgIGFkanVzdCA9IChiIC0gYW5jaG9yKSAvIChhbmNob3IyIC0gYW5jaG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtKHdob2xlTW9udGhEaWZmICsgYWRqdXN0KTtcbiAgICB9XG5cbiAgICB1dGlsc19ob29rc19faG9va3MuZGVmYXVsdEZvcm1hdCA9ICdZWVlZLU1NLUREVEhIOm1tOnNzWic7XG5cbiAgICBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkubG9jYWxlKCdlbicpLmZvcm1hdCgnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzIFtHTVRdWlonKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfZm9ybWF0X190b0lTT1N0cmluZyAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5jbG9uZSgpLnV0YygpO1xuICAgICAgICBpZiAoMCA8IG0ueWVhcigpICYmIG0ueWVhcigpIDw9IDk5OTkpIHtcbiAgICAgICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVktTU0tRERbVF1ISDptbTpzcy5TU1NbWl0nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXRNb21lbnQobSwgJ1lZWVlZWS1NTS1ERFtUXUhIOm1tOnNzLlNTU1taXScpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZm9ybWF0IChpbnB1dFN0cmluZykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gZm9ybWF0TW9tZW50KHRoaXMsIGlucHV0U3RyaW5nIHx8IHV0aWxzX2hvb2tzX19ob29rcy5kZWZhdWx0Rm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLnBvc3Rmb3JtYXQob3V0cHV0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmcm9tICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVfX2NyZWF0ZUR1cmF0aW9uKHt0bzogdGhpcywgZnJvbTogdGltZX0pLmxvY2FsZSh0aGlzLmxvY2FsZSgpKS5odW1hbml6ZSghd2l0aG91dFN1ZmZpeCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGxvY2FsX19jcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZShrZXkpO1xuICAgICAgICAgICAgaWYgKG5ld0xvY2FsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvY2FsZSA9IG5ld0xvY2FsZURhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsYW5nID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubGFuZygpIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQsIHVzZSBtb21lbnQoKS5sb2NhbGVEYXRhKCkgdG8gZ2V0IHRoZSBsYW5ndWFnZSBjb25maWd1cmF0aW9uLiBVc2UgbW9tZW50KCkubG9jYWxlKCkgdG8gY2hhbmdlIGxhbmd1YWdlcy4nLFxuICAgICAgICBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZURhdGEgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHN3aXRjaCBpbnRlbnRpb25hbGx5IG9taXRzIGJyZWFrIGtleXdvcmRzXG4gICAgICAgIC8vIHRvIHV0aWxpemUgZmFsbGluZyB0aHJvdWdoIHRoZSBjYXNlcy5cbiAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgIHRoaXMubW9udGgoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3F1YXJ0ZXInOlxuICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICB0aGlzLmRhdGUoMSk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICBjYXNlICdpc29XZWVrJzpcbiAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIHRoaXMuaG91cnMoMCk7XG4gICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgdGhpcy5taW51dGVzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgdGhpcy5zZWNvbmRzKDApO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZHMoMCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZWVrcyBhcmUgYSBzcGVjaWFsIGNhc2VcbiAgICAgICAgaWYgKHVuaXRzID09PSAnd2VlaycpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla2RheSgwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdHMgPT09ICdpc29XZWVrJykge1xuICAgICAgICAgICAgdGhpcy5pc29XZWVrZGF5KDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcXVhcnRlcnMgYXJlIGFsc28gc3BlY2lhbFxuICAgICAgICBpZiAodW5pdHMgPT09ICdxdWFydGVyJykge1xuICAgICAgICAgICAgdGhpcy5tb250aChNYXRoLmZsb29yKHRoaXMubW9udGgoKSAvIDMpICogMyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlbmRPZiAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mKHVuaXRzKS5hZGQoMSwgKHVuaXRzID09PSAnaXNvV2VlaycgPyAnd2VlaycgOiB1bml0cykpLnN1YnRyYWN0KDEsICdtcycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvX3R5cGVfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gK3RoaXMuX2QgLSAoKHRoaXMuX29mZnNldCB8fCAwKSAqIDYwMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bml4ICgpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoK3RoaXMgLyAxMDAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0RhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0ID8gbmV3IERhdGUoK3RoaXMpIDogdGhpcy5fZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICAgICAgdmFyIG0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW20ueWVhcigpLCBtLm1vbnRoKCksIG0uZGF0ZSgpLCBtLmhvdXIoKSwgbS5taW51dGUoKSwgbS5zZWNvbmQoKSwgbS5taWxsaXNlY29uZCgpXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb21lbnRfdmFsaWRfX2lzVmFsaWQgKCkge1xuICAgICAgICByZXR1cm4gdmFsaWRfX2lzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgdGhpcy5fcGYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWRBdCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZi5vdmVyZmxvdztcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ2dnJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2Vla1llYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnR0cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc29XZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1llYXJGb3JtYXRUb2tlbiAodG9rZW4sIGdldHRlcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbigwLCBbdG9rZW4sIHRva2VuLmxlbmd0aF0sIDAsIGdldHRlcik7XG4gICAgfVxuXG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignZ2dnZycsICAgICAnd2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnZycsICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ0dHR0cnLCAgJ2lzb1dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHR0cnLCAnaXNvV2Vla1llYXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnd2Vla1llYXInLCAnZ2cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtZZWFyJywgJ0dHJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlVHdvRGlnaXRZZWFyKGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHJldHVybiB3ZWVrT2ZZZWFyKGxvY2FsX19jcmVhdGVMb2NhbChbeWVhciwgMTEsIDMxICsgZG93IC0gZG95XSksIGRvdywgZG95KS53ZWVrO1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LCB0aGlzLmxvY2FsZURhdGEoKS5fd2Vlay5kb3kpLnllYXI7XG4gICAgICAgIHJldHVybiBpbnB1dCA9PSBudWxsID8geWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIHllYXIpLCAneScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWtZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgeWVhciA9IHdlZWtPZlllYXIodGhpcywgMSwgNCkueWVhcjtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB5ZWFyIDogdGhpcy5hZGQoKGlucHV0IC0geWVhciksICd5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdRJywgMCwgMCwgJ3F1YXJ0ZXInKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygncXVhcnRlcicsICdRJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdRJywgbWF0Y2gxKTtcbiAgICBhZGRQYXJzZVRva2VuKCdRJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSAodG9JbnQoaW5wdXQpIC0gMSkgKiAzO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0UXVhcnRlciAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyBNYXRoLmNlaWwoKHRoaXMubW9udGgoKSArIDEpIC8gMykgOiB0aGlzLm1vbnRoKChpbnB1dCAtIDEpICogMyArIHRoaXMubW9udGgoKSAlIDMpO1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdEJywgWydERCcsIDJdLCAnRG8nLCAnZGF0ZScpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXRlJywgJ0QnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBpc1N0cmljdCA/IGxvY2FsZS5fb3JkaW5hbFBhcnNlIDogbG9jYWxlLl9vcmRpbmFsUGFyc2VMZW5pZW50O1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0QnLCAnREQnXSwgREFURSk7XG4gICAgYWRkUGFyc2VUb2tlbignRG8nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W0RBVEVdID0gdG9JbnQoaW5wdXQubWF0Y2gobWF0Y2gxdG8yKVswXSwgMTApO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZCcsIDAsICdkbycsICdkYXknKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzTWluKHRoaXMsIGZvcm1hdCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5cyh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2UnLCAwLCAwLCAnd2Vla2RheScpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdFJywgMCwgMCwgJ2lzb1dlZWtkYXknKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnZGF5JywgJ2QnKTtcbiAgICBhZGRVbml0QWxpYXMoJ3dlZWtkYXknLCAnZScpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla2RheScsICdFJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdkJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdlJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdFJywgICAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZCcsICAgbWF0Y2hXb3JkKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGQnLCAgbWF0Y2hXb3JkKTtcbiAgICBhZGRSZWdleFRva2VuKCdkZGRkJywgbWF0Y2hXb3JkKTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcpIHtcbiAgICAgICAgdmFyIHdlZWtkYXkgPSBjb25maWcuX2xvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX3BmLmludmFsaWRXZWVrZGF5ID0gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZCcsICdlJywgJ0UnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgZnVuY3Rpb24gcGFyc2VXZWVrZGF5KGlucHV0LCBsb2NhbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICghaXNOYU4oaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBwYXJzZUludChpbnB1dCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBsb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzID0gJ1N1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93ZWVrZGF5c1ttLmRheSgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQgPSAnU3VuX01vbl9UdWVfV2VkX1RodV9GcmlfU2F0Jy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWtkYXlzU2hvcnQgKG0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRbbS5kYXkoKV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5bbS5kYXkoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUpIHtcbiAgICAgICAgdmFyIGksIG1vbSwgcmVnZXg7XG5cbiAgICAgICAgaWYgKCF0aGlzLl93ZWVrZGF5c1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICAvLyBtYWtlIHRoZSByZWdleCBpZiB3ZSBkb24ndCBoYXZlIGl0IGFscmVhZHlcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIG1vbSA9IGxvY2FsX19jcmVhdGVMb2NhbChbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c1Nob3J0KG1vbSwgJycpICsgJ3xeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZVtpXSA9IG5ldyBSZWdFeHAocmVnZXgucmVwbGFjZSgnLicsICcnKSwgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRlc3QgdGhlIHJlZ2V4XG4gICAgICAgICAgICBpZiAodGhpcy5fd2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5ID0gdGhpcy5faXNVVEMgPyB0aGlzLl9kLmdldFVUQ0RheSgpIDogdGhpcy5fZC5nZXREYXkoKTtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlucHV0ID0gcGFyc2VXZWVrZGF5KGlucHV0LCB0aGlzLmxvY2FsZURhdGEoKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQoaW5wdXQgLSBkYXksICdkJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZGF5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0TG9jYWxlRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB0aGlzLmRheSgpIHx8IDcgOiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IGlucHV0IDogaW5wdXQgLSA3KTtcbiAgICB9XG5cbiAgICBhZGRGb3JtYXRUb2tlbignSCcsIFsnSEgnLCAyXSwgMCwgJ2hvdXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignaCcsIFsnaGgnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpICUgMTIgfHwgMTI7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbSAodG9rZW4sIGxvd2VyY2FzZSkge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLm1lcmlkaWVtKHRoaXMuaG91cnMoKSwgdGhpcy5taW51dGVzKCksIGxvd2VyY2FzZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG1lcmlkaWVtKCdhJywgdHJ1ZSk7XG4gICAgbWVyaWRpZW0oJ0EnLCBmYWxzZSk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2hvdXInLCAnaCcpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgZnVuY3Rpb24gbWF0Y2hNZXJpZGllbSAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLl9tZXJpZGllbVBhcnNlO1xuICAgIH1cblxuICAgIGFkZFJlZ2V4VG9rZW4oJ2EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignQScsICBtYXRjaE1lcmlkaWVtKTtcbiAgICBhZGRSZWdleFRva2VuKCdIJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignaCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0hIJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2hoJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ0gnLCAnSEgnXSwgSE9VUik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2EnLCAnQSddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9pc1BtID0gY29uZmlnLl9sb2NhbGUuaXNQTShpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fbWVyaWRpZW0gPSBpbnB1dDtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKFsnaCcsICdoaCddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dCk7XG4gICAgICAgIGNvbmZpZy5fcGYuYmlnSG91ciA9IHRydWU7XG4gICAgfSk7XG5cbiAgICAvLyBMT0NBTEVTXG5cbiAgICBmdW5jdGlvbiBsb2NhbGVJc1BNIChpbnB1dCkge1xuICAgICAgICAvLyBJRTggUXVpcmtzIE1vZGUgJiBJRTcgU3RhbmRhcmRzIE1vZGUgZG8gbm90IGFsbG93IGFjY2Vzc2luZyBzdHJpbmdzIGxpa2UgYXJyYXlzXG4gICAgICAgIC8vIFVzaW5nIGNoYXJBdCBzaG91bGQgYmUgbW9yZSBjb21wYXRpYmxlLlxuICAgICAgICByZXR1cm4gKChpbnB1dCArICcnKS50b0xvd2VyQ2FzZSgpLmNoYXJBdCgwKSA9PT0gJ3AnKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2UgPSAvW2FwXVxcLj9tP1xcLj8vaTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNZXJpZGllbSAoaG91cnMsIG1pbnV0ZXMsIGlzTG93ZXIpIHtcbiAgICAgICAgaWYgKGhvdXJzID4gMTEpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0xvd2VyID8gJ3BtJyA6ICdQTSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdhbScgOiAnQU0nO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICAvLyBTZXR0aW5nIHRoZSBob3VyIHNob3VsZCBrZWVwIHRoZSB0aW1lLCBiZWNhdXNlIHRoZSB1c2VyIGV4cGxpY2l0bHlcbiAgICAvLyBzcGVjaWZpZWQgd2hpY2ggaG91ciBoZSB3YW50cy4gU28gdHJ5aW5nIHRvIG1haW50YWluIHRoZSBzYW1lIGhvdXIgKGluXG4gICAgLy8gYSBuZXcgdGltZXpvbmUpIG1ha2VzIHNlbnNlLiBBZGRpbmcvc3VidHJhY3RpbmcgaG91cnMgZG9lcyBub3QgZm9sbG93XG4gICAgLy8gdGhpcyBydWxlLlxuICAgIHZhciBnZXRTZXRIb3VyID0gbWFrZUdldFNldCgnSG91cnMnLCB0cnVlKTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdtJywgWydtbScsIDJdLCAwLCAnbWludXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ21pbnV0ZScsICdtJyk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdtJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignbW0nLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUGFyc2VUb2tlbihbJ20nLCAnbW0nXSwgTUlOVVRFKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaW51dGUgPSBtYWtlR2V0U2V0KCdNaW51dGVzJywgZmFsc2UpO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ3MnLCBbJ3NzJywgMl0sIDAsICdzZWNvbmQnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnc2Vjb25kJywgJ3MnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3MnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdzcycsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsncycsICdzcyddLCBTRUNPTkQpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldFNlY29uZCA9IG1ha2VHZXRTZXQoJ1NlY29uZHMnLCBmYWxzZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignUycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwMCk7XG4gICAgfSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1NTJywgMl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIH5+KHRoaXMubWlsbGlzZWNvbmQoKSAvIDEwKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1pbGxpc2Vjb25kX19taWxsaXNlY29uZHMgKHRva2VuKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgM10sIDAsICdtaWxsaXNlY29uZCcpO1xuICAgIH1cblxuICAgIG1pbGxpc2Vjb25kX19taWxsaXNlY29uZHMoJ1NTUycpO1xuICAgIG1pbGxpc2Vjb25kX19taWxsaXNlY29uZHMoJ1NTU1MnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1MnLCAgICBtYXRjaDF0bzMsIG1hdGNoMSk7XG4gICAgYWRkUmVnZXhUb2tlbignU1MnLCAgIG1hdGNoMXRvMywgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdTU1MnLCAgbWF0Y2gxdG8zLCBtYXRjaDMpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTU1MnLCBtYXRjaFVuc2lnbmVkKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnUycsICdTUycsICdTU1MnLCAnU1NTUyddLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01JTExJU0VDT05EXSA9IHRvSW50KCgnMC4nICsgaW5wdXQpICogMTAwMCk7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0TWlsbGlzZWNvbmQgPSBtYWtlR2V0U2V0KCdNaWxsaXNlY29uZHMnLCBmYWxzZSk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbigneicsICAwLCAwLCAnem9uZUFiYnInKTtcbiAgICBhZGRGb3JtYXRUb2tlbignenonLCAwLCAwLCAnem9uZU5hbWUnKTtcblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFpvbmVBYmJyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ1VUQycgOiAnJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRab25lTmFtZSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1VUQyA/ICdDb29yZGluYXRlZCBVbml2ZXJzYWwgVGltZScgOiAnJztcbiAgICB9XG5cbiAgICB2YXIgbW9tZW50UHJvdG90eXBlX19wcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmFkZCAgICAgICAgICA9IGFkZF9zdWJ0cmFjdF9fYWRkO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uY2FsZW5kYXIgICAgID0gbW9tZW50X2NhbGVuZGFyX19jYWxlbmRhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmNsb25lICAgICAgICA9IGNsb25lO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGlmZiAgICAgICAgID0gZGlmZjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmVuZE9mICAgICAgICA9IGVuZE9mO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZm9ybWF0ICAgICAgID0gZm9ybWF0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZnJvbSAgICAgICAgID0gZnJvbTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmZyb21Ob3cgICAgICA9IGZyb21Ob3c7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5nZXQgICAgICAgICAgPSBnZXRTZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pbnZhbGlkQXQgICAgPSBpbnZhbGlkQXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0FmdGVyICAgICAgPSBpc0FmdGVyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNCZWZvcmUgICAgID0gaXNCZWZvcmU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0JldHdlZW4gICAgPSBpc0JldHdlZW47XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1NhbWUgICAgICAgPSBpc1NhbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1ZhbGlkICAgICAgPSBtb21lbnRfdmFsaWRfX2lzVmFsaWQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sYW5nICAgICAgICAgPSBsYW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgID0gbG9jYWxlO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubG9jYWxlRGF0YSAgID0gbG9jYWxlRGF0YTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1heCAgICAgICAgICA9IHByb3RvdHlwZU1heDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbiAgICAgICAgICA9IHByb3RvdHlwZU1pbjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnBhcnNpbmdGbGFncyA9IHBhcnNpbmdGbGFncztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNldCAgICAgICAgICA9IGdldFNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnN0YXJ0T2YgICAgICA9IHN0YXJ0T2Y7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zdWJ0cmFjdCAgICAgPSBhZGRfc3VidHJhY3RfX3N1YnRyYWN0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9BcnJheSAgICAgID0gdG9BcnJheTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvRGF0ZSAgICAgICA9IHRvRGF0ZTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnRvSVNPU3RyaW5nICA9IG1vbWVudF9mb3JtYXRfX3RvSVNPU3RyaW5nO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8udG9KU09OICAgICAgID0gbW9tZW50X2Zvcm1hdF9fdG9JU09TdHJpbmc7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by50b1N0cmluZyAgICAgPSB0b1N0cmluZztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnVuaXggICAgICAgICA9IHVuaXg7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by52YWx1ZU9mICAgICAgPSB0b190eXBlX192YWx1ZU9mO1xuXG4gICAgLy8gWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ueWVhciAgICAgICA9IGdldFNldFllYXI7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcblxuICAgIC8vIFdlZWsgWWVhclxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla1llYXIgICAgPSBnZXRTZXRXZWVrWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG5cbiAgICAvLyBRdWFydGVyXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVyID0gbW9tZW50UHJvdG90eXBlX19wcm90by5xdWFydGVycyA9IGdldFNldFF1YXJ0ZXI7XG5cbiAgICAvLyBNb250aFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubW9udGggICAgICAgPSBnZXRTZXRNb250aDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG5cbiAgICAvLyBXZWVrXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by53ZWVrICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3MgICAgICAgID0gZ2V0U2V0V2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWsgICAgICAgID0gbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrcyAgICAgPSBnZXRTZXRJU09XZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ud2Vla3NJblllYXIgICAgPSBnZXRXZWVrc0luWWVhcjtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG5cbiAgICAvLyBEYXlcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmRhdGUgICAgICAgPSBnZXRTZXREYXlPZk1vbnRoO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5ICAgICAgICA9IG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5cyAgICAgICAgICAgICA9IGdldFNldERheU9mV2VlaztcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLndlZWtkYXkgICAgPSBnZXRTZXRMb2NhbGVEYXlPZldlZWs7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF5T2ZZZWFyICA9IGdldFNldERheU9mWWVhcjtcblxuICAgIC8vIEhvdXJcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXIgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcblxuICAgIC8vIE1pbnV0ZVxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWludXRlID0gbW9tZW50UHJvdG90eXBlX19wcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuXG4gICAgLy8gU2Vjb25kXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5zZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG5cbiAgICAvLyBNaWxsaXNlY29uZFxuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubWlsbGlzZWNvbmQgPSBtb21lbnRQcm90b3R5cGVfX3Byb3RvLm1pbGxpc2Vjb25kcyA9IGdldFNldE1pbGxpc2Vjb25kO1xuXG4gICAgLy8gT2Zmc2V0XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnV0YyAgICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9VVEM7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5sb2NhbCAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvTG9jYWw7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaGFzQWxpZ25lZEhvdXJPZmZzZXQgPSBoYXNBbGlnbmVkSG91ck9mZnNldDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzRFNUICAgICAgICAgICAgICAgID0gaXNEYXlsaWdodFNhdmluZ1RpbWU7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc0RTVFNoaWZ0ZWQgICAgICAgICA9IGlzRGF5bGlnaHRTYXZpbmdUaW1lU2hpZnRlZDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzTG9jYWwgICAgICAgICAgICAgID0gaXNMb2NhbDtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLmlzVXRjT2Zmc2V0ICAgICAgICAgID0gaXNVdGNPZmZzZXQ7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uaXNVVEMgICAgICAgICAgICAgICAgPSBpc1V0YztcblxuICAgIC8vIFRpbWV6b25lXG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by56b25lQWJiciA9IGdldFpvbmVBYmJyO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uem9uZU5hbWUgPSBnZXRab25lTmFtZTtcblxuICAgIC8vIERlcHJlY2F0aW9uc1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8uZGF0ZXMgID0gZGVwcmVjYXRlKCdkYXRlcyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgZGF0ZSBpbnN0ZWFkLicsIGdldFNldERheU9mTW9udGgpO1xuICAgIG1vbWVudFByb3RvdHlwZV9fcHJvdG8ubW9udGhzID0gZGVwcmVjYXRlKCdtb250aHMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbnRoIGluc3RlYWQnLCBnZXRTZXRNb250aCk7XG4gICAgbW9tZW50UHJvdG90eXBlX19wcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbiAgICBtb21lbnRQcm90b3R5cGVfX3Byb3RvLnpvbmUgICA9IGRlcHJlY2F0ZSgnbW9tZW50KCkuem9uZSBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50KCkudXRjT2Zmc2V0IGluc3RlYWQuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2lzc3Vlcy8xNzc5JywgZ2V0U2V0Wm9uZSk7XG5cbiAgICB2YXIgbW9tZW50UHJvdG90eXBlID0gbW9tZW50UHJvdG90eXBlX19wcm90bztcblxuICAgIGZ1bmN0aW9uIG1vbWVudF9fY3JlYXRlVW5peCAoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudF9fY3JlYXRlSW5ab25lICgpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsX19jcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0Q2FsZW5kYXIgPSB7XG4gICAgICAgIHNhbWVEYXkgOiAnW1RvZGF5IGF0XSBMVCcsXG4gICAgICAgIG5leHREYXkgOiAnW1RvbW9ycm93IGF0XSBMVCcsXG4gICAgICAgIG5leHRXZWVrIDogJ2RkZGQgW2F0XSBMVCcsXG4gICAgICAgIGxhc3REYXkgOiAnW1llc3RlcmRheSBhdF0gTFQnLFxuICAgICAgICBsYXN0V2VlayA6ICdbTGFzdF0gZGRkZCBbYXRdIExUJyxcbiAgICAgICAgc2FtZUVsc2UgOiAnTCdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlX2NhbGVuZGFyX19jYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicgPyBvdXRwdXQuY2FsbChtb20sIG5vdykgOiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb25nRGF0ZUZvcm1hdCA9IHtcbiAgICAgICAgTFRTICA6ICdoOm1tOnNzIEEnLFxuICAgICAgICBMVCAgIDogJ2g6bW0gQScsXG4gICAgICAgIEwgICAgOiAnTU0vREQvWVlZWScsXG4gICAgICAgIExMICAgOiAnTU1NTSBELCBZWVlZJyxcbiAgICAgICAgTExMICA6ICdNTU1NIEQsIFlZWVkgTFQnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBMVCdcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gbG9uZ0RhdGVGb3JtYXQgKGtleSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5XTtcbiAgICAgICAgaWYgKCFvdXRwdXQgJiYgdGhpcy5fbG9uZ0RhdGVGb3JtYXRba2V5LnRvVXBwZXJDYXNlKCldKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXkudG9VcHBlckNhc2UoKV0ucmVwbGFjZSgvTU1NTXxNTXxERHxkZGRkL2csIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsLnNsaWNlKDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLl9sb25nRGF0ZUZvcm1hdFtrZXldID0gb3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdE9yZGluYWxQYXJzZSA9IC9cXGR7MSwyfS87XG5cbiAgICBmdW5jdGlvbiBvcmRpbmFsIChudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29yZGluYWwucmVwbGFjZSgnJWQnLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRSZWxhdGl2ZVRpbWUgPSB7XG4gICAgICAgIGZ1dHVyZSA6ICdpbiAlcycsXG4gICAgICAgIHBhc3QgICA6ICclcyBhZ28nLFxuICAgICAgICBzICA6ICdhIGZldyBzZWNvbmRzJyxcbiAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCAgOiAnYW4gaG91cicsXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgZCAgOiAnYSBkYXknLFxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgTSAgOiAnYSBtb250aCcsXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgIHkgIDogJ2EgeWVhcicsXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZV9fcmVsYXRpdmVUaW1lIChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIHtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMuX3JlbGF0aXZlVGltZVtzdHJpbmddO1xuICAgICAgICByZXR1cm4gKHR5cGVvZiBvdXRwdXQgPT09ICdmdW5jdGlvbicpID9cbiAgICAgICAgICAgIG91dHB1dChudW1iZXIsIHdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpIDpcbiAgICAgICAgICAgIG91dHB1dC5yZXBsYWNlKC8lZC9pLCBudW1iZXIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhc3RGdXR1cmUgKGRpZmYsIG91dHB1dCkge1xuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW2RpZmYgPiAwID8gJ2Z1dHVyZScgOiAncGFzdCddO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PT0gJ2Z1bmN0aW9uJyA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlX3NldF9fc2V0IChjb25maWcpIHtcbiAgICAgICAgdmFyIHByb3AsIGk7XG4gICAgICAgIGZvciAoaSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIHByb3AgPSBjb25maWdbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGVuaWVudCBvcmRpbmFsIHBhcnNpbmcgYWNjZXB0cyBqdXN0IGEgbnVtYmVyIGluIGFkZGl0aW9uIHRvXG4gICAgICAgIC8vIG51bWJlciArIChwb3NzaWJseSkgc3R1ZmYgY29taW5nIGZyb20gX29yZGluYWxQYXJzZUxlbmllbnQuXG4gICAgICAgIHRoaXMuX29yZGluYWxQYXJzZUxlbmllbnQgPSBuZXcgUmVnRXhwKHRoaXMuX29yZGluYWxQYXJzZS5zb3VyY2UgKyAnfCcgKyAvXFxkezEsMn0vLnNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvdHlwZV9fcHJvdG8gPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG90eXBlX19wcm90by5fY2FsZW5kYXIgICAgICAgPSBkZWZhdWx0Q2FsZW5kYXI7XG4gICAgcHJvdG90eXBlX19wcm90by5jYWxlbmRhciAgICAgICAgPSBsb2NhbGVfY2FsZW5kYXJfX2NhbGVuZGFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uX2xvbmdEYXRlRm9ybWF0ID0gZGVmYXVsdExvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ubG9uZ0RhdGVGb3JtYXQgID0gbG9uZ0RhdGVGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5faW52YWxpZERhdGUgICAgPSBkZWZhdWx0SW52YWxpZERhdGU7XG4gICAgcHJvdG90eXBlX19wcm90by5pbnZhbGlkRGF0ZSAgICAgPSBpbnZhbGlkRGF0ZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9vcmRpbmFsICAgICAgICA9IGRlZmF1bHRPcmRpbmFsO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ub3JkaW5hbCAgICAgICAgID0gb3JkaW5hbDtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9vcmRpbmFsUGFyc2UgICA9IGRlZmF1bHRPcmRpbmFsUGFyc2U7XG4gICAgcHJvdG90eXBlX19wcm90by5wcmVwYXJzZSAgICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5wb3N0Zm9ybWF0ICAgICAgPSBwcmVQYXJzZVBvc3RGb3JtYXQ7XG4gICAgcHJvdG90eXBlX19wcm90by5fcmVsYXRpdmVUaW1lICAgPSBkZWZhdWx0UmVsYXRpdmVUaW1lO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVfX3JlbGF0aXZlVGltZTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLnBhc3RGdXR1cmUgICAgICA9IHBhc3RGdXR1cmU7XG4gICAgcHJvdG90eXBlX19wcm90by5zZXQgICAgICAgICAgICAgPSBsb2NhbGVfc2V0X19zZXQ7XG5cbiAgICAvLyBNb250aFxuICAgIHByb3RvdHlwZV9fcHJvdG8ubW9udGhzICAgICAgID0gICAgICAgIGxvY2FsZU1vbnRocztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tb250aHMgICAgICA9IGRlZmF1bHRMb2NhbGVNb250aHM7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNTaG9ydCAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5fbW9udGhzU2hvcnQgPSBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5tb250aHNQYXJzZSAgPSAgICAgICAgbG9jYWxlTW9udGhzUGFyc2U7XG5cbiAgICAvLyBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrID0gZGVmYXVsdExvY2FsZVdlZWs7XG4gICAgcHJvdG90eXBlX19wcm90by5maXJzdERheU9mWWVhciA9IGxvY2FsZUZpcnN0RGF5T2ZZZWFyO1xuICAgIHByb3RvdHlwZV9fcHJvdG8uZmlyc3REYXlPZldlZWsgPSBsb2NhbGVGaXJzdERheU9mV2VlaztcblxuICAgIC8vIERheSBvZiBXZWVrXG4gICAgcHJvdG90eXBlX19wcm90by53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90b3R5cGVfX3Byb3RvLl93ZWVrZGF5cyAgICAgID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzO1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNNaW4gICAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNNaW47XG4gICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXNNaW4gICA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbjtcbiAgICBwcm90b3R5cGVfX3Byb3RvLndlZWtkYXlzU2hvcnQgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzU2hvcnQ7XG4gICAgcHJvdG90eXBlX19wcm90by5fd2Vla2RheXNTaG9ydCA9IGRlZmF1bHRMb2NhbGVXZWVrZGF5c1Nob3J0O1xuICAgIHByb3RvdHlwZV9fcHJvdG8ud2Vla2RheXNQYXJzZSAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNQYXJzZTtcblxuICAgIC8vIEhvdXJzXG4gICAgcHJvdG90eXBlX19wcm90by5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90b3R5cGVfX3Byb3RvLl9tZXJpZGllbVBhcnNlID0gZGVmYXVsdExvY2FsZU1lcmlkaWVtUGFyc2U7XG4gICAgcHJvdG90eXBlX19wcm90by5tZXJpZGllbSA9IGxvY2FsZU1lcmlkaWVtO1xuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2dldCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSgpO1xuICAgICAgICB2YXIgdXRjID0gY3JlYXRlX3V0Y19fY3JlYXRlVVRDKCkuc2V0KHNldHRlciwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gbG9jYWxlW2ZpZWxkXSh1dGMsIGZvcm1hdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdCAoZm9ybWF0LCBpbmRleCwgZmllbGQsIGNvdW50LCBzZXR0ZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcblxuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RzX19nZXQoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gbGlzdHNfX2dldChmb3JtYXQsIGksIGZpZWxkLCBzZXR0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RNb250aHMgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ21vbnRocycsIDEyLCAnbW9udGgnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICdtb250aHNTaG9ydCcsIDEyLCAnbW9udGgnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0KGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycsIDcsICdkYXknKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0c19fbGlzdFdlZWtkYXlzU2hvcnQgKGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3QoZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzU2hvcnQnLCA3LCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdHNfX2xpc3RXZWVrZGF5c01pbiAoZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdChmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNNaW4nLCA3LCAnZGF5Jyk7XG4gICAgfVxuXG4gICAgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSgnZW4nLCB7XG4gICAgICAgIG9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmcgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nIGlzIGRlcHJlY2F0ZWQuIFVzZSBtb21lbnQubG9jYWxlIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldFNldEdsb2JhbExvY2FsZSk7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmxhbmdEYXRhID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZ0RhdGEgaXMgZGVwcmVjYXRlZC4gVXNlIG1vbWVudC5sb2NhbGVEYXRhIGluc3RlYWQuJywgbG9jYWxlX2xvY2FsZXNfX2dldExvY2FsZSk7XG5cbiAgICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWJzX19hYnMgKCkge1xuICAgICAgICB2YXIgZGF0YSAgICAgICAgICAgPSB0aGlzLl9kYXRhO1xuXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9IG1hdGhBYnModGhpcy5fbWlsbGlzZWNvbmRzKTtcbiAgICAgICAgdGhpcy5fZGF5cyAgICAgICAgID0gbWF0aEFicyh0aGlzLl9kYXlzKTtcbiAgICAgICAgdGhpcy5fbW9udGhzICAgICAgID0gbWF0aEFicyh0aGlzLl9tb250aHMpO1xuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzICA9IG1hdGhBYnMoZGF0YS5taWxsaXNlY29uZHMpO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICAgPSBtYXRoQWJzKGRhdGEuc2Vjb25kcyk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgICA9IG1hdGhBYnMoZGF0YS5taW51dGVzKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgID0gbWF0aEFicyhkYXRhLmhvdXJzKTtcbiAgICAgICAgZGF0YS5tb250aHMgICAgICAgID0gbWF0aEFicyhkYXRhLm1vbnRocyk7XG4gICAgICAgIGRhdGEueWVhcnMgICAgICAgICA9IG1hdGhBYnMoZGF0YS55ZWFycyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19hZGRTdWJ0cmFjdCAoZHVyYXRpb24sIGlucHV0LCB2YWx1ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdGhlciA9IGNyZWF0ZV9fY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZCAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZFN1YnRyYWN0KHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX3N1YnRyYWN0IChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGR1cmF0aW9uX2FkZF9zdWJ0cmFjdF9fYWRkU3VidHJhY3QodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzID0gMDtcblxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgYnViYmxlcyB1cCB2YWx1ZXMsIHNlZSB0aGUgdGVzdHMgZm9yXG4gICAgICAgIC8vIGV4YW1wbGVzIG9mIHdoYXQgdGhhdCBtZWFucy5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgPSBtaWxsaXNlY29uZHMgJSAxMDAwO1xuXG4gICAgICAgIHNlY29uZHMgICAgICAgICAgID0gYWJzRmxvb3IobWlsbGlzZWNvbmRzIC8gMTAwMCk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgID0gc2Vjb25kcyAlIDYwO1xuXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgPSBtaW51dGVzICUgNjA7XG5cbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICA9IGhvdXJzICUgMjQ7XG5cbiAgICAgICAgZGF5cyArPSBhYnNGbG9vcihob3VycyAvIDI0KTtcblxuICAgICAgICAvLyBBY2N1cmF0ZWx5IGNvbnZlcnQgZGF5cyB0byB5ZWFycywgYXNzdW1lIHN0YXJ0IGZyb20geWVhciAwLlxuICAgICAgICB5ZWFycyA9IGFic0Zsb29yKGRheXNUb1llYXJzKGRheXMpKTtcbiAgICAgICAgZGF5cyAtPSBhYnNGbG9vcih5ZWFyc1RvRGF5cyh5ZWFycykpO1xuXG4gICAgICAgIC8vIDMwIGRheXMgdG8gYSBtb250aFxuICAgICAgICAvLyBUT0RPIChpc2tyZW4pOiBVc2UgYW5jaG9yIGRhdGUgKGxpa2UgMXN0IEphbikgdG8gY29tcHV0ZSB0aGlzLlxuICAgICAgICBtb250aHMgKz0gYWJzRmxvb3IoZGF5cyAvIDMwKTtcbiAgICAgICAgZGF5cyAgICU9IDMwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgICs9IGFic0Zsb29yKG1vbnRocyAvIDEyKTtcbiAgICAgICAgbW9udGhzICU9IDEyO1xuXG4gICAgICAgIGRhdGEuZGF5cyAgID0gZGF5cztcbiAgICAgICAgZGF0YS5tb250aHMgPSBtb250aHM7XG4gICAgICAgIGRhdGEueWVhcnMgID0geWVhcnM7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5c1RvWWVhcnMgKGRheXMpIHtcbiAgICAgICAgLy8gNDAwIHllYXJzIGhhdmUgMTQ2MDk3IGRheXMgKHRha2luZyBpbnRvIGFjY291bnQgbGVhcCB5ZWFyIHJ1bGVzKVxuICAgICAgICByZXR1cm4gZGF5cyAqIDQwMCAvIDE0NjA5NztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB5ZWFyc1RvRGF5cyAoeWVhcnMpIHtcbiAgICAgICAgLy8geWVhcnMgKiAzNjUgKyBhYnNGbG9vcih5ZWFycyAvIDQpIC1cbiAgICAgICAgLy8gICAgIGFic0Zsb29yKHllYXJzIC8gMTAwKSArIGFic0Zsb29yKHllYXJzIC8gNDAwKTtcbiAgICAgICAgcmV0dXJuIHllYXJzICogMTQ2MDk3IC8gNDAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICB2YXIgZGF5cztcbiAgICAgICAgdmFyIG1vbnRocztcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcblxuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdtb250aCcgfHwgdW5pdHMgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgZGF5cyAgID0gdGhpcy5fZGF5cyAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9ZZWFycyhkYXlzKSAqIDEyO1xuICAgICAgICAgICAgcmV0dXJuIHVuaXRzID09PSAnbW9udGgnID8gbW9udGhzIDogbW9udGhzIC8gMTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQoeWVhcnNUb0RheXModGhpcy5fbW9udGhzIC8gMTIpKTtcbiAgICAgICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgICAgICBjYXNlICd3ZWVrJyAgIDogcmV0dXJuIGRheXMgLyA3ICAgICAgICAgICAgKyBtaWxsaXNlY29uZHMgLyA2MDQ4ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGF5JyAgICA6IHJldHVybiBkYXlzICAgICAgICAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gMzZlNTtcbiAgICAgICAgICAgICAgICBjYXNlICdtaW51dGUnIDogcmV0dXJuIGRheXMgKiAyNCAqIDYwICAgICAgKyBtaWxsaXNlY29uZHMgLyA2ZTQ7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vjb25kJyA6IHJldHVybiBkYXlzICogMjQgKiA2MCAqIDYwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiAyNCAqIDYwICogNjAgKiAxMDAwKSArIG1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETzogVXNlIHRoaXMuYXMoJ21zJyk/XG4gICAgZnVuY3Rpb24gZHVyYXRpb25fYXNfX3ZhbHVlT2YgKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzICtcbiAgICAgICAgICAgIHRoaXMuX2RheXMgKiA4NjRlNSArXG4gICAgICAgICAgICAodGhpcy5fbW9udGhzICUgMTIpICogMjU5MmU2ICtcbiAgICAgICAgICAgIHRvSW50KHRoaXMuX21vbnRocyAvIDEyKSAqIDMxNTM2ZTZcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlQXMgKGFsaWFzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcyhhbGlhcyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGFzTWlsbGlzZWNvbmRzID0gbWFrZUFzKCdtcycpO1xuICAgIHZhciBhc1NlY29uZHMgICAgICA9IG1ha2VBcygncycpO1xuICAgIHZhciBhc01pbnV0ZXMgICAgICA9IG1ha2VBcygnbScpO1xuICAgIHZhciBhc0hvdXJzICAgICAgICA9IG1ha2VBcygnaCcpO1xuICAgIHZhciBhc0RheXMgICAgICAgICA9IG1ha2VBcygnZCcpO1xuICAgIHZhciBhc1dlZWtzICAgICAgICA9IG1ha2VBcygndycpO1xuICAgIHZhciBhc01vbnRocyAgICAgICA9IG1ha2VBcygnTScpO1xuICAgIHZhciBhc1llYXJzICAgICAgICA9IG1ha2VBcygneScpO1xuXG4gICAgZnVuY3Rpb24gZHVyYXRpb25fZ2V0X19nZXQgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpc1t1bml0cyArICdzJ10oKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYWtlR2V0dGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kYXRhW25hbWVdO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkdXJhdGlvbl9nZXRfX21pbGxpc2Vjb25kcyA9IG1ha2VHZXR0ZXIoJ21pbGxpc2Vjb25kcycpO1xuICAgIHZhciBzZWNvbmRzICAgICAgPSBtYWtlR2V0dGVyKCdzZWNvbmRzJyk7XG4gICAgdmFyIG1pbnV0ZXMgICAgICA9IG1ha2VHZXR0ZXIoJ21pbnV0ZXMnKTtcbiAgICB2YXIgaG91cnMgICAgICAgID0gbWFrZUdldHRlcignaG91cnMnKTtcbiAgICB2YXIgZGF5cyAgICAgICAgID0gbWFrZUdldHRlcignZGF5cycpO1xuICAgIHZhciBtb250aHMgICAgICAgPSBtYWtlR2V0dGVyKCdtb250aHMnKTtcbiAgICB2YXIgeWVhcnMgICAgICAgID0gbWFrZUdldHRlcigneWVhcnMnKTtcblxuICAgIGZ1bmN0aW9uIHdlZWtzICgpIHtcbiAgICAgICAgcmV0dXJuIGFic0Zsb29yKHRoaXMuZGF5cygpIC8gNyk7XG4gICAgfVxuXG4gICAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbiAgICB2YXIgdGhyZXNob2xkcyA9IHtcbiAgICAgICAgczogNDUsICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICBtOiA0NSwgIC8vIG1pbnV0ZXMgdG8gaG91clxuICAgICAgICBoOiAyMiwgIC8vIGhvdXJzIHRvIGRheVxuICAgICAgICBkOiAyNiwgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgTTogMTEgICAvLyBtb250aHMgdG8geWVhclxuICAgIH07XG5cbiAgICAvLyBoZWxwZXIgZnVuY3Rpb24gZm9yIG1vbWVudC5mbi5mcm9tLCBtb21lbnQuZm4uZnJvbU5vdywgYW5kIG1vbWVudC5kdXJhdGlvbi5mbi5odW1hbml6ZVxuICAgIGZ1bmN0aW9uIHN1YnN0aXR1dGVUaW1lQWdvKHN0cmluZywgbnVtYmVyLCB3aXRob3V0U3VmZml4LCBpc0Z1dHVyZSwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUucmVsYXRpdmVUaW1lKG51bWJlciB8fCAxLCAhIXdpdGhvdXRTdWZmaXgsIHN0cmluZywgaXNGdXR1cmUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUgKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbihwb3NOZWdEdXJhdGlvbikuYWJzKCk7XG4gICAgICAgIHZhciBzZWNvbmRzICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdzJykpO1xuICAgICAgICB2YXIgbWludXRlcyAgPSByb3VuZChkdXJhdGlvbi5hcygnbScpKTtcbiAgICAgICAgdmFyIGhvdXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ2gnKSk7XG4gICAgICAgIHZhciBkYXlzICAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdkJykpO1xuICAgICAgICB2YXIgbW9udGhzICAgPSByb3VuZChkdXJhdGlvbi5hcygnTScpKTtcbiAgICAgICAgdmFyIHllYXJzICAgID0gcm91bmQoZHVyYXRpb24uYXMoJ3knKSk7XG5cbiAgICAgICAgdmFyIGEgPSBzZWNvbmRzIDwgdGhyZXNob2xkcy5zICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPT09IDEgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAmJiBbJ21tJywgbWludXRlc10gfHxcbiAgICAgICAgICAgICAgICBob3VycyAgID09PSAxICAgICAgICAgICYmIFsnaCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPCB0aHJlc2hvbGRzLmggJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA9PT0gMSAgICAgICAgICAmJiBbJ2QnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBkYXlzICAgIDwgdGhyZXNob2xkcy5kICYmIFsnZGQnLCBkYXlzXSAgICB8fFxuICAgICAgICAgICAgICAgIG1vbnRocyAgPT09IDEgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAmJiBbJ01NJywgbW9udGhzXSAgfHxcbiAgICAgICAgICAgICAgICB5ZWFycyAgID09PSAxICAgICAgICAgICYmIFsneSddICAgICAgICAgICB8fCBbJ3l5JywgeWVhcnNdO1xuXG4gICAgICAgIGFbMl0gPSB3aXRob3V0U3VmZml4O1xuICAgICAgICBhWzNdID0gK3Bvc05lZ0R1cmF0aW9uID4gMDtcbiAgICAgICAgYVs0XSA9IGxvY2FsZTtcbiAgICAgICAgcmV0dXJuIHN1YnN0aXR1dGVUaW1lQWdvLmFwcGx5KG51bGwsIGEpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gYWxsb3dzIHlvdSB0byBzZXQgYSB0aHJlc2hvbGQgZm9yIHJlbGF0aXZlIHRpbWUgc3RyaW5nc1xuICAgIGZ1bmN0aW9uIGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGh1bWFuaXplICh3aXRoU3VmZml4KSB7XG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IGR1cmF0aW9uX2h1bWFuaXplX19yZWxhdGl2ZVRpbWUodGhpcywgIXdpdGhTdWZmaXgsIGxvY2FsZSk7XG5cbiAgICAgICAgaWYgKHdpdGhTdWZmaXgpIHtcbiAgICAgICAgICAgIG91dHB1dCA9IGxvY2FsZS5wYXN0RnV0dXJlKCt0aGlzLCBvdXRwdXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxvY2FsZS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGlzb19zdHJpbmdfX2FicyA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gaXNvX3N0cmluZ19fdG9JU09TdHJpbmcoKSB7XG4gICAgICAgIC8vIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9kb3JkaWxsZS9tb21lbnQtaXNvZHVyYXRpb24vYmxvYi9tYXN0ZXIvbW9tZW50Lmlzb2R1cmF0aW9uLmpzXG4gICAgICAgIHZhciBZID0gaXNvX3N0cmluZ19fYWJzKHRoaXMueWVhcnMoKSk7XG4gICAgICAgIHZhciBNID0gaXNvX3N0cmluZ19fYWJzKHRoaXMubW9udGhzKCkpO1xuICAgICAgICB2YXIgRCA9IGlzb19zdHJpbmdfX2Ficyh0aGlzLmRheXMoKSk7XG4gICAgICAgIHZhciBoID0gaXNvX3N0cmluZ19fYWJzKHRoaXMuaG91cnMoKSk7XG4gICAgICAgIHZhciBtID0gaXNvX3N0cmluZ19fYWJzKHRoaXMubWludXRlcygpKTtcbiAgICAgICAgdmFyIHMgPSBpc29fc3RyaW5nX19hYnModGhpcy5zZWNvbmRzKCkgKyB0aGlzLm1pbGxpc2Vjb25kcygpIC8gMTAwMCk7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICh0b3RhbCA8IDAgPyAnLScgOiAnJykgK1xuICAgICAgICAgICAgJ1AnICtcbiAgICAgICAgICAgIChZID8gWSArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAoTSA/IE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKEQgPyBEICsgJ0QnIDogJycpICtcbiAgICAgICAgICAgICgoaCB8fCBtIHx8IHMpID8gJ1QnIDogJycpICtcbiAgICAgICAgICAgIChoID8gaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobSA/IG0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKHMgPyBzICsgJ1MnIDogJycpO1xuICAgIH1cblxuICAgIHZhciBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvID0gRHVyYXRpb24ucHJvdG90eXBlO1xuXG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hYnMgICAgICAgICAgICA9IGR1cmF0aW9uX2Fic19fYWJzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYWRkICAgICAgICAgICAgPSBkdXJhdGlvbl9hZGRfc3VidHJhY3RfX2FkZDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnN1YnRyYWN0ICAgICAgID0gZHVyYXRpb25fYWRkX3N1YnRyYWN0X19zdWJ0cmFjdDtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzICAgICAgICAgICAgID0gYXM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbGxpc2Vjb25kcyA9IGFzTWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNTZWNvbmRzICAgICAgPSBhc1NlY29uZHM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5hc01pbnV0ZXMgICAgICA9IGFzTWludXRlcztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzSG91cnMgICAgICAgID0gYXNIb3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzRGF5cyAgICAgICAgID0gYXNEYXlzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNXZWVrcyAgICAgICAgPSBhc1dlZWtzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uYXNNb250aHMgICAgICAgPSBhc01vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmFzWWVhcnMgICAgICAgID0gYXNZZWFycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnZhbHVlT2YgICAgICAgID0gZHVyYXRpb25fYXNfX3ZhbHVlT2Y7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmdldCAgICAgICAgICAgID0gZHVyYXRpb25fZ2V0X19nZXQ7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5taWxsaXNlY29uZHMgICA9IGR1cmF0aW9uX2dldF9fbWlsbGlzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uc2Vjb25kcyAgICAgICAgPSBzZWNvbmRzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubWludXRlcyAgICAgICAgPSBtaW51dGVzO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8uaG91cnMgICAgICAgICAgPSBob3VycztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmRheXMgICAgICAgICAgID0gZGF5cztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLndlZWtzICAgICAgICAgID0gd2Vla3M7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5tb250aHMgICAgICAgICA9IG1vbnRocztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnllYXJzICAgICAgICAgID0geWVhcnM7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5odW1hbml6ZSAgICAgICA9IGh1bWFuaXplO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8udG9JU09TdHJpbmcgICAgPSBpc29fc3RyaW5nX190b0lTT1N0cmluZztcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvU3RyaW5nICAgICAgID0gaXNvX3N0cmluZ19fdG9JU09TdHJpbmc7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by50b0pTT04gICAgICAgICA9IGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nO1xuICAgIGR1cmF0aW9uX3Byb3RvdHlwZV9fcHJvdG8ubG9jYWxlICAgICAgICAgPSBsb2NhbGU7XG4gICAgZHVyYXRpb25fcHJvdG90eXBlX19wcm90by5sb2NhbGVEYXRhICAgICA9IGxvY2FsZURhdGE7XG5cbiAgICAvLyBEZXByZWNhdGlvbnNcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLnRvSXNvU3RyaW5nID0gZGVwcmVjYXRlKCd0b0lzb1N0cmluZygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdG9JU09TdHJpbmcoKSBpbnN0ZWFkIChub3RpY2UgdGhlIGNhcGl0YWxzKScsIGlzb19zdHJpbmdfX3RvSVNPU3RyaW5nKTtcbiAgICBkdXJhdGlvbl9wcm90b3R5cGVfX3Byb3RvLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnZlcnNpb24gPSAnMi4xMC4yJztcblxuICAgIHNldEhvb2tDYWxsYmFjayhsb2NhbF9fY3JlYXRlTG9jYWwpO1xuXG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IG1vbWVudFByb3RvdHlwZTtcbiAgICB1dGlsc19ob29rc19faG9va3MubWluICAgICAgICAgICAgICAgICAgID0gbWluO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZV91dGNfX2NyZWF0ZVVUQztcbiAgICB1dGlsc19ob29rc19faG9va3MudW5peCAgICAgICAgICAgICAgICAgID0gbW9tZW50X19jcmVhdGVVbml4O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHMgICAgICAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRocztcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGUgICAgICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0U2V0R2xvYmFsTG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSB2YWxpZF9fY3JlYXRlSW52YWxpZDtcbiAgICB1dGlsc19ob29rc19faG9va3MuZHVyYXRpb24gICAgICAgICAgICAgID0gY3JlYXRlX19jcmVhdGVEdXJhdGlvbjtcbiAgICB1dGlsc19ob29rc19faG9va3MuaXNNb21lbnQgICAgICAgICAgICAgID0gaXNNb21lbnQ7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnBhcnNlWm9uZSAgICAgICAgICAgICA9IG1vbWVudF9fY3JlYXRlSW5ab25lO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5sb2NhbGVEYXRhICAgICAgICAgICAgPSBsb2NhbGVfbG9jYWxlc19fZ2V0TG9jYWxlO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5pc0R1cmF0aW9uICAgICAgICAgICAgPSBpc0R1cmF0aW9uO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5tb250aHNTaG9ydCAgICAgICAgICAgPSBsaXN0c19fbGlzdE1vbnRoc1Nob3J0O1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy53ZWVrZGF5c01pbiAgICAgICAgICAgPSBsaXN0c19fbGlzdFdlZWtkYXlzTWluO1xuICAgIHV0aWxzX2hvb2tzX19ob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RzX19saXN0V2Vla2RheXNTaG9ydDtcbiAgICB1dGlsc19ob29rc19faG9va3Mubm9ybWFsaXplVW5pdHMgICAgICAgID0gbm9ybWFsaXplVW5pdHM7XG4gICAgdXRpbHNfaG9va3NfX2hvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGR1cmF0aW9uX2h1bWFuaXplX19nZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQ7XG5cbiAgICB2YXIgX21vbWVudCA9IHV0aWxzX2hvb2tzX19ob29rcztcblxuICAgIHJldHVybiBfbW9tZW50O1xuXG59KSk7IiwidmFyIFN2Z1Bhblpvb20gPSByZXF1aXJlKCcuL3N2Zy1wYW4tem9vbS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN2Z1Bhblpvb207XG4iLCJ2YXIgU3ZnVXRpbHMgPSByZXF1aXJlKCcuL3N2Zy11dGlsaXRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGVuYWJsZTogZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICAvLyBTZWxlY3QgKGFuZCBjcmVhdGUgaWYgbmVjZXNzYXJ5KSBkZWZzXG4gICAgdmFyIGRlZnMgPSBpbnN0YW5jZS5zdmcucXVlcnlTZWxlY3RvcignZGVmcycpXG4gICAgaWYgKCFkZWZzKSB7XG4gICAgICBkZWZzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFN2Z1V0aWxzLnN2Z05TLCAnZGVmcycpXG4gICAgICBpbnN0YW5jZS5zdmcuYXBwZW5kQ2hpbGQoZGVmcylcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgc3R5bGUgZWxlbWVudFxuICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTdmdVdGlscy5zdmdOUywgJ3N0eWxlJylcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dC9jc3MnKVxuICAgIHN0eWxlLnRleHRDb250ZW50ID0gJy5zdmctcGFuLXpvb20tY29udHJvbCB7IGN1cnNvcjogcG9pbnRlcjsgZmlsbDogYmxhY2s7IGZpbGwtb3BhY2l0eTogMC4zMzM7IH0gLnN2Zy1wYW4tem9vbS1jb250cm9sOmhvdmVyIHsgZmlsbC1vcGFjaXR5OiAwLjg7IH0gLnN2Zy1wYW4tem9vbS1jb250cm9sLWJhY2tncm91bmQgeyBmaWxsOiB3aGl0ZTsgZmlsbC1vcGFjaXR5OiAwLjU7IH0gLnN2Zy1wYW4tem9vbS1jb250cm9sLWJhY2tncm91bmQgeyBmaWxsLW9wYWNpdHk6IDAuODsgfSdcbiAgICBkZWZzLmFwcGVuZENoaWxkKHN0eWxlKVxuXG5cbiAgICAvLyBab29tIEdyb3VwXG4gICAgdmFyIHpvb21Hcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTdmdVdGlscy5zdmdOUywgJ2cnKTtcbiAgICB6b29tR3JvdXAuc2V0QXR0cmlidXRlKCdpZCcsICdzdmctcGFuLXpvb20tY29udHJvbHMnKTtcbiAgICB6b29tR3JvdXAuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyAoIGluc3RhbmNlLndpZHRoIC0gNzAgKSArICcgJyArICggaW5zdGFuY2UuaGVpZ2h0IC0gNzYgKSArICcpIHNjYWxlKDAuNzUpJyk7XG4gICAgem9vbUdyb3VwLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc3ZnLXBhbi16b29tLWNvbnRyb2wnKTtcblxuICAgIC8vIENvbnRyb2wgZWxlbWVudHNcbiAgICB6b29tR3JvdXAuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlWm9vbUluKGluc3RhbmNlKSlcbiAgICB6b29tR3JvdXAuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlWm9vbVJlc2V0KGluc3RhbmNlKSlcbiAgICB6b29tR3JvdXAuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlWm9vbU91dChpbnN0YW5jZSkpXG5cbiAgICAvLyBGaW5hbGx5IGFwcGVuZCBjcmVhdGVkIGVsZW1lbnRcbiAgICBpbnN0YW5jZS5zdmcuYXBwZW5kQ2hpbGQoem9vbUdyb3VwKVxuXG4gICAgLy8gQ2FjaGUgY29udHJvbCBpbnN0YW5jZVxuICAgIGluc3RhbmNlLmNvbnRyb2xJY29ucyA9IHpvb21Hcm91cFxuICB9XG5cbiwgX2NyZWF0ZVpvb21JbjogZnVuY3Rpb24oaW5zdGFuY2UpIHtcbiAgICB2YXIgem9vbUluID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFN2Z1V0aWxzLnN2Z05TLCAnZycpO1xuICAgIHpvb21Jbi5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3N2Zy1wYW4tem9vbS16b29tLWluJyk7XG4gICAgem9vbUluLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgzMC41IDUpIHNjYWxlKDAuMDE1KScpO1xuICAgIHpvb21Jbi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3N2Zy1wYW4tem9vbS1jb250cm9sJyk7XG4gICAgem9vbUluLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7aW5zdGFuY2UuZ2V0UHVibGljSW5zdGFuY2UoKS56b29tSW4oKX0sIGZhbHNlKVxuICAgIHpvb21Jbi5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7aW5zdGFuY2UuZ2V0UHVibGljSW5zdGFuY2UoKS56b29tSW4oKX0sIGZhbHNlKVxuXG4gICAgdmFyIHpvb21JbkJhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU3ZnVXRpbHMuc3ZnTlMsICdyZWN0Jyk7IC8vIFRPRE8gY2hhbmdlIHRoZXNlIGJhY2tncm91bmQgc3BhY2UgZmlsbGVycyB0byByb3VuZGVkIHJlY3RhbmdsZXMgc28gdGhleSBsb29rIHByZXR0aWVyXG4gICAgem9vbUluQmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ3gnLCAnMCcpO1xuICAgIHpvb21JbkJhY2tncm91bmQuc2V0QXR0cmlidXRlKCd5JywgJzAnKTtcbiAgICB6b29tSW5CYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMTUwMCcpOyAvLyBsYXJnZXIgdGhhbiBleHBlY3RlZCBiZWNhdXNlIHRoZSB3aG9sZSBncm91cCBpcyB0cmFuc2Zvcm1lZCB0byBzY2FsZSBkb3duXG4gICAgem9vbUluQmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxNDAwJyk7XG4gICAgem9vbUluQmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3N2Zy1wYW4tem9vbS1jb250cm9sLWJhY2tncm91bmQnKTtcbiAgICB6b29tSW4uYXBwZW5kQ2hpbGQoem9vbUluQmFja2dyb3VuZCk7XG5cbiAgICB2YXIgem9vbUluU2hhcGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU3ZnVXRpbHMuc3ZnTlMsICdwYXRoJyk7XG4gICAgem9vbUluU2hhcGUuc2V0QXR0cmlidXRlKCdkJywgJ00xMjgwIDU3NnYxMjhxMCAyNiAtMTkgNDV0LTQ1IDE5aC0zMjB2MzIwcTAgMjYgLTE5IDQ1dC00NSAxOWgtMTI4cS0yNiAwIC00NSAtMTl0LTE5IC00NXYtMzIwaC0zMjBxLTI2IDAgLTQ1IC0xOXQtMTkgLTQ1di0xMjhxMCAtMjYgMTkgLTQ1dDQ1IC0xOWgzMjB2LTMyMHEwIC0yNiAxOSAtNDV0NDUgLTE5aDEyOHEyNiAwIDQ1IDE5dDE5IDQ1djMyMGgzMjBxMjYgMCA0NSAxOXQxOSA0NXpNMTUzNiAxMTIwdi05NjAgcTAgLTExOSAtODQuNSAtMjAzLjV0LTIwMy41IC04NC41aC05NjBxLTExOSAwIC0yMDMuNSA4NC41dC04NC41IDIwMy41djk2MHEwIDExOSA4NC41IDIwMy41dDIwMy41IDg0LjVoOTYwcTExOSAwIDIwMy41IC04NC41dDg0LjUgLTIwMy41eicpO1xuICAgIHpvb21JblNoYXBlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc3ZnLXBhbi16b29tLWNvbnRyb2wtZWxlbWVudCcpO1xuICAgIHpvb21Jbi5hcHBlbmRDaGlsZCh6b29tSW5TaGFwZSk7XG5cbiAgICByZXR1cm4gem9vbUluXG4gIH1cblxuLCBfY3JlYXRlWm9vbVJlc2V0OiBmdW5jdGlvbihpbnN0YW5jZSl7XG4gICAgLy8gcmVzZXRcbiAgICB2YXIgcmVzZXRQYW5ab29tQ29udHJvbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTdmdVdGlscy5zdmdOUywgJ2cnKTtcbiAgICByZXNldFBhblpvb21Db250cm9sLnNldEF0dHJpYnV0ZSgnaWQnLCAnc3ZnLXBhbi16b29tLXJlc2V0LXBhbi16b29tJyk7XG4gICAgcmVzZXRQYW5ab29tQ29udHJvbC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoNSAzNSkgc2NhbGUoMC40KScpO1xuICAgIHJlc2V0UGFuWm9vbUNvbnRyb2wuc2V0QXR0cmlidXRlKCdjbGFzcycsICdzdmctcGFuLXpvb20tY29udHJvbCcpO1xuICAgIHJlc2V0UGFuWm9vbUNvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtpbnN0YW5jZS5nZXRQdWJsaWNJbnN0YW5jZSgpLnJlc2V0KCl9LCBmYWxzZSk7XG4gICAgcmVzZXRQYW5ab29tQ29udHJvbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oKSB7aW5zdGFuY2UuZ2V0UHVibGljSW5zdGFuY2UoKS5yZXNldCgpfSwgZmFsc2UpO1xuXG4gICAgdmFyIHJlc2V0UGFuWm9vbUNvbnRyb2xCYWNrZ3JvdW5kID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFN2Z1V0aWxzLnN2Z05TLCAncmVjdCcpOyAvLyBUT0RPIGNoYW5nZSB0aGVzZSBiYWNrZ3JvdW5kIHNwYWNlIGZpbGxlcnMgdG8gcm91bmRlZCByZWN0YW5nbGVzIHNvIHRoZXkgbG9vayBwcmV0dGllclxuICAgIHJlc2V0UGFuWm9vbUNvbnRyb2xCYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgneCcsICcyJyk7XG4gICAgcmVzZXRQYW5ab29tQ29udHJvbEJhY2tncm91bmQuc2V0QXR0cmlidXRlKCd5JywgJzInKTtcbiAgICByZXNldFBhblpvb21Db250cm9sQmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzE4MicpOyAvLyBsYXJnZXIgdGhhbiBleHBlY3RlZCBiZWNhdXNlIHRoZSB3aG9sZSBncm91cCBpcyB0cmFuc2Zvcm1lZCB0byBzY2FsZSBkb3duXG4gICAgcmVzZXRQYW5ab29tQ29udHJvbEJhY2tncm91bmQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnNTgnKTtcbiAgICByZXNldFBhblpvb21Db250cm9sQmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ3N2Zy1wYW4tem9vbS1jb250cm9sLWJhY2tncm91bmQnKTtcbiAgICByZXNldFBhblpvb21Db250cm9sLmFwcGVuZENoaWxkKHJlc2V0UGFuWm9vbUNvbnRyb2xCYWNrZ3JvdW5kKTtcblxuICAgIHZhciByZXNldFBhblpvb21Db250cm9sU2hhcGUxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFN2Z1V0aWxzLnN2Z05TLCAncGF0aCcpO1xuICAgIHJlc2V0UGFuWm9vbUNvbnRyb2xTaGFwZTEuc2V0QXR0cmlidXRlKCdkJywgJ00zMy4wNTEsMjAuNjMyYy0wLjc0Mi0wLjQwNi0xLjg1NC0wLjYwOS0zLjMzOC0wLjYwOWgtNy45Njl2OS4yODFoNy43NjljMS41NDMsMCwyLjcwMS0wLjE4OCwzLjQ3My0wLjU2MmMxLjM2NS0wLjY1NiwyLjA0OC0xLjk1MywyLjA0OC0zLjg5MUMzNS4wMzIsMjIuNzU3LDM0LjM3MiwyMS4zNTEsMzMuMDUxLDIwLjYzMnonKTtcbiAgICByZXNldFBhblpvb21Db250cm9sU2hhcGUxLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc3ZnLXBhbi16b29tLWNvbnRyb2wtZWxlbWVudCcpO1xuICAgIHJlc2V0UGFuWm9vbUNvbnRyb2wuYXBwZW5kQ2hpbGQocmVzZXRQYW5ab29tQ29udHJvbFNoYXBlMSk7XG5cbiAgICB2YXIgcmVzZXRQYW5ab29tQ29udHJvbFNoYXBlMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTdmdVdGlscy5zdmdOUywgJ3BhdGgnKTtcbiAgICByZXNldFBhblpvb21Db250cm9sU2hhcGUyLnNldEF0dHJpYnV0ZSgnZCcsICdNMTcwLjIzMSwwLjVIMTUuODQ3QzcuMTAyLDAuNSwwLjUsNS43MDgsMC41LDExLjg0djM4Ljg2MUMwLjUsNTYuODMzLDcuMTAyLDYxLjUsMTUuODQ3LDYxLjVoMTU0LjM4NGM4Ljc0NSwwLDE1LjI2OS00LjY2NywxNS4yNjktMTAuNzk4VjExLjg0QzE4NS41LDUuNzA4LDE3OC45NzYsMC41LDE3MC4yMzEsMC41eiBNNDIuODM3LDQ4LjU2OWgtNy45NjljLTAuMjE5LTAuNzY2LTAuMzc1LTEuMzgzLTAuNDY5LTEuODUyYy0wLjE4OC0wLjk2OS0wLjI4OS0xLjk2MS0wLjMwNS0yLjk3N2wtMC4wNDctMy4yMTFjLTAuMDMtMi4yMDMtMC40MS0zLjY3Mi0xLjE0Mi00LjQwNmMtMC43MzItMC43MzQtMi4xMDMtMS4xMDItNC4xMTMtMS4xMDJoLTcuMDV2MTMuNTQ3aC03LjA1NVYxNC4wMjJoMTYuNTI0YzIuMzYxLDAuMDQ3LDQuMTc4LDAuMzQ0LDUuNDUsMC44OTFjMS4yNzIsMC41NDcsMi4zNTEsMS4zNTIsMy4yMzQsMi40MTRjMC43MzEsMC44NzUsMS4zMSwxLjg0NCwxLjczNywyLjkwNnMwLjY0LDIuMjczLDAuNjQsMy42MzNjMCwxLjY0MS0wLjQxNCwzLjI1NC0xLjI0Miw0Ljg0cy0yLjE5NSwyLjcwNy00LjEwMiwzLjM2M2MxLjU5NCwwLjY0MSwyLjcyMywxLjU1MSwzLjM4NywyLjczczAuOTk2LDIuOTgsMC45OTYsNS40MDJ2Mi4zMmMwLDEuNTc4LDAuMDYzLDIuNjQ4LDAuMTksMy4yMTFjMC4xOSwwLjg5MSwwLjYzNSwxLjU0NywxLjMzMywxLjk2OVY0OC41Njl6IE03NS41NzksNDguNTY5aC0yNi4xOFYxNC4wMjJoMjUuMzM2djYuMTE3SDU2LjQ1NHY3LjMzNmgxNi43ODF2Nkg1Ni40NTR2OC44ODNoMTkuMTI1VjQ4LjU2OXogTTEwNC40OTcsNDYuMzMxYy0yLjQ0LDIuMDg2LTUuODg3LDMuMTI5LTEwLjM0LDMuMTI5Yy00LjU0OCwwLTguMTI1LTEuMDI3LTEwLjczMS0zLjA4MnMtMy45MDktNC44NzktMy45MDktOC40NzNoNi44OTFjMC4yMjQsMS41NzgsMC42NjIsMi43NTgsMS4zMTYsMy41MzljMS4xOTYsMS40MjIsMy4yNDYsMi4xMzMsNi4xNSwyLjEzM2MxLjczOSwwLDMuMTUxLTAuMTg4LDQuMjM2LTAuNTYyYzIuMDU4LTAuNzE5LDMuMDg3LTIuMDU1LDMuMDg3LTQuMDA4YzAtMS4xNDEtMC41MDQtMi4wMjMtMS41MTItMi42NDhjLTEuMDA4LTAuNjA5LTIuNjA3LTEuMTQ4LTQuNzk2LTEuNjE3bC0zLjc0LTAuODJjLTMuNjc2LTAuODEyLTYuMjAxLTEuNjk1LTcuNTc2LTIuNjQ4Yy0yLjMyOC0xLjU5NC0zLjQ5Mi00LjA4Ni0zLjQ5Mi03LjQ3N2MwLTMuMDk0LDEuMTM5LTUuNjY0LDMuNDE3LTcuNzExczUuNjIzLTMuMDcsMTAuMDM2LTMuMDdjMy42ODUsMCw2LjgyOSwwLjk2NSw5LjQzMSwyLjg5NWMyLjYwMiwxLjkzLDMuOTY2LDQuNzMsNC4wOTMsOC40MDJoLTYuOTM4Yy0wLjEyOC0yLjA3OC0xLjA1Ny0zLjU1NS0yLjc4Ny00LjQzYy0xLjE1NC0wLjU3OC0yLjU4Ny0wLjg2Ny00LjMwMS0wLjg2N2MtMS45MDcsMC0zLjQyOCwwLjM3NS00LjU2NSwxLjEyNWMtMS4xMzgsMC43NS0xLjcwNiwxLjc5Ny0xLjcwNiwzLjE0MWMwLDEuMjM0LDAuNTYxLDIuMTU2LDEuNjgyLDIuNzY2YzAuNzIxLDAuNDA2LDIuMjUsMC44ODMsNC41ODksMS40M2w2LjA2MywxLjQzYzIuNjU3LDAuNjI1LDQuNjQ4LDEuNDYxLDUuOTc1LDIuNTA4YzIuMDU5LDEuNjI1LDMuMDg5LDMuOTc3LDMuMDg5LDcuMDU1QzEwOC4xNTcsNDEuNjI0LDEwNi45MzcsNDQuMjQ1LDEwNC40OTcsNDYuMzMxeiBNMTM5LjYxLDQ4LjU2OWgtMjYuMThWMTQuMDIyaDI1LjMzNnY2LjExN2gtMTguMjgxdjcuMzM2aDE2Ljc4MXY2aC0xNi43ODF2OC44ODNoMTkuMTI1VjQ4LjU2OXogTTE3MC4zMzcsMjAuMTRoLTEwLjMzNnYyOC40M2gtNy4yNjZWMjAuMTRoLTEwLjM4M3YtNi4xMTdoMjcuOTg0VjIwLjE0eicpO1xuICAgIHJlc2V0UGFuWm9vbUNvbnRyb2xTaGFwZTIuc2V0QXR0cmlidXRlKCdjbGFzcycsICdzdmctcGFuLXpvb20tY29udHJvbC1lbGVtZW50Jyk7XG4gICAgcmVzZXRQYW5ab29tQ29udHJvbC5hcHBlbmRDaGlsZChyZXNldFBhblpvb21Db250cm9sU2hhcGUyKTtcblxuICAgIHJldHVybiByZXNldFBhblpvb21Db250cm9sXG4gIH1cblxuLCBfY3JlYXRlWm9vbU91dDogZnVuY3Rpb24oaW5zdGFuY2Upe1xuICAgIC8vIHpvb20gb3V0XG4gICAgdmFyIHpvb21PdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU3ZnVXRpbHMuc3ZnTlMsICdnJyk7XG4gICAgem9vbU91dC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3N2Zy1wYW4tem9vbS16b29tLW91dCcpO1xuICAgIHpvb21PdXQuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDMwLjUgNzApIHNjYWxlKDAuMDE1KScpO1xuICAgIHpvb21PdXQuc2V0QXR0cmlidXRlKCdjbGFzcycsICdzdmctcGFuLXpvb20tY29udHJvbCcpO1xuICAgIHpvb21PdXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtpbnN0YW5jZS5nZXRQdWJsaWNJbnN0YW5jZSgpLnpvb21PdXQoKX0sIGZhbHNlKTtcbiAgICB6b29tT3V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbigpIHtpbnN0YW5jZS5nZXRQdWJsaWNJbnN0YW5jZSgpLnpvb21PdXQoKX0sIGZhbHNlKTtcblxuICAgIHZhciB6b29tT3V0QmFja2dyb3VuZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTdmdVdGlscy5zdmdOUywgJ3JlY3QnKTsgLy8gVE9ETyBjaGFuZ2UgdGhlc2UgYmFja2dyb3VuZCBzcGFjZSBmaWxsZXJzIHRvIHJvdW5kZWQgcmVjdGFuZ2xlcyBzbyB0aGV5IGxvb2sgcHJldHRpZXJcbiAgICB6b29tT3V0QmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ3gnLCAnMCcpO1xuICAgIHpvb21PdXRCYWNrZ3JvdW5kLnNldEF0dHJpYnV0ZSgneScsICcwJyk7XG4gICAgem9vbU91dEJhY2tncm91bmQuc2V0QXR0cmlidXRlKCd3aWR0aCcsICcxNTAwJyk7IC8vIGxhcmdlciB0aGFuIGV4cGVjdGVkIGJlY2F1c2UgdGhlIHdob2xlIGdyb3VwIGlzIHRyYW5zZm9ybWVkIHRvIHNjYWxlIGRvd25cbiAgICB6b29tT3V0QmFja2dyb3VuZC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcxNDAwJyk7XG4gICAgem9vbU91dEJhY2tncm91bmQuc2V0QXR0cmlidXRlKCdjbGFzcycsICdzdmctcGFuLXpvb20tY29udHJvbC1iYWNrZ3JvdW5kJyk7XG4gICAgem9vbU91dC5hcHBlbmRDaGlsZCh6b29tT3V0QmFja2dyb3VuZCk7XG5cbiAgICB2YXIgem9vbU91dFNoYXBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFN2Z1V0aWxzLnN2Z05TLCAncGF0aCcpO1xuICAgIHpvb21PdXRTaGFwZS5zZXRBdHRyaWJ1dGUoJ2QnLCAnTTEyODAgNTc2djEyOHEwIDI2IC0xOSA0NXQtNDUgMTloLTg5NnEtMjYgMCAtNDUgLTE5dC0xOSAtNDV2LTEyOHEwIC0yNiAxOSAtNDV0NDUgLTE5aDg5NnEyNiAwIDQ1IDE5dDE5IDQ1ek0xNTM2IDExMjB2LTk2MHEwIC0xMTkgLTg0LjUgLTIwMy41dC0yMDMuNSAtODQuNWgtOTYwcS0xMTkgMCAtMjAzLjUgODQuNXQtODQuNSAyMDMuNXY5NjBxMCAxMTkgODQuNSAyMDMuNXQyMDMuNSA4NC41aDk2MHExMTkgMCAyMDMuNSAtODQuNSB0ODQuNSAtMjAzLjV6Jyk7XG4gICAgem9vbU91dFNoYXBlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnc3ZnLXBhbi16b29tLWNvbnRyb2wtZWxlbWVudCcpO1xuICAgIHpvb21PdXQuYXBwZW5kQ2hpbGQoem9vbU91dFNoYXBlKTtcblxuICAgIHJldHVybiB6b29tT3V0XG4gIH1cblxuLCBkaXNhYmxlOiBmdW5jdGlvbihpbnN0YW5jZSkge1xuICAgIGlmIChpbnN0YW5jZS5jb250cm9sSWNvbnMpIHtcbiAgICAgIGluc3RhbmNlLmNvbnRyb2xJY29ucy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGluc3RhbmNlLmNvbnRyb2xJY29ucylcbiAgICAgIGluc3RhbmNlLmNvbnRyb2xJY29ucyA9IG51bGxcbiAgICB9XG4gIH1cbn1cbiIsInZhciBTdmdVdGlscyA9IHJlcXVpcmUoJy4vc3ZnLXV0aWxpdGllcycpXG4gICwgVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxpdGllcycpXG4gIDtcblxudmFyIFNoYWRvd1ZpZXdwb3J0ID0gZnVuY3Rpb24odmlld3BvcnQsIG9wdGlvbnMpe1xuICB0aGlzLmluaXQodmlld3BvcnQsIG9wdGlvbnMpXG59XG5cbi8qKlxuICogSW5pdGlhbGl6YXRpb25cbiAqXG4gKiBAcGFyYW0gIHtTVkdFbGVtZW50fSB2aWV3cG9ydFxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRpb25zXG4gKi9cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24odmlld3BvcnQsIG9wdGlvbnMpIHtcbiAgLy8gRE9NIEVsZW1lbnRzXG4gIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydFxuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zXG5cbiAgLy8gU3RhdGUgY2FjaGVcbiAgdGhpcy5vcmlnaW5hbFN0YXRlID0ge3pvb206IDEsIHg6IDAsIHk6IDB9XG4gIHRoaXMuYWN0aXZlU3RhdGUgPSB7em9vbTogMSwgeDogMCwgeTogMH1cblxuICB0aGlzLnVwZGF0ZUNUTUNhY2hlZCA9IFV0aWxzLnByb3h5KHRoaXMudXBkYXRlQ1RNLCB0aGlzKVxuXG4gIC8vIENyZWF0ZSBhIGN1c3RvbSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgdGFraW5nIGluIGFjY291bnQgcmVmcmVzaFJhdGVcbiAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBVdGlscy5jcmVhdGVSZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5vcHRpb25zLnJlZnJlc2hSYXRlKVxuXG4gIC8vIFZpZXdCb3hcbiAgdGhpcy52aWV3Qm94ID0ge3g6IDAsIHk6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDB9XG4gIHRoaXMuY2FjaGVWaWV3Qm94KClcblxuICAvLyBQcm9jZXNzIENUTVxuICB0aGlzLnByb2Nlc3NDVE0oKVxufVxuXG4vKipcbiAqIENhY2hlIGluaXRpYWwgdmlld0JveCB2YWx1ZVxuICogSWYgbm8gdmlld0JveCBpcyBkZWZpbmVkLCB0aGVuIHVzZSB2aWV3cG9ydCBzaXplL3Bvc2l0aW9uIGluc3RlYWQgZm9yIHZpZXdCb3ggdmFsdWVzXG4gKi9cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS5jYWNoZVZpZXdCb3ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN2Z1ZpZXdCb3ggPSB0aGlzLm9wdGlvbnMuc3ZnLmdldEF0dHJpYnV0ZSgndmlld0JveCcpXG5cbiAgaWYgKHN2Z1ZpZXdCb3gpIHtcbiAgICB2YXIgdmlld0JveFZhbHVlcyA9IHN2Z1ZpZXdCb3guc3BsaXQoJyAnKS5tYXAocGFyc2VGbG9hdClcblxuICAgIC8vIENhY2hlIHZpZXdib3ggeCBhbmQgeSBvZmZzZXRcbiAgICB0aGlzLnZpZXdCb3gueCA9IHZpZXdCb3hWYWx1ZXNbMF1cbiAgICB0aGlzLnZpZXdCb3gueSA9IHZpZXdCb3hWYWx1ZXNbMV1cbiAgICB0aGlzLnZpZXdCb3gud2lkdGggPSB2aWV3Qm94VmFsdWVzWzJdXG4gICAgdGhpcy52aWV3Qm94LmhlaWdodCA9IHZpZXdCb3hWYWx1ZXNbM11cblxuICAgIHZhciB6b29tID0gTWF0aC5taW4odGhpcy5vcHRpb25zLndpZHRoIC8gdGhpcy52aWV3Qm94LndpZHRoLCB0aGlzLm9wdGlvbnMuaGVpZ2h0IC8gdGhpcy52aWV3Qm94LmhlaWdodClcblxuICAgIC8vIFVwZGF0ZSBhY3RpdmUgc3RhdGVcbiAgICB0aGlzLmFjdGl2ZVN0YXRlLnpvb20gPSB6b29tXG4gICAgdGhpcy5hY3RpdmVTdGF0ZS54ID0gKHRoaXMub3B0aW9ucy53aWR0aCAtIHRoaXMudmlld0JveC53aWR0aCAqIHpvb20pIC8gMlxuICAgIHRoaXMuYWN0aXZlU3RhdGUueSA9ICh0aGlzLm9wdGlvbnMuaGVpZ2h0IC0gdGhpcy52aWV3Qm94LmhlaWdodCAqIHpvb20pIC8gMlxuXG4gICAgLy8gRm9yY2UgdXBkYXRpbmcgQ1RNXG4gICAgdGhpcy51cGRhdGVDVE1Pbk5leHRGcmFtZSgpXG5cbiAgICB0aGlzLm9wdGlvbnMuc3ZnLnJlbW92ZUF0dHJpYnV0ZSgndmlld0JveCcpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGJCb3ggPSB0aGlzLnZpZXdwb3J0LmdldEJCb3goKTtcblxuICAgIC8vIENhY2hlIHZpZXdib3ggc2l6ZXNcbiAgICB0aGlzLnZpZXdCb3gueCA9IGJCb3gueDtcbiAgICB0aGlzLnZpZXdCb3gueSA9IGJCb3gueTtcbiAgICB0aGlzLnZpZXdCb3gud2lkdGggPSBiQm94LndpZHRoXG4gICAgdGhpcy52aWV3Qm94LmhlaWdodCA9IGJCb3guaGVpZ2h0XG4gIH1cbn1cblxuLyoqXG4gKiBSZWNhbGN1bGF0ZSB2aWV3cG9ydCBzaXplcyBhbmQgdXBkYXRlIHZpZXdCb3ggY2FjaGVcbiAqL1xuU2hhZG93Vmlld3BvcnQucHJvdG90eXBlLnJlY2FjaGVWaWV3Qm94ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBib3VuZGluZ0NsaWVudFJlY3QgPSB0aGlzLnZpZXdwb3J0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgLCB2aWV3Qm94V2lkdGggPSBib3VuZGluZ0NsaWVudFJlY3Qud2lkdGggLyB0aGlzLmdldFpvb20oKVxuICAgICwgdmlld0JveEhlaWdodCA9IGJvdW5kaW5nQ2xpZW50UmVjdC5oZWlnaHQgLyB0aGlzLmdldFpvb20oKVxuXG4gIC8vIENhY2hlIHZpZXdib3hcbiAgdGhpcy52aWV3Qm94LnggPSAwXG4gIHRoaXMudmlld0JveC55ID0gMFxuICB0aGlzLnZpZXdCb3gud2lkdGggPSB2aWV3Qm94V2lkdGhcbiAgdGhpcy52aWV3Qm94LmhlaWdodCA9IHZpZXdCb3hIZWlnaHRcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdmlld2JveCBvYmplY3QuIFNhZmUgdG8gYWx0ZXJcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHZpZXdib3ggb2JqZWN0XG4gKi9cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS5nZXRWaWV3Qm94ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBVdGlscy5leHRlbmQoe30sIHRoaXMudmlld0JveClcbn1cblxuLyoqXG4gKiBHZXQgaW5pdGlhbCB6b29tIGFuZCBwYW4gdmFsdWVzLiBTYXZlIHRoZW0gaW50byBvcmlnaW5hbFN0YXRlXG4gKiBQYXJzZXMgdmlld0JveCBhdHRyaWJ1dGUgdG8gYWx0ZXIgaW5pdGlhbCBzaXplc1xuICovXG5TaGFkb3dWaWV3cG9ydC5wcm90b3R5cGUucHJvY2Vzc0NUTSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbmV3Q1RNID0gdGhpcy5nZXRDVE0oKVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuZml0KSB7XG4gICAgdmFyIG5ld1NjYWxlID0gTWF0aC5taW4odGhpcy5vcHRpb25zLndpZHRoLyh0aGlzLnZpZXdCb3gud2lkdGggLSB0aGlzLnZpZXdCb3gueCksIHRoaXMub3B0aW9ucy5oZWlnaHQvKHRoaXMudmlld0JveC5oZWlnaHQgLSB0aGlzLnZpZXdCb3gueSkpO1xuXG4gICAgbmV3Q1RNLmEgPSBuZXdTY2FsZTsgLy94LXNjYWxlXG4gICAgbmV3Q1RNLmQgPSBuZXdTY2FsZTsgLy95LXNjYWxlXG4gICAgbmV3Q1RNLmUgPSAtdGhpcy52aWV3Qm94LnggKiBuZXdTY2FsZTsgLy94LXRyYW5zZm9ybVxuICAgIG5ld0NUTS5mID0gLXRoaXMudmlld0JveC55ICogbmV3U2NhbGU7IC8veS10cmFuc2Zvcm1cbiAgfVxuXG4gIGlmICh0aGlzLm9wdGlvbnMuY2VudGVyKSB7XG4gICAgdmFyIG9mZnNldFggPSAodGhpcy5vcHRpb25zLndpZHRoIC0gKHRoaXMudmlld0JveC53aWR0aCArIHRoaXMudmlld0JveC54KSAqIG5ld0NUTS5hKSAqIDAuNVxuICAgICAgLCBvZmZzZXRZID0gKHRoaXMub3B0aW9ucy5oZWlnaHQgLSAodGhpcy52aWV3Qm94LmhlaWdodCArIHRoaXMudmlld0JveC55KSAqIG5ld0NUTS5hKSAqIDAuNVxuXG4gICAgbmV3Q1RNLmUgPSBvZmZzZXRYXG4gICAgbmV3Q1RNLmYgPSBvZmZzZXRZXG4gIH1cblxuICAvLyBDYWNoZSBpbml0aWFsIHZhbHVlcy4gQmFzZWQgb24gYWN0aXZlU3RhdGUgYW5kIGZpeCtjZW50ZXIgb3BpdG9uc1xuICB0aGlzLm9yaWdpbmFsU3RhdGUuem9vbSA9IG5ld0NUTS5hXG4gIHRoaXMub3JpZ2luYWxTdGF0ZS54ID0gbmV3Q1RNLmVcbiAgdGhpcy5vcmlnaW5hbFN0YXRlLnkgPSBuZXdDVE0uZlxuXG4gIC8vIFVwZGF0ZSB2aWV3cG9ydCBDVE0gYW5kIGNhY2hlIHpvb20gYW5kIHBhblxuICB0aGlzLnNldENUTShuZXdDVE0pO1xufVxuXG4vKipcbiAqIFJldHVybiBvcmlnaW5hbFN0YXRlIG9iamVjdC4gU2FmZSB0byBhbHRlclxuICpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuU2hhZG93Vmlld3BvcnQucHJvdG90eXBlLmdldE9yaWdpbmFsU3RhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFV0aWxzLmV4dGVuZCh7fSwgdGhpcy5vcmlnaW5hbFN0YXRlKVxufVxuXG4vKipcbiAqIFJldHVybiBhY3R1YWxTdGF0ZSBvYmplY3QuIFNhZmUgdG8gYWx0ZXJcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS5nZXRTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gVXRpbHMuZXh0ZW5kKHt9LCB0aGlzLmFjdGl2ZVN0YXRlKVxufVxuXG4vKipcbiAqIEdldCB6b29tIHNjYWxlXG4gKlxuICogQHJldHVybiB7RmxvYXR9IHpvb20gc2NhbGVcbiAqL1xuU2hhZG93Vmlld3BvcnQucHJvdG90eXBlLmdldFpvb20gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYWN0aXZlU3RhdGUuem9vbVxufVxuXG4vKipcbiAqIEdldCB6b29tIHNjYWxlIGZvciBwdWJpbGMgdXNhZ2VcbiAqXG4gKiBAcmV0dXJuIHtGbG9hdH0gem9vbSBzY2FsZVxuICovXG5TaGFkb3dWaWV3cG9ydC5wcm90b3R5cGUuZ2V0UmVsYXRpdmVab29tID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmFjdGl2ZVN0YXRlLnpvb20gLyB0aGlzLm9yaWdpbmFsU3RhdGUuem9vbVxufVxuXG4vKipcbiAqIENvbXB1dGUgem9vbSBzY2FsZSBmb3IgcHViaWxjIHVzYWdlXG4gKlxuICogQHJldHVybiB7RmxvYXR9IHpvb20gc2NhbGVcbiAqL1xuU2hhZG93Vmlld3BvcnQucHJvdG90eXBlLmNvbXB1dGVSZWxhdGl2ZVpvb20gPSBmdW5jdGlvbihzY2FsZSkge1xuICByZXR1cm4gc2NhbGUgLyB0aGlzLm9yaWdpbmFsU3RhdGUuem9vbVxufVxuXG4vKipcbiAqIEdldCBwYW5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS5nZXRQYW4gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHt4OiB0aGlzLmFjdGl2ZVN0YXRlLngsIHk6IHRoaXMuYWN0aXZlU3RhdGUueX1cbn1cblxuLyoqXG4gKiBSZXR1cm4gY2FjaGVkIHZpZXdwb3J0IENUTSB2YWx1ZSB0aGF0IGNhbiBiZSBzYWZlbHkgbW9kaWZpZWRcbiAqXG4gKiBAcmV0dXJuIHtTVkdNYXRyaXh9XG4gKi9cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS5nZXRDVE0gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNhZmVDVE0gPSB0aGlzLm9wdGlvbnMuc3ZnLmNyZWF0ZVNWR01hdHJpeCgpXG5cbiAgLy8gQ29weSB2YWx1ZXMgbWFudWFsbHkgYXMgaW4gRkYgdGhleSBhcmUgbm90IGl0dGVyYWJsZVxuICBzYWZlQ1RNLmEgPSB0aGlzLmFjdGl2ZVN0YXRlLnpvb21cbiAgc2FmZUNUTS5iID0gMFxuICBzYWZlQ1RNLmMgPSAwXG4gIHNhZmVDVE0uZCA9IHRoaXMuYWN0aXZlU3RhdGUuem9vbVxuICBzYWZlQ1RNLmUgPSB0aGlzLmFjdGl2ZVN0YXRlLnhcbiAgc2FmZUNUTS5mID0gdGhpcy5hY3RpdmVTdGF0ZS55XG5cbiAgcmV0dXJuIHNhZmVDVE1cbn1cblxuLyoqXG4gKiBTZXQgYSBuZXcgQ1RNXG4gKlxuICogQHBhcmFtIHtTVkdNYXRyaXh9IG5ld0NUTVxuICovXG5TaGFkb3dWaWV3cG9ydC5wcm90b3R5cGUuc2V0Q1RNID0gZnVuY3Rpb24obmV3Q1RNKSB7XG4gIHZhciB3aWxsWm9vbSA9IHRoaXMuaXNab29tRGlmZmVyZW50KG5ld0NUTSlcbiAgICAsIHdpbGxQYW4gPSB0aGlzLmlzUGFuRGlmZmVyZW50KG5ld0NUTSlcblxuICBpZiAod2lsbFpvb20gfHwgd2lsbFBhbikge1xuICAgIC8vIEJlZm9yZSB6b29tXG4gICAgaWYgKHdpbGxab29tKSB7XG4gICAgICAvLyBJZiByZXR1cm5zIGZhbHNlIHRoZW4gY2FuY2VsIHpvb21pbmdcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmVmb3JlWm9vbSh0aGlzLmdldFJlbGF0aXZlWm9vbSgpLCB0aGlzLmNvbXB1dGVSZWxhdGl2ZVpvb20obmV3Q1RNLmEpKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbmV3Q1RNLmEgPSBuZXdDVE0uZCA9IHRoaXMuYWN0aXZlU3RhdGUuem9vbVxuICAgICAgICB3aWxsWm9vbSA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQmVmb3JlIHBhblxuICAgIGlmICh3aWxsUGFuKSB7XG4gICAgICB2YXIgcHJldmVudFBhbiA9IHRoaXMub3B0aW9ucy5iZWZvcmVQYW4odGhpcy5nZXRQYW4oKSwge3g6IG5ld0NUTS5lLCB5OiBuZXdDVE0uZn0pXG4gICAgICAgICAgLy8gSWYgcHJldmVudCBwYW4gaXMgYW4gb2JqZWN0XG4gICAgICAgICwgcHJldmVudFBhblggPSBmYWxzZVxuICAgICAgICAsIHByZXZlbnRQYW5ZID0gZmFsc2VcblxuICAgICAgLy8gSWYgcHJldmVudCBwYW4gaXMgQm9vbGVhbiBmYWxzZVxuICAgICAgaWYgKHByZXZlbnRQYW4gPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIFNldCB4IGFuZCB5IHNhbWUgYXMgYmVmb3JlXG4gICAgICAgIG5ld0NUTS5lID0gdGhpcy5nZXRQYW4oKS54XG4gICAgICAgIG5ld0NUTS5mID0gdGhpcy5nZXRQYW4oKS55XG5cbiAgICAgICAgcHJldmVudFBhblggPSBwcmV2ZW50UGFuWSA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoVXRpbHMuaXNPYmplY3QocHJldmVudFBhbikpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIFggYXhlcyBhdHRyaWJ1dGVcbiAgICAgICAgaWYgKHByZXZlbnRQYW4ueCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyBQcmV2ZW50IHBhbm5pbmcgb24geCBheGVzXG4gICAgICAgICAgbmV3Q1RNLmUgPSB0aGlzLmdldFBhbigpLnhcbiAgICAgICAgICBwcmV2ZW50UGFuWCA9IHRydWVcbiAgICAgICAgfSBlbHNlIGlmIChVdGlscy5pc051bWJlcihwcmV2ZW50UGFuLngpKSB7XG4gICAgICAgICAgLy8gU2V0IGEgY3VzdG9tIHBhbiB2YWx1ZVxuICAgICAgICAgIG5ld0NUTS5lID0gcHJldmVudFBhbi54XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgWSBheGVzIGF0dHJpYnV0ZVxuICAgICAgICBpZiAocHJldmVudFBhbi55ID09PSBmYWxzZSkge1xuICAgICAgICAgIC8vIFByZXZlbnQgcGFubmluZyBvbiB4IGF4ZXNcbiAgICAgICAgICBuZXdDVE0uZiA9IHRoaXMuZ2V0UGFuKCkueVxuICAgICAgICAgIHByZXZlbnRQYW5ZID0gdHJ1ZVxuICAgICAgICB9IGVsc2UgaWYgKFV0aWxzLmlzTnVtYmVyKHByZXZlbnRQYW4ueSkpIHtcbiAgICAgICAgICAvLyBTZXQgYSBjdXN0b20gcGFuIHZhbHVlXG4gICAgICAgICAgbmV3Q1RNLmYgPSBwcmV2ZW50UGFuLnlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgd2lsbFBhbiBmbGFnXG4gICAgICBpZiAocHJldmVudFBhblggJiYgcHJldmVudFBhblkpIHtcbiAgICAgICAgd2lsbFBhbiA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgYWdhaW4gaWYgc2hvdWxkIHpvb20gb3IgcGFuXG4gICAgaWYgKHdpbGxab29tIHx8IHdpbGxQYW4pIHtcbiAgICAgIHRoaXMudXBkYXRlQ2FjaGUobmV3Q1RNKVxuXG4gICAgICB0aGlzLnVwZGF0ZUNUTU9uTmV4dEZyYW1lKClcblxuICAgICAgLy8gQWZ0ZXIgY2FsbGJhY2tzXG4gICAgICBpZiAod2lsbFpvb20pIHt0aGlzLm9wdGlvbnMub25ab29tKHRoaXMuZ2V0UmVsYXRpdmVab29tKCkpfVxuICAgICAgaWYgKHdpbGxQYW4pIHt0aGlzLm9wdGlvbnMub25QYW4odGhpcy5nZXRQYW4oKSl9XG4gICAgfVxuICB9XG59XG5cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS5pc1pvb21EaWZmZXJlbnQgPSBmdW5jdGlvbihuZXdDVE0pIHtcbiAgcmV0dXJuIHRoaXMuYWN0aXZlU3RhdGUuem9vbSAhPT0gbmV3Q1RNLmFcbn1cblxuU2hhZG93Vmlld3BvcnQucHJvdG90eXBlLmlzUGFuRGlmZmVyZW50ID0gZnVuY3Rpb24obmV3Q1RNKSB7XG4gIHJldHVybiB0aGlzLmFjdGl2ZVN0YXRlLnggIT09IG5ld0NUTS5lIHx8IHRoaXMuYWN0aXZlU3RhdGUueSAhPT0gbmV3Q1RNLmZcbn1cblxuXG4vKipcbiAqIFVwZGF0ZSBjYWNoZWQgQ1RNIGFuZCBhY3RpdmUgc3RhdGVcbiAqXG4gKiBAcGFyYW0ge1NWR01hdHJpeH0gbmV3Q1RNXG4gKi9cblNoYWRvd1ZpZXdwb3J0LnByb3RvdHlwZS51cGRhdGVDYWNoZSA9IGZ1bmN0aW9uKG5ld0NUTSkge1xuICB0aGlzLmFjdGl2ZVN0YXRlLnpvb20gPSBuZXdDVE0uYVxuICB0aGlzLmFjdGl2ZVN0YXRlLnggPSBuZXdDVE0uZVxuICB0aGlzLmFjdGl2ZVN0YXRlLnkgPSBuZXdDVE0uZlxufVxuXG5TaGFkb3dWaWV3cG9ydC5wcm90b3R5cGUucGVuZGluZ1VwZGF0ZSA9IGZhbHNlXG5cbi8qKlxuICogUGxhY2UgYSByZXF1ZXN0IHRvIHVwZGF0ZSBDVE0gb24gbmV4dCBGcmFtZVxuICovXG5TaGFkb3dWaWV3cG9ydC5wcm90b3R5cGUudXBkYXRlQ1RNT25OZXh0RnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLnBlbmRpbmdVcGRhdGUpIHtcbiAgICAvLyBMb2NrXG4gICAgdGhpcy5wZW5kaW5nVXBkYXRlID0gdHJ1ZVxuXG4gICAgLy8gVGhyb3R0bGUgbmV4dCB1cGRhdGVcbiAgICB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgdGhpcy51cGRhdGVDVE1DYWNoZWQpXG4gIH1cbn1cblxuLyoqXG4gKiBVcGRhdGUgdmlld3BvcnQgQ1RNIHdpdGggY2FjaGVkIENUTVxuICovXG5TaGFkb3dWaWV3cG9ydC5wcm90b3R5cGUudXBkYXRlQ1RNID0gZnVuY3Rpb24oKSB7XG4gIC8vIFVwZGF0ZXMgU1ZHIGVsZW1lbnRcbiAgU3ZnVXRpbHMuc2V0Q1RNKHRoaXMudmlld3BvcnQsIHRoaXMuZ2V0Q1RNKCksIHRoaXMuZGVmcylcblxuICAvLyBGcmVlIHRoZSBsb2NrXG4gIHRoaXMucGVuZGluZ1VwZGF0ZSA9IGZhbHNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmlld3BvcnQsIG9wdGlvbnMpe1xuICByZXR1cm4gbmV3IFNoYWRvd1ZpZXdwb3J0KHZpZXdwb3J0LCBvcHRpb25zKVxufVxuIiwidmFyIFdoZWVsID0gcmVxdWlyZSgnLi91bml3aGVlbCcpXG4sIENvbnRyb2xJY29ucyA9IHJlcXVpcmUoJy4vY29udHJvbC1pY29ucycpXG4sIFV0aWxzID0gcmVxdWlyZSgnLi91dGlsaXRpZXMnKVxuLCBTdmdVdGlscyA9IHJlcXVpcmUoJy4vc3ZnLXV0aWxpdGllcycpXG4sIFNoYWRvd1ZpZXdwb3J0ID0gcmVxdWlyZSgnLi9zaGFkb3ctdmlld3BvcnQnKVxuXG52YXIgU3ZnUGFuWm9vbSA9IGZ1bmN0aW9uKHN2Zywgb3B0aW9ucykge1xuICB0aGlzLmluaXQoc3ZnLCBvcHRpb25zKVxufVxuXG52YXIgb3B0aW9uc0RlZmF1bHRzID0ge1xuICB2aWV3cG9ydFNlbGVjdG9yOiAnLnN2Zy1wYW4tem9vbV92aWV3cG9ydCcgLy8gVmlld3BvcnQgc2VsZWN0b3IuIENhbiBiZSBxdWVyeVNlbGVjdG9yIHN0cmluZyBvciBTVkdFbGVtZW50XG4sIHBhbkVuYWJsZWQ6IHRydWUgLy8gZW5hYmxlIG9yIGRpc2FibGUgcGFubmluZyAoZGVmYXVsdCBlbmFibGVkKVxuLCBjb250cm9sSWNvbnNFbmFibGVkOiBmYWxzZSAvLyBpbnNlcnQgaWNvbnMgdG8gZ2l2ZSB1c2VyIGFuIG9wdGlvbiBpbiBhZGRpdGlvbiB0byBtb3VzZSBldmVudHMgdG8gY29udHJvbCBwYW4vem9vbSAoZGVmYXVsdCBkaXNhYmxlZClcbiwgem9vbUVuYWJsZWQ6IHRydWUgLy8gZW5hYmxlIG9yIGRpc2FibGUgem9vbWluZyAoZGVmYXVsdCBlbmFibGVkKVxuLCBkYmxDbGlja1pvb21FbmFibGVkOiB0cnVlIC8vIGVuYWJsZSBvciBkaXNhYmxlIHpvb21pbmcgYnkgZG91YmxlIGNsaWNraW5nIChkZWZhdWx0IGVuYWJsZWQpXG4sIG1vdXNlV2hlZWxab29tRW5hYmxlZDogdHJ1ZSAvLyBlbmFibGUgb3IgZGlzYWJsZSB6b29taW5nIGJ5IG1vdXNlIHdoZWVsIChkZWZhdWx0IGVuYWJsZWQpXG4sIHpvb21TY2FsZVNlbnNpdGl2aXR5OiAwLjIgLy8gWm9vbSBzZW5zaXRpdml0eVxuLCBtaW5ab29tOiAwLjUgLy8gTWluaW11bSBab29tIGxldmVsXG4sIG1heFpvb206IDEwIC8vIE1heGltdW0gWm9vbSBsZXZlbFxuLCBmaXQ6IHRydWUgLy8gZW5hYmxlIG9yIGRpc2FibGUgdmlld3BvcnQgZml0IGluIFNWRyAoZGVmYXVsdCB0cnVlKVxuLCBjZW50ZXI6IHRydWUgLy8gZW5hYmxlIG9yIGRpc2FibGUgdmlld3BvcnQgY2VudGVyaW5nIGluIFNWRyAoZGVmYXVsdCB0cnVlKVxuLCByZWZyZXNoUmF0ZTogJ2F1dG8nIC8vIE1heGltdW0gbnVtYmVyIG9mIGZyYW1lcyBwZXIgc2Vjb25kIChhbHRlcmluZyBTVkcncyB2aWV3cG9ydClcbiwgYmVmb3JlWm9vbTogbnVsbFxuLCBvblpvb206IG51bGxcbiwgYmVmb3JlUGFuOiBudWxsXG4sIG9uUGFuOiBudWxsXG4sIGN1c3RvbUV2ZW50c0hhbmRsZXI6IG51bGxcbn1cblxuU3ZnUGFuWm9vbS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKHN2Zywgb3B0aW9ucykge1xuICB2YXIgdGhhdCA9IHRoaXNcblxuICB0aGlzLnN2ZyA9IHN2Z1xuICB0aGlzLmRlZnMgPSBzdmcucXVlcnlTZWxlY3RvcignZGVmcycpXG5cbiAgLy8gQWRkIGRlZmF1bHQgYXR0cmlidXRlcyB0byBTVkdcbiAgU3ZnVXRpbHMuc2V0dXBTdmdBdHRyaWJ1dGVzKHRoaXMuc3ZnKVxuXG4gIC8vIFNldCBvcHRpb25zXG4gIHRoaXMub3B0aW9ucyA9IFV0aWxzLmV4dGVuZChVdGlscy5leHRlbmQoe30sIG9wdGlvbnNEZWZhdWx0cyksIG9wdGlvbnMpXG5cbiAgLy8gU2V0IGRlZmF1bHQgc3RhdGVcbiAgdGhpcy5zdGF0ZSA9ICdub25lJ1xuXG4gIC8vIEdldCBkaW1lbnNpb25zXG4gIHZhciBib3VuZGluZ0NsaWVudFJlY3ROb3JtYWxpemVkID0gU3ZnVXRpbHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0Tm9ybWFsaXplZChzdmcpXG4gIHRoaXMud2lkdGggPSBib3VuZGluZ0NsaWVudFJlY3ROb3JtYWxpemVkLndpZHRoXG4gIHRoaXMuaGVpZ2h0ID0gYm91bmRpbmdDbGllbnRSZWN0Tm9ybWFsaXplZC5oZWlnaHRcblxuICAvLyBJbml0IHNoYWRvdyB2aWV3cG9ydFxuICB0aGlzLnZpZXdwb3J0ID0gU2hhZG93Vmlld3BvcnQoU3ZnVXRpbHMuZ2V0T3JDcmVhdGVWaWV3cG9ydCh0aGlzLnN2ZywgdGhpcy5vcHRpb25zLnZpZXdwb3J0U2VsZWN0b3IpLCB7XG4gICAgc3ZnOiB0aGlzLnN2Z1xuICAsIHdpZHRoOiB0aGlzLndpZHRoXG4gICwgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAsIGZpdDogdGhpcy5vcHRpb25zLmZpdFxuICAsIGNlbnRlcjogdGhpcy5vcHRpb25zLmNlbnRlclxuICAsIHJlZnJlc2hSYXRlOiB0aGlzLm9wdGlvbnMucmVmcmVzaFJhdGVcbiAgLy8gUHV0IGNhbGxiYWNrcyBpbnRvIGZ1bmN0aW9ucyBhcyB0aGV5IGNhbiBjaGFuZ2UgdGhyb3VnaCB0aW1lXG4gICwgYmVmb3JlWm9vbTogZnVuY3Rpb24ob2xkU2NhbGUsIG5ld1NjYWxlKSB7XG4gICAgICBpZiAodGhhdC52aWV3cG9ydCAmJiB0aGF0Lm9wdGlvbnMuYmVmb3JlWm9vbSkge3JldHVybiB0aGF0Lm9wdGlvbnMuYmVmb3JlWm9vbShvbGRTY2FsZSwgbmV3U2NhbGUpfVxuICAgIH1cbiAgLCBvblpvb206IGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgICBpZiAodGhhdC52aWV3cG9ydCAmJiB0aGF0Lm9wdGlvbnMub25ab29tKSB7cmV0dXJuIHRoYXQub3B0aW9ucy5vblpvb20oc2NhbGUpfVxuICAgIH1cbiAgLCBiZWZvcmVQYW46IGZ1bmN0aW9uKG9sZFBvaW50LCBuZXdQb2ludCkge1xuICAgICAgaWYgKHRoYXQudmlld3BvcnQgJiYgdGhhdC5vcHRpb25zLmJlZm9yZVBhbikge3JldHVybiB0aGF0Lm9wdGlvbnMuYmVmb3JlUGFuKG9sZFBvaW50LCBuZXdQb2ludCl9XG4gICAgfVxuICAsIG9uUGFuOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgaWYgKHRoYXQudmlld3BvcnQgJiYgdGhhdC5vcHRpb25zLm9uUGFuKSB7cmV0dXJuIHRoYXQub3B0aW9ucy5vblBhbihwb2ludCl9XG4gICAgfVxuICB9KVxuXG4gIC8vIFdyYXAgY2FsbGJhY2tzIGludG8gcHVibGljIEFQSSBjb250ZXh0XG4gIHZhciBwdWJsaWNJbnN0YW5jZSA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKVxuICBwdWJsaWNJbnN0YW5jZS5zZXRCZWZvcmVab29tKHRoaXMub3B0aW9ucy5iZWZvcmVab29tKVxuICBwdWJsaWNJbnN0YW5jZS5zZXRPblpvb20odGhpcy5vcHRpb25zLm9uWm9vbSlcbiAgcHVibGljSW5zdGFuY2Uuc2V0QmVmb3JlUGFuKHRoaXMub3B0aW9ucy5iZWZvcmVQYW4pXG4gIHB1YmxpY0luc3RhbmNlLnNldE9uUGFuKHRoaXMub3B0aW9ucy5vblBhbilcblxuICBpZiAodGhpcy5vcHRpb25zLmNvbnRyb2xJY29uc0VuYWJsZWQpIHtcbiAgICBDb250cm9sSWNvbnMuZW5hYmxlKHRoaXMpXG4gIH1cblxuICAvLyBJbml0IGV2ZW50cyBoYW5kbGVyc1xuICB0aGlzLnNldHVwSGFuZGxlcnMoKVxufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLnNldHVwSGFuZGxlcnMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRoYXQgPSB0aGlzXG4gICAgLCBwcmV2RXZ0ID0gbnVsbCAvLyB1c2UgZm9yIHRvdWNoc3RhcnQgZXZlbnQgdG8gZGV0ZWN0IGRvdWJsZSB0YXBcbiAgICA7XG5cbiAgdGhpcy5ldmVudExpc3RlbmVycyA9IHtcbiAgICAvLyBNb3VzZSBkb3duIGdyb3VwXG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHJldHVybiB0aGF0LmhhbmRsZU1vdXNlRG93bihldnQsIG51bGwpO1xuICAgIH1cbiAgLCB0b3VjaHN0YXJ0OiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0aGF0LmhhbmRsZU1vdXNlRG93bihldnQsIHByZXZFdnQpO1xuICAgICAgcHJldkV2dCA9IGV2dFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvLyBNb3VzZSB1cCBncm91cFxuICAsIG1vdXNldXA6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgcmV0dXJuIHRoYXQuaGFuZGxlTW91c2VVcChldnQpO1xuICAgIH1cbiAgLCB0b3VjaGVuZDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICByZXR1cm4gdGhhdC5oYW5kbGVNb3VzZVVwKGV2dCk7XG4gICAgfVxuXG4gICAgLy8gTW91c2UgbW92ZSBncm91cFxuICAsIG1vdXNlbW92ZTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICByZXR1cm4gdGhhdC5oYW5kbGVNb3VzZU1vdmUoZXZ0KTtcbiAgICB9XG4gICwgdG91Y2htb3ZlOiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHJldHVybiB0aGF0LmhhbmRsZU1vdXNlTW92ZShldnQpO1xuICAgIH1cblxuICAgIC8vIE1vdXNlIGxlYXZlIGdyb3VwXG4gICwgbW91c2VsZWF2ZTogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICByZXR1cm4gdGhhdC5oYW5kbGVNb3VzZVVwKGV2dCk7XG4gICAgfVxuICAsIHRvdWNobGVhdmU6IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgcmV0dXJuIHRoYXQuaGFuZGxlTW91c2VVcChldnQpO1xuICAgIH1cbiAgLCB0b3VjaGNhbmNlbDogZnVuY3Rpb24oZXZ0KSB7XG4gICAgICByZXR1cm4gdGhhdC5oYW5kbGVNb3VzZVVwKGV2dCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5pdCBjdXN0b20gZXZlbnRzIGhhbmRsZXIgaWYgYXZhaWxhYmxlXG4gIGlmICh0aGlzLm9wdGlvbnMuY3VzdG9tRXZlbnRzSGFuZGxlciAhPSBudWxsKSB7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHRoaXMub3B0aW9ucy5jdXN0b21FdmVudHNIYW5kbGVyLmluaXQoe1xuICAgICAgc3ZnRWxlbWVudDogdGhpcy5zdmdcbiAgICAsIGluc3RhbmNlOiB0aGlzLmdldFB1YmxpY0luc3RhbmNlKClcbiAgICB9KVxuXG4gICAgLy8gQ3VzdG9tIGV2ZW50IGhhbmRsZXIgbWF5IGhhbHQgYnVpbHRpbiBsaXN0ZW5lcnNcbiAgICB2YXIgaGFsdEV2ZW50TGlzdGVuZXJzID0gdGhpcy5vcHRpb25zLmN1c3RvbUV2ZW50c0hhbmRsZXIuaGFsdEV2ZW50TGlzdGVuZXJzXG4gICAgaWYgKGhhbHRFdmVudExpc3RlbmVycyAmJiBoYWx0RXZlbnRMaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gaGFsdEV2ZW50TGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLmhhc093blByb3BlcnR5KGhhbHRFdmVudExpc3RlbmVyc1tpXSkpIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudExpc3RlbmVyc1toYWx0RXZlbnRMaXN0ZW5lcnNbaV1dXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBCaW5kIGV2ZW50TGlzdGVuZXJzXG4gIGZvciAodmFyIGV2ZW50IGluIHRoaXMuZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICB0aGlzLnN2Zy5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmV2ZW50TGlzdGVuZXJzW2V2ZW50XSwgZmFsc2UpXG4gIH1cblxuICAvLyBab29tIHVzaW5nIG1vdXNlIHdoZWVsXG4gIGlmICh0aGlzLm9wdGlvbnMubW91c2VXaGVlbFpvb21FbmFibGVkKSB7XG4gICAgdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxab29tRW5hYmxlZCA9IGZhbHNlIC8vIHNldCB0byBmYWxzZSBhcyBlbmFibGUgd2lsbCBzZXQgaXQgYmFjayB0byB0cnVlXG4gICAgdGhpcy5lbmFibGVNb3VzZVdoZWVsWm9vbSgpXG4gIH1cbn1cblxuLyoqXG4gKiBFbmFibGUgYWJpbGl0eSB0byB6b29tIHVzaW5nIG1vdXNlIHdoZWVsXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLmVuYWJsZU1vdXNlV2hlZWxab29tID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxab29tRW5hYmxlZCkge1xuICAgIHZhciB0aGF0ID0gdGhpc1xuXG4gICAgLy8gTW91c2Ugd2hlZWwgbGlzdGVuZXJcbiAgICB0aGlzLndoZWVsTGlzdGVuZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIHJldHVybiB0aGF0LmhhbmRsZU1vdXNlV2hlZWwoZXZ0KTtcbiAgICB9XG5cbiAgICAvLyBCaW5kIHdoZWVsTGlzdGVuZXJcbiAgICBXaGVlbC5vbih0aGlzLnN2ZywgdGhpcy53aGVlbExpc3RlbmVyLCBmYWxzZSlcblxuICAgIHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsWm9vbUVuYWJsZWQgPSB0cnVlXG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGFiaWxpdHkgdG8gem9vbSB1c2luZyBtb3VzZSB3aGVlbFxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5kaXNhYmxlTW91c2VXaGVlbFpvb20gPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMub3B0aW9ucy5tb3VzZVdoZWVsWm9vbUVuYWJsZWQpIHtcbiAgICBXaGVlbC5vZmYodGhpcy5zdmcsIHRoaXMud2hlZWxMaXN0ZW5lciwgZmFsc2UpXG4gICAgdGhpcy5vcHRpb25zLm1vdXNlV2hlZWxab29tRW5hYmxlZCA9IGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgbW91c2Ugd2hlZWwgZXZlbnRcbiAqXG4gKiBAcGFyYW0gIHtFdmVudH0gZXZ0XG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLmhhbmRsZU1vdXNlV2hlZWwgPSBmdW5jdGlvbihldnQpIHtcbiAgaWYgKCF0aGlzLm9wdGlvbnMuem9vbUVuYWJsZWQgfHwgdGhpcy5zdGF0ZSAhPT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9IGVsc2Uge1xuICAgIGV2dC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGRlbHRhID0gMFxuXG4gIGlmICgnZGVsdGFNb2RlJyBpbiBldnQgJiYgZXZ0LmRlbHRhTW9kZSA9PT0gMCkge1xuICAgIC8vIE1ha2UgZW1waXJpY2FsIGFkanVzdG1lbnRzIGZvciBicm93c2VycyB0aGF0IGdpdmUgZGVsdGFZIGluIHBpeGVscyAoZGVsdGFNb2RlPTApXG5cbiAgICBpZiAoZXZ0LndoZWVsRGVsdGEpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZXIgZm9yIENocm9tZVxuICAgICAgZGVsdGEgPSBldnQuZGVsdGFZIC8gTWF0aC5hYnMoZXZ0LndoZWVsRGVsdGEvMylcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJzLiBQb3NzaWJseSB0YWJsZXRzPyBVc2UgYSB2YWx1ZSBqdXN0IGluIGNhc2VcbiAgICAgIGRlbHRhID0gZXZ0LmRlbHRhWSAvIDEyMFxuICAgIH1cbiAgfSBlbHNlIGlmICgnbW96UHJlc3N1cmUnIGluIGV2dCkge1xuICAgIC8vIE5vcm1hbGl6ZXIgZm9yIG5ld2VyIEZpcmVmb3hcbiAgICAvLyBOT1RFOiBNYXkgbmVlZCB0byBjaGFuZ2UgZGV0ZWN0aW9uIGF0IHNvbWUgcG9pbnQgaWYgbW96UHJlc3N1cmUgZGlzYXBwZWFycy5cbiAgICBkZWx0YSA9IGV2dC5kZWx0YVkgLyAzO1xuICB9IGVsc2Uge1xuICAgIC8vIE90aGVycyBzaG91bGQgYmUgcmVhc29uYWJseSBub3JtYWxpemVkIGJ5IHRoZSBtb3VzZXdoZWVsIGNvZGUgYXQgdGhlIGVuZCBvZiB0aGUgZmlsZS5cbiAgICBkZWx0YSA9IGV2dC5kZWx0YVk7XG4gIH1cblxuICB2YXIgaW52ZXJzZWRTY3JlZW5DVE0gPSB0aGlzLnN2Zy5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKClcbiAgICAsIHJlbGF0aXZlTW91c2VQb2ludCA9IFN2Z1V0aWxzLmdldEV2ZW50UG9pbnQoZXZ0LCB0aGlzLnN2ZykubWF0cml4VHJhbnNmb3JtKGludmVyc2VkU2NyZWVuQ1RNKVxuICAgICwgem9vbSA9IE1hdGgucG93KDEgKyB0aGlzLm9wdGlvbnMuem9vbVNjYWxlU2Vuc2l0aXZpdHksICgtMSkgKiBkZWx0YSk7IC8vIG11bHRpcGx5aW5nIGJ5IG5lZy4gMSBzbyBhcyB0byBtYWtlIHpvb20gaW4vb3V0IGJlaGF2aW9yIG1hdGNoIEdvb2dsZSBtYXBzIGJlaGF2aW9yXG5cbiAgdGhpcy56b29tQXRQb2ludCh6b29tLCByZWxhdGl2ZU1vdXNlUG9pbnQpXG59XG5cbi8qKlxuICogWm9vbSBpbiBhdCBhIFNWRyBwb2ludFxuICpcbiAqIEBwYXJhbSAge1NWR1BvaW50fSBwb2ludFxuICogQHBhcmFtICB7RmxvYXR9IHpvb21TY2FsZSAgICBOdW1iZXIgcmVwcmVzZW50aW5nIGhvdyBtdWNoIHRvIHpvb21cbiAqIEBwYXJhbSAge0Jvb2xlYW59IHpvb21BYnNvbHV0ZSBEZWZhdWx0IGZhbHNlLiBJZiB0cnVlLCB6b29tU2NhbGUgaXMgdHJlYXRlZCBhcyBhbiBhYnNvbHV0ZSB2YWx1ZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPdGhlcndpc2UsIHpvb21TY2FsZSBpcyB0cmVhdGVkIGFzIGEgbXVsdGlwbGllZCAoZS5nLiAxLjEwIHdvdWxkIHpvb20gaW4gMTAlKVxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS56b29tQXRQb2ludCA9IGZ1bmN0aW9uKHpvb21TY2FsZSwgcG9pbnQsIHpvb21BYnNvbHV0ZSkge1xuICB2YXIgb3JpZ2luYWxTdGF0ZSA9IHRoaXMudmlld3BvcnQuZ2V0T3JpZ2luYWxTdGF0ZSgpXG5cbiAgaWYgKCF6b29tQWJzb2x1dGUpIHtcbiAgICAvLyBGaXQgem9vbVNjYWxlIGluIHNldCBib3VuZHNcbiAgICBpZiAodGhpcy5nZXRab29tKCkgKiB6b29tU2NhbGUgPCB0aGlzLm9wdGlvbnMubWluWm9vbSAqIG9yaWdpbmFsU3RhdGUuem9vbSkge1xuICAgICAgem9vbVNjYWxlID0gKHRoaXMub3B0aW9ucy5taW5ab29tICogb3JpZ2luYWxTdGF0ZS56b29tKSAvIHRoaXMuZ2V0Wm9vbSgpXG4gICAgfSBlbHNlIGlmICh0aGlzLmdldFpvb20oKSAqIHpvb21TY2FsZSA+IHRoaXMub3B0aW9ucy5tYXhab29tICogb3JpZ2luYWxTdGF0ZS56b29tKSB7XG4gICAgICB6b29tU2NhbGUgPSAodGhpcy5vcHRpb25zLm1heFpvb20gKiBvcmlnaW5hbFN0YXRlLnpvb20pIC8gdGhpcy5nZXRab29tKClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRml0IHpvb21TY2FsZSBpbiBzZXQgYm91bmRzXG4gICAgem9vbVNjYWxlID0gTWF0aC5tYXgodGhpcy5vcHRpb25zLm1pblpvb20gKiBvcmlnaW5hbFN0YXRlLnpvb20sIE1hdGgubWluKHRoaXMub3B0aW9ucy5tYXhab29tICogb3JpZ2luYWxTdGF0ZS56b29tLCB6b29tU2NhbGUpKVxuICAgIC8vIEZpbmQgcmVsYXRpdmUgc2NhbGUgdG8gYWNoaWV2ZSBkZXNpcmVkIHNjYWxlXG4gICAgem9vbVNjYWxlID0gem9vbVNjYWxlL3RoaXMuZ2V0Wm9vbSgpXG4gIH1cblxuICB2YXIgb2xkQ1RNID0gdGhpcy52aWV3cG9ydC5nZXRDVE0oKVxuICAgICwgcmVsYXRpdmVQb2ludCA9IHBvaW50Lm1hdHJpeFRyYW5zZm9ybShvbGRDVE0uaW52ZXJzZSgpKVxuICAgICwgbW9kaWZpZXIgPSB0aGlzLnN2Zy5jcmVhdGVTVkdNYXRyaXgoKS50cmFuc2xhdGUocmVsYXRpdmVQb2ludC54LCByZWxhdGl2ZVBvaW50LnkpLnNjYWxlKHpvb21TY2FsZSkudHJhbnNsYXRlKC1yZWxhdGl2ZVBvaW50LngsIC1yZWxhdGl2ZVBvaW50LnkpXG4gICAgLCBuZXdDVE0gPSBvbGRDVE0ubXVsdGlwbHkobW9kaWZpZXIpXG5cbiAgaWYgKG5ld0NUTS5hICE9PSBvbGRDVE0uYSkge1xuICAgIHRoaXMudmlld3BvcnQuc2V0Q1RNKG5ld0NUTSlcbiAgfVxufVxuXG4vKipcbiAqIFpvb20gYXQgY2VudGVyIHBvaW50XG4gKlxuICogQHBhcmFtICB7RmxvYXR9IHNjYWxlXG4gKiBAcGFyYW0gIHtCb29sZWFufSBhYnNvbHV0ZSBNYXJrcyB6b29tIHNjYWxlIGFzIHJlbGF0aXZlIG9yIGFic29sdXRlXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLnpvb20gPSBmdW5jdGlvbihzY2FsZSwgYWJzb2x1dGUpIHtcbiAgdGhpcy56b29tQXRQb2ludChzY2FsZSwgU3ZnVXRpbHMuZ2V0U3ZnQ2VudGVyUG9pbnQodGhpcy5zdmcsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSwgYWJzb2x1dGUpXG59XG5cbi8qKlxuICogWm9vbSB1c2VkIGJ5IHB1YmxpYyBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSAge0Zsb2F0fSBzY2FsZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gYWJzb2x1dGUgTWFya3Mgem9vbSBzY2FsZSBhcyByZWxhdGl2ZSBvciBhYnNvbHV0ZVxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5wdWJsaWNab29tID0gZnVuY3Rpb24oc2NhbGUsIGFic29sdXRlKSB7XG4gIGlmIChhYnNvbHV0ZSkge1xuICAgIHNjYWxlID0gdGhpcy5jb21wdXRlRnJvbVJlbGF0aXZlWm9vbShzY2FsZSlcbiAgfVxuXG4gIHRoaXMuem9vbShzY2FsZSwgYWJzb2x1dGUpXG59XG5cbi8qKlxuICogWm9vbSBhdCBwb2ludCB1c2VkIGJ5IHB1YmxpYyBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSAge0Zsb2F0fSBzY2FsZVxuICogQHBhcmFtICB7U1ZHUG9pbnR8T2JqZWN0fSBwb2ludCAgICBBbiBvYmplY3QgdGhhdCBoYXMgeCBhbmQgeSBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gIHtCb29sZWFufSBhYnNvbHV0ZSBNYXJrcyB6b29tIHNjYWxlIGFzIHJlbGF0aXZlIG9yIGFic29sdXRlXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLnB1YmxpY1pvb21BdFBvaW50ID0gZnVuY3Rpb24oc2NhbGUsIHBvaW50LCBhYnNvbHV0ZSkge1xuICBpZiAoYWJzb2x1dGUpIHtcbiAgICAvLyBUcmFuc2Zvcm0gem9vbSBpbnRvIGEgcmVsYXRpdmUgdmFsdWVcbiAgICBzY2FsZSA9IHRoaXMuY29tcHV0ZUZyb21SZWxhdGl2ZVpvb20oc2NhbGUpXG4gIH1cblxuICAvLyBJZiBub3QgYSBTVkdQb2ludCBidXQgaGFzIHggYW5kIHkgdGhhbiBjcmVhdGUgYSBTVkdQb2ludFxuICBpZiAoVXRpbHMuZ2V0VHlwZShwb2ludCkgIT09ICdTVkdQb2ludCcgJiYgJ3gnIGluIHBvaW50ICYmICd5JyBpbiBwb2ludCkge1xuICAgIHBvaW50ID0gU3ZnVXRpbHMuY3JlYXRlU1ZHUG9pbnQodGhpcy5zdmcsIHBvaW50LngsIHBvaW50LnkpXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHaXZlbiBwb2ludCBpcyBpbnZhbGlkJylcbiAgICByZXR1cm5cbiAgfVxuXG4gIHRoaXMuem9vbUF0UG9pbnQoc2NhbGUsIHBvaW50LCBhYnNvbHV0ZSlcbn1cblxuLyoqXG4gKiBHZXQgem9vbSBzY2FsZVxuICpcbiAqIEByZXR1cm4ge0Zsb2F0fSB6b29tIHNjYWxlXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLmdldFpvb20gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudmlld3BvcnQuZ2V0Wm9vbSgpXG59XG5cbi8qKlxuICogR2V0IHpvb20gc2NhbGUgZm9yIHB1YmxpYyB1c2FnZVxuICpcbiAqIEByZXR1cm4ge0Zsb2F0fSB6b29tIHNjYWxlXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLmdldFJlbGF0aXZlWm9vbSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy52aWV3cG9ydC5nZXRSZWxhdGl2ZVpvb20oKVxufVxuXG4vKipcbiAqIENvbXB1dGUgYWN0dWFsIHpvb20gZnJvbSBwdWJsaWMgem9vbVxuICpcbiAqIEBwYXJhbSAge0Zsb2F0fSB6b29tXG4gKiBAcmV0dXJuIHtGbG9hdH0gem9vbSBzY2FsZVxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5jb21wdXRlRnJvbVJlbGF0aXZlWm9vbSA9IGZ1bmN0aW9uKHpvb20pIHtcbiAgcmV0dXJuIHpvb20gKiB0aGlzLnZpZXdwb3J0LmdldE9yaWdpbmFsU3RhdGUoKS56b29tXG59XG5cbi8qKlxuICogU2V0IHpvb20gdG8gaW5pdGlhbCBzdGF0ZVxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5yZXNldFpvb20gPSBmdW5jdGlvbigpIHtcbiAgdmFyIG9yaWdpbmFsU3RhdGUgPSB0aGlzLnZpZXdwb3J0LmdldE9yaWdpbmFsU3RhdGUoKVxuXG4gIHRoaXMuem9vbShvcmlnaW5hbFN0YXRlLnpvb20sIHRydWUpO1xufVxuXG4vKipcbiAqIFNldCBwYW4gdG8gaW5pdGlhbCBzdGF0ZVxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5yZXNldFBhbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnBhbih0aGlzLnZpZXdwb3J0LmdldE9yaWdpbmFsU3RhdGUoKSk7XG59XG5cbi8qKlxuICogU2V0IHBhbiBhbmQgem9vbSB0byBpbml0aWFsIHN0YXRlXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVzZXRab29tKClcbiAgdGhpcy5yZXNldFBhbigpXG59XG5cbi8qKlxuICogSGFuZGxlIGRvdWJsZSBjbGljayBldmVudFxuICogU2VlIGhhbmRsZU1vdXNlRG93bigpIGZvciBhbHRlcm5hdGUgZGV0ZWN0aW9uIG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5oYW5kbGVEYmxDbGljayA9IGZ1bmN0aW9uKGV2dCkge1xuICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgfSBlbHNlIHtcbiAgICBldnQucmV0dXJuVmFsdWUgPSBmYWxzZVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgdGFyZ2V0IHdhcyBhIGNvbnRyb2wgYnV0dG9uXG4gIGlmICh0aGlzLm9wdGlvbnMuY29udHJvbEljb25zRW5hYmxlZCkge1xuICAgIHZhciB0YXJnZXRDbGFzcyA9IGV2dC50YXJnZXQuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnXG4gICAgaWYgKHRhcmdldENsYXNzLmluZGV4T2YoJ3N2Zy1wYW4tem9vbS1jb250cm9sJykgPiAtMSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgdmFyIHpvb21GYWN0b3JcblxuICBpZiAoZXZ0LnNoaWZ0S2V5KSB7XG4gICAgem9vbUZhY3RvciA9IDEvKCgxICsgdGhpcy5vcHRpb25zLnpvb21TY2FsZVNlbnNpdGl2aXR5KSAqIDIpIC8vIHpvb20gb3V0IHdoZW4gc2hpZnQga2V5IHByZXNzZWRcbiAgfSBlbHNlIHtcbiAgICB6b29tRmFjdG9yID0gKDEgKyB0aGlzLm9wdGlvbnMuem9vbVNjYWxlU2Vuc2l0aXZpdHkpICogMlxuICB9XG5cbiAgdmFyIHBvaW50ID0gU3ZnVXRpbHMuZ2V0RXZlbnRQb2ludChldnQsIHRoaXMuc3ZnKS5tYXRyaXhUcmFuc2Zvcm0odGhpcy5zdmcuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpKVxuICB0aGlzLnpvb21BdFBvaW50KHpvb21GYWN0b3IsIHBvaW50KVxufVxuXG4vKipcbiAqIEhhbmRsZSBjbGljayBldmVudFxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5oYW5kbGVNb3VzZURvd24gPSBmdW5jdGlvbihldnQsIHByZXZFdnQpIHtcbiAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gIH0gZWxzZSB7XG4gICAgZXZ0LnJldHVyblZhbHVlID0gZmFsc2VcbiAgfVxuXG4gIFV0aWxzLm1vdXNlQW5kVG91Y2hOb3JtYWxpemUoZXZ0LCB0aGlzLnN2ZylcblxuICAvLyBEb3VibGUgY2xpY2sgZGV0ZWN0aW9uOyBtb3JlIGNvbnNpc3RlbnQgdGhhbiBvbmRibGNsaWNrXG4gIGlmICh0aGlzLm9wdGlvbnMuZGJsQ2xpY2tab29tRW5hYmxlZCAmJiBVdGlscy5pc0RibENsaWNrKGV2dCwgcHJldkV2dCkpe1xuICAgIHRoaXMuaGFuZGxlRGJsQ2xpY2soZXZ0KVxuICB9IGVsc2Uge1xuICAgIC8vIFBhbiBtb2RlXG4gICAgdGhpcy5zdGF0ZSA9ICdwYW4nXG4gICAgdGhpcy5maXJzdEV2ZW50Q1RNID0gdGhpcy52aWV3cG9ydC5nZXRDVE0oKVxuICAgIHRoaXMuc3RhdGVPcmlnaW4gPSBTdmdVdGlscy5nZXRFdmVudFBvaW50KGV2dCwgdGhpcy5zdmcpLm1hdHJpeFRyYW5zZm9ybSh0aGlzLmZpcnN0RXZlbnRDVE0uaW52ZXJzZSgpKVxuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIG1vdXNlIG1vdmUgZXZlbnRcbiAqXG4gKiBAcGFyYW0gIHtFdmVudH0gZXZ0XG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uKGV2dCkge1xuICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KClcbiAgfSBlbHNlIHtcbiAgICBldnQucmV0dXJuVmFsdWUgPSBmYWxzZVxuICB9XG5cbiAgaWYgKHRoaXMuc3RhdGUgPT09ICdwYW4nICYmIHRoaXMub3B0aW9ucy5wYW5FbmFibGVkKSB7XG4gICAgLy8gUGFuIG1vZGVcbiAgICB2YXIgcG9pbnQgPSBTdmdVdGlscy5nZXRFdmVudFBvaW50KGV2dCwgdGhpcy5zdmcpLm1hdHJpeFRyYW5zZm9ybSh0aGlzLmZpcnN0RXZlbnRDVE0uaW52ZXJzZSgpKVxuICAgICAgLCB2aWV3cG9ydENUTSA9IHRoaXMuZmlyc3RFdmVudENUTS50cmFuc2xhdGUocG9pbnQueCAtIHRoaXMuc3RhdGVPcmlnaW4ueCwgcG9pbnQueSAtIHRoaXMuc3RhdGVPcmlnaW4ueSlcblxuICAgIHRoaXMudmlld3BvcnQuc2V0Q1RNKHZpZXdwb3J0Q1RNKVxuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIG1vdXNlIGJ1dHRvbiByZWxlYXNlIGV2ZW50XG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXZ0XG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLmhhbmRsZU1vdXNlVXAgPSBmdW5jdGlvbihldnQpIHtcbiAgaWYgKGV2dC5wcmV2ZW50RGVmYXVsdCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpXG4gIH0gZWxzZSB7XG4gICAgZXZ0LnJldHVyblZhbHVlID0gZmFsc2VcbiAgfVxuXG4gIGlmICh0aGlzLnN0YXRlID09PSAncGFuJykge1xuICAgIC8vIFF1aXQgcGFuIG1vZGVcbiAgICB0aGlzLnN0YXRlID0gJ25vbmUnXG4gIH1cbn1cblxuLyoqXG4gKiBBZGp1c3Qgdmlld3BvcnQgc2l6ZSAob25seSkgc28gaXQgd2lsbCBmaXQgaW4gU1ZHXG4gKiBEb2VzIG5vdCBjZW50ZXIgaW1hZ2VcbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUuZml0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciB2aWV3Qm94ID0gdGhpcy52aWV3cG9ydC5nZXRWaWV3Qm94KClcbiAgICAsIG5ld1NjYWxlID0gTWF0aC5taW4odGhpcy53aWR0aC8odmlld0JveC53aWR0aCAtIHZpZXdCb3gueCksIHRoaXMuaGVpZ2h0Lyh2aWV3Qm94LmhlaWdodCAtIHZpZXdCb3gueSkpXG5cbiAgdGhpcy56b29tKG5ld1NjYWxlLCB0cnVlKVxufVxuXG4vKipcbiAqIEFkanVzdCB2aWV3cG9ydCBwYW4gKG9ubHkpIHNvIGl0IHdpbGwgYmUgY2VudGVyZWQgaW4gU1ZHXG4gKiBEb2VzIG5vdCB6b29tL2ZpdCBpbWFnZVxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5jZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHZpZXdCb3ggPSB0aGlzLnZpZXdwb3J0LmdldFZpZXdCb3goKVxuICAgICwgb2Zmc2V0WCA9ICh0aGlzLndpZHRoIC0gKHZpZXdCb3gud2lkdGggKyB2aWV3Qm94LngpICogdGhpcy5nZXRab29tKCkpICogMC41XG4gICAgLCBvZmZzZXRZID0gKHRoaXMuaGVpZ2h0IC0gKHZpZXdCb3guaGVpZ2h0ICsgdmlld0JveC55KSAqIHRoaXMuZ2V0Wm9vbSgpKSAqIDAuNVxuXG4gIHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKS5wYW4oe3g6IG9mZnNldFgsIHk6IG9mZnNldFl9KVxufVxuXG4vKipcbiAqIFVwZGF0ZSBjb250ZW50IGNhY2hlZCBCb3JkZXJCb3hcbiAqIFVzZSB3aGVuIHZpZXdwb3J0IGNvbnRlbnRzIGNoYW5nZVxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS51cGRhdGVCQm94ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMudmlld3BvcnQucmVjYWNoZVZpZXdCb3goKVxufVxuXG4vKipcbiAqIFBhbiB0byBhIHJlbmRlcmVkIHBvc2l0aW9uXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCB7eDogMCwgeTogMH1cbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUucGFuID0gZnVuY3Rpb24ocG9pbnQpIHtcbiAgdmFyIHZpZXdwb3J0Q1RNID0gdGhpcy52aWV3cG9ydC5nZXRDVE0oKVxuICB2aWV3cG9ydENUTS5lID0gcG9pbnQueFxuICB2aWV3cG9ydENUTS5mID0gcG9pbnQueVxuICB0aGlzLnZpZXdwb3J0LnNldENUTSh2aWV3cG9ydENUTSlcbn1cblxuLyoqXG4gKiBSZWxhdGl2ZWx5IHBhbiB0aGUgZ3JhcGggYnkgYSBzcGVjaWZpZWQgcmVuZGVyZWQgcG9zaXRpb24gdmVjdG9yXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCB7eDogMCwgeTogMH1cbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUucGFuQnkgPSBmdW5jdGlvbihwb2ludCkge1xuICB2YXIgdmlld3BvcnRDVE0gPSB0aGlzLnZpZXdwb3J0LmdldENUTSgpXG4gIHZpZXdwb3J0Q1RNLmUgKz0gcG9pbnQueFxuICB2aWV3cG9ydENUTS5mICs9IHBvaW50LnlcbiAgdGhpcy52aWV3cG9ydC5zZXRDVE0odmlld3BvcnRDVE0pXG59XG5cbi8qKlxuICogR2V0IHBhbiB2ZWN0b3JcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHt4OiAwLCB5OiAwfVxuICovXG5TdmdQYW5ab29tLnByb3RvdHlwZS5nZXRQYW4gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy52aWV3cG9ydC5nZXRTdGF0ZSgpXG5cbiAgcmV0dXJuIHt4OiBzdGF0ZS54LCB5OiBzdGF0ZS55fVxufVxuXG4vKipcbiAqIFJlY2FsY3VsYXRlcyBjYWNoZWQgc3ZnIGRpbWVuc2lvbnMgYW5kIGNvbnRyb2xzIHBvc2l0aW9uXG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBHZXQgZGltZW5zaW9uc1xuICB2YXIgYm91bmRpbmdDbGllbnRSZWN0Tm9ybWFsaXplZCA9IFN2Z1V0aWxzLmdldEJvdW5kaW5nQ2xpZW50UmVjdE5vcm1hbGl6ZWQodGhpcy5zdmcpXG4gIHRoaXMud2lkdGggPSBib3VuZGluZ0NsaWVudFJlY3ROb3JtYWxpemVkLndpZHRoXG4gIHRoaXMuaGVpZ2h0ID0gYm91bmRpbmdDbGllbnRSZWN0Tm9ybWFsaXplZC5oZWlnaHRcblxuICAvLyBSZXBvc2l0aW9uIGNvbnRyb2wgaWNvbnMgYnkgcmUtZW5hYmxpbmcgdGhlbVxuICBpZiAodGhpcy5vcHRpb25zLmNvbnRyb2xJY29uc0VuYWJsZWQpIHtcbiAgICB0aGlzLmdldFB1YmxpY0luc3RhbmNlKCkuZGlzYWJsZUNvbnRyb2xJY29ucygpXG4gICAgdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpLmVuYWJsZUNvbnRyb2xJY29ucygpXG4gIH1cbn1cblxuLyoqXG4gKiBVbmJpbmQgbW91c2UgZXZlbnRzLCBmcmVlIGNhbGxiYWNrcyBhbmQgZGVzdHJveSBwdWJsaWMgaW5zdGFuY2VcbiAqL1xuU3ZnUGFuWm9vbS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdGhhdCA9IHRoaXNcblxuICAvLyBGcmVlIGNhbGxiYWNrc1xuICB0aGlzLmJlZm9yZVpvb20gPSBudWxsXG4gIHRoaXMub25ab29tID0gbnVsbFxuICB0aGlzLmJlZm9yZVBhbiA9IG51bGxcbiAgdGhpcy5vblBhbiA9IG51bGxcblxuICAvLyBEZXN0cm95IGN1c3RvbSBldmVudCBoYW5kbGVyc1xuICBpZiAodGhpcy5vcHRpb25zLmN1c3RvbUV2ZW50c0hhbmRsZXIgIT0gbnVsbCkgeyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICB0aGlzLm9wdGlvbnMuY3VzdG9tRXZlbnRzSGFuZGxlci5kZXN0cm95KHtcbiAgICAgIHN2Z0VsZW1lbnQ6IHRoaXMuc3ZnXG4gICAgLCBpbnN0YW5jZTogdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSgpXG4gICAgfSlcbiAgfVxuXG4gIC8vIFVuYmluZCBldmVudExpc3RlbmVyc1xuICBmb3IgKHZhciBldmVudCBpbiB0aGlzLmV2ZW50TGlzdGVuZXJzKSB7XG4gICAgdGhpcy5zdmcucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgdGhpcy5ldmVudExpc3RlbmVyc1tldmVudF0sIGZhbHNlKVxuICB9XG5cbiAgLy8gVW5iaW5kIHdoZWVsTGlzdGVuZXJcbiAgdGhpcy5kaXNhYmxlTW91c2VXaGVlbFpvb20oKVxuXG4gIC8vIFJlbW92ZSBjb250cm9sIGljb25zXG4gIHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKS5kaXNhYmxlQ29udHJvbEljb25zKClcblxuICAvLyBSZXNldCB6b29tIGFuZCBwYW5cbiAgdGhpcy5yZXNldCgpXG5cbiAgLy8gUmVtb3ZlIGluc3RhbmNlIGZyb20gaW5zdGFuY2VzU3RvcmVcbiAgaW5zdGFuY2VzU3RvcmUgPSBpbnN0YW5jZXNTdG9yZS5maWx0ZXIoZnVuY3Rpb24oaW5zdGFuY2Upe1xuICAgIHJldHVybiBpbnN0YW5jZS5zdmcgIT09IHRoYXQuc3ZnXG4gIH0pXG5cbiAgLy8gRGVsZXRlIG9wdGlvbnMgYW5kIGl0cyBjb250ZW50c1xuICBkZWxldGUgdGhpcy5vcHRpb25zXG5cbiAgLy8gRGVzdHJveSBwdWJsaWMgaW5zdGFuY2UgYW5kIHJld3JpdGUgZ2V0UHVibGljSW5zdGFuY2VcbiAgZGVsZXRlIHRoaXMucHVibGljSW5zdGFuY2VcbiAgZGVsZXRlIHRoaXMucGlcbiAgdGhpcy5nZXRQdWJsaWNJbnN0YW5jZSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBwdWJsaWMgaW5zdGFuY2Ugb2JqZWN0XG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBQdWJsaWMgaW5zdGFuY2Ugb2JqZWN0XG4gKi9cblN2Z1Bhblpvb20ucHJvdG90eXBlLmdldFB1YmxpY0luc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gIHZhciB0aGF0ID0gdGhpc1xuXG4gIC8vIENyZWF0ZSBjYWNoZVxuICBpZiAoIXRoaXMucHVibGljSW5zdGFuY2UpIHtcbiAgICB0aGlzLnB1YmxpY0luc3RhbmNlID0gdGhpcy5waSA9IHtcbiAgICAgIC8vIFBhblxuICAgICAgZW5hYmxlUGFuOiBmdW5jdGlvbigpIHt0aGF0Lm9wdGlvbnMucGFuRW5hYmxlZCA9IHRydWU7IHJldHVybiB0aGF0LnBpfVxuICAgICwgZGlzYWJsZVBhbjogZnVuY3Rpb24oKSB7dGhhdC5vcHRpb25zLnBhbkVuYWJsZWQgPSBmYWxzZTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCBpc1BhbkVuYWJsZWQ6IGZ1bmN0aW9uKCkge3JldHVybiAhIXRoYXQub3B0aW9ucy5wYW5FbmFibGVkfVxuICAgICwgcGFuOiBmdW5jdGlvbihwb2ludCkge3RoYXQucGFuKHBvaW50KTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCBwYW5CeTogZnVuY3Rpb24ocG9pbnQpIHt0aGF0LnBhbkJ5KHBvaW50KTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCBnZXRQYW46IGZ1bmN0aW9uKCkge3JldHVybiB0aGF0LmdldFBhbigpfVxuICAgICAgLy8gUGFuIGV2ZW50XG4gICAgLCBzZXRCZWZvcmVQYW46IGZ1bmN0aW9uKGZuKSB7dGhhdC5vcHRpb25zLmJlZm9yZVBhbiA9IGZuID09PSBudWxsID8gbnVsbCA6IFV0aWxzLnByb3h5KGZuLCB0aGF0LnB1YmxpY0luc3RhbmNlKTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCBzZXRPblBhbjogZnVuY3Rpb24oZm4pIHt0aGF0Lm9wdGlvbnMub25QYW4gPSBmbiA9PT0gbnVsbCA/IG51bGwgOiBVdGlscy5wcm94eShmbiwgdGhhdC5wdWJsaWNJbnN0YW5jZSk7IHJldHVybiB0aGF0LnBpfVxuICAgICAgLy8gWm9vbSBhbmQgQ29udHJvbCBJY29uc1xuICAgICwgZW5hYmxlWm9vbTogZnVuY3Rpb24oKSB7dGhhdC5vcHRpb25zLnpvb21FbmFibGVkID0gdHJ1ZTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCBkaXNhYmxlWm9vbTogZnVuY3Rpb24oKSB7dGhhdC5vcHRpb25zLnpvb21FbmFibGVkID0gZmFsc2U7IHJldHVybiB0aGF0LnBpfVxuICAgICwgaXNab29tRW5hYmxlZDogZnVuY3Rpb24oKSB7cmV0dXJuICEhdGhhdC5vcHRpb25zLnpvb21FbmFibGVkfVxuICAgICwgZW5hYmxlQ29udHJvbEljb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGF0Lm9wdGlvbnMuY29udHJvbEljb25zRW5hYmxlZCkge1xuICAgICAgICAgIHRoYXQub3B0aW9ucy5jb250cm9sSWNvbnNFbmFibGVkID0gdHJ1ZVxuICAgICAgICAgIENvbnRyb2xJY29ucy5lbmFibGUodGhhdClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhhdC5waVxuICAgICAgfVxuICAgICwgZGlzYWJsZUNvbnRyb2xJY29uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGF0Lm9wdGlvbnMuY29udHJvbEljb25zRW5hYmxlZCkge1xuICAgICAgICAgIHRoYXQub3B0aW9ucy5jb250cm9sSWNvbnNFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgQ29udHJvbEljb25zLmRpc2FibGUodGhhdClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhhdC5waVxuICAgICAgfVxuICAgICwgaXNDb250cm9sSWNvbnNFbmFibGVkOiBmdW5jdGlvbigpIHtyZXR1cm4gISF0aGF0Lm9wdGlvbnMuY29udHJvbEljb25zRW5hYmxlZH1cbiAgICAgIC8vIERvdWJsZSBjbGljayB6b29tXG4gICAgLCBlbmFibGVEYmxDbGlja1pvb206IGZ1bmN0aW9uKCkge3RoYXQub3B0aW9ucy5kYmxDbGlja1pvb21FbmFibGVkID0gdHJ1ZTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCBkaXNhYmxlRGJsQ2xpY2tab29tOiBmdW5jdGlvbigpIHt0aGF0Lm9wdGlvbnMuZGJsQ2xpY2tab29tRW5hYmxlZCA9IGZhbHNlOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIGlzRGJsQ2xpY2tab29tRW5hYmxlZDogZnVuY3Rpb24oKSB7cmV0dXJuICEhdGhhdC5vcHRpb25zLmRibENsaWNrWm9vbUVuYWJsZWR9XG4gICAgICAvLyBNb3VzZSB3aGVlbCB6b29tXG4gICAgLCBlbmFibGVNb3VzZVdoZWVsWm9vbTogZnVuY3Rpb24oKSB7dGhhdC5lbmFibGVNb3VzZVdoZWVsWm9vbSgpOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIGRpc2FibGVNb3VzZVdoZWVsWm9vbTogZnVuY3Rpb24oKSB7dGhhdC5kaXNhYmxlTW91c2VXaGVlbFpvb20oKTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCBpc01vdXNlV2hlZWxab29tRW5hYmxlZDogZnVuY3Rpb24oKSB7cmV0dXJuICEhdGhhdC5vcHRpb25zLm1vdXNlV2hlZWxab29tRW5hYmxlZH1cbiAgICAgIC8vIFpvb20gc2NhbGUgYW5kIGJvdW5kc1xuICAgICwgc2V0Wm9vbVNjYWxlU2Vuc2l0aXZpdHk6IGZ1bmN0aW9uKHNjYWxlKSB7dGhhdC5vcHRpb25zLnpvb21TY2FsZVNlbnNpdGl2aXR5ID0gc2NhbGU7IHJldHVybiB0aGF0LnBpfVxuICAgICwgc2V0TWluWm9vbTogZnVuY3Rpb24oem9vbSkge3RoYXQub3B0aW9ucy5taW5ab29tID0gem9vbTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCBzZXRNYXhab29tOiBmdW5jdGlvbih6b29tKSB7dGhhdC5vcHRpb25zLm1heFpvb20gPSB6b29tOyByZXR1cm4gdGhhdC5waX1cbiAgICAgIC8vIFpvb20gZXZlbnRcbiAgICAsIHNldEJlZm9yZVpvb206IGZ1bmN0aW9uKGZuKSB7dGhhdC5vcHRpb25zLmJlZm9yZVpvb20gPSBmbiA9PT0gbnVsbCA/IG51bGwgOiBVdGlscy5wcm94eShmbiwgdGhhdC5wdWJsaWNJbnN0YW5jZSk7IHJldHVybiB0aGF0LnBpfVxuICAgICwgc2V0T25ab29tOiBmdW5jdGlvbihmbikge3RoYXQub3B0aW9ucy5vblpvb20gPSBmbiA9PT0gbnVsbCA/IG51bGwgOiBVdGlscy5wcm94eShmbiwgdGhhdC5wdWJsaWNJbnN0YW5jZSk7IHJldHVybiB0aGF0LnBpfVxuICAgICAgLy8gWm9vbWluZ1xuICAgICwgem9vbTogZnVuY3Rpb24oc2NhbGUpIHt0aGF0LnB1YmxpY1pvb20oc2NhbGUsIHRydWUpOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIHpvb21CeTogZnVuY3Rpb24oc2NhbGUpIHt0aGF0LnB1YmxpY1pvb20oc2NhbGUsIGZhbHNlKTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCB6b29tQXRQb2ludDogZnVuY3Rpb24oc2NhbGUsIHBvaW50KSB7dGhhdC5wdWJsaWNab29tQXRQb2ludChzY2FsZSwgcG9pbnQsIHRydWUpOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIHpvb21BdFBvaW50Qnk6IGZ1bmN0aW9uKHNjYWxlLCBwb2ludCkge3RoYXQucHVibGljWm9vbUF0UG9pbnQoc2NhbGUsIHBvaW50LCBmYWxzZSk7IHJldHVybiB0aGF0LnBpfVxuICAgICwgem9vbUluOiBmdW5jdGlvbigpIHt0aGlzLnpvb21CeSgxICsgdGhhdC5vcHRpb25zLnpvb21TY2FsZVNlbnNpdGl2aXR5KTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCB6b29tT3V0OiBmdW5jdGlvbigpIHt0aGlzLnpvb21CeSgxIC8gKDEgKyB0aGF0Lm9wdGlvbnMuem9vbVNjYWxlU2Vuc2l0aXZpdHkpKTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCBnZXRab29tOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhhdC5nZXRSZWxhdGl2ZVpvb20oKX1cbiAgICAgIC8vIFJlc2V0XG4gICAgLCByZXNldFpvb206IGZ1bmN0aW9uKCkge3RoYXQucmVzZXRab29tKCk7IHJldHVybiB0aGF0LnBpfVxuICAgICwgcmVzZXRQYW46IGZ1bmN0aW9uKCkge3RoYXQucmVzZXRQYW4oKTsgcmV0dXJuIHRoYXQucGl9XG4gICAgLCByZXNldDogZnVuY3Rpb24oKSB7dGhhdC5yZXNldCgpOyByZXR1cm4gdGhhdC5waX1cbiAgICAgIC8vIEZpdCBhbmQgQ2VudGVyXG4gICAgLCBmaXQ6IGZ1bmN0aW9uKCkge3RoYXQuZml0KCk7IHJldHVybiB0aGF0LnBpfVxuICAgICwgY2VudGVyOiBmdW5jdGlvbigpIHt0aGF0LmNlbnRlcigpOyByZXR1cm4gdGhhdC5waX1cbiAgICAgIC8vIFNpemUgYW5kIFJlc2l6ZVxuICAgICwgdXBkYXRlQkJveDogZnVuY3Rpb24oKSB7dGhhdC51cGRhdGVCQm94KCk7IHJldHVybiB0aGF0LnBpfVxuICAgICwgcmVzaXplOiBmdW5jdGlvbigpIHt0aGF0LnJlc2l6ZSgpOyByZXR1cm4gdGhhdC5waX1cbiAgICAsIGdldFNpemVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogdGhhdC53aWR0aFxuICAgICAgICAsIGhlaWdodDogdGhhdC5oZWlnaHRcbiAgICAgICAgLCByZWFsWm9vbTogdGhhdC5nZXRab29tKClcbiAgICAgICAgLCB2aWV3Qm94OiB0aGF0LnZpZXdwb3J0LmdldFZpZXdCb3goKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBEZXN0cm95XG4gICAgLCBkZXN0cm95OiBmdW5jdGlvbigpIHt0aGF0LmRlc3Ryb3koKTsgcmV0dXJuIHRoYXQucGl9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXMucHVibGljSW5zdGFuY2Vcbn1cblxuLyoqXG4gKiBTdG9yZXMgcGFpcnMgb2YgaW5zdGFuY2VzIG9mIFN2Z1Bhblpvb20gYW5kIFNWR1xuICogRWFjaCBwYWlyIGlzIHJlcHJlc2VudGVkIGJ5IGFuIG9iamVjdCB7c3ZnOiBTVkdTVkdFbGVtZW50LCBpbnN0YW5jZTogU3ZnUGFuWm9vbX1cbiAqXG4gKiBAdHlwZSB7QXJyYXl9XG4gKi9cbnZhciBpbnN0YW5jZXNTdG9yZSA9IFtdXG5cbnZhciBzdmdQYW5ab29tID0gZnVuY3Rpb24oZWxlbWVudE9yU2VsZWN0b3IsIG9wdGlvbnMpe1xuICB2YXIgc3ZnID0gVXRpbHMuZ2V0U3ZnKGVsZW1lbnRPclNlbGVjdG9yKVxuXG4gIGlmIChzdmcgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9IGVsc2Uge1xuICAgIC8vIExvb2sgZm9yIGV4aXN0ZW50IGluc3RhbmNlXG4gICAgZm9yKHZhciBpID0gaW5zdGFuY2VzU3RvcmUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChpbnN0YW5jZXNTdG9yZVtpXS5zdmcgPT09IHN2Zykge1xuICAgICAgICByZXR1cm4gaW5zdGFuY2VzU3RvcmVbaV0uaW5zdGFuY2UuZ2V0UHVibGljSW5zdGFuY2UoKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGluc3RhbmNlIG5vdCBmb3VuZCAtIGNyZWF0ZSBvbmVcbiAgICBpbnN0YW5jZXNTdG9yZS5wdXNoKHtcbiAgICAgIHN2Zzogc3ZnXG4gICAgLCBpbnN0YW5jZTogbmV3IFN2Z1Bhblpvb20oc3ZnLCBvcHRpb25zKVxuICAgIH0pXG5cbiAgICAvLyBSZXR1cm4ganVzdCBwdXNoZWQgaW5zdGFuY2VcbiAgICByZXR1cm4gaW5zdGFuY2VzU3RvcmVbaW5zdGFuY2VzU3RvcmUubGVuZ3RoIC0gMV0uaW5zdGFuY2UuZ2V0UHVibGljSW5zdGFuY2UoKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3ZnUGFuWm9vbTtcbiIsInZhciBVdGlscyA9IHJlcXVpcmUoJy4vdXRpbGl0aWVzJylcbiAgLCBfYnJvd3NlciA9ICd1bmtub3duJ1xuICA7XG5cbi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTg0NzU4MC9ob3ctdG8tZGV0ZWN0LXNhZmFyaS1jaHJvbWUtaWUtZmlyZWZveC1hbmQtb3BlcmEtYnJvd3NlclxuaWYgKC8qQGNjX29uIUAqL2ZhbHNlIHx8ICEhZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSB7IC8vIGludGVybmV0IGV4cGxvcmVyXG4gIF9icm93c2VyID0gJ2llJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN2Z05TOiAgJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJ1xuLCB4bWxOUzogICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG4sIHhtbG5zTlM6ICAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG4sIHhsaW5rTlM6ICAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaydcbiwgZXZOUzogICdodHRwOi8vd3d3LnczLm9yZy8yMDAxL3htbC1ldmVudHMnXG5cbiAgLyoqXG4gICAqIEdldCBzdmcgZGltZW5zaW9uczogd2lkdGggYW5kIGhlaWdodFxuICAgKlxuICAgKiBAcGFyYW0gIHtTVkdTVkdFbGVtZW50fSBzdmdcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAge3dpZHRoOiAwLCBoZWlnaHQ6IDB9XG4gICAqL1xuLCBnZXRCb3VuZGluZ0NsaWVudFJlY3ROb3JtYWxpemVkOiBmdW5jdGlvbihzdmcpIHtcbiAgICBpZiAoc3ZnLmNsaWVudFdpZHRoICYmIHN2Zy5jbGllbnRIZWlnaHQpIHtcbiAgICAgIHJldHVybiB7d2lkdGg6IHN2Zy5jbGllbnRXaWR0aCwgaGVpZ2h0OiBzdmcuY2xpZW50SGVpZ2h0fVxuICAgIH0gZWxzZSBpZiAoISFzdmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpIHtcbiAgICAgIHJldHVybiBzdmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCBCb3VuZGluZ0NsaWVudFJlY3QgZm9yIFNWRy4nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBnIGVsZW1lbnQgd2l0aCBjbGFzcyBvZiBcInZpZXdwb3J0XCIgb3IgY3JlYXRlcyBpdCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAqXG4gICAqIEBwYXJhbSAge1NWR1NWR0VsZW1lbnR9IHN2Z1xuICAgKiBAcmV0dXJuIHtTVkdFbGVtZW50fSAgICAgZyAoZ3JvdXApIGVsZW1lbnRcbiAgICovXG4sIGdldE9yQ3JlYXRlVmlld3BvcnQ6IGZ1bmN0aW9uKHN2Zywgc2VsZWN0b3IpIHtcbiAgICB2YXIgdmlld3BvcnQgPSBudWxsXG5cbiAgICBpZiAoVXRpbHMuaXNFbGVtZW50KHNlbGVjdG9yKSkge1xuICAgICAgdmlld3BvcnQgPSBzZWxlY3RvclxuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3cG9ydCA9IHN2Zy5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICAgIH1cblxuICAgIC8vIENoZWNrIGlmIHRoZXJlIGlzIGp1c3Qgb25lIG1haW4gZ3JvdXAgaW4gU1ZHXG4gICAgaWYgKCF2aWV3cG9ydCkge1xuICAgICAgdmFyIGNoaWxkTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzdmcuY2hpbGROb2RlcyB8fCBzdmcuY2hpbGRyZW4pLmZpbHRlcihmdW5jdGlvbihlbCl7XG4gICAgICAgIHJldHVybiBlbC5ub2RlTmFtZSAhPT0gJ2RlZnMnICYmIGVsLm5vZGVOYW1lICE9PSAnI3RleHQnXG4gICAgICB9KVxuXG4gICAgICAvLyBOb2RlIG5hbWUgc2hvdWxkIGJlIFNWR0dFbGVtZW50IGFuZCBzaG91bGQgaGF2ZSBubyB0cmFuc2Zvcm0gYXR0cmlidXRlXG4gICAgICAvLyBHcm91cHMgd2l0aCB0cmFuc2Zvcm0gYXJlIG5vdCB1c2VkIGFzIHZpZXdwb3J0IGJlY2F1c2UgaXQgaW52b2x2ZXMgcGFyc2luZyBvZiBhbGwgdHJhbnNmb3JtIHBvc3NpYmlsaXRpZXNcbiAgICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSAmJiBjaGlsZE5vZGVzWzBdLm5vZGVOYW1lID09PSAnZycgJiYgY2hpbGROb2Rlc1swXS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpID09PSBudWxsKSB7XG4gICAgICAgIHZpZXdwb3J0ID0gY2hpbGROb2Rlc1swXVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vIGZhdm9yYWJsZSBncm91cCBlbGVtZW50IGV4aXN0cyB0aGVuIGNyZWF0ZSBvbmVcbiAgICBpZiAoIXZpZXdwb3J0KSB7XG4gICAgICB2YXIgdmlld3BvcnRJZCA9ICd2aWV3cG9ydC0nICsgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1xcRC9nLCAnJyk7XG4gICAgICB2aWV3cG9ydCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh0aGlzLnN2Z05TLCAnZycpO1xuICAgICAgdmlld3BvcnQuc2V0QXR0cmlidXRlKCdpZCcsIHZpZXdwb3J0SWQpO1xuXG4gICAgICAvLyBJbnRlcm5ldCBFeHBsb3JlciAoYWxsIHZlcnNpb25zPykgY2FuJ3QgdXNlIGNoaWxkTm9kZXMsIGJ1dCBvdGhlciBicm93c2VycyBwcmVmZXIgKHJlcXVpcmU/KSB1c2luZyBjaGlsZE5vZGVzXG4gICAgICB2YXIgc3ZnQ2hpbGRyZW4gPSBzdmcuY2hpbGROb2RlcyB8fCBzdmcuY2hpbGRyZW47XG4gICAgICBpZiAoISFzdmdDaGlsZHJlbiAmJiBzdmdDaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBzdmdDaGlsZHJlbi5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAvLyBNb3ZlIGV2ZXJ5dGhpbmcgaW50byB2aWV3cG9ydCBleGNlcHQgZGVmc1xuICAgICAgICAgIGlmIChzdmdDaGlsZHJlbltzdmdDaGlsZHJlbi5sZW5ndGggLSBpXS5ub2RlTmFtZSAhPT0gJ2RlZnMnKSB7XG4gICAgICAgICAgICB2aWV3cG9ydC5hcHBlbmRDaGlsZChzdmdDaGlsZHJlbltzdmdDaGlsZHJlbi5sZW5ndGggLSBpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdmcuYXBwZW5kQ2hpbGQodmlld3BvcnQpO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIGNsYXNzIG5hbWVzXG4gICAgdmFyIGNsYXNzTmFtZXMgPSBbXTtcbiAgICBpZiAodmlld3BvcnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpKSB7XG4gICAgICBjbGFzc05hbWVzID0gdmlld3BvcnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpLnNwbGl0KCcgJylcbiAgICB9XG5cbiAgICAvLyBTZXQgY2xhc3MgKGlmIG5vdCBzZXQgYWxyZWFkeSlcbiAgICBpZiAoIX5jbGFzc05hbWVzLmluZGV4T2YoJ3N2Zy1wYW4tem9vbV92aWV3cG9ydCcpKSB7XG4gICAgICBjbGFzc05hbWVzLnB1c2goJ3N2Zy1wYW4tem9vbV92aWV3cG9ydCcpXG4gICAgICB2aWV3cG9ydC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lcy5qb2luKCcgJykpXG4gICAgfVxuXG4gICAgcmV0dXJuIHZpZXdwb3J0XG4gIH1cblxuICAvKipcbiAgICogU2V0IFNWRyBhdHRyaWJ1dGVzXG4gICAqXG4gICAqIEBwYXJhbSAge1NWR1NWR0VsZW1lbnR9IHN2Z1xuICAgKi9cbiAgLCBzZXR1cFN2Z0F0dHJpYnV0ZXM6IGZ1bmN0aW9uKHN2Zykge1xuICAgIC8vIFNldHRpbmcgZGVmYXVsdCBhdHRyaWJ1dGVzXG4gICAgc3ZnLnNldEF0dHJpYnV0ZSgneG1sbnMnLCB0aGlzLnN2Z05TKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlTlModGhpcy54bWxuc05TLCAneG1sbnM6eGxpbmsnLCB0aGlzLnhsaW5rTlMpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGVOUyh0aGlzLnhtbG5zTlMsICd4bWxuczpldicsIHRoaXMuZXZOUyk7XG5cbiAgICAvLyBOZWVkZWQgZm9yIEludGVybmV0IEV4cGxvcmVyLCBvdGhlcndpc2UgdGhlIHZpZXdwb3J0IG92ZXJmbG93c1xuICAgIGlmIChzdmcucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHN0eWxlID0gc3ZnLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSB8fCAnJztcbiAgICAgIGlmIChzdHlsZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ292ZXJmbG93JykgPT09IC0xKSB7XG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ292ZXJmbG93OiBoaWRkZW47ICcgKyBzdHlsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbi8qKlxuICogSG93IGxvbmcgSW50ZXJuZXQgRXhwbG9yZXIgdGFrZXMgdG8gZmluaXNoIHVwZGF0aW5nIGl0cyBkaXNwbGF5IChtcykuXG4gKi9cbiwgaW50ZXJuZXRFeHBsb3JlclJlZGlzcGxheUludGVydmFsOiAzMDBcblxuLyoqXG4gKiBGb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVkaXNwbGF5IGFsbCBTVkcgZWxlbWVudHMgdGhhdCByZWx5IG9uIGFuXG4gKiBlbGVtZW50IGRlZmluZWQgaW4gYSAnZGVmcycgc2VjdGlvbi4gSXQgd29ya3MgZ2xvYmFsbHksIGZvciBldmVyeVxuICogYXZhaWxhYmxlIGRlZnMgZWxlbWVudCBvbiB0aGUgcGFnZS5cbiAqIFRoZSB0aHJvdHRsaW5nIGlzIGludGVudGlvbmFsbHkgZ2xvYmFsLlxuICpcbiAqIFRoaXMgaXMgb25seSBuZWVkZWQgZm9yIElFLiBJdCBpcyBhcyBhIGhhY2sgdG8gbWFrZSBtYXJrZXJzIChhbmQgJ3VzZScgZWxlbWVudHM/KVxuICogdmlzaWJsZSBhZnRlciBwYW4vem9vbSB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBTVkdzIG9uIHRoZSBwYWdlLlxuICogU2VlIGJ1ZyByZXBvcnQ6IGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvNzgxOTY0L1xuICogYWxzbyBzZWUgc3ZnLXBhbi16b29tIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vYXJpdXR0YS9zdmctcGFuLXpvb20vaXNzdWVzLzYyXG4gKi9cbiwgcmVmcmVzaERlZnNHbG9iYWw6IFV0aWxzLnRocm90dGxlKGZ1bmN0aW9uKCkge1xuICAgIHZhciBhbGxEZWZzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnZGVmcycpO1xuICAgIHZhciBhbGxEZWZzQ291bnQgPSBhbGxEZWZzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbERlZnNDb3VudDsgaSsrKSB7XG4gICAgICB2YXIgdGhpc0RlZnMgPSBhbGxEZWZzW2ldO1xuICAgICAgdGhpc0RlZnMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpc0RlZnMsIHRoaXNEZWZzKTtcbiAgICB9XG4gIH0sIHRoaXMuaW50ZXJuZXRFeHBsb3JlclJlZGlzcGxheUludGVydmFsKVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybSBtYXRyaXggb2YgYW4gZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtTVkdNYXRyaXh9IG1hdHJpeCAgQ1RNXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZGVmc1xuICAgKi9cbiwgc2V0Q1RNOiBmdW5jdGlvbihlbGVtZW50LCBtYXRyaXgsIGRlZnMpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXNcbiAgICAgICwgcyA9ICdtYXRyaXgoJyArIG1hdHJpeC5hICsgJywnICsgbWF0cml4LmIgKyAnLCcgKyBtYXRyaXguYyArICcsJyArIG1hdHJpeC5kICsgJywnICsgbWF0cml4LmUgKyAnLCcgKyBtYXRyaXguZiArICcpJztcblxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgJ3RyYW5zZm9ybScsIHMpO1xuXG4gICAgLy8gSUUgaGFzIGEgYnVnIHRoYXQgbWFrZXMgbWFya2VycyBkaXNhcHBlYXIgb24gem9vbSAod2hlbiB0aGUgbWF0cml4IFwiYVwiIGFuZC9vciBcImRcIiBlbGVtZW50cyBjaGFuZ2UpXG4gICAgLy8gc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc2NTQ1Nzgvc3ZnLW1hcmtlci1kb2VzLW5vdC13b3JrLWluLWllOS0xMFxuICAgIC8vIGFuZCBodHRwOi8vc3JuZG9saGEud29yZHByZXNzLmNvbS8yMDEzLzExLzI1L3N2Zy1saW5lLW1hcmtlcnMtbWF5LWRpc2FwcGVhci1pbi1pbnRlcm5ldC1leHBsb3Jlci0xMS9cbiAgICBpZiAoX2Jyb3dzZXIgPT09ICdpZScgJiYgISFkZWZzKSB7XG4gICAgICAvLyB0aGlzIHJlZnJlc2ggaXMgaW50ZW5kZWQgZm9yIHJlZGlzcGxheWluZyB0aGUgU1ZHIGR1cmluZyB6b29taW5nXG4gICAgICBkZWZzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRlZnMsIGRlZnMpO1xuICAgICAgLy8gdGhpcyByZWZyZXNoIGlzIGludGVuZGVkIGZvciByZWRpc3BsYXlpbmcgdGhlIG90aGVyIFNWR3Mgb24gYSBwYWdlIHdoZW4gcGFubmluZyBhIGdpdmVuIFNWR1xuICAgICAgLy8gaXQgaXMgYWxzbyBuZWVkZWQgZm9yIHRoZSBnaXZlbiBTVkcgaXRzZWxmLCBvbiB6b29tRW5kLCBpZiB0aGUgU1ZHIGNvbnRhaW5zIGFueSBtYXJrZXJzIHRoYXRcbiAgICAgIC8vIGFyZSBsb2NhdGVkIHVuZGVyIGFueSBvdGhlciBlbGVtZW50KHMpLlxuICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQucmVmcmVzaERlZnNHbG9iYWwoKTtcbiAgICAgIH0sIHRoYXQuaW50ZXJuZXRFeHBsb3JlclJlZGlzcGxheUludGVydmFsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5zdGFudGlhdGUgYW4gU1ZHUG9pbnQgb2JqZWN0IHdpdGggZ2l2ZW4gZXZlbnQgY29vcmRpbmF0ZXNcbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZ0XG4gICAqIEBwYXJhbSAge1NWR1NWR0VsZW1lbnR9IHN2Z1xuICAgKiBAcmV0dXJuIHtTVkdQb2ludH0gICAgIHBvaW50XG4gICAqL1xuLCBnZXRFdmVudFBvaW50OiBmdW5jdGlvbihldnQsIHN2Zykge1xuICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpXG5cbiAgICBVdGlscy5tb3VzZUFuZFRvdWNoTm9ybWFsaXplKGV2dCwgc3ZnKVxuXG4gICAgcG9pbnQueCA9IGV2dC5jbGllbnRYXG4gICAgcG9pbnQueSA9IGV2dC5jbGllbnRZXG5cbiAgICByZXR1cm4gcG9pbnRcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgU1ZHIGNlbnRlciBwb2ludFxuICAgKlxuICAgKiBAcGFyYW0gIHtTVkdTVkdFbGVtZW50fSBzdmdcbiAgICogQHJldHVybiB7U1ZHUG9pbnR9XG4gICAqL1xuLCBnZXRTdmdDZW50ZXJQb2ludDogZnVuY3Rpb24oc3ZnLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlU1ZHUG9pbnQoc3ZnLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgU1ZHUG9pbnQgd2l0aCBnaXZlbiB4IGFuZCB5XG4gICAqXG4gICAqIEBwYXJhbSAge1NWR1NWR0VsZW1lbnR9IHN2Z1xuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHhcbiAgICogQHBhcmFtICB7TnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge1NWR1BvaW50fVxuICAgKi9cbiwgY3JlYXRlU1ZHUG9pbnQ6IGZ1bmN0aW9uKHN2ZywgeCwgeSkge1xuICAgIHZhciBwb2ludCA9IHN2Zy5jcmVhdGVTVkdQb2ludCgpXG4gICAgcG9pbnQueCA9IHhcbiAgICBwb2ludC55ID0geVxuXG4gICAgcmV0dXJuIHBvaW50XG4gIH1cbn1cbiIsIi8vIHVuaXdoZWVsIDAuMS4yIChjdXN0b21pemVkKVxuLy8gQSB1bmlmaWVkIGNyb3NzIGJyb3dzZXIgbW91c2Ugd2hlZWwgZXZlbnQgaGFuZGxlclxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RlZW11YWxhcC91bml3aGVlbFxuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpe1xuXG4gIC8vRnVsbCBkZXRhaWxzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9SZWZlcmVuY2UvRXZlbnRzL3doZWVsXG5cbiAgdmFyIHByZWZpeCA9IFwiXCIsIF9hZGRFdmVudExpc3RlbmVyLCBfcmVtb3ZlRXZlbnRMaXN0ZW5lciwgb253aGVlbCwgc3VwcG9ydCwgZm5zID0gW107XG5cbiAgLy8gZGV0ZWN0IGV2ZW50IG1vZGVsXG4gIGlmICggd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG4gICAgX2FkZEV2ZW50TGlzdGVuZXIgPSBcImFkZEV2ZW50TGlzdGVuZXJcIjtcbiAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiO1xuICB9IGVsc2Uge1xuICAgIF9hZGRFdmVudExpc3RlbmVyID0gXCJhdHRhY2hFdmVudFwiO1xuICAgIF9yZW1vdmVFdmVudExpc3RlbmVyID0gXCJkZXRhY2hFdmVudFwiO1xuICAgIHByZWZpeCA9IFwib25cIjtcbiAgfVxuXG4gIC8vIGRldGVjdCBhdmFpbGFibGUgd2hlZWwgZXZlbnRcbiAgc3VwcG9ydCA9IFwib253aGVlbFwiIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgPyBcIndoZWVsXCIgOiAvLyBNb2Rlcm4gYnJvd3NlcnMgc3VwcG9ydCBcIndoZWVsXCJcbiAgICAgICAgICAgIGRvY3VtZW50Lm9ubW91c2V3aGVlbCAhPT0gdW5kZWZpbmVkID8gXCJtb3VzZXdoZWVsXCIgOiAvLyBXZWJraXQgYW5kIElFIHN1cHBvcnQgYXQgbGVhc3QgXCJtb3VzZXdoZWVsXCJcbiAgICAgICAgICAgIFwiRE9NTW91c2VTY3JvbGxcIjsgLy8gbGV0J3MgYXNzdW1lIHRoYXQgcmVtYWluaW5nIGJyb3dzZXJzIGFyZSBvbGRlciBGaXJlZm94XG5cblxuICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFjayhlbGVtZW50LGNhbGxiYWNrLGNhcHR1cmUpIHtcblxuICAgIHZhciBmbiA9IGZ1bmN0aW9uKG9yaWdpbmFsRXZlbnQpIHtcblxuICAgICAgIW9yaWdpbmFsRXZlbnQgJiYgKCBvcmlnaW5hbEV2ZW50ID0gd2luZG93LmV2ZW50ICk7XG5cbiAgICAgIC8vIGNyZWF0ZSBhIG5vcm1hbGl6ZWQgZXZlbnQgb2JqZWN0XG4gICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgIC8vIGtlZXAgYSByZWYgdG8gdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBvcmlnaW5hbEV2ZW50LFxuICAgICAgICB0YXJnZXQ6IG9yaWdpbmFsRXZlbnQudGFyZ2V0IHx8IG9yaWdpbmFsRXZlbnQuc3JjRWxlbWVudCxcbiAgICAgICAgdHlwZTogXCJ3aGVlbFwiLFxuICAgICAgICBkZWx0YU1vZGU6IG9yaWdpbmFsRXZlbnQudHlwZSA9PSBcIk1vek1vdXNlUGl4ZWxTY3JvbGxcIiA/IDAgOiAxLFxuICAgICAgICBkZWx0YVg6IDAsXG4gICAgICAgIGRlbGF0WjogMCxcbiAgICAgICAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG9yaWdpbmFsRXZlbnQucHJldmVudERlZmF1bHQgP1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpIDpcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gY2FsY3VsYXRlIGRlbHRhWSAoYW5kIGRlbHRhWCkgYWNjb3JkaW5nIHRvIHRoZSBldmVudFxuICAgICAgaWYgKCBzdXBwb3J0ID09IFwibW91c2V3aGVlbFwiICkge1xuICAgICAgICBldmVudC5kZWx0YVkgPSAtIDEvNDAgKiBvcmlnaW5hbEV2ZW50LndoZWVsRGVsdGE7XG4gICAgICAgIC8vIFdlYmtpdCBhbHNvIHN1cHBvcnQgd2hlZWxEZWx0YVhcbiAgICAgICAgb3JpZ2luYWxFdmVudC53aGVlbERlbHRhWCAmJiAoIGV2ZW50LmRlbHRhWCA9IC0gMS80MCAqIG9yaWdpbmFsRXZlbnQud2hlZWxEZWx0YVggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV2ZW50LmRlbHRhWSA9IG9yaWdpbmFsRXZlbnQuZGV0YWlsO1xuICAgICAgfVxuXG4gICAgICAvLyBpdCdzIHRpbWUgdG8gZmlyZSB0aGUgY2FsbGJhY2tcbiAgICAgIHJldHVybiBjYWxsYmFjayggZXZlbnQgKTtcblxuICAgIH07XG5cbiAgICBmbnMucHVzaCh7XG4gICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgZm46IGZuLFxuICAgICAgY2FwdHVyZTogY2FwdHVyZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q2FsbGJhY2soZWxlbWVudCxjYXB0dXJlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChmbnNbaV0uZWxlbWVudCA9PT0gZWxlbWVudCAmJiBmbnNbaV0uY2FwdHVyZSA9PT0gY2FwdHVyZSkge1xuICAgICAgICByZXR1cm4gZm5zW2ldLmZuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKXt9O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQ2FsbGJhY2soZWxlbWVudCxjYXB0dXJlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChmbnNbaV0uZWxlbWVudCA9PT0gZWxlbWVudCAmJiBmbnNbaV0uY2FwdHVyZSA9PT0gY2FwdHVyZSkge1xuICAgICAgICByZXR1cm4gZm5zLnNwbGljZShpLDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9hZGRXaGVlbExpc3RlbmVyKCBlbGVtLCBldmVudE5hbWUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlICkge1xuXG4gICAgdmFyIGNiO1xuXG4gICAgaWYgKHN1cHBvcnQgPT09IFwid2hlZWxcIikge1xuICAgICAgY2IgPSBjYWxsYmFjaztcbiAgICB9IGVsc2Uge1xuICAgICAgY2IgPSBjcmVhdGVDYWxsYmFjayhlbGVtLGNhbGxiYWNrLHVzZUNhcHR1cmUpO1xuICAgIH1cblxuICAgIGVsZW1bIF9hZGRFdmVudExpc3RlbmVyIF0oIHByZWZpeCArIGV2ZW50TmFtZSwgY2IsIHVzZUNhcHR1cmUgfHwgZmFsc2UgKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gX3JlbW92ZVdoZWVsTGlzdGVuZXIoIGVsZW0sIGV2ZW50TmFtZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUgKSB7XG5cbiAgICBpZiAoc3VwcG9ydCA9PT0gXCJ3aGVlbFwiKSB7XG4gICAgICBjYiA9IGNhbGxiYWNrO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYiA9IGdldENhbGxiYWNrKGVsZW0sdXNlQ2FwdHVyZSk7XG4gICAgfVxuXG4gICAgZWxlbVsgX3JlbW92ZUV2ZW50TGlzdGVuZXIgXSggcHJlZml4ICsgZXZlbnROYW1lLCBjYiwgdXNlQ2FwdHVyZSB8fCBmYWxzZSApO1xuXG4gICAgcmVtb3ZlQ2FsbGJhY2soZWxlbSx1c2VDYXB0dXJlKTtcblxuICB9XG5cbiAgZnVuY3Rpb24gYWRkV2hlZWxMaXN0ZW5lciggZWxlbSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUgKSB7XG4gICAgX2FkZFdoZWVsTGlzdGVuZXIoIGVsZW0sIHN1cHBvcnQsIGNhbGxiYWNrLCB1c2VDYXB0dXJlICk7XG5cbiAgICAvLyBoYW5kbGUgTW96TW91c2VQaXhlbFNjcm9sbCBpbiBvbGRlciBGaXJlZm94XG4gICAgaWYoIHN1cHBvcnQgPT0gXCJET01Nb3VzZVNjcm9sbFwiICkge1xuICAgICAgICBfYWRkV2hlZWxMaXN0ZW5lciggZWxlbSwgXCJNb3pNb3VzZVBpeGVsU2Nyb2xsXCIsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVXaGVlbExpc3RlbmVyKGVsZW0sY2FsbGJhY2ssdXNlQ2FwdHVyZSl7XG4gICAgX3JlbW92ZVdoZWVsTGlzdGVuZXIoZWxlbSxzdXBwb3J0LGNhbGxiYWNrLHVzZUNhcHR1cmUpO1xuXG4gICAgLy8gaGFuZGxlIE1vek1vdXNlUGl4ZWxTY3JvbGwgaW4gb2xkZXIgRmlyZWZveFxuICAgIGlmKCBzdXBwb3J0ID09IFwiRE9NTW91c2VTY3JvbGxcIiApIHtcbiAgICAgICAgX3JlbW92ZVdoZWVsTGlzdGVuZXIoZWxlbSwgXCJNb3pNb3VzZVBpeGVsU2Nyb2xsXCIsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uOiBhZGRXaGVlbExpc3RlbmVyLFxuICAgIG9mZjogcmVtb3ZlV2hlZWxMaXN0ZW5lclxuICB9O1xuXG59KSgpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8qKlxuICAgKiBFeHRlbmRzIGFuIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHRhcmdldCBvYmplY3QgdG8gZXh0ZW5kXG4gICAqIEBwYXJhbSAge09iamVjdH0gc291cmNlIG9iamVjdCB0byB0YWtlIHByb3BlcnRpZXMgZnJvbVxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICBleHRlbmRlZCBvYmplY3RcbiAgICovXG4gIGV4dGVuZDogZnVuY3Rpb24odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgIC8vIEdvIHJlY3Vyc2l2ZWx5XG4gICAgICBpZiAodGhpcy5pc09iamVjdChzb3VyY2VbcHJvcF0pKSB7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHRoaXMuZXh0ZW5kKHRhcmdldFtwcm9wXSwgc291cmNlW3Byb3BdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGFuIG9iamVjdCBpcyBhIERPTSBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG8gSFRNTCBlbGVtZW50IG9yIFN0cmluZ1xuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgIHJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgYSBET00gZWxlbWVudFxuICAgKi9cbiwgaXNFbGVtZW50OiBmdW5jdGlvbihvKXtcbiAgICByZXR1cm4gKFxuICAgICAgbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8IG8gaW5zdGFuY2VvZiBTVkdFbGVtZW50IHx8IG8gaW5zdGFuY2VvZiBTVkdTVkdFbGVtZW50IHx8IC8vRE9NMlxuICAgICAgKG8gJiYgdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG8gIT09IG51bGwgJiYgby5ub2RlVHlwZSA9PT0gMSAmJiB0eXBlb2Ygby5ub2RlTmFtZSA9PT0gJ3N0cmluZycpXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYW4gb2JqZWN0IGlzIGFuIE9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvIE9iamVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgIHJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgYW4gT2JqZWN0XG4gICAqL1xuLCBpc09iamVjdDogZnVuY3Rpb24obyl7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHZhcmlhYmxlIGlzIE51bWJlclxuICAgKlxuICAgKiBAcGFyYW0gIHtJbnRlZ2VyfEZsb2F0fSAgblxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgIHJldHVybnMgdHJ1ZSBpZiB2YXJpYWJsZSBpcyBOdW1iZXJcbiAgICovXG4sIGlzTnVtYmVyOiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZWFyY2ggZm9yIGFuIFNWRyBlbGVtZW50XG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdHxTdHJpbmd9IGVsZW1lbnRPclNlbGVjdG9yIERPTSBFbGVtZW50IG9yIHNlbGVjdG9yIFN0cmluZ1xuICAgKiBAcmV0dXJuIHtPYmplY3R8TnVsbH0gICAgICAgICAgICAgICAgICAgU1ZHIG9yIG51bGxcbiAgICovXG4sIGdldFN2ZzogZnVuY3Rpb24oZWxlbWVudE9yU2VsZWN0b3IpIHtcbiAgICB2YXIgZWxlbWVudFxuICAgICAgLCBzdmc7XG5cbiAgICBpZiAoIXRoaXMuaXNFbGVtZW50KGVsZW1lbnRPclNlbGVjdG9yKSkge1xuICAgICAgLy8gSWYgc2VsZWN0b3IgcHJvdmlkZWRcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudE9yU2VsZWN0b3IgPT09ICdzdHJpbmcnIHx8IGVsZW1lbnRPclNlbGVjdG9yIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgIC8vIFRyeSB0byBmaW5kIHRoZSBlbGVtZW50XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnRPclNlbGVjdG9yKVxuXG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdmlkZWQgc2VsZWN0b3IgZGlkIG5vdCBmaW5kIGFueSBlbGVtZW50cy4gU2VsZWN0b3I6ICcgKyBlbGVtZW50T3JTZWxlY3RvcilcbiAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3ZpZGVkIHNlbGVjdG9yIGlzIG5vdCBhbiBIVE1MIG9iamVjdCBub3IgU3RyaW5nJylcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnRPclNlbGVjdG9yXG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJykge1xuICAgICAgc3ZnID0gZWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBzdmcgPSBlbGVtZW50LmNvbnRlbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdlbWJlZCcpIHtcbiAgICAgICAgICBzdmcgPSBlbGVtZW50LmdldFNWR0RvY3VtZW50KCkuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChlbGVtZW50LnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2ltZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNjcmlwdCBhbiBTVkcgaW4gYW4gXCJpbWdcIiBlbGVtZW50LiBQbGVhc2UgdXNlIGFuIFwib2JqZWN0XCIgZWxlbWVudCBvciBhbiBpbi1saW5lIFNWRy4nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZ2V0IFNWRy4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzdmdcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRhY2ggYSBnaXZlbiBjb250ZXh0IHRvIGEgZnVuY3Rpb25cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgICAgRnVuY3Rpb25cbiAgICogQHBhcmFtICB7T2JqZWN0fSAgIGNvbnRleHQgQ29udGV4dFxuICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gICAgICAgICAgIEZ1bmN0aW9uIHdpdGggY2VydGFpbiBjb250ZXh0XG4gICAqL1xuLCBwcm94eTogZnVuY3Rpb24oZm4sIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9iamVjdCB0eXBlXG4gICAqIFVzZXMgdG9TdHJpbmcgdGhhdCByZXR1cm5zIFtvYmplY3QgU1ZHUG9pbnRdXG4gICAqIEFuZCB0aGFuIHBhcnNlcyBvYmplY3QgdHlwZSBmcm9tIHN0cmluZ1xuICAgKlxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG8gQW55IG9iamVjdFxuICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgT2JqZWN0IHR5cGVcbiAgICovXG4sIGdldFR5cGU6IGZ1bmN0aW9uKG8pIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShvKS5yZXBsYWNlKC9eXFxbb2JqZWN0XFxzLywgJycpLnJlcGxhY2UoL1xcXSQvLCAnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBpdCBpcyBhIHRvdWNoIGV2ZW50IHRoYW4gYWRkIGNsaWVudFggYW5kIGNsaWVudFkgdG8gZXZlbnQgb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSAge0V2ZW50fSBldnRcbiAgICogQHBhcmFtICB7U1ZHU1ZHRWxlbWVudH0gc3ZnXG4gICAqL1xuLCBtb3VzZUFuZFRvdWNoTm9ybWFsaXplOiBmdW5jdGlvbihldnQsIHN2Zykge1xuICAgIC8vIElmIG5vIGNpbGVudFggYW5kIGJ1dCB0b3VjaCBvYmplY3RzIGFyZSBhdmFpbGFibGVcbiAgICBpZiAoZXZ0LmNsaWVudFggPT09IHZvaWQgMCB8fCBldnQuY2xpZW50WCA9PT0gbnVsbCkge1xuICAgICAgLy8gRmFsbGJhY2tcbiAgICAgIGV2dC5jbGllbnRYID0gMFxuICAgICAgZXZ0LmNsaWVudFkgPSAwXG5cbiAgICAgIC8vIElmIGl0IGlzIGEgdG91Y2ggZXZlbnRcbiAgICAgIGlmIChldnQuY2hhbmdlZFRvdWNoZXMgIT09IHZvaWQgMCAmJiBldnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIElmIHRvdWNoIGV2ZW50IGhhcyBjaGFuZ2VkVG91Y2hlc1xuICAgICAgICBpZiAoZXZ0LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFggIT09IHZvaWQgMCkge1xuICAgICAgICAgIGV2dC5jbGllbnRYID0gZXZ0LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFhcbiAgICAgICAgICBldnQuY2xpZW50WSA9IGV2dC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZXG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgY2hhbmdlZFRvdWNoZXMgaGFzIHBhZ2VYIGF0dHJpYnV0ZVxuICAgICAgICBlbHNlIGlmIChldnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciByZWN0ID0gc3ZnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgZXZ0LmNsaWVudFggPSBldnQuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVggLSByZWN0LmxlZnRcbiAgICAgICAgICBldnQuY2xpZW50WSA9IGV2dC5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWSAtIHJlY3QudG9wXG4gICAgICAgIH1cbiAgICAgIC8vIElmIGl0IGlzIGEgY3VzdG9tIGV2ZW50XG4gICAgICB9IGVsc2UgaWYgKGV2dC5vcmlnaW5hbEV2ZW50ICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKGV2dC5vcmlnaW5hbEV2ZW50LmNsaWVudFggIT09IHZvaWQgMCkge1xuICAgICAgICAgIGV2dC5jbGllbnRYID0gZXZ0Lm9yaWdpbmFsRXZlbnQuY2xpZW50WFxuICAgICAgICAgIGV2dC5jbGllbnRZID0gZXZ0Lm9yaWdpbmFsRXZlbnQuY2xpZW50WVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGV2ZW50IGlzIGEgZG91YmxlIGNsaWNrL3RhcFxuICAgKiBUT0RPOiBGb3IgdG91Y2ggZ2VzdHVyZXMgdXNlIGEgbGlicmFyeSAoaGFtbWVyLmpzKSB0aGF0IHRha2VzIGluIGFjY291bnQgb3RoZXIgZXZlbnRzXG4gICAqICh0b3VjaG1vdmUgYW5kIHRvdWNoZW5kKS4gSXQgc2hvdWxkIHRha2UgaW4gYWNjb3VudCB0YXAgZHVyYXRpb24gYW5kIHRyYXZlbGVkIGRpc3RhbmNlXG4gICAqXG4gICAqIEBwYXJhbSAge0V2ZW50fSAgZXZ0XG4gICAqIEBwYXJhbSAge0V2ZW50fSAgcHJldkV2dCBQcmV2aW91cyBFdmVudFxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiwgaXNEYmxDbGljazogZnVuY3Rpb24oZXZ0LCBwcmV2RXZ0KSB7XG4gICAgLy8gRG91YmxlIGNsaWNrIGRldGVjdGVkIGJ5IGJyb3dzZXJcbiAgICBpZiAoZXZ0LmRldGFpbCA9PT0gMikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFRyeSB0byBjb21wYXJlIGV2ZW50c1xuICAgIGVsc2UgaWYgKHByZXZFdnQgIT09IHZvaWQgMCAmJiBwcmV2RXZ0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgdGltZVN0YW1wRGlmZiA9IGV2dC50aW1lU3RhbXAgLSBwcmV2RXZ0LnRpbWVTdGFtcCAvLyBzaG91bGQgYmUgbG93ZXIgdGhhbiAyNTAgbXNcbiAgICAgICAgLCB0b3VjaGVzRGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coZXZ0LmNsaWVudFggLSBwcmV2RXZ0LmNsaWVudFgsIDIpICsgTWF0aC5wb3coZXZ0LmNsaWVudFkgLSBwcmV2RXZ0LmNsaWVudFksIDIpKVxuXG4gICAgICByZXR1cm4gdGltZVN0YW1wRGlmZiA8IDI1MCAmJiB0b3VjaGVzRGlzdGFuY2UgPCAxMFxuICAgIH1cblxuICAgIC8vIE5vdGhpbmcgZm91bmRcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4sIG5vdzogRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG5cbiAgLy8gRnJvbSB1bmRlcnNjb3JlLlxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4vLyBqc2NzOmRpc2FibGVcbi8vIGpzaGludCBpZ25vcmU6c3RhcnRcbiwgdGhyb3R0bGU6IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiB0aGF0Lm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gdGhhdC5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9XG4vLyBqc2hpbnQgaWdub3JlOmVuZFxuLy8ganNjczplbmFibGVcblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHNpbXVsYXRpb25cbiAgICpcbiAgICogQHBhcmFtICB7TnVtYmVyfFN0cmluZ30gcmVmcmVzaFJhdGVcbiAgICogQHJldHVybiB7RnVuY3Rpb259XG4gICAqL1xuLCBjcmVhdGVSZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uKHJlZnJlc2hSYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQgPSBudWxsXG5cbiAgICAvLyBDb252ZXJ0IHJlZnJlc2hSYXRlIHRvIHRpbWVvdXRcbiAgICBpZiAocmVmcmVzaFJhdGUgIT09ICdhdXRvJyAmJiByZWZyZXNoUmF0ZSA8IDYwICYmIHJlZnJlc2hSYXRlID4gMSkge1xuICAgICAgdGltZW91dCA9IE1hdGguZmxvb3IoMTAwMCAvIHJlZnJlc2hSYXRlKVxuICAgIH1cblxuICAgIGlmICh0aW1lb3V0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCByZXF1ZXN0VGltZW91dCgzMylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlcXVlc3RUaW1lb3V0KHRpbWVvdXQpXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2FsbGJhY2sgdGhhdCB3aWxsIGV4ZWN1dGUgYWZ0ZXIgYSBnaXZlbiB0aW1lb3V0XG4gKlxuICogQHBhcmFtICB7RnVuY3Rpb259IHRpbWVvdXRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiByZXF1ZXN0VGltZW91dCh0aW1lb3V0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCB0aW1lb3V0KVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2luZGV4LmpzJyk7XG4iLCIvKipcbiAqIHRlcm0uanMgLSBhbiB4dGVybSBlbXVsYXRvclxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTMsIENocmlzdG9waGVyIEplZmZyZXkgKE1JVCBMaWNlbnNlKVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NoamovdGVybS5qc1xuICovXG5cbmZ1bmN0aW9uIHRlcm0ob3B0aW9ucykge1xuICByZXR1cm4gbmV3IHRlcm0uVGVybWluYWwob3B0aW9ucyk7XG59XG5cbnRlcm0ubWlkZGxld2FyZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgdmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnBhdGggfHwgJy90ZXJtLmpzJztcblxuICByZXR1cm4gZnVuY3Rpb24ocmVxLCByZXMsIG5leHQpIHtcbiAgICBpZiAodXJsLnBhcnNlKHJlcS51cmwpLnBhdGhuYW1lICE9PSBvcHRpb25zLnBhdGgpIHtcbiAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKCtuZXcgRGF0ZShyZXEuaGVhZGVyc1snaWYtbW9kaWZpZWQtc2luY2UnXSkgPT09IHRlcm0ubGFzdCkge1xuICAgICAgcmVzLnN0YXR1c0NvZGUgPSAzMDQ7XG4gICAgICByZXMuZW5kKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVzLndyaXRlSGVhZCgyMDAsIHtcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdDsgY2hhcnNldD11dGYtOCcsXG4gICAgICAnQ29udGVudC1MZW5ndGgnOiBCdWZmZXIuYnl0ZUxlbmd0aCh0ZXJtLnNjcmlwdCksXG4gICAgICAnTGFzdC1Nb2RpZmllZCc6IHRlcm0ubGFzdFxuICAgIH0pO1xuXG4gICAgcmVzLmVuZCh0ZXJtLnNjcmlwdCk7XG4gIH07XG59O1xuXG50ZXJtLnBhdGggPSBfX2Rpcm5hbWUgKyAnLy4uL3NyYy90ZXJtLmpzJztcblxudGVybS5fX2RlZmluZUdldHRlcl9fKCdzY3JpcHQnLCBmdW5jdGlvbigpIHtcbiAgaWYgKHRlcm0uX3NjcmlwdCkgcmV0dXJuIHRlcm0uX3NjcmlwdDtcbiAgdGVybS5sYXN0ID0gK25ldyBEYXRlO1xuICByZXR1cm4gdGVybS5fc2NyaXB0ID0gcmVxdWlyZSgnZnMnKS5yZWFkRmlsZVN5bmModGVybS5wYXRoLCAndXRmOCcpO1xufSk7XG5cbnRlcm0uX19kZWZpbmVHZXR0ZXJfXygnVGVybWluYWwnLCBmdW5jdGlvbigpIHtcbiAgaWYgKHRlcm0uX1Rlcm1pbmFsKSByZXR1cm4gdGVybS5fVGVybWluYWw7XG4gIHJldHVybiB0ZXJtLl9UZXJtaW5hbCA9IHJlcXVpcmUoJy4uL3NyYy90ZXJtJyk7XG59KTtcblxuLyoqXG4gKiBFeHBvc2VcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRlcm07XG4iLCIvKipcbiAqIHRlcm0uanMgLSBhbiB4dGVybSBlbXVsYXRvclxuICogQ29weXJpZ2h0IChjKSAyMDEyLTIwMTMsIENocmlzdG9waGVyIEplZmZyZXkgKE1JVCBMaWNlbnNlKVxuICogaHR0cHM6Ly9naXRodWIuY29tL2NoamovdGVybS5qc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKlxuICogT3JpZ2luYWxseSBmb3JrZWQgZnJvbSAod2l0aCB0aGUgYXV0aG9yJ3MgcGVybWlzc2lvbik6XG4gKiAgIEZhYnJpY2UgQmVsbGFyZCdzIGphdmFzY3JpcHQgdnQxMDAgZm9yIGpzbGludXg6XG4gKiAgIGh0dHA6Ly9iZWxsYXJkLm9yZy9qc2xpbnV4L1xuICogICBDb3B5cmlnaHQgKGMpIDIwMTEgRmFicmljZSBCZWxsYXJkXG4gKiAgIFRoZSBvcmlnaW5hbCBkZXNpZ24gcmVtYWlucy4gVGhlIHRlcm1pbmFsIGl0c2VsZlxuICogICBoYXMgYmVlbiBleHRlbmRlZCB0byBpbmNsdWRlIHh0ZXJtIENTSSBjb2RlcywgYW1vbmdcbiAqICAgb3RoZXIgZmVhdHVyZXMuXG4gKi9cblxuOyhmdW5jdGlvbigpIHtcblxuLyoqXG4gKiBUZXJtaW5hbCBFbXVsYXRpb24gUmVmZXJlbmNlczpcbiAqICAgaHR0cDovL3Z0MTAwLm5ldC9cbiAqICAgaHR0cDovL2ludmlzaWJsZS1pc2xhbmQubmV0L3h0ZXJtL2N0bHNlcXMvY3Rsc2Vxcy50eHRcbiAqICAgaHR0cDovL2ludmlzaWJsZS1pc2xhbmQubmV0L3h0ZXJtL2N0bHNlcXMvY3Rsc2Vxcy5odG1sXG4gKiAgIGh0dHA6Ly9pbnZpc2libGUtaXNsYW5kLm5ldC92dHRlc3QvXG4gKiAgIGh0dHA6Ly93d3cuaW53YXAuY29tL3BkcDEwL2Fuc2ljb2RlLnR4dFxuICogICBodHRwOi8vbGludXguZGllLm5ldC9tYW4vNC9jb25zb2xlX2NvZGVzXG4gKiAgIGh0dHA6Ly9saW51eC5kaWUubmV0L21hbi83L3VyeHZ0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNoYXJlZFxuICovXG5cbnZhciB3aW5kb3cgPSB0aGlzXG4gICwgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50O1xuXG4vKipcbiAqIEV2ZW50RW1pdHRlclxuICovXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdGhpcy5fZXZlbnRzW3R5cGVdID0gdGhpcy5fZXZlbnRzW3R5cGVdIHx8IFtdO1xuICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm47XG5cbiAgdmFyIG9iaiA9IHRoaXMuX2V2ZW50c1t0eXBlXVxuICAgICwgaSA9IG9iai5sZW5ndGg7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChvYmpbaV0gPT09IGxpc3RlbmVyIHx8IG9ialtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgIG9iai5zcGxpY2UoaSwgMSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKSBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgb24pO1xuICAgIHJldHVybiBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuICBvbi5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICByZXR1cm4gdGhpcy5vbih0eXBlLCBvbik7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKSByZXR1cm47XG5cbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBvYmogPSB0aGlzLl9ldmVudHNbdHlwZV1cbiAgICAsIGwgPSBvYmoubGVuZ3RoXG4gICAgLCBpID0gMDtcblxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIG9ialtpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNbdHlwZV0gPSB0aGlzLl9ldmVudHNbdHlwZV0gfHwgW107XG59O1xuXG4vKipcbiAqIFN0YXRlc1xuICovXG5cbnZhciBub3JtYWwgPSAwXG4gICwgZXNjYXBlZCA9IDFcbiAgLCBjc2kgPSAyXG4gICwgb3NjID0gM1xuICAsIGNoYXJzZXQgPSA0XG4gICwgZGNzID0gNVxuICAsIGlnbm9yZSA9IDY7XG5cbi8qKlxuICogVGVybWluYWxcbiAqL1xuXG5mdW5jdGlvbiBUZXJtaW5hbChvcHRpb25zKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGVybWluYWwpKSB7XG4gICAgcmV0dXJuIG5ldyBUZXJtaW5hbChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgfVxuXG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ251bWJlcicpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgY29sczogYXJndW1lbnRzWzBdLFxuICAgICAgcm93czogYXJndW1lbnRzWzFdLFxuICAgICAgaGFuZGxlcjogYXJndW1lbnRzWzJdXG4gICAgfTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGVhY2goa2V5cyhUZXJtaW5hbC5kZWZhdWx0cyksIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChvcHRpb25zW2tleV0gPT0gbnVsbCkge1xuICAgICAgb3B0aW9uc1trZXldID0gVGVybWluYWwub3B0aW9uc1trZXldO1xuICAgICAgLy8gTGVnYWN5OlxuICAgICAgaWYgKFRlcm1pbmFsW2tleV0gIT09IFRlcm1pbmFsLmRlZmF1bHRzW2tleV0pIHtcbiAgICAgICAgb3B0aW9uc1trZXldID0gVGVybWluYWxba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZltrZXldID0gb3B0aW9uc1trZXldO1xuICB9KTtcblxuICBpZiAob3B0aW9ucy5jb2xvcnMubGVuZ3RoID09PSA4KSB7XG4gICAgb3B0aW9ucy5jb2xvcnMgPSBvcHRpb25zLmNvbG9ycy5jb25jYXQoVGVybWluYWwuX2NvbG9ycy5zbGljZSg4KSk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5jb2xvcnMubGVuZ3RoID09PSAxNikge1xuICAgIG9wdGlvbnMuY29sb3JzID0gb3B0aW9ucy5jb2xvcnMuY29uY2F0KFRlcm1pbmFsLl9jb2xvcnMuc2xpY2UoMTYpKTtcbiAgfSBlbHNlIGlmIChvcHRpb25zLmNvbG9ycy5sZW5ndGggPT09IDEwKSB7XG4gICAgb3B0aW9ucy5jb2xvcnMgPSBvcHRpb25zLmNvbG9ycy5zbGljZSgwLCAtMikuY29uY2F0KFxuICAgICAgVGVybWluYWwuX2NvbG9ycy5zbGljZSg4LCAtMiksIG9wdGlvbnMuY29sb3JzLnNsaWNlKC0yKSk7XG4gIH0gZWxzZSBpZiAob3B0aW9ucy5jb2xvcnMubGVuZ3RoID09PSAxOCkge1xuICAgIG9wdGlvbnMuY29sb3JzID0gb3B0aW9ucy5jb2xvcnMuY29uY2F0KFxuICAgICAgVGVybWluYWwuX2NvbG9ycy5zbGljZSgxNiwgLTIpLCBvcHRpb25zLmNvbG9ycy5zbGljZSgtMikpO1xuICB9XG4gIHRoaXMuY29sb3JzID0gb3B0aW9ucy5jb2xvcnM7XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAvLyB0aGlzLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQgfHwgd2luZG93O1xuICAvLyB0aGlzLmRvY3VtZW50ID0gb3B0aW9ucy5kb2N1bWVudCB8fCBkb2N1bWVudDtcbiAgdGhpcy5wYXJlbnQgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5wYXJlbnRcbiAgICB8fCAoZG9jdW1lbnQgPyBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdIDogbnVsbCk7XG5cbiAgdGhpcy5jb2xzID0gb3B0aW9ucy5jb2xzIHx8IG9wdGlvbnMuZ2VvbWV0cnlbMF07XG4gIHRoaXMucm93cyA9IG9wdGlvbnMucm93cyB8fCBvcHRpb25zLmdlb21ldHJ5WzFdO1xuXG4gIGlmIChvcHRpb25zLmhhbmRsZXIpIHtcbiAgICB0aGlzLm9uKCdkYXRhJywgb3B0aW9ucy5oYW5kbGVyKTtcbiAgfVxuXG4gIHRoaXMueWJhc2UgPSAwO1xuICB0aGlzLnlkaXNwID0gMDtcbiAgdGhpcy54ID0gMDtcbiAgdGhpcy55ID0gMDtcbiAgdGhpcy5jdXJzb3JTdGF0ZSA9IDA7XG4gIHRoaXMuY3Vyc29ySGlkZGVuID0gZmFsc2U7XG4gIHRoaXMuY29udmVydEVvbDtcbiAgdGhpcy5zdGF0ZSA9IDA7XG4gIHRoaXMucXVldWUgPSAnJztcbiAgdGhpcy5zY3JvbGxUb3AgPSAwO1xuICB0aGlzLnNjcm9sbEJvdHRvbSA9IHRoaXMucm93cyAtIDE7XG5cbiAgLy8gbW9kZXNcbiAgdGhpcy5hcHBsaWNhdGlvbktleXBhZCA9IGZhbHNlO1xuICB0aGlzLmFwcGxpY2F0aW9uQ3Vyc29yID0gZmFsc2U7XG4gIHRoaXMub3JpZ2luTW9kZSA9IGZhbHNlO1xuICB0aGlzLmluc2VydE1vZGUgPSBmYWxzZTtcbiAgdGhpcy53cmFwYXJvdW5kTW9kZSA9IGZhbHNlO1xuICB0aGlzLm5vcm1hbCA9IG51bGw7XG5cbiAgLy8gc2VsZWN0IG1vZGVzXG4gIHRoaXMucHJlZml4TW9kZSA9IGZhbHNlO1xuICB0aGlzLnNlbGVjdE1vZGUgPSBmYWxzZTtcbiAgdGhpcy52aXN1YWxNb2RlID0gZmFsc2U7XG4gIHRoaXMuc2VhcmNoTW9kZSA9IGZhbHNlO1xuICB0aGlzLnNlYXJjaERvd247XG4gIHRoaXMuZW50cnkgPSAnJztcbiAgdGhpcy5lbnRyeVByZWZpeCA9ICdTZWFyY2g6ICc7XG4gIHRoaXMuX3JlYWw7XG4gIHRoaXMuX3NlbGVjdGVkO1xuICB0aGlzLl90ZXh0YXJlYTtcblxuICAvLyBjaGFyc2V0XG4gIHRoaXMuY2hhcnNldCA9IG51bGw7XG4gIHRoaXMuZ2NoYXJzZXQgPSBudWxsO1xuICB0aGlzLmdsZXZlbCA9IDA7XG4gIHRoaXMuY2hhcnNldHMgPSBbbnVsbF07XG5cbiAgLy8gbW91c2UgcHJvcGVydGllc1xuICB0aGlzLmRlY0xvY2F0b3I7XG4gIHRoaXMueDEwTW91c2U7XG4gIHRoaXMudnQyMDBNb3VzZTtcbiAgdGhpcy52dDMwME1vdXNlO1xuICB0aGlzLm5vcm1hbE1vdXNlO1xuICB0aGlzLm1vdXNlRXZlbnRzO1xuICB0aGlzLnNlbmRGb2N1cztcbiAgdGhpcy51dGZNb3VzZTtcbiAgdGhpcy5zZ3JNb3VzZTtcbiAgdGhpcy51cnh2dE1vdXNlO1xuXG4gIC8vIG1pc2NcbiAgdGhpcy5lbGVtZW50O1xuICB0aGlzLmNoaWxkcmVuO1xuICB0aGlzLnJlZnJlc2hTdGFydDtcbiAgdGhpcy5yZWZyZXNoRW5kO1xuICB0aGlzLnNhdmVkWDtcbiAgdGhpcy5zYXZlZFk7XG4gIHRoaXMuc2F2ZWRDb2xzO1xuXG4gIC8vIHN0cmVhbVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgdGhpcy5kZWZBdHRyID0gKDAgPDwgMTgpIHwgKDI1NyA8PCA5KSB8ICgyNTYgPDwgMCk7XG4gIHRoaXMuY3VyQXR0ciA9IHRoaXMuZGVmQXR0cjtcblxuICB0aGlzLnBhcmFtcyA9IFtdO1xuICB0aGlzLmN1cnJlbnRQYXJhbSA9IDA7XG4gIHRoaXMucHJlZml4ID0gJyc7XG4gIHRoaXMucG9zdGZpeCA9ICcnO1xuXG4gIHRoaXMubGluZXMgPSBbXTtcbiAgdmFyIGkgPSB0aGlzLnJvd3M7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB0aGlzLmxpbmVzLnB1c2godGhpcy5ibGFua0xpbmUoKSk7XG4gIH1cblxuICB0aGlzLnRhYnM7XG4gIHRoaXMuc2V0dXBTdG9wcygpO1xufVxuXG5pbmhlcml0cyhUZXJtaW5hbCwgRXZlbnRFbWl0dGVyKTtcblxuLy8gYmFja19jb2xvcl9lcmFzZSBmZWF0dXJlIGZvciB4dGVybS5cblRlcm1pbmFsLnByb3RvdHlwZS5lcmFzZUF0dHIgPSBmdW5jdGlvbigpIHtcbiAgLy8gaWYgKHRoaXMuaXMoJ3NjcmVlbicpKSByZXR1cm4gdGhpcy5kZWZBdHRyO1xuICByZXR1cm4gKHRoaXMuZGVmQXR0ciAmIH4weDFmZikgfCAodGhpcy5jdXJBdHRyICYgMHgxZmYpO1xufTtcblxuLyoqXG4gKiBDb2xvcnNcbiAqL1xuXG4vLyBDb2xvcnMgMC0xNVxuVGVybWluYWwudGFuZ29Db2xvcnMgPSBbXG4gIC8vIGRhcms6XG4gICcjMmUzNDM2JyxcbiAgJyNjYzAwMDAnLFxuICAnIzRlOWEwNicsXG4gICcjYzRhMDAwJyxcbiAgJyMzNDY1YTQnLFxuICAnIzc1NTA3YicsXG4gICcjMDY5ODlhJyxcbiAgJyNkM2Q3Y2YnLFxuICAvLyBicmlnaHQ6XG4gICcjNTU1NzUzJyxcbiAgJyNlZjI5MjknLFxuICAnIzhhZTIzNCcsXG4gICcjZmNlOTRmJyxcbiAgJyM3MjlmY2YnLFxuICAnI2FkN2ZhOCcsXG4gICcjMzRlMmUyJyxcbiAgJyNlZWVlZWMnXG5dO1xuXG5UZXJtaW5hbC54dGVybUNvbG9ycyA9IFtcbiAgLy8gZGFyazpcbiAgJyMwMDAwMDAnLCAvLyBibGFja1xuICAnI2NkMDAwMCcsIC8vIHJlZDNcbiAgJyMwMGNkMDAnLCAvLyBncmVlbjNcbiAgJyNjZGNkMDAnLCAvLyB5ZWxsb3czXG4gICcjMDAwMGVlJywgLy8gYmx1ZTJcbiAgJyNjZDAwY2QnLCAvLyBtYWdlbnRhM1xuICAnIzAwY2RjZCcsIC8vIGN5YW4zXG4gICcjZTVlNWU1JywgLy8gZ3JheTkwXG4gIC8vIGJyaWdodDpcbiAgJyM3ZjdmN2YnLCAvLyBncmF5NTBcbiAgJyNmZjAwMDAnLCAvLyByZWRcbiAgJyMwMGZmMDAnLCAvLyBncmVlblxuICAnI2ZmZmYwMCcsIC8vIHllbGxvd1xuICAnIzVjNWNmZicsIC8vIHJnYjo1Yy81Yy9mZlxuICAnI2ZmMDBmZicsIC8vIG1hZ2VudGFcbiAgJyMwMGZmZmYnLCAvLyBjeWFuXG4gICcjZmZmZmZmJyAgLy8gd2hpdGVcbl07XG5cbi8vIENvbG9ycyAwLTE1ICsgMTYtMjU1XG4vLyBNdWNoIHRoYW5rcyB0byBUb29UYWxsTmF0ZSBmb3Igd3JpdGluZyB0aGlzLlxuVGVybWluYWwuY29sb3JzID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgY29sb3JzID0gVGVybWluYWwudGFuZ29Db2xvcnMuc2xpY2UoKVxuICAgICwgciA9IFsweDAwLCAweDVmLCAweDg3LCAweGFmLCAweGQ3LCAweGZmXVxuICAgICwgaTtcblxuICAvLyAxNi0yMzFcbiAgaSA9IDA7XG4gIGZvciAoOyBpIDwgMjE2OyBpKyspIHtcbiAgICBvdXQoclsoaSAvIDM2KSAlIDYgfCAwXSwgclsoaSAvIDYpICUgNiB8IDBdLCByW2kgJSA2XSk7XG4gIH1cblxuICAvLyAyMzItMjU1IChncmV5KVxuICBpID0gMDtcbiAgZm9yICg7IGkgPCAyNDsgaSsrKSB7XG4gICAgciA9IDggKyBpICogMTA7XG4gICAgb3V0KHIsIHIsIHIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb3V0KHIsIGcsIGIpIHtcbiAgICBjb2xvcnMucHVzaCgnIycgKyBoZXgocikgKyBoZXgoZykgKyBoZXgoYikpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGV4KGMpIHtcbiAgICBjID0gYy50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGMubGVuZ3RoIDwgMiA/ICcwJyArIGMgOiBjO1xuICB9XG5cbiAgcmV0dXJuIGNvbG9ycztcbn0pKCk7XG5cbi8vIERlZmF1bHQgQkcvRkdcblRlcm1pbmFsLmNvbG9yc1syNTZdID0gJyMwMDAwMDAnO1xuVGVybWluYWwuY29sb3JzWzI1N10gPSAnI2YwZjBmMCc7XG5cblRlcm1pbmFsLl9jb2xvcnMgPSBUZXJtaW5hbC5jb2xvcnMuc2xpY2UoKTtcblxuVGVybWluYWwudmNvbG9ycyA9IChmdW5jdGlvbigpIHtcbiAgdmFyIG91dCA9IFtdXG4gICAgLCBjb2xvcnMgPSBUZXJtaW5hbC5jb2xvcnNcbiAgICAsIGkgPSAwXG4gICAgLCBjb2xvcjtcblxuICBmb3IgKDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgY29sb3IgPSBwYXJzZUludChjb2xvcnNbaV0uc3Vic3RyaW5nKDEpLCAxNik7XG4gICAgb3V0LnB1c2goW1xuICAgICAgKGNvbG9yID4+IDE2KSAmIDB4ZmYsXG4gICAgICAoY29sb3IgPj4gOCkgJiAweGZmLFxuICAgICAgY29sb3IgJiAweGZmXG4gICAgXSk7XG4gIH1cblxuICByZXR1cm4gb3V0O1xufSkoKTtcblxuLyoqXG4gKiBPcHRpb25zXG4gKi9cblxuVGVybWluYWwuZGVmYXVsdHMgPSB7XG4gIGNvbG9yczogVGVybWluYWwuY29sb3JzLFxuICBjb252ZXJ0RW9sOiBmYWxzZSxcbiAgdGVybU5hbWU6ICd4dGVybScsXG4gIGdlb21ldHJ5OiBbODAsIDI0XSxcbiAgY3Vyc29yQmxpbms6IHRydWUsXG4gIHZpc3VhbEJlbGw6IGZhbHNlLFxuICBwb3BPbkJlbGw6IGZhbHNlLFxuICBzY3JvbGxiYWNrOiAxMDAwLFxuICBzY3JlZW5LZXlzOiBmYWxzZSxcbiAgZGVidWc6IGZhbHNlLFxuICB1c2VTdHlsZTogZmFsc2VcbiAgLy8gcHJvZ3JhbUZlYXR1cmVzOiBmYWxzZSxcbiAgLy8gZm9jdXNLZXlzOiBmYWxzZSxcbn07XG5cblRlcm1pbmFsLm9wdGlvbnMgPSB7fTtcblxuZWFjaChrZXlzKFRlcm1pbmFsLmRlZmF1bHRzKSwgZnVuY3Rpb24oa2V5KSB7XG4gIFRlcm1pbmFsW2tleV0gPSBUZXJtaW5hbC5kZWZhdWx0c1trZXldO1xuICBUZXJtaW5hbC5vcHRpb25zW2tleV0gPSBUZXJtaW5hbC5kZWZhdWx0c1trZXldO1xufSk7XG5cbi8qKlxuICogRm9jdXNlZCBUZXJtaW5hbFxuICovXG5cblRlcm1pbmFsLmZvY3VzID0gbnVsbDtcblxuVGVybWluYWwucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24oKSB7XG4gIGlmIChUZXJtaW5hbC5mb2N1cyA9PT0gdGhpcykgcmV0dXJuO1xuXG4gIGlmIChUZXJtaW5hbC5mb2N1cykge1xuICAgIFRlcm1pbmFsLmZvY3VzLmJsdXIoKTtcbiAgfVxuXG4gIGlmICh0aGlzLnNlbmRGb2N1cykgdGhpcy5zZW5kKCdcXHgxYltJJyk7XG4gIHRoaXMuc2hvd0N1cnNvcigpO1xuXG4gIC8vIHRyeSB7XG4gIC8vICAgdGhpcy5lbGVtZW50LmZvY3VzKCk7XG4gIC8vIH0gY2F0Y2ggKGUpIHtcbiAgLy8gICA7XG4gIC8vIH1cblxuICAvLyB0aGlzLmVtaXQoJ2ZvY3VzJyk7XG5cbiAgVGVybWluYWwuZm9jdXMgPSB0aGlzO1xufTtcblxuVGVybWluYWwucHJvdG90eXBlLmJsdXIgPSBmdW5jdGlvbigpIHtcbiAgaWYgKFRlcm1pbmFsLmZvY3VzICE9PSB0aGlzKSByZXR1cm47XG5cbiAgdGhpcy5jdXJzb3JTdGF0ZSA9IDA7XG4gIHRoaXMucmVmcmVzaCh0aGlzLnksIHRoaXMueSk7XG4gIGlmICh0aGlzLnNlbmRGb2N1cykgdGhpcy5zZW5kKCdcXHgxYltPJyk7XG5cbiAgLy8gdHJ5IHtcbiAgLy8gICB0aGlzLmVsZW1lbnQuYmx1cigpO1xuICAvLyB9IGNhdGNoIChlKSB7XG4gIC8vICAgO1xuICAvLyB9XG5cbiAgLy8gdGhpcy5lbWl0KCdibHVyJyk7XG5cbiAgVGVybWluYWwuZm9jdXMgPSBudWxsO1xufTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGdsb2JhbCBiZWhhdmlvclxuICovXG5cblRlcm1pbmFsLnByb3RvdHlwZS5pbml0R2xvYmFsID0gZnVuY3Rpb24oKSB7XG4gIHZhciBkb2N1bWVudCA9IHRoaXMuZG9jdW1lbnQ7XG5cbiAgVGVybWluYWwuX2JvdW5kRG9jcyA9IFRlcm1pbmFsLl9ib3VuZERvY3MgfHwgW107XG4gIGlmICh+aW5kZXhPZihUZXJtaW5hbC5fYm91bmREb2NzLCBkb2N1bWVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgVGVybWluYWwuX2JvdW5kRG9jcy5wdXNoKGRvY3VtZW50KTtcblxuICBUZXJtaW5hbC5iaW5kUGFzdGUoZG9jdW1lbnQpO1xuXG4gIFRlcm1pbmFsLmJpbmRLZXlzKGRvY3VtZW50KTtcblxuICBUZXJtaW5hbC5iaW5kQ29weShkb2N1bWVudCk7XG5cbiAgaWYgKHRoaXMuaXNJcGFkIHx8IHRoaXMuaXNJcGhvbmUpIHtcbiAgICBUZXJtaW5hbC5maXhJcGFkKGRvY3VtZW50KTtcbiAgfVxuXG4gIGlmICh0aGlzLnVzZVN0eWxlKSB7XG4gICAgVGVybWluYWwuaW5zZXJ0U3R5bGUoZG9jdW1lbnQsIHRoaXMuY29sb3JzWzI1Nl0sIHRoaXMuY29sb3JzWzI1N10pO1xuICB9XG59O1xuXG4vKipcbiAqIEJpbmQgdG8gcGFzdGUgZXZlbnRcbiAqL1xuXG5UZXJtaW5hbC5iaW5kUGFzdGUgPSBmdW5jdGlvbihkb2N1bWVudCkge1xuICAvLyBUaGlzIHNlZW1zIHRvIHdvcmsgd2VsbCBmb3IgY3RybC1WIGFuZCBtaWRkbGUtY2xpY2ssXG4gIC8vIGV2ZW4gd2l0aG91dCB0aGUgY29udGVudEVkaXRhYmxlIHdvcmthcm91bmQuXG4gIHZhciB3aW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldztcbiAgb24od2luZG93LCAncGFzdGUnLCBmdW5jdGlvbihldikge1xuICAgIHZhciB0ZXJtID0gVGVybWluYWwuZm9jdXM7XG4gICAgaWYgKCF0ZXJtKSByZXR1cm47XG4gICAgaWYgKGV2LmNsaXBib2FyZERhdGEpIHtcbiAgICAgIHRlcm0uc2VuZChldi5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKSk7XG4gICAgfSBlbHNlIGlmICh0ZXJtLmNvbnRleHQuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgdGVybS5zZW5kKHRlcm0uY29udGV4dC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ1RleHQnKSk7XG4gICAgfVxuICAgIC8vIE5vdCBuZWNlc3NhcnkuIERvIGl0IGFueXdheSBmb3IgZ29vZCBtZWFzdXJlLlxuICAgIHRlcm0uZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSAnaW5oZXJpdCc7XG4gICAgcmV0dXJuIGNhbmNlbChldik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHbG9iYWwgRXZlbnRzIGZvciBrZXkgaGFuZGxpbmdcbiAqL1xuXG5UZXJtaW5hbC5iaW5kS2V5cyA9IGZ1bmN0aW9uKGRvY3VtZW50KSB7XG4gIC8vIFdlIHNob3VsZCBvbmx5IG5lZWQgdG8gY2hlY2sgYHRhcmdldCA9PT0gYm9keWAgYmVsb3csXG4gIC8vIGJ1dCB3ZSBjYW4gY2hlY2sgZXZlcnl0aGluZyBmb3IgZ29vZCBtZWFzdXJlLlxuICBvbihkb2N1bWVudCwgJ2tleWRvd24nLCBmdW5jdGlvbihldikge1xuICAgIGlmICghVGVybWluYWwuZm9jdXMpIHJldHVybjtcbiAgICB2YXIgdGFyZ2V0ID0gZXYudGFyZ2V0IHx8IGV2LnNyY0VsZW1lbnQ7XG4gICAgaWYgKCF0YXJnZXQpIHJldHVybjtcbiAgICBpZiAodGFyZ2V0ID09PSBUZXJtaW5hbC5mb2N1cy5lbGVtZW50XG4gICAgICAgIHx8IHRhcmdldCA9PT0gVGVybWluYWwuZm9jdXMuY29udGV4dFxuICAgICAgICB8fCB0YXJnZXQgPT09IFRlcm1pbmFsLmZvY3VzLmRvY3VtZW50XG4gICAgICAgIHx8IHRhcmdldCA9PT0gVGVybWluYWwuZm9jdXMuYm9keVxuICAgICAgICB8fCB0YXJnZXQgPT09IFRlcm1pbmFsLl90ZXh0YXJlYVxuICAgICAgICB8fCB0YXJnZXQgPT09IFRlcm1pbmFsLmZvY3VzLnBhcmVudCkge1xuICAgICAgcmV0dXJuIFRlcm1pbmFsLmZvY3VzLmtleURvd24oZXYpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG5cbiAgb24oZG9jdW1lbnQsICdrZXlwcmVzcycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYgKCFUZXJtaW5hbC5mb2N1cykgcmV0dXJuO1xuICAgIHZhciB0YXJnZXQgPSBldi50YXJnZXQgfHwgZXYuc3JjRWxlbWVudDtcbiAgICBpZiAoIXRhcmdldCkgcmV0dXJuO1xuICAgIGlmICh0YXJnZXQgPT09IFRlcm1pbmFsLmZvY3VzLmVsZW1lbnRcbiAgICAgICAgfHwgdGFyZ2V0ID09PSBUZXJtaW5hbC5mb2N1cy5jb250ZXh0XG4gICAgICAgIHx8IHRhcmdldCA9PT0gVGVybWluYWwuZm9jdXMuZG9jdW1lbnRcbiAgICAgICAgfHwgdGFyZ2V0ID09PSBUZXJtaW5hbC5mb2N1cy5ib2R5XG4gICAgICAgIHx8IHRhcmdldCA9PT0gVGVybWluYWwuX3RleHRhcmVhXG4gICAgICAgIHx8IHRhcmdldCA9PT0gVGVybWluYWwuZm9jdXMucGFyZW50KSB7XG4gICAgICByZXR1cm4gVGVybWluYWwuZm9jdXMua2V5UHJlc3MoZXYpO1xuICAgIH1cbiAgfSwgdHJ1ZSk7XG5cbiAgLy8gSWYgd2UgY2xpY2sgc29tZXdoZXJlIG90aGVyIHRoYW4gYVxuICAvLyB0ZXJtaW5hbCwgdW5mb2N1cyB0aGUgdGVybWluYWwuXG4gIG9uKGRvY3VtZW50LCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZXYpIHtcbiAgICBpZiAoIVRlcm1pbmFsLmZvY3VzKSByZXR1cm47XG5cbiAgICB2YXIgZWwgPSBldi50YXJnZXQgfHwgZXYuc3JjRWxlbWVudDtcbiAgICBpZiAoIWVsKSByZXR1cm47XG5cbiAgICBkbyB7XG4gICAgICBpZiAoZWwgPT09IFRlcm1pbmFsLmZvY3VzLmVsZW1lbnQpIHJldHVybjtcbiAgICB9IHdoaWxlIChlbCA9IGVsLnBhcmVudE5vZGUpO1xuXG4gICAgVGVybWluYWwuZm9jdXMuYmx1cigpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ29weSBTZWxlY3Rpb24gdy8gQ3RybC1DIChTZWxlY3QgTW9kZSlcbiAqL1xuXG5UZXJtaW5hbC5iaW5kQ29weSA9IGZ1bmN0aW9uKGRvY3VtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldztcblxuICAvLyBpZiAoISgnb25iZWZvcmVjb3B5JyBpbiBkb2N1bWVudCkpIHtcbiAgLy8gICAvLyBDb3BpZXMgdG8gKm9ubHkqIHRoZSBjbGlwYm9hcmQuXG4gIC8vICAgb24od2luZG93LCAnY29weScsIGZ1bmN0aW9uIGZuKGV2KSB7XG4gIC8vICAgICB2YXIgdGVybSA9IFRlcm1pbmFsLmZvY3VzO1xuICAvLyAgICAgaWYgKCF0ZXJtKSByZXR1cm47XG4gIC8vICAgICBpZiAoIXRlcm0uX3NlbGVjdGVkKSByZXR1cm47XG4gIC8vICAgICB2YXIgdGV4dCA9IHRlcm0uZ3JhYlRleHQoXG4gIC8vICAgICAgIHRlcm0uX3NlbGVjdGVkLngxLCB0ZXJtLl9zZWxlY3RlZC54MixcbiAgLy8gICAgICAgdGVybS5fc2VsZWN0ZWQueTEsIHRlcm0uX3NlbGVjdGVkLnkyKTtcbiAgLy8gICAgIHRlcm0uZW1pdCgnY29weScsIHRleHQpO1xuICAvLyAgICAgZXYuY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgdGV4dCk7XG4gIC8vICAgfSk7XG4gIC8vICAgcmV0dXJuO1xuICAvLyB9XG5cbiAgLy8gQ29waWVzIHRvIHByaW1hcnkgc2VsZWN0aW9uICphbmQqIGNsaXBib2FyZC5cbiAgLy8gTk9URTogVGhpcyBtYXkgd29yayBiZXR0ZXIgb24gY2FwdHVyZSBwaGFzZSxcbiAgLy8gb3IgdXNpbmcgdGhlIGBiZWZvcmVjb3B5YCBldmVudC5cbiAgb24od2luZG93LCAnY29weScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgdmFyIHRlcm0gPSBUZXJtaW5hbC5mb2N1cztcbiAgICBpZiAoIXRlcm0pIHJldHVybjtcbiAgICBpZiAoIXRlcm0uX3NlbGVjdGVkKSByZXR1cm47XG4gICAgdmFyIHRleHRhcmVhID0gdGVybS5nZXRDb3B5VGV4dGFyZWEoKTtcbiAgICB2YXIgdGV4dCA9IHRlcm0uZ3JhYlRleHQoXG4gICAgICB0ZXJtLl9zZWxlY3RlZC54MSwgdGVybS5fc2VsZWN0ZWQueDIsXG4gICAgICB0ZXJtLl9zZWxlY3RlZC55MSwgdGVybS5fc2VsZWN0ZWQueTIpO1xuICAgIHRlcm0uZW1pdCgnY29weScsIHRleHQpO1xuICAgIHRleHRhcmVhLmZvY3VzKCk7XG4gICAgdGV4dGFyZWEudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIHRleHRhcmVhLnZhbHVlID0gdGV4dDtcbiAgICB0ZXh0YXJlYS5zZXRTZWxlY3Rpb25SYW5nZSgwLCB0ZXh0Lmxlbmd0aCk7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHRlcm0uZWxlbWVudC5mb2N1cygpO1xuICAgICAgdGVybS5mb2N1cygpO1xuICAgIH0sIDEpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRml4IGlQYWQgLSBubyBpZGVhIGlmIHRoaXMgd29ya3NcbiAqL1xuXG5UZXJtaW5hbC5maXhJcGFkID0gZnVuY3Rpb24oZG9jdW1lbnQpIHtcbiAgdmFyIHRleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgdGV4dGFyZWEuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICB0ZXh0YXJlYS5zdHlsZS5sZWZ0ID0gJy0zMjAwMHB4JztcbiAgdGV4dGFyZWEuc3R5bGUudG9wID0gJy0zMjAwMHB4JztcbiAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSAnMHB4JztcbiAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XG4gIHRleHRhcmVhLnN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gIHRleHRhcmVhLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gIHRleHRhcmVhLnN0eWxlLmJvcmRlclN0eWxlID0gJ25vbmUnO1xuICB0ZXh0YXJlYS5zdHlsZS5vdXRsaW5lU3R5bGUgPSAnbm9uZSc7XG4gIHRleHRhcmVhLmF1dG9jYXBpdGFsaXplID0gJ25vbmUnO1xuICB0ZXh0YXJlYS5hdXRvY29ycmVjdCA9ICdvZmYnO1xuXG4gIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF0uYXBwZW5kQ2hpbGQodGV4dGFyZWEpO1xuXG4gIFRlcm1pbmFsLl90ZXh0YXJlYSA9IHRleHRhcmVhO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgdGV4dGFyZWEuZm9jdXMoKTtcbiAgfSwgMTAwMCk7XG59O1xuXG4vKipcbiAqIEluc2VydCBhIGRlZmF1bHQgc3R5bGVcbiAqL1xuXG5UZXJtaW5hbC5pbnNlcnRTdHlsZSA9IGZ1bmN0aW9uKGRvY3VtZW50LCBiZywgZmcpIHtcbiAgdmFyIHN0eWxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Rlcm0tc3R5bGUnKTtcbiAgaWYgKHN0eWxlKSByZXR1cm47XG5cbiAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICBpZiAoIWhlYWQpIHJldHVybjtcblxuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS5pZCA9ICd0ZXJtLXN0eWxlJztcblxuICAvLyB0ZXh0Q29udGVudCBkb2Vzbid0IHdvcmsgd2VsbCB3aXRoIElFIGZvciA8c3R5bGU+IGVsZW1lbnRzLlxuICBzdHlsZS5pbm5lckhUTUwgPSAnJ1xuICAgICsgJy50ZXJtaW5hbCB7XFxuJ1xuICAgICsgJyAgZmxvYXQ6IGxlZnQ7XFxuJ1xuICAgICsgJyAgYm9yZGVyOiAnICsgYmcgKyAnIHNvbGlkIDVweDtcXG4nXG4gICAgKyAnICBmb250LWZhbWlseTogXCJEZWphVnUgU2FucyBNb25vXCIsIFwiTGliZXJhdGlvbiBNb25vXCIsIG1vbm9zcGFjZTtcXG4nXG4gICAgKyAnICBmb250LXNpemU6IDExcHg7XFxuJ1xuICAgICsgJyAgY29sb3I6ICcgKyBmZyArICc7XFxuJ1xuICAgICsgJyAgYmFja2dyb3VuZDogJyArIGJnICsgJztcXG4nXG4gICAgKyAnfVxcbidcbiAgICArICdcXG4nXG4gICAgKyAnLnRlcm1pbmFsLWN1cnNvciB7XFxuJ1xuICAgICsgJyAgY29sb3I6ICcgKyBiZyArICc7XFxuJ1xuICAgICsgJyAgYmFja2dyb3VuZDogJyArIGZnICsgJztcXG4nXG4gICAgKyAnfVxcbic7XG5cbiAgLy8gdmFyIG91dCA9ICcnO1xuICAvLyBlYWNoKFRlcm1pbmFsLmNvbG9ycywgZnVuY3Rpb24oY29sb3IsIGkpIHtcbiAgLy8gICBpZiAoaSA9PT0gMjU2KSB7XG4gIC8vICAgICBvdXQgKz0gJ1xcbi50ZXJtLWJnLWNvbG9yLWRlZmF1bHQgeyBiYWNrZ3JvdW5kLWNvbG9yOiAnICsgY29sb3IgKyAnOyB9JztcbiAgLy8gICB9XG4gIC8vICAgaWYgKGkgPT09IDI1Nykge1xuICAvLyAgICAgb3V0ICs9ICdcXG4udGVybS1mZy1jb2xvci1kZWZhdWx0IHsgY29sb3I6ICcgKyBjb2xvciArICc7IH0nO1xuICAvLyAgIH1cbiAgLy8gICBvdXQgKz0gJ1xcbi50ZXJtLWJnLWNvbG9yLScgKyBpICsgJyB7IGJhY2tncm91bmQtY29sb3I6ICcgKyBjb2xvciArICc7IH0nO1xuICAvLyAgIG91dCArPSAnXFxuLnRlcm0tZmctY29sb3ItJyArIGkgKyAnIHsgY29sb3I6ICcgKyBjb2xvciArICc7IH0nO1xuICAvLyB9KTtcbiAgLy8gc3R5bGUuaW5uZXJIVE1MICs9IG91dCArICdcXG4nO1xuXG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBoZWFkLmZpcnN0Q2hpbGQpO1xufTtcblxuLyoqXG4gKiBPcGVuIFRlcm1pbmFsXG4gKi9cblxuVGVybWluYWwucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbihwYXJlbnQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCBpID0gMFxuICAgICwgZGl2O1xuXG4gIHRoaXMucGFyZW50ID0gcGFyZW50IHx8IHRoaXMucGFyZW50O1xuXG4gIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlcm1pbmFsIHJlcXVpcmVzIGEgcGFyZW50IGVsZW1lbnQuJyk7XG4gIH1cblxuICAvLyBHcmFiIGdsb2JhbCBlbGVtZW50cy5cbiAgdGhpcy5jb250ZXh0ID0gdGhpcy5wYXJlbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgdGhpcy5kb2N1bWVudCA9IHRoaXMucGFyZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHRoaXMuYm9keSA9IHRoaXMuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcblxuICAvLyBQYXJzZSB1c2VyLWFnZW50IHN0cmluZ3MuXG4gIGlmICh0aGlzLmNvbnRleHQubmF2aWdhdG9yICYmIHRoaXMuY29udGV4dC5uYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgdGhpcy5pc01hYyA9ICEhfnRoaXMuY29udGV4dC5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01hYycpO1xuICAgIHRoaXMuaXNJcGFkID0gISF+dGhpcy5jb250ZXh0Lm5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignaVBhZCcpO1xuICAgIHRoaXMuaXNJcGhvbmUgPSAhIX50aGlzLmNvbnRleHQubmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdpUGhvbmUnKTtcbiAgICB0aGlzLmlzTVNJRSA9ICEhfnRoaXMuY29udGV4dC5uYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ01TSUUnKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBvdXIgbWFpbiB0ZXJtaW5hbCBlbGVtZW50LlxuICB0aGlzLmVsZW1lbnQgPSB0aGlzLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gJ3Rlcm1pbmFsJztcbiAgdGhpcy5lbGVtZW50LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmNvbG9yc1syNTZdO1xuICB0aGlzLmVsZW1lbnQuc3R5bGUuY29sb3IgPSB0aGlzLmNvbG9yc1syNTddO1xuXG4gIC8vIENyZWF0ZSB0aGUgbGluZXMgZm9yIG91ciB0ZXJtaW5hbC5cbiAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICBmb3IgKDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgZGl2ID0gdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goZGl2KTtcbiAgfVxuICB0aGlzLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuXG4gIC8vIERyYXcgdGhlIHNjcmVlbi5cbiAgdGhpcy5yZWZyZXNoKDAsIHRoaXMucm93cyAtIDEpO1xuXG4gIC8vIEluaXRpYWxpemUgZ2xvYmFsIGFjdGlvbnMgdGhhdFxuICAvLyBuZWVkIHRvIGJlIHRha2VuIG9uIHRoZSBkb2N1bWVudC5cbiAgdGhpcy5pbml0R2xvYmFsKCk7XG5cbiAgLy8gRW5zdXJlIHRoZXJlIGlzIGEgVGVybWluYWwuZm9jdXMuXG4gIHRoaXMuZm9jdXMoKTtcblxuICAvLyBTdGFydCBibGlua2luZyB0aGUgY3Vyc29yLlxuICB0aGlzLnN0YXJ0QmxpbmsoKTtcblxuICAvLyBCaW5kIHRvIERPTSBldmVudHMgcmVsYXRlZFxuICAvLyB0byBmb2N1cyBhbmQgcGFzdGUgYmVoYXZpb3IuXG4gIG9uKHRoaXMuZWxlbWVudCwgJ2ZvY3VzJywgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5mb2N1cygpO1xuICAgIGlmIChzZWxmLmlzSXBhZCB8fCBzZWxmLmlzSXBob25lKSB7XG4gICAgICBUZXJtaW5hbC5fdGV4dGFyZWEuZm9jdXMoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRoaXMgY2F1c2VzIHNsaWdodGx5IGZ1bmt5IGJlaGF2aW9yLlxuICAvLyBvbih0aGlzLmVsZW1lbnQsICdibHVyJywgZnVuY3Rpb24oKSB7XG4gIC8vICAgc2VsZi5ibHVyKCk7XG4gIC8vIH0pO1xuXG4gIG9uKHRoaXMuZWxlbWVudCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZm9jdXMoKTtcbiAgfSk7XG5cbiAgLy8gQ2xpY2thYmxlIHBhc3RlIHdvcmthcm91bmQsIHVzaW5nIGNvbnRlbnRFZGl0YWJsZS5cbiAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3Qgd29yayxcbiAgLy8gLi4uIGJ1dCBpdCBkb2VzLiBGaXJlZm94J3MgcGFzdGVcbiAgLy8gZXZlbnQgc2VlbXMgdG8gb25seSB3b3JrIGZvciB0ZXh0YXJlYXM/XG4gIG9uKHRoaXMuZWxlbWVudCwgJ21vdXNlZG93bicsIGZ1bmN0aW9uKGV2KSB7XG4gICAgdmFyIGJ1dHRvbiA9IGV2LmJ1dHRvbiAhPSBudWxsXG4gICAgICA/ICtldi5idXR0b25cbiAgICAgIDogZXYud2hpY2ggIT0gbnVsbFxuICAgICAgICA/IGV2LndoaWNoIC0gMVxuICAgICAgICA6IG51bGw7XG5cbiAgICAvLyBEb2VzIElFOSBkbyB0aGlzP1xuICAgIGlmIChzZWxmLmlzTVNJRSkge1xuICAgICAgYnV0dG9uID0gYnV0dG9uID09PSAxID8gMCA6IGJ1dHRvbiA9PT0gNCA/IDEgOiBidXR0b247XG4gICAgfVxuXG4gICAgaWYgKGJ1dHRvbiAhPT0gMikgcmV0dXJuO1xuXG4gICAgc2VsZi5lbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9ICd0cnVlJztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9ICdpbmhlcml0JzsgLy8gJ2ZhbHNlJztcbiAgICB9LCAxKTtcbiAgfSwgdHJ1ZSk7XG5cbiAgLy8gTGlzdGVuIGZvciBtb3VzZSBldmVudHMgYW5kIHRyYW5zbGF0ZVxuICAvLyB0aGVtIGludG8gdGVybWluYWwgbW91c2UgcHJvdG9jb2xzLlxuICB0aGlzLmJpbmRNb3VzZSgpO1xuXG4gIC8vIEZpZ3VyZSBvdXQgd2hldGhlciBib2xkbmVzcyBhZmZlY3RzXG4gIC8vIHRoZSBjaGFyYWN0ZXIgd2lkdGggb2YgbW9ub3NwYWNlIGZvbnRzLlxuICBpZiAoVGVybWluYWwuYnJva2VuQm9sZCA9PSBudWxsKSB7XG4gICAgVGVybWluYWwuYnJva2VuQm9sZCA9IGlzQm9sZEJyb2tlbih0aGlzLmRvY3VtZW50KTtcbiAgfVxuXG4gIC8vIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgcGFzdGluZyxcbiAgLy8gYXMgd2VsbCBhcyB0aGUgaVBhZCBmaXguXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbGVtZW50LmZvY3VzKCk7XG4gIH0sIDEwMCk7XG59O1xuXG4vLyBYVGVybSBtb3VzZSBldmVudHNcbi8vIGh0dHA6Ly9pbnZpc2libGUtaXNsYW5kLm5ldC94dGVybS9jdGxzZXFzL2N0bHNlcXMuaHRtbCNNb3VzZSUyMFRyYWNraW5nXG4vLyBUbyBiZXR0ZXIgdW5kZXJzdGFuZCB0aGVzZVxuLy8gdGhlIHh0ZXJtIGNvZGUgaXMgdmVyeSBoZWxwZnVsOlxuLy8gUmVsZXZhbnQgZmlsZXM6XG4vLyAgIGJ1dHRvbi5jLCBjaGFycHJvYy5jLCBtaXNjLmNcbi8vIFJlbGV2YW50IGZ1bmN0aW9ucyBpbiB4dGVybS9idXR0b24uYzpcbi8vICAgQnRuQ29kZSwgRW1pdEJ1dHRvbkNvZGUsIEVkaXRvckJ1dHRvbiwgU2VuZE1vdXNlUG9zaXRpb25cblRlcm1pbmFsLnByb3RvdHlwZS5iaW5kTW91c2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGVsID0gdGhpcy5lbGVtZW50XG4gICAgLCBzZWxmID0gdGhpc1xuICAgICwgcHJlc3NlZCA9IDMyO1xuXG4gIHZhciB3aGVlbEV2ZW50ID0gJ29ubW91c2V3aGVlbCcgaW4gdGhpcy5jb250ZXh0XG4gICAgPyAnbW91c2V3aGVlbCdcbiAgICA6ICdET01Nb3VzZVNjcm9sbCc7XG5cbiAgLy8gbW91c2V1cCwgbW91c2Vkb3duLCBtb3VzZXdoZWVsXG4gIC8vIGxlZnQgY2xpY2s6IF5bW00gMzxeW1tNIzM8XG4gIC8vIG1vdXNld2hlZWwgdXA6IF5bW01gMz5cbiAgZnVuY3Rpb24gc2VuZEJ1dHRvbihldikge1xuICAgIHZhciBidXR0b25cbiAgICAgICwgcG9zO1xuXG4gICAgLy8gZ2V0IHRoZSB4dGVybS1zdHlsZSBidXR0b25cbiAgICBidXR0b24gPSBnZXRCdXR0b24oZXYpO1xuXG4gICAgLy8gZ2V0IG1vdXNlIGNvb3JkaW5hdGVzXG4gICAgcG9zID0gZ2V0Q29vcmRzKGV2KTtcbiAgICBpZiAoIXBvcykgcmV0dXJuO1xuXG4gICAgc2VuZEV2ZW50KGJ1dHRvbiwgcG9zKTtcblxuICAgIHN3aXRjaCAoZXYudHlwZSkge1xuICAgICAgY2FzZSAnbW91c2Vkb3duJzpcbiAgICAgICAgcHJlc3NlZCA9IGJ1dHRvbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtb3VzZXVwJzpcbiAgICAgICAgLy8ga2VlcCBpdCBhdCB0aGUgbGVmdFxuICAgICAgICAvLyBidXR0b24sIGp1c3QgaW4gY2FzZS5cbiAgICAgICAgcHJlc3NlZCA9IDMyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2Ugd2hlZWxFdmVudDpcbiAgICAgICAgLy8gbm90aGluZy4gZG9uJ3RcbiAgICAgICAgLy8gaW50ZXJmZXJlIHdpdGhcbiAgICAgICAgLy8gYHByZXNzZWRgLlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvLyBtb3Rpb24gZXhhbXBsZSBvZiBhIGxlZnQgY2xpY2s6XG4gIC8vIF5bW00gMzxeW1tNQDQ8XltbTUA1PF5bW01ANjxeW1tNQDc8XltbTSM3PFxuICBmdW5jdGlvbiBzZW5kTW92ZShldikge1xuICAgIHZhciBidXR0b24gPSBwcmVzc2VkXG4gICAgICAsIHBvcztcblxuICAgIHBvcyA9IGdldENvb3Jkcyhldik7XG4gICAgaWYgKCFwb3MpIHJldHVybjtcblxuICAgIC8vIGJ1dHRvbnMgbWFya2VkIGFzIG1vdGlvbnNcbiAgICAvLyBhcmUgaW5jcmVtZW50ZWQgYnkgMzJcbiAgICBidXR0b24gKz0gMzI7XG5cbiAgICBzZW5kRXZlbnQoYnV0dG9uLCBwb3MpO1xuICB9XG5cbiAgLy8gZW5jb2RlIGJ1dHRvbiBhbmRcbiAgLy8gcG9zaXRpb24gdG8gY2hhcmFjdGVyc1xuICBmdW5jdGlvbiBlbmNvZGUoZGF0YSwgY2gpIHtcbiAgICBpZiAoIXNlbGYudXRmTW91c2UpIHtcbiAgICAgIGlmIChjaCA9PT0gMjU1KSByZXR1cm4gZGF0YS5wdXNoKDApO1xuICAgICAgaWYgKGNoID4gMTI3KSBjaCA9IDEyNztcbiAgICAgIGRhdGEucHVzaChjaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaCA9PT0gMjA0NykgcmV0dXJuIGRhdGEucHVzaCgwKTtcbiAgICAgIGlmIChjaCA8IDEyNykge1xuICAgICAgICBkYXRhLnB1c2goY2gpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNoID4gMjA0NykgY2ggPSAyMDQ3O1xuICAgICAgICBkYXRhLnB1c2goMHhDMCB8IChjaCA+PiA2KSk7XG4gICAgICAgIGRhdGEucHVzaCgweDgwIHwgKGNoICYgMHgzRikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNlbmQgYSBtb3VzZSBldmVudDpcbiAgLy8gcmVndWxhci91dGY4OiBeW1tNIENiIEN4IEN5XG4gIC8vIHVyeHZ0OiBeW1sgQ2IgOyBDeCA7IEN5IE1cbiAgLy8gc2dyOiBeW1sgQ2IgOyBDeCA7IEN5IE0vbVxuICAvLyB2dDMwMDogXltbIDI0KDEvMy81KX4gWyBDeCAsIEN5IF0gXFxyXG4gIC8vIGxvY2F0b3I6IENTSSBQIGUgOyBQIGIgOyBQIHIgOyBQIGMgOyBQIHAgJiB3XG4gIGZ1bmN0aW9uIHNlbmRFdmVudChidXR0b24sIHBvcykge1xuICAgIC8vIHNlbGYuZW1pdCgnbW91c2UnLCB7XG4gICAgLy8gICB4OiBwb3MueCAtIDMyLFxuICAgIC8vICAgeTogcG9zLnggLSAzMixcbiAgICAvLyAgIGJ1dHRvbjogYnV0dG9uXG4gICAgLy8gfSk7XG5cbiAgICBpZiAoc2VsZi52dDMwME1vdXNlKSB7XG4gICAgICAvLyBOT1RFOiBVbnN0YWJsZS5cbiAgICAgIC8vIGh0dHA6Ly93d3cudnQxMDAubmV0L2RvY3MvdnQzeHgtZ3AvY2hhcHRlcjE1Lmh0bWxcbiAgICAgIGJ1dHRvbiAmPSAzO1xuICAgICAgcG9zLnggLT0gMzI7XG4gICAgICBwb3MueSAtPSAzMjtcbiAgICAgIHZhciBkYXRhID0gJ1xceDFiWzI0JztcbiAgICAgIGlmIChidXR0b24gPT09IDApIGRhdGEgKz0gJzEnO1xuICAgICAgZWxzZSBpZiAoYnV0dG9uID09PSAxKSBkYXRhICs9ICczJztcbiAgICAgIGVsc2UgaWYgKGJ1dHRvbiA9PT0gMikgZGF0YSArPSAnNSc7XG4gICAgICBlbHNlIGlmIChidXR0b24gPT09IDMpIHJldHVybjtcbiAgICAgIGVsc2UgZGF0YSArPSAnMCc7XG4gICAgICBkYXRhICs9ICd+WycgKyBwb3MueCArICcsJyArIHBvcy55ICsgJ11cXHInO1xuICAgICAgc2VsZi5zZW5kKGRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZWxmLmRlY0xvY2F0b3IpIHtcbiAgICAgIC8vIE5PVEU6IFVuc3RhYmxlLlxuICAgICAgYnV0dG9uICY9IDM7XG4gICAgICBwb3MueCAtPSAzMjtcbiAgICAgIHBvcy55IC09IDMyO1xuICAgICAgaWYgKGJ1dHRvbiA9PT0gMCkgYnV0dG9uID0gMjtcbiAgICAgIGVsc2UgaWYgKGJ1dHRvbiA9PT0gMSkgYnV0dG9uID0gNDtcbiAgICAgIGVsc2UgaWYgKGJ1dHRvbiA9PT0gMikgYnV0dG9uID0gNjtcbiAgICAgIGVsc2UgaWYgKGJ1dHRvbiA9PT0gMykgYnV0dG9uID0gMztcbiAgICAgIHNlbGYuc2VuZCgnXFx4MWJbJ1xuICAgICAgICArIGJ1dHRvblxuICAgICAgICArICc7J1xuICAgICAgICArIChidXR0b24gPT09IDMgPyA0IDogMClcbiAgICAgICAgKyAnOydcbiAgICAgICAgKyBwb3MueVxuICAgICAgICArICc7J1xuICAgICAgICArIHBvcy54XG4gICAgICAgICsgJzsnXG4gICAgICAgICsgKHBvcy5wYWdlIHx8IDApXG4gICAgICAgICsgJyZ3Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlbGYudXJ4dnRNb3VzZSkge1xuICAgICAgcG9zLnggLT0gMzI7XG4gICAgICBwb3MueSAtPSAzMjtcbiAgICAgIHBvcy54Kys7XG4gICAgICBwb3MueSsrO1xuICAgICAgc2VsZi5zZW5kKCdcXHgxYlsnICsgYnV0dG9uICsgJzsnICsgcG9zLnggKyAnOycgKyBwb3MueSArICdNJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuc2dyTW91c2UpIHtcbiAgICAgIHBvcy54IC09IDMyO1xuICAgICAgcG9zLnkgLT0gMzI7XG4gICAgICBzZWxmLnNlbmQoJ1xceDFiWzwnXG4gICAgICAgICsgKChidXR0b24gJiAzKSA9PT0gMyA/IGJ1dHRvbiAmIH4zIDogYnV0dG9uKVxuICAgICAgICArICc7J1xuICAgICAgICArIHBvcy54XG4gICAgICAgICsgJzsnXG4gICAgICAgICsgcG9zLnlcbiAgICAgICAgKyAoKGJ1dHRvbiAmIDMpID09PSAzID8gJ20nIDogJ00nKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSBbXTtcblxuICAgIGVuY29kZShkYXRhLCBidXR0b24pO1xuICAgIGVuY29kZShkYXRhLCBwb3MueCk7XG4gICAgZW5jb2RlKGRhdGEsIHBvcy55KTtcblxuICAgIHNlbGYuc2VuZCgnXFx4MWJbTScgKyBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgZGF0YSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QnV0dG9uKGV2KSB7XG4gICAgdmFyIGJ1dHRvblxuICAgICAgLCBzaGlmdFxuICAgICAgLCBtZXRhXG4gICAgICAsIGN0cmxcbiAgICAgICwgbW9kO1xuXG4gICAgLy8gdHdvIGxvdyBiaXRzOlxuICAgIC8vIDAgPSBsZWZ0XG4gICAgLy8gMSA9IG1pZGRsZVxuICAgIC8vIDIgPSByaWdodFxuICAgIC8vIDMgPSByZWxlYXNlXG4gICAgLy8gd2hlZWwgdXAvZG93bjpcbiAgICAvLyAxLCBhbmQgMiAtIHdpdGggNjQgYWRkZWRcbiAgICBzd2l0Y2ggKGV2LnR5cGUpIHtcbiAgICAgIGNhc2UgJ21vdXNlZG93bic6XG4gICAgICAgIGJ1dHRvbiA9IGV2LmJ1dHRvbiAhPSBudWxsXG4gICAgICAgICAgPyArZXYuYnV0dG9uXG4gICAgICAgICAgOiBldi53aGljaCAhPSBudWxsXG4gICAgICAgICAgICA/IGV2LndoaWNoIC0gMVxuICAgICAgICAgICAgOiBudWxsO1xuXG4gICAgICAgIGlmIChzZWxmLmlzTVNJRSkge1xuICAgICAgICAgIGJ1dHRvbiA9IGJ1dHRvbiA9PT0gMSA/IDAgOiBidXR0b24gPT09IDQgPyAxIDogYnV0dG9uO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2V1cCc6XG4gICAgICAgIGJ1dHRvbiA9IDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnRE9NTW91c2VTY3JvbGwnOlxuICAgICAgICBidXR0b24gPSBldi5kZXRhaWwgPCAwXG4gICAgICAgICAgPyA2NFxuICAgICAgICAgIDogNjU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW91c2V3aGVlbCc6XG4gICAgICAgIGJ1dHRvbiA9IGV2LndoZWVsRGVsdGFZID4gMFxuICAgICAgICAgID8gNjRcbiAgICAgICAgICA6IDY1O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBuZXh0IHRocmVlIGJpdHMgYXJlIHRoZSBtb2RpZmllcnM6XG4gICAgLy8gNCA9IHNoaWZ0LCA4ID0gbWV0YSwgMTYgPSBjb250cm9sXG4gICAgc2hpZnQgPSBldi5zaGlmdEtleSA/IDQgOiAwO1xuICAgIG1ldGEgPSBldi5tZXRhS2V5ID8gOCA6IDA7XG4gICAgY3RybCA9IGV2LmN0cmxLZXkgPyAxNiA6IDA7XG4gICAgbW9kID0gc2hpZnQgfCBtZXRhIHwgY3RybDtcblxuICAgIC8vIG5vIG1vZHNcbiAgICBpZiAoc2VsZi52dDIwME1vdXNlKSB7XG4gICAgICAvLyBjdHJsIG9ubHlcbiAgICAgIG1vZCAmPSBjdHJsO1xuICAgIH0gZWxzZSBpZiAoIXNlbGYubm9ybWFsTW91c2UpIHtcbiAgICAgIG1vZCA9IDA7XG4gICAgfVxuXG4gICAgLy8gaW5jcmVtZW50IHRvIFNQXG4gICAgYnV0dG9uID0gKDMyICsgKG1vZCA8PCAyKSkgKyBidXR0b247XG5cbiAgICByZXR1cm4gYnV0dG9uO1xuICB9XG5cbiAgLy8gbW91c2UgY29vcmRpbmF0ZXMgbWVhc3VyZWQgaW4gY29scy9yb3dzXG4gIGZ1bmN0aW9uIGdldENvb3Jkcyhldikge1xuICAgIHZhciB4LCB5LCB3LCBoLCBlbDtcblxuICAgIC8vIGlnbm9yZSBicm93c2VycyB3aXRob3V0IHBhZ2VYIGZvciBub3dcbiAgICBpZiAoZXYucGFnZVggPT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgeCA9IGV2LnBhZ2VYO1xuICAgIHkgPSBldi5wYWdlWTtcbiAgICBlbCA9IHNlbGYuZWxlbWVudDtcblxuICAgIC8vIHNob3VsZCBwcm9iYWJseSBjaGVjayBvZmZzZXRQYXJlbnRcbiAgICAvLyBidXQgdGhpcyBpcyBtb3JlIHBvcnRhYmxlXG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBzZWxmLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgeCAtPSBlbC5vZmZzZXRMZWZ0O1xuICAgICAgeSAtPSBlbC5vZmZzZXRUb3A7XG4gICAgICBlbCA9ICdvZmZzZXRQYXJlbnQnIGluIGVsXG4gICAgICAgID8gZWwub2Zmc2V0UGFyZW50XG4gICAgICAgIDogZWwucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHRvIGNvbHMvcm93c1xuICAgIHcgPSBzZWxmLmVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgaCA9IHNlbGYuZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgeCA9IE1hdGgucm91bmQoKHggLyB3KSAqIHNlbGYuY29scyk7XG4gICAgeSA9IE1hdGgucm91bmQoKHkgLyBoKSAqIHNlbGYucm93cyk7XG5cbiAgICAvLyBiZSBzdXJlIHRvIGF2b2lkIHNlbmRpbmdcbiAgICAvLyBiYWQgcG9zaXRpb25zIHRvIHRoZSBwcm9ncmFtXG4gICAgaWYgKHggPCAwKSB4ID0gMDtcbiAgICBpZiAoeCA+IHNlbGYuY29scykgeCA9IHNlbGYuY29scztcbiAgICBpZiAoeSA8IDApIHkgPSAwO1xuICAgIGlmICh5ID4gc2VsZi5yb3dzKSB5ID0gc2VsZi5yb3dzO1xuXG4gICAgLy8geHRlcm0gc2VuZHMgcmF3IGJ5dGVzIGFuZFxuICAgIC8vIHN0YXJ0cyBhdCAzMiAoU1ApIGZvciBlYWNoLlxuICAgIHggKz0gMzI7XG4gICAgeSArPSAzMjtcblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHR5cGU6IGV2LnR5cGUgPT09IHdoZWVsRXZlbnRcbiAgICAgICAgPyAnbW91c2V3aGVlbCdcbiAgICAgICAgOiBldi50eXBlXG4gICAgfTtcbiAgfVxuXG4gIG9uKGVsLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZXYpIHtcbiAgICBpZiAoIXNlbGYubW91c2VFdmVudHMpIHJldHVybjtcblxuICAgIC8vIHNlbmQgdGhlIGJ1dHRvblxuICAgIHNlbmRCdXR0b24oZXYpO1xuXG4gICAgLy8gZW5zdXJlIGZvY3VzXG4gICAgc2VsZi5mb2N1cygpO1xuXG4gICAgLy8gZml4IGZvciBvZGQgYnVnXG4gICAgLy9pZiAoc2VsZi52dDIwME1vdXNlICYmICFzZWxmLm5vcm1hbE1vdXNlKSB7XG4gICAgaWYgKHNlbGYudnQyMDBNb3VzZSkge1xuICAgICAgc2VuZEJ1dHRvbih7IF9fcHJvdG9fXzogZXYsIHR5cGU6ICdtb3VzZXVwJyB9KTtcbiAgICAgIHJldHVybiBjYW5jZWwoZXYpO1xuICAgIH1cblxuICAgIC8vIGJpbmQgZXZlbnRzXG4gICAgaWYgKHNlbGYubm9ybWFsTW91c2UpIG9uKHNlbGYuZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBzZW5kTW92ZSk7XG5cbiAgICAvLyB4MTAgY29tcGF0aWJpbGl0eSBtb2RlIGNhbid0IHNlbmQgYnV0dG9uIHJlbGVhc2VzXG4gICAgaWYgKCFzZWxmLngxME1vdXNlKSB7XG4gICAgICBvbihzZWxmLmRvY3VtZW50LCAnbW91c2V1cCcsIGZ1bmN0aW9uIHVwKGV2KSB7XG4gICAgICAgIHNlbmRCdXR0b24oZXYpO1xuICAgICAgICBpZiAoc2VsZi5ub3JtYWxNb3VzZSkgb2ZmKHNlbGYuZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBzZW5kTW92ZSk7XG4gICAgICAgIG9mZihzZWxmLmRvY3VtZW50LCAnbW91c2V1cCcsIHVwKTtcbiAgICAgICAgcmV0dXJuIGNhbmNlbChldik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FuY2VsKGV2KTtcbiAgfSk7XG5cbiAgLy9pZiAoc2VsZi5ub3JtYWxNb3VzZSkge1xuICAvLyAgb24oc2VsZi5kb2N1bWVudCwgJ21vdXNlbW92ZScsIHNlbmRNb3ZlKTtcbiAgLy99XG5cbiAgb24oZWwsIHdoZWVsRXZlbnQsIGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYgKCFzZWxmLm1vdXNlRXZlbnRzKSByZXR1cm47XG4gICAgaWYgKHNlbGYueDEwTW91c2VcbiAgICAgICAgfHwgc2VsZi52dDMwME1vdXNlXG4gICAgICAgIHx8IHNlbGYuZGVjTG9jYXRvcikgcmV0dXJuO1xuICAgIHNlbmRCdXR0b24oZXYpO1xuICAgIHJldHVybiBjYW5jZWwoZXYpO1xuICB9KTtcblxuICAvLyBhbGxvdyBtb3VzZXdoZWVsIHNjcm9sbGluZyBpblxuICAvLyB0aGUgc2hlbGwgZm9yIGV4YW1wbGVcbiAgb24oZWwsIHdoZWVsRXZlbnQsIGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYgKHNlbGYubW91c2VFdmVudHMpIHJldHVybjtcbiAgICBpZiAoc2VsZi5hcHBsaWNhdGlvbktleXBhZCkgcmV0dXJuO1xuICAgIGlmIChldi50eXBlID09PSAnRE9NTW91c2VTY3JvbGwnKSB7XG4gICAgICBzZWxmLnNjcm9sbERpc3AoZXYuZGV0YWlsIDwgMCA/IC01IDogNSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuc2Nyb2xsRGlzcChldi53aGVlbERlbHRhWSA+IDAgPyAtNSA6IDUpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuY2VsKGV2KTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIERlc3Ryb3kgVGVybWluYWxcbiAqL1xuXG5UZXJtaW5hbC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdGhpcy5fZXZlbnRzID0ge307XG4gIHRoaXMuaGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG4gIHRoaXMud3JpdGUgPSBmdW5jdGlvbigpIHt9O1xuICBpZiAodGhpcy5lbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICB9XG4gIC8vdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcblxuLyoqXG4gKiBSZW5kZXJpbmcgRW5naW5lXG4gKi9cblxuLy8gSW4gdGhlIHNjcmVlbiBidWZmZXIsIGVhY2ggY2hhcmFjdGVyXG4vLyBpcyBzdG9yZWQgYXMgYSBhbiBhcnJheSB3aXRoIGEgY2hhcmFjdGVyXG4vLyBhbmQgYSAzMi1iaXQgaW50ZWdlci5cbi8vIEZpcnN0IHZhbHVlOiBhIHV0Zi0xNiBjaGFyYWN0ZXIuXG4vLyBTZWNvbmQgdmFsdWU6XG4vLyBOZXh0IDkgYml0czogYmFja2dyb3VuZCBjb2xvciAoMC01MTEpLlxuLy8gTmV4dCA5IGJpdHM6IGZvcmVncm91bmQgY29sb3IgKDAtNTExKS5cbi8vIE5leHQgMTQgYml0czogYSBtYXNrIGZvciBtaXNjLiBmbGFnczpcbi8vICAgMT1ib2xkLCAyPXVuZGVybGluZSwgND1ibGluaywgOD1pbnZlcnNlLCAxNj1pbnZpc2libGVcblxuVGVybWluYWwucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbihzdGFydCwgZW5kKSB7XG4gIHZhciB4XG4gICAgLCB5XG4gICAgLCBpXG4gICAgLCBsaW5lXG4gICAgLCBvdXRcbiAgICAsIGNoXG4gICAgLCB3aWR0aFxuICAgICwgZGF0YVxuICAgICwgYXR0clxuICAgICwgYmdcbiAgICAsIGZnXG4gICAgLCBmbGFnc1xuICAgICwgcm93XG4gICAgLCBwYXJlbnQ7XG5cbiAgaWYgKGVuZCAtIHN0YXJ0ID49IHRoaXMucm93cyAvIDIpIHtcbiAgICBwYXJlbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50KSBwYXJlbnQucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgfVxuXG4gIHdpZHRoID0gdGhpcy5jb2xzO1xuICB5ID0gc3RhcnQ7XG5cbiAgaWYgKGVuZCA+PSB0aGlzLmxpbmVzLmxlbmd0aCkge1xuICAgIHRoaXMubG9nKCdgZW5kYCBpcyB0b28gbGFyZ2UuIE1vc3QgbGlrZWx5IGEgYmFkIENTUi4nKTtcbiAgICBlbmQgPSB0aGlzLmxpbmVzLmxlbmd0aCAtIDE7XG4gIH1cblxuICBmb3IgKDsgeSA8PSBlbmQ7IHkrKykge1xuICAgIHJvdyA9IHkgKyB0aGlzLnlkaXNwO1xuXG4gICAgbGluZSA9IHRoaXMubGluZXNbcm93XTtcbiAgICBvdXQgPSAnJztcblxuICAgIGlmICh5ID09PSB0aGlzLnlcbiAgICAgICAgJiYgdGhpcy5jdXJzb3JTdGF0ZVxuICAgICAgICAmJiAodGhpcy55ZGlzcCA9PT0gdGhpcy55YmFzZSB8fCB0aGlzLnNlbGVjdE1vZGUpXG4gICAgICAgICYmICF0aGlzLmN1cnNvckhpZGRlbikge1xuICAgICAgeCA9IHRoaXMueDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IC0xO1xuICAgIH1cblxuICAgIGF0dHIgPSB0aGlzLmRlZkF0dHI7XG4gICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICAgIGRhdGEgPSBsaW5lW2ldWzBdO1xuICAgICAgY2ggPSBsaW5lW2ldWzFdO1xuXG4gICAgICBpZiAoaSA9PT0geCkgZGF0YSA9IC0xO1xuXG4gICAgICBpZiAoZGF0YSAhPT0gYXR0cikge1xuICAgICAgICBpZiAoYXR0ciAhPT0gdGhpcy5kZWZBdHRyKSB7XG4gICAgICAgICAgb3V0ICs9ICc8L3NwYW4+JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSAhPT0gdGhpcy5kZWZBdHRyKSB7XG4gICAgICAgICAgaWYgKGRhdGEgPT09IC0xKSB7XG4gICAgICAgICAgICBvdXQgKz0gJzxzcGFuIGNsYXNzPVwicmV2ZXJzZS12aWRlbyB0ZXJtaW5hbC1jdXJzb3JcIj4nO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXQgKz0gJzxzcGFuIHN0eWxlPVwiJztcblxuICAgICAgICAgICAgYmcgPSBkYXRhICYgMHgxZmY7XG4gICAgICAgICAgICBmZyA9IChkYXRhID4+IDkpICYgMHgxZmY7XG4gICAgICAgICAgICBmbGFncyA9IGRhdGEgPj4gMTg7XG5cbiAgICAgICAgICAgIC8vIGJvbGRcbiAgICAgICAgICAgIGlmIChmbGFncyAmIDEpIHtcbiAgICAgICAgICAgICAgaWYgKCFUZXJtaW5hbC5icm9rZW5Cb2xkKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICdmb250LXdlaWdodDpib2xkOyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gU2VlOiBYVGVybSpib2xkQ29sb3JzXG4gICAgICAgICAgICAgIGlmIChmZyA8IDgpIGZnICs9IDg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVuZGVybGluZVxuICAgICAgICAgICAgaWYgKGZsYWdzICYgMikge1xuICAgICAgICAgICAgICBvdXQgKz0gJ3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmU7JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmxpbmtcbiAgICAgICAgICAgIGlmIChmbGFncyAmIDQpIHtcbiAgICAgICAgICAgICAgaWYgKGZsYWdzICYgMikge1xuICAgICAgICAgICAgICAgIG91dCA9IG91dC5zbGljZSgwLCAtMSk7XG4gICAgICAgICAgICAgICAgb3V0ICs9ICcgYmxpbms7JztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gJ3RleHQtZGVjb3JhdGlvbjpibGluazsnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGludmVyc2VcbiAgICAgICAgICAgIGlmIChmbGFncyAmIDgpIHtcbiAgICAgICAgICAgICAgYmcgPSAoZGF0YSA+PiA5KSAmIDB4MWZmO1xuICAgICAgICAgICAgICBmZyA9IGRhdGEgJiAweDFmZjtcbiAgICAgICAgICAgICAgLy8gU2hvdWxkIGludmVyc2UganVzdCBiZSBiZWZvcmUgdGhlXG4gICAgICAgICAgICAgIC8vIGFib3ZlIGJvbGRDb2xvcnMgZWZmZWN0IGluc3RlYWQ/XG4gICAgICAgICAgICAgIGlmICgoZmxhZ3MgJiAxKSAmJiBmZyA8IDgpIGZnICs9IDg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGludmlzaWJsZVxuICAgICAgICAgICAgaWYgKGZsYWdzICYgMTYpIHtcbiAgICAgICAgICAgICAgb3V0ICs9ICd2aXNpYmlsaXR5OmhpZGRlbjsnO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvdXQgKz0gJ1wiIGNsYXNzPVwiJ1xuICAgICAgICAgICAgLy8gICArICd0ZXJtLWJnLWNvbG9yLScgKyBiZ1xuICAgICAgICAgICAgLy8gICArICcgJ1xuICAgICAgICAgICAgLy8gICArICd0ZXJtLWZnLWNvbG9yLScgKyBmZ1xuICAgICAgICAgICAgLy8gICArICdcIj4nO1xuXG4gICAgICAgICAgICBpZiAoYmcgIT09IDI1Nikge1xuICAgICAgICAgICAgICBvdXQgKz0gJ2JhY2tncm91bmQtY29sb3I6J1xuICAgICAgICAgICAgICAgICsgdGhpcy5jb2xvcnNbYmddXG4gICAgICAgICAgICAgICAgKyAnOyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChmZyAhPT0gMjU3KSB7XG4gICAgICAgICAgICAgIG91dCArPSAnY29sb3I6J1xuICAgICAgICAgICAgICAgICsgdGhpcy5jb2xvcnNbZmddXG4gICAgICAgICAgICAgICAgKyAnOyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG91dCArPSAnXCI+JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlICcmJzpcbiAgICAgICAgICBvdXQgKz0gJyZhbXA7JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPCc6XG4gICAgICAgICAgb3V0ICs9ICcmbHQ7JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnPic6XG4gICAgICAgICAgb3V0ICs9ICcmZ3Q7JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoY2ggPD0gJyAnKSB7XG4gICAgICAgICAgICBvdXQgKz0gJyZuYnNwOyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpc1dpZGUoY2gpKSBpKys7XG4gICAgICAgICAgICBvdXQgKz0gY2g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhdHRyID0gZGF0YTtcbiAgICB9XG5cbiAgICBpZiAoYXR0ciAhPT0gdGhpcy5kZWZBdHRyKSB7XG4gICAgICBvdXQgKz0gJzwvc3Bhbj4nO1xuICAgIH1cblxuICAgIHRoaXMuY2hpbGRyZW5beV0uaW5uZXJIVE1MID0gb3V0O1xuICB9XG5cbiAgaWYgKHBhcmVudCkgcGFyZW50LmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUuX2N1cnNvckJsaW5rID0gZnVuY3Rpb24oKSB7XG4gIGlmIChUZXJtaW5hbC5mb2N1cyAhPT0gdGhpcykgcmV0dXJuO1xuICB0aGlzLmN1cnNvclN0YXRlIF49IDE7XG4gIHRoaXMucmVmcmVzaCh0aGlzLnksIHRoaXMueSk7XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUuc2hvd0N1cnNvciA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuY3Vyc29yU3RhdGUpIHtcbiAgICB0aGlzLmN1cnNvclN0YXRlID0gMTtcbiAgICB0aGlzLnJlZnJlc2godGhpcy55LCB0aGlzLnkpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRlbXBvcmFyaWx5IGRpc2FibGVkOlxuICAgIC8vIHRoaXMucmVmcmVzaEJsaW5rKCk7XG4gIH1cbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5zdGFydEJsaW5rID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jdXJzb3JCbGluaykgcmV0dXJuO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2JsaW5rZXIgPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9jdXJzb3JCbGluaygpO1xuICB9O1xuICB0aGlzLl9ibGluayA9IHNldEludGVydmFsKHRoaXMuX2JsaW5rZXIsIDUwMCk7XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUucmVmcmVzaEJsaW5rID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jdXJzb3JCbGluaykgcmV0dXJuO1xuICBjbGVhckludGVydmFsKHRoaXMuX2JsaW5rKTtcbiAgdGhpcy5fYmxpbmsgPSBzZXRJbnRlcnZhbCh0aGlzLl9ibGlua2VyLCA1MDApO1xufTtcblxuVGVybWluYWwucHJvdG90eXBlLnNjcm9sbCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcm93O1xuXG4gIGlmICgrK3RoaXMueWJhc2UgPT09IHRoaXMuc2Nyb2xsYmFjaykge1xuICAgIHRoaXMueWJhc2UgPSB0aGlzLnliYXNlIC8gMiB8IDA7XG4gICAgdGhpcy5saW5lcyA9IHRoaXMubGluZXMuc2xpY2UoLSh0aGlzLnliYXNlICsgdGhpcy5yb3dzKSArIDEpO1xuICB9XG5cbiAgdGhpcy55ZGlzcCA9IHRoaXMueWJhc2U7XG5cbiAgLy8gbGFzdCBsaW5lXG4gIHJvdyA9IHRoaXMueWJhc2UgKyB0aGlzLnJvd3MgLSAxO1xuXG4gIC8vIHN1YnRyYWN0IHRoZSBib3R0b20gc2Nyb2xsIHJlZ2lvblxuICByb3cgLT0gdGhpcy5yb3dzIC0gMSAtIHRoaXMuc2Nyb2xsQm90dG9tO1xuXG4gIGlmIChyb3cgPT09IHRoaXMubGluZXMubGVuZ3RoKSB7XG4gICAgLy8gcG90ZW50aWFsIG9wdGltaXphdGlvbjpcbiAgICAvLyBwdXNoaW5nIGlzIGZhc3RlciB0aGFuIHNwbGljaW5nXG4gICAgLy8gd2hlbiB0aGV5IGFtb3VudCB0byB0aGUgc2FtZVxuICAgIC8vIGJlaGF2aW9yLlxuICAgIHRoaXMubGluZXMucHVzaCh0aGlzLmJsYW5rTGluZSgpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBhZGQgb3VyIG5ldyBsaW5lXG4gICAgdGhpcy5saW5lcy5zcGxpY2Uocm93LCAwLCB0aGlzLmJsYW5rTGluZSgpKTtcbiAgfVxuXG4gIGlmICh0aGlzLnNjcm9sbFRvcCAhPT0gMCkge1xuICAgIGlmICh0aGlzLnliYXNlICE9PSAwKSB7XG4gICAgICB0aGlzLnliYXNlLS07XG4gICAgICB0aGlzLnlkaXNwID0gdGhpcy55YmFzZTtcbiAgICB9XG4gICAgdGhpcy5saW5lcy5zcGxpY2UodGhpcy55YmFzZSArIHRoaXMuc2Nyb2xsVG9wLCAxKTtcbiAgfVxuXG4gIC8vIHRoaXMubWF4UmFuZ2UoKTtcbiAgdGhpcy51cGRhdGVSYW5nZSh0aGlzLnNjcm9sbFRvcCk7XG4gIHRoaXMudXBkYXRlUmFuZ2UodGhpcy5zY3JvbGxCb3R0b20pO1xufTtcblxuVGVybWluYWwucHJvdG90eXBlLnNjcm9sbERpc3AgPSBmdW5jdGlvbihkaXNwKSB7XG4gIHRoaXMueWRpc3AgKz0gZGlzcDtcblxuICBpZiAodGhpcy55ZGlzcCA+IHRoaXMueWJhc2UpIHtcbiAgICB0aGlzLnlkaXNwID0gdGhpcy55YmFzZTtcbiAgfSBlbHNlIGlmICh0aGlzLnlkaXNwIDwgMCkge1xuICAgIHRoaXMueWRpc3AgPSAwO1xuICB9XG5cbiAgdGhpcy5yZWZyZXNoKDAsIHRoaXMucm93cyAtIDEpO1xufTtcblxuVGVybWluYWwucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgbCA9IGRhdGEubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgalxuICAgICwgY3NcbiAgICAsIGNoO1xuXG4gIHRoaXMucmVmcmVzaFN0YXJ0ID0gdGhpcy55O1xuICB0aGlzLnJlZnJlc2hFbmQgPSB0aGlzLnk7XG5cbiAgaWYgKHRoaXMueWJhc2UgIT09IHRoaXMueWRpc3ApIHtcbiAgICB0aGlzLnlkaXNwID0gdGhpcy55YmFzZTtcbiAgICB0aGlzLm1heFJhbmdlKCk7XG4gIH1cblxuICAvLyB0aGlzLmxvZyhKU09OLnN0cmluZ2lmeShkYXRhLnJlcGxhY2UoL1xceDFiL2csICdeWycpKSk7XG5cbiAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICBjaCA9IGRhdGFbaV07XG4gICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICBjYXNlIG5vcm1hbDpcbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgIC8vICdcXDAnXG4gICAgICAgICAgLy8gY2FzZSAnXFwwJzpcbiAgICAgICAgICAvLyBjYXNlICdcXDIwMCc6XG4gICAgICAgICAgLy8gICBicmVhaztcblxuICAgICAgICAgIC8vICdcXGEnXG4gICAgICAgICAgY2FzZSAnXFx4MDcnOlxuICAgICAgICAgICAgdGhpcy5iZWxsKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vICdcXG4nLCAnXFx2JywgJ1xcZidcbiAgICAgICAgICBjYXNlICdcXG4nOlxuICAgICAgICAgIGNhc2UgJ1xceDBiJzpcbiAgICAgICAgICBjYXNlICdcXHgwYyc6XG4gICAgICAgICAgICBpZiAodGhpcy5jb252ZXJ0RW9sKSB7XG4gICAgICAgICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgZWF0X25ld2xpbmVfZ2xpdGNoLlxuICAgICAgICAgICAgLy8gaWYgKHRoaXMucmVhbFggPj0gdGhpcy5jb2xzKSBicmVhaztcbiAgICAgICAgICAgIC8vIHRoaXMucmVhbFggPSAwO1xuICAgICAgICAgICAgdGhpcy55Kys7XG4gICAgICAgICAgICBpZiAodGhpcy55ID4gdGhpcy5zY3JvbGxCb3R0b20pIHtcbiAgICAgICAgICAgICAgdGhpcy55LS07XG4gICAgICAgICAgICAgIHRoaXMuc2Nyb2xsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vICdcXHInXG4gICAgICAgICAgY2FzZSAnXFxyJzpcbiAgICAgICAgICAgIHRoaXMueCA9IDA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vICdcXGInXG4gICAgICAgICAgY2FzZSAnXFx4MDgnOlxuICAgICAgICAgICAgaWYgKHRoaXMueCA+IDApIHtcbiAgICAgICAgICAgICAgdGhpcy54LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vICdcXHQnXG4gICAgICAgICAgY2FzZSAnXFx0JzpcbiAgICAgICAgICAgIHRoaXMueCA9IHRoaXMubmV4dFN0b3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gc2hpZnQgb3V0XG4gICAgICAgICAgY2FzZSAnXFx4MGUnOlxuICAgICAgICAgICAgdGhpcy5zZXRnTGV2ZWwoMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIHNoaWZ0IGluXG4gICAgICAgICAgY2FzZSAnXFx4MGYnOlxuICAgICAgICAgICAgdGhpcy5zZXRnTGV2ZWwoMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vICdcXGUnXG4gICAgICAgICAgY2FzZSAnXFx4MWInOlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGVzY2FwZWQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyAnICdcbiAgICAgICAgICAgIGlmIChjaCA+PSAnICcpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhcnNldCAmJiB0aGlzLmNoYXJzZXRbY2hdKSB7XG4gICAgICAgICAgICAgICAgY2ggPSB0aGlzLmNoYXJzZXRbY2hdO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMueCA+PSB0aGlzLmNvbHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMueSsrO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnkgPiB0aGlzLnNjcm9sbEJvdHRvbSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy55LS07XG4gICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMubGluZXNbdGhpcy55ICsgdGhpcy55YmFzZV1bdGhpcy54XSA9IFt0aGlzLmN1ckF0dHIsIGNoXTtcbiAgICAgICAgICAgICAgdGhpcy54Kys7XG4gICAgICAgICAgICAgIHRoaXMudXBkYXRlUmFuZ2UodGhpcy55KTtcblxuICAgICAgICAgICAgICBpZiAoaXNXaWRlKGNoKSkge1xuICAgICAgICAgICAgICAgIGogPSB0aGlzLnkgKyB0aGlzLnliYXNlO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbHMgPCAyIHx8IHRoaXMueCA+PSB0aGlzLmNvbHMpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMubGluZXNbal1bdGhpcy54IC0gMV0gPSBbdGhpcy5jdXJBdHRyLCAnICddO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGluZXNbal1bdGhpcy54XSA9IFt0aGlzLmN1ckF0dHIsICcgJ107XG4gICAgICAgICAgICAgICAgdGhpcy54Kys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBlc2NhcGVkOlxuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgLy8gRVNDIFsgQ29udHJvbCBTZXF1ZW5jZSBJbnRyb2R1Y2VyICggQ1NJIGlzIDB4OWIpLlxuICAgICAgICAgIGNhc2UgJ1snOlxuICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhcmFtID0gMDtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBjc2k7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIEVTQyBdIE9wZXJhdGluZyBTeXN0ZW0gQ29tbWFuZCAoIE9TQyBpcyAweDlkKS5cbiAgICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgIHRoaXMucGFyYW1zID0gW107XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXJhbSA9IDA7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gb3NjO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBFU0MgUCBEZXZpY2UgQ29udHJvbCBTdHJpbmcgKCBEQ1MgaXMgMHg5MCkuXG4gICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGFyYW0gPSAwO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGRjcztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gRVNDIF8gQXBwbGljYXRpb24gUHJvZ3JhbSBDb21tYW5kICggQVBDIGlzIDB4OWYpLlxuICAgICAgICAgIGNhc2UgJ18nOlxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGlnbm9yZTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gRVNDIF4gUHJpdmFjeSBNZXNzYWdlICggUE0gaXMgMHg5ZSkuXG4gICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gaWdub3JlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBFU0MgYyBGdWxsIFJlc2V0IChSSVMpLlxuICAgICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBFU0MgRSBOZXh0IExpbmUgKCBORUwgaXMgMHg4NSkuXG4gICAgICAgICAgLy8gRVNDIEQgSW5kZXggKCBJTkQgaXMgMHg4NCkuXG4gICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICB0aGlzLnggPSAwO1xuICAgICAgICAgICAgO1xuICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgdGhpcy5pbmRleCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBFU0MgTSBSZXZlcnNlIEluZGV4ICggUkkgaXMgMHg4ZCkuXG4gICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICB0aGlzLnJldmVyc2VJbmRleCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBFU0MgJSBTZWxlY3QgZGVmYXVsdC91dGYtOCBjaGFyYWN0ZXIgc2V0LlxuICAgICAgICAgIC8vIEAgPSBkZWZhdWx0LCBHID0gdXRmLThcbiAgICAgICAgICBjYXNlICclJzpcbiAgICAgICAgICAgIC8vdGhpcy5jaGFyc2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuc2V0Z0xldmVsKDApO1xuICAgICAgICAgICAgdGhpcy5zZXRnQ2hhcnNldCgwLCBUZXJtaW5hbC5jaGFyc2V0cy5VUyk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbm9ybWFsO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBFU0MgKCwpLCosKywtLC4gRGVzaWduYXRlIEcwLUcyIENoYXJhY3RlciBTZXQuXG4gICAgICAgICAgY2FzZSAnKCc6IC8vIDwtLSB0aGlzIHNlZW1zIHRvIGdldCBhbGwgdGhlIGF0dGVudGlvblxuICAgICAgICAgIGNhc2UgJyknOlxuICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgIGNhc2UgJysnOlxuICAgICAgICAgIGNhc2UgJy0nOlxuICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICB0aGlzLmdjaGFyc2V0ID0gMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgICAgICAgdGhpcy5nY2hhcnNldCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJyonOlxuICAgICAgICAgICAgICAgIHRoaXMuZ2NoYXJzZXQgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICcrJzpcbiAgICAgICAgICAgICAgICB0aGlzLmdjaGFyc2V0ID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnLSc6XG4gICAgICAgICAgICAgICAgdGhpcy5nY2hhcnNldCA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgICAgIHRoaXMuZ2NoYXJzZXQgPSAyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGNoYXJzZXQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIERlc2lnbmF0ZSBHMyBDaGFyYWN0ZXIgU2V0IChWVDMwMCkuXG4gICAgICAgICAgLy8gQSA9IElTTyBMYXRpbi0xIFN1cHBsZW1lbnRhbC5cbiAgICAgICAgICAvLyBOb3QgaW1wbGVtZW50ZWQuXG4gICAgICAgICAgY2FzZSAnLyc6XG4gICAgICAgICAgICB0aGlzLmdjaGFyc2V0ID0gMztcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBjaGFyc2V0O1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBFU0MgTlxuICAgICAgICAgIC8vIFNpbmdsZSBTaGlmdCBTZWxlY3Qgb2YgRzIgQ2hhcmFjdGVyIFNldFxuICAgICAgICAgIC8vICggU1MyIGlzIDB4OGUpLiBUaGlzIGFmZmVjdHMgbmV4dCBjaGFyYWN0ZXIgb25seS5cbiAgICAgICAgICBjYXNlICdOJzpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIEVTQyBPXG4gICAgICAgICAgLy8gU2luZ2xlIFNoaWZ0IFNlbGVjdCBvZiBHMyBDaGFyYWN0ZXIgU2V0XG4gICAgICAgICAgLy8gKCBTUzMgaXMgMHg4ZikuIFRoaXMgYWZmZWN0cyBuZXh0IGNoYXJhY3RlciBvbmx5LlxuICAgICAgICAgIGNhc2UgJ08nOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gRVNDIG5cbiAgICAgICAgICAvLyBJbnZva2UgdGhlIEcyIENoYXJhY3RlciBTZXQgYXMgR0wgKExTMikuXG4gICAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICB0aGlzLnNldGdMZXZlbCgyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIEVTQyBvXG4gICAgICAgICAgLy8gSW52b2tlIHRoZSBHMyBDaGFyYWN0ZXIgU2V0IGFzIEdMIChMUzMpLlxuICAgICAgICAgIGNhc2UgJ28nOlxuICAgICAgICAgICAgdGhpcy5zZXRnTGV2ZWwoMyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAvLyBFU0MgfFxuICAgICAgICAgIC8vIEludm9rZSB0aGUgRzMgQ2hhcmFjdGVyIFNldCBhcyBHUiAoTFMzUikuXG4gICAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICB0aGlzLnNldGdMZXZlbCgzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIEVTQyB9XG4gICAgICAgICAgLy8gSW52b2tlIHRoZSBHMiBDaGFyYWN0ZXIgU2V0IGFzIEdSIChMUzJSKS5cbiAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgIHRoaXMuc2V0Z0xldmVsKDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gRVNDIH5cbiAgICAgICAgICAvLyBJbnZva2UgdGhlIEcxIENoYXJhY3RlciBTZXQgYXMgR1IgKExTMVIpLlxuICAgICAgICAgIGNhc2UgJ34nOlxuICAgICAgICAgICAgdGhpcy5zZXRnTGV2ZWwoMSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIEVTQyA3IFNhdmUgQ3Vyc29yIChERUNTQykuXG4gICAgICAgICAgY2FzZSAnNyc6XG4gICAgICAgICAgICB0aGlzLnNhdmVDdXJzb3IoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBub3JtYWw7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIEVTQyA4IFJlc3RvcmUgQ3Vyc29yIChERUNSQykuXG4gICAgICAgICAgY2FzZSAnOCc6XG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVDdXJzb3IoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBub3JtYWw7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIEVTQyAjIDMgREVDIGxpbmUgaGVpZ2h0L3dpZHRoXG4gICAgICAgICAgY2FzZSAnIyc6XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gbm9ybWFsO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBFU0MgSCBUYWIgU2V0IChIVFMgaXMgMHg4OCkuXG4gICAgICAgICAgY2FzZSAnSCc6XG4gICAgICAgICAgICB0aGlzLnRhYlNldCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBFU0MgPSBBcHBsaWNhdGlvbiBLZXlwYWQgKERFQ1BBTSkuXG4gICAgICAgICAgY2FzZSAnPSc6XG4gICAgICAgICAgICB0aGlzLmxvZygnU2VyaWFsIHBvcnQgcmVxdWVzdGVkIGFwcGxpY2F0aW9uIGtleXBhZC4nKTtcbiAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb25LZXlwYWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5vcm1hbDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gRVNDID4gTm9ybWFsIEtleXBhZCAoREVDUE5NKS5cbiAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgYmFjayB0byBub3JtYWwga2V5cGFkLicpO1xuICAgICAgICAgICAgdGhpcy5hcHBsaWNhdGlvbktleXBhZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5vcm1hbDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBub3JtYWw7XG4gICAgICAgICAgICB0aGlzLmVycm9yKCdVbmtub3duIEVTQyBjb250cm9sOiAlcy4nLCBjaCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBjaGFyc2V0OlxuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgY2FzZSAnMCc6IC8vIERFQyBTcGVjaWFsIENoYXJhY3RlciBhbmQgTGluZSBEcmF3aW5nIFNldC5cbiAgICAgICAgICAgIGNzID0gVGVybWluYWwuY2hhcnNldHMuU0NMRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0EnOiAvLyBVS1xuICAgICAgICAgICAgY3MgPSBUZXJtaW5hbC5jaGFyc2V0cy5VSztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ0InOiAvLyBVbml0ZWQgU3RhdGVzIChVU0FTQ0lJKS5cbiAgICAgICAgICAgIGNzID0gVGVybWluYWwuY2hhcnNldHMuVVM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICc0JzogLy8gRHV0Y2hcbiAgICAgICAgICAgIGNzID0gVGVybWluYWwuY2hhcnNldHMuRHV0Y2g7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdDJzogLy8gRmlubmlzaFxuICAgICAgICAgIGNhc2UgJzUnOlxuICAgICAgICAgICAgY3MgPSBUZXJtaW5hbC5jaGFyc2V0cy5GaW5uaXNoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnUic6IC8vIEZyZW5jaFxuICAgICAgICAgICAgY3MgPSBUZXJtaW5hbC5jaGFyc2V0cy5GcmVuY2g7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdRJzogLy8gRnJlbmNoQ2FuYWRpYW5cbiAgICAgICAgICAgIGNzID0gVGVybWluYWwuY2hhcnNldHMuRnJlbmNoQ2FuYWRpYW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdLJzogLy8gR2VybWFuXG4gICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLkdlcm1hbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1knOiAvLyBJdGFsaWFuXG4gICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLkl0YWxpYW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdFJzogLy8gTm9yd2VnaWFuRGFuaXNoXG4gICAgICAgICAgY2FzZSAnNic6XG4gICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLk5vcndlZ2lhbkRhbmlzaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ1onOiAvLyBTcGFuaXNoXG4gICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLlNwYW5pc2g7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdIJzogLy8gU3dlZGlzaFxuICAgICAgICAgIGNhc2UgJzcnOlxuICAgICAgICAgICAgY3MgPSBUZXJtaW5hbC5jaGFyc2V0cy5Td2VkaXNoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnPSc6IC8vIFN3aXNzXG4gICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLlN3aXNzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnLyc6IC8vIElTT0xhdGluIChhY3R1YWxseSAvQSlcbiAgICAgICAgICAgIGNzID0gVGVybWluYWwuY2hhcnNldHMuSVNPTGF0aW47XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiAvLyBEZWZhdWx0XG4gICAgICAgICAgICBjcyA9IFRlcm1pbmFsLmNoYXJzZXRzLlVTO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRnQ2hhcnNldCh0aGlzLmdjaGFyc2V0LCBjcyk7XG4gICAgICAgIHRoaXMuZ2NoYXJzZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gbm9ybWFsO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBvc2M6XG4gICAgICAgIC8vIE9TQyBQcyA7IFB0IFNUXG4gICAgICAgIC8vIE9TQyBQcyA7IFB0IEJFTFxuICAgICAgICAvLyAgIFNldCBUZXh0IFBhcmFtZXRlcnMuXG4gICAgICAgIGlmIChjaCA9PT0gJ1xceDFiJyB8fCBjaCA9PT0gJ1xceDA3Jykge1xuICAgICAgICAgIGlmIChjaCA9PT0gJ1xceDFiJykgaSsrO1xuXG4gICAgICAgICAgdGhpcy5wYXJhbXMucHVzaCh0aGlzLmN1cnJlbnRQYXJhbSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKHRoaXMucGFyYW1zWzBdKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGlmICh0aGlzLnBhcmFtc1sxXSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGl0bGUgPSB0aGlzLnBhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRpdGxlKHRoaXMudGl0bGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAvLyBzZXQgWCBwcm9wZXJ0eVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgLy8gY2hhbmdlIGR5bmFtaWMgY29sb3JzXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgLy8gY2hhbmdlIGR5bmFtaWMgdWkgY29sb3JzXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0NjpcbiAgICAgICAgICAgICAgLy8gY2hhbmdlIGxvZyBmaWxlXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1MDpcbiAgICAgICAgICAgICAgLy8gZHluYW1pYyBmb250XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1MTpcbiAgICAgICAgICAgICAgLy8gZW1hY3Mgc2hlbGxcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDUyOlxuICAgICAgICAgICAgICAvLyBtYW5pcHVsYXRlIHNlbGVjdGlvbiBkYXRhXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMDQ6XG4gICAgICAgICAgICBjYXNlIDEwNTpcbiAgICAgICAgICAgIGNhc2UgMTEwOlxuICAgICAgICAgICAgY2FzZSAxMTE6XG4gICAgICAgICAgICBjYXNlIDExMjpcbiAgICAgICAgICAgIGNhc2UgMTEzOlxuICAgICAgICAgICAgY2FzZSAxMTQ6XG4gICAgICAgICAgICBjYXNlIDExNTpcbiAgICAgICAgICAgIGNhc2UgMTE2OlxuICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICBjYXNlIDExODpcbiAgICAgICAgICAgICAgLy8gcmVzZXQgY29sb3JzXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucGFyYW1zID0gW107XG4gICAgICAgICAgdGhpcy5jdXJyZW50UGFyYW0gPSAwO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBub3JtYWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgIHRoaXMuY3VycmVudFBhcmFtID1cbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXJhbSAqIDEwICsgY2guY2hhckNvZGVBdCgwKSAtIDQ4O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJzsnKSB7XG4gICAgICAgICAgICAgIHRoaXMucGFyYW1zLnB1c2godGhpcy5jdXJyZW50UGFyYW0pO1xuICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXJhbSA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXJhbSArPSBjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgY3NpOlxuICAgICAgICAvLyAnPycsICc+JywgJyEnXG4gICAgICAgIGlmIChjaCA9PT0gJz8nIHx8IGNoID09PSAnPicgfHwgY2ggPT09ICchJykge1xuICAgICAgICAgIHRoaXMucHJlZml4ID0gY2g7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAwIC0gOVxuICAgICAgICBpZiAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgIHRoaXMuY3VycmVudFBhcmFtID0gdGhpcy5jdXJyZW50UGFyYW0gKiAxMCArIGNoLmNoYXJDb2RlQXQoMCkgLSA0ODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICckJywgJ1wiJywgJyAnLCAnXFwnJ1xuICAgICAgICBpZiAoY2ggPT09ICckJyB8fCBjaCA9PT0gJ1wiJyB8fCBjaCA9PT0gJyAnIHx8IGNoID09PSAnXFwnJykge1xuICAgICAgICAgIHRoaXMucG9zdGZpeCA9IGNoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wYXJhbXMucHVzaCh0aGlzLmN1cnJlbnRQYXJhbSk7XG4gICAgICAgIHRoaXMuY3VycmVudFBhcmFtID0gMDtcblxuICAgICAgICAvLyAnOydcbiAgICAgICAgaWYgKGNoID09PSAnOycpIGJyZWFrO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSBub3JtYWw7XG5cbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgIC8vIENTSSBQcyBBXG4gICAgICAgICAgLy8gQ3Vyc29yIFVwIFBzIFRpbWVzIChkZWZhdWx0ID0gMSkgKENVVSkuXG4gICAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICB0aGlzLmN1cnNvclVwKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIEJcbiAgICAgICAgICAvLyBDdXJzb3IgRG93biBQcyBUaW1lcyAoZGVmYXVsdCA9IDEpIChDVUQpLlxuICAgICAgICAgIGNhc2UgJ0InOlxuICAgICAgICAgICAgdGhpcy5jdXJzb3JEb3duKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIENcbiAgICAgICAgICAvLyBDdXJzb3IgRm9yd2FyZCBQcyBUaW1lcyAoZGVmYXVsdCA9IDEpIChDVUYpLlxuICAgICAgICAgIGNhc2UgJ0MnOlxuICAgICAgICAgICAgdGhpcy5jdXJzb3JGb3J3YXJkKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIERcbiAgICAgICAgICAvLyBDdXJzb3IgQmFja3dhcmQgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ1VCKS5cbiAgICAgICAgICBjYXNlICdEJzpcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yQmFja3dhcmQodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBDU0kgUHMgOyBQcyBIXG4gICAgICAgICAgLy8gQ3Vyc29yIFBvc2l0aW9uIFtyb3c7Y29sdW1uXSAoZGVmYXVsdCA9IFsxLDFdKSAoQ1VQKS5cbiAgICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yUG9zKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIEogIEVyYXNlIGluIERpc3BsYXkgKEVEKS5cbiAgICAgICAgICBjYXNlICdKJzpcbiAgICAgICAgICAgIHRoaXMuZXJhc2VJbkRpc3BsYXkodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBDU0kgUHMgSyAgRXJhc2UgaW4gTGluZSAoRUwpLlxuICAgICAgICAgIGNhc2UgJ0snOlxuICAgICAgICAgICAgdGhpcy5lcmFzZUluTGluZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQbSBtICBDaGFyYWN0ZXIgQXR0cmlidXRlcyAoU0dSKS5cbiAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmVmaXgpIHtcbiAgICAgICAgICAgICAgdGhpcy5jaGFyQXR0cmlidXRlcyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQcyBuICBEZXZpY2UgU3RhdHVzIFJlcG9ydCAoRFNSKS5cbiAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmVmaXgpIHtcbiAgICAgICAgICAgICAgdGhpcy5kZXZpY2VTdGF0dXModGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBBZGRpdGlvbnNcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIC8vIENTSSBQcyBAXG4gICAgICAgICAgLy8gSW5zZXJ0IFBzIChCbGFuaykgQ2hhcmFjdGVyKHMpIChkZWZhdWx0ID0gMSkgKElDSCkuXG4gICAgICAgICAgY2FzZSAnQCc6XG4gICAgICAgICAgICB0aGlzLmluc2VydENoYXJzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIEVcbiAgICAgICAgICAvLyBDdXJzb3IgTmV4dCBMaW5lIFBzIFRpbWVzIChkZWZhdWx0ID0gMSkgKENOTCkuXG4gICAgICAgICAgY2FzZSAnRSc6XG4gICAgICAgICAgICB0aGlzLmN1cnNvck5leHRMaW5lKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIEZcbiAgICAgICAgICAvLyBDdXJzb3IgUHJlY2VkaW5nIExpbmUgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ05MKS5cbiAgICAgICAgICBjYXNlICdGJzpcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yUHJlY2VkaW5nTGluZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQcyBHXG4gICAgICAgICAgLy8gQ3Vyc29yIENoYXJhY3RlciBBYnNvbHV0ZSAgW2NvbHVtbl0gKGRlZmF1bHQgPSBbcm93LDFdKSAoQ0hBKS5cbiAgICAgICAgICBjYXNlICdHJzpcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yQ2hhckFic29sdXRlKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIExcbiAgICAgICAgICAvLyBJbnNlcnQgUHMgTGluZShzKSAoZGVmYXVsdCA9IDEpIChJTCkuXG4gICAgICAgICAgY2FzZSAnTCc6XG4gICAgICAgICAgICB0aGlzLmluc2VydExpbmVzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIE1cbiAgICAgICAgICAvLyBEZWxldGUgUHMgTGluZShzKSAoZGVmYXVsdCA9IDEpIChETCkuXG4gICAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZUxpbmVzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIFBcbiAgICAgICAgICAvLyBEZWxldGUgUHMgQ2hhcmFjdGVyKHMpIChkZWZhdWx0ID0gMSkgKERDSCkuXG4gICAgICAgICAgY2FzZSAnUCc6XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZUNoYXJzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIFhcbiAgICAgICAgICAvLyBFcmFzZSBQcyBDaGFyYWN0ZXIocykgKGRlZmF1bHQgPSAxKSAoRUNIKS5cbiAgICAgICAgICBjYXNlICdYJzpcbiAgICAgICAgICAgIHRoaXMuZXJhc2VDaGFycyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQbSBgICBDaGFyYWN0ZXIgUG9zaXRpb24gQWJzb2x1dGVcbiAgICAgICAgICAvLyAgIFtjb2x1bW5dIChkZWZhdWx0ID0gW3JvdywxXSkgKEhQQSkuXG4gICAgICAgICAgY2FzZSAnYCc6XG4gICAgICAgICAgICB0aGlzLmNoYXJQb3NBYnNvbHV0ZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIDE0MSA2MSBhICogSFBSIC1cbiAgICAgICAgICAvLyBIb3Jpem9udGFsIFBvc2l0aW9uIFJlbGF0aXZlXG4gICAgICAgICAgY2FzZSAnYSc6XG4gICAgICAgICAgICB0aGlzLkhQb3NpdGlvblJlbGF0aXZlKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFAgcyBjXG4gICAgICAgICAgLy8gU2VuZCBEZXZpY2UgQXR0cmlidXRlcyAoUHJpbWFyeSBEQSkuXG4gICAgICAgICAgLy8gQ1NJID4gUCBzIGNcbiAgICAgICAgICAvLyBTZW5kIERldmljZSBBdHRyaWJ1dGVzIChTZWNvbmRhcnkgREEpXG4gICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICB0aGlzLnNlbmREZXZpY2VBdHRyaWJ1dGVzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBtIGRcbiAgICAgICAgICAvLyBMaW5lIFBvc2l0aW9uIEFic29sdXRlICBbcm93XSAoZGVmYXVsdCA9IFsxLGNvbHVtbl0pIChWUEEpLlxuICAgICAgICAgIGNhc2UgJ2QnOlxuICAgICAgICAgICAgdGhpcy5saW5lUG9zQWJzb2x1dGUodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyAxNDUgNjUgZSAqIFZQUiAtIFZlcnRpY2FsIFBvc2l0aW9uIFJlbGF0aXZlXG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICB0aGlzLlZQb3NpdGlvblJlbGF0aXZlKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIDsgUHMgZlxuICAgICAgICAgIC8vICAgSG9yaXpvbnRhbCBhbmQgVmVydGljYWwgUG9zaXRpb24gW3Jvdztjb2x1bW5dIChkZWZhdWx0ID1cbiAgICAgICAgICAvLyAgIFsxLDFdKSAoSFZQKS5cbiAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIHRoaXMuSFZQb3NpdGlvbih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQbSBoICBTZXQgTW9kZSAoU00pLlxuICAgICAgICAgIC8vIENTSSA/IFBtIGggLSBtb3VzZSBlc2NhcGUgY29kZXMsIGN1cnNvciBlc2NhcGUgY29kZXNcbiAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgIHRoaXMuc2V0TW9kZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQbSBsICBSZXNldCBNb2RlIChSTSkuXG4gICAgICAgICAgLy8gQ1NJID8gUG0gbFxuICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgdGhpcy5yZXNldE1vZGUodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBDU0kgUHMgOyBQcyByXG4gICAgICAgICAgLy8gICBTZXQgU2Nyb2xsaW5nIFJlZ2lvbiBbdG9wO2JvdHRvbV0gKGRlZmF1bHQgPSBmdWxsIHNpemUgb2Ygd2luLVxuICAgICAgICAgIC8vICAgZG93KSAoREVDU1RCTSkuXG4gICAgICAgICAgLy8gQ1NJID8gUG0gclxuICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgdGhpcy5zZXRTY3JvbGxSZWdpb24odGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBDU0kgc1xuICAgICAgICAgIC8vICAgU2F2ZSBjdXJzb3IgKEFOU0kuU1lTKS5cbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIHRoaXMuc2F2ZUN1cnNvcih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSB1XG4gICAgICAgICAgLy8gICBSZXN0b3JlIGN1cnNvciAoQU5TSS5TWVMpLlxuICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlQ3Vyc29yKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogTGVzc2VyIFVzZWRcbiAgICAgICAgICAgKi9cblxuICAgICAgICAgIC8vIENTSSBQcyBJXG4gICAgICAgICAgLy8gQ3Vyc29yIEZvcndhcmQgVGFidWxhdGlvbiBQcyB0YWIgc3RvcHMgKGRlZmF1bHQgPSAxKSAoQ0hUKS5cbiAgICAgICAgICBjYXNlICdJJzpcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yRm9yd2FyZFRhYih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQcyBTICBTY3JvbGwgdXAgUHMgbGluZXMgKGRlZmF1bHQgPSAxKSAoU1UpLlxuICAgICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgICAgdGhpcy5zY3JvbGxVcCh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQcyBUICBTY3JvbGwgZG93biBQcyBsaW5lcyAoZGVmYXVsdCA9IDEpIChTRCkuXG4gICAgICAgICAgLy8gQ1NJIFBzIDsgUHMgOyBQcyA7IFBzIDsgUHMgVFxuICAgICAgICAgIC8vIENTSSA+IFBzOyBQcyBUXG4gICAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICAvLyBpZiAodGhpcy5wcmVmaXggPT09ICc+Jykge1xuICAgICAgICAgICAgLy8gICB0aGlzLnJlc2V0VGl0bGVNb2Rlcyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gaWYgKHRoaXMucGFyYW1zLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIC8vICAgdGhpcy5pbml0TW91c2VUcmFja2luZyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgaWYgKHRoaXMucGFyYW1zLmxlbmd0aCA8IDIgJiYgIXRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRG93bih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQcyBaXG4gICAgICAgICAgLy8gQ3Vyc29yIEJhY2t3YXJkIFRhYnVsYXRpb24gUHMgdGFiIHN0b3BzIChkZWZhdWx0ID0gMSkgKENCVCkuXG4gICAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgICB0aGlzLmN1cnNvckJhY2t3YXJkVGFiKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIGIgIFJlcGVhdCB0aGUgcHJlY2VkaW5nIGdyYXBoaWMgY2hhcmFjdGVyIFBzIHRpbWVzIChSRVApLlxuICAgICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgdGhpcy5yZXBlYXRQcmVjZWRpbmdDaGFyYWN0ZXIodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBDU0kgUHMgZyAgVGFiIENsZWFyIChUQkMpLlxuICAgICAgICAgIGNhc2UgJ2cnOlxuICAgICAgICAgICAgdGhpcy50YWJDbGVhcih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQbSBpICBNZWRpYSBDb3B5IChNQykuXG4gICAgICAgICAgLy8gQ1NJID8gUG0gaVxuICAgICAgICAgIC8vIGNhc2UgJ2knOlxuICAgICAgICAgIC8vICAgdGhpcy5tZWRpYUNvcHkodGhpcy5wYXJhbXMpO1xuICAgICAgICAgIC8vICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBDU0kgUG0gbSAgQ2hhcmFjdGVyIEF0dHJpYnV0ZXMgKFNHUikuXG4gICAgICAgICAgLy8gQ1NJID4gUHM7IFBzIG1cbiAgICAgICAgICAvLyBjYXNlICdtJzogLy8gZHVwbGljYXRlXG4gICAgICAgICAgLy8gICBpZiAodGhpcy5wcmVmaXggPT09ICc+Jykge1xuICAgICAgICAgIC8vICAgICB0aGlzLnNldFJlc291cmNlcyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgLy8gICB9IGVsc2Uge1xuICAgICAgICAgIC8vICAgICB0aGlzLmNoYXJBdHRyaWJ1dGVzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIG4gIERldmljZSBTdGF0dXMgUmVwb3J0IChEU1IpLlxuICAgICAgICAgIC8vIENTSSA+IFBzIG5cbiAgICAgICAgICAvLyBjYXNlICduJzogLy8gZHVwbGljYXRlXG4gICAgICAgICAgLy8gICBpZiAodGhpcy5wcmVmaXggPT09ICc+Jykge1xuICAgICAgICAgIC8vICAgICB0aGlzLmRpc2FibGVNb2RpZmllcnModGhpcy5wYXJhbXMpO1xuICAgICAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAgICAgdGhpcy5kZXZpY2VTdGF0dXModGhpcy5wYXJhbXMpO1xuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBDU0kgPiBQcyBwICBTZXQgcG9pbnRlciBtb2RlLlxuICAgICAgICAgIC8vIENTSSAhIHAgICBTb2Z0IHRlcm1pbmFsIHJlc2V0IChERUNTVFIpLlxuICAgICAgICAgIC8vIENTSSBQcyQgcFxuICAgICAgICAgIC8vICAgUmVxdWVzdCBBTlNJIG1vZGUgKERFQ1JRTSkuXG4gICAgICAgICAgLy8gQ1NJID8gUHMkIHBcbiAgICAgICAgICAvLyAgIFJlcXVlc3QgREVDIHByaXZhdGUgbW9kZSAoREVDUlFNKS5cbiAgICAgICAgICAvLyBDU0kgUHMgOyBQcyBcIiBwXG4gICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICAgIC8vIGNhc2UgJz4nOlxuICAgICAgICAgICAgICAvLyAgIHRoaXMuc2V0UG9pbnRlck1vZGUodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAvLyAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgICAgICB0aGlzLnNvZnRSZXNldCh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIC8vIGNhc2UgJz8nOlxuICAgICAgICAgICAgICAvLyAgIGlmICh0aGlzLnBvc3RmaXggPT09ICckJykge1xuICAgICAgICAgICAgICAvLyAgICAgdGhpcy5yZXF1ZXN0UHJpdmF0ZU1vZGUodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgICAgLy8gICBicmVhaztcbiAgICAgICAgICAgICAgLy8gZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnXCInKSB7XG4gICAgICAgICAgICAgIC8vICAgICB0aGlzLnNldENvbmZvcm1hbmNlTGV2ZWwodGhpcy5wYXJhbXMpO1xuICAgICAgICAgICAgICAvLyAgIH0gZWxzZSBpZiAodGhpcy5wb3N0Zml4ID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgLy8gICAgIHRoaXMucmVxdWVzdEFuc2lNb2RlKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAgIC8vICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQcyBxICBMb2FkIExFRHMgKERFQ0xMKS5cbiAgICAgICAgICAvLyBDU0kgUHMgU1AgcVxuICAgICAgICAgIC8vIENTSSBQcyBcIiBxXG4gICAgICAgICAgLy8gY2FzZSAncSc6XG4gICAgICAgICAgLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnICcpIHtcbiAgICAgICAgICAvLyAgICAgdGhpcy5zZXRDdXJzb3JTdHlsZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgLy8gICAgIGJyZWFrO1xuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vICAgaWYgKHRoaXMucG9zdGZpeCA9PT0gJ1wiJykge1xuICAgICAgICAgIC8vICAgICB0aGlzLnNldENoYXJQcm90ZWN0aW9uQXR0cih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgLy8gICAgIGJyZWFrO1xuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vICAgdGhpcy5sb2FkTEVEcyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgLy8gICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQcyA7IFBzIHJcbiAgICAgICAgICAvLyAgIFNldCBTY3JvbGxpbmcgUmVnaW9uIFt0b3A7Ym90dG9tXSAoZGVmYXVsdCA9IGZ1bGwgc2l6ZSBvZiB3aW4tXG4gICAgICAgICAgLy8gICBkb3cpIChERUNTVEJNKS5cbiAgICAgICAgICAvLyBDU0kgPyBQbSByXG4gICAgICAgICAgLy8gQ1NJIFB0OyBQbDsgUGI7IFByOyBQcyQgclxuICAgICAgICAgIC8vIGNhc2UgJ3InOiAvLyBkdXBsaWNhdGVcbiAgICAgICAgICAvLyAgIGlmICh0aGlzLnByZWZpeCA9PT0gJz8nKSB7XG4gICAgICAgICAgLy8gICAgIHRoaXMucmVzdG9yZVByaXZhdGVWYWx1ZXModGhpcy5wYXJhbXMpO1xuICAgICAgICAgIC8vICAgfSBlbHNlIGlmICh0aGlzLnBvc3RmaXggPT09ICckJykge1xuICAgICAgICAgIC8vICAgICB0aGlzLnNldEF0dHJJblJlY3RhbmdsZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgLy8gICB9IGVsc2Uge1xuICAgICAgICAgIC8vICAgICB0aGlzLnNldFNjcm9sbFJlZ2lvbih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgLy8gICB9XG4gICAgICAgICAgLy8gICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBzICAgICBTYXZlIGN1cnNvciAoQU5TSS5TWVMpLlxuICAgICAgICAgIC8vIENTSSA/IFBtIHNcbiAgICAgICAgICAvLyBjYXNlICdzJzogLy8gZHVwbGljYXRlXG4gICAgICAgICAgLy8gICBpZiAodGhpcy5wcmVmaXggPT09ICc/Jykge1xuICAgICAgICAgIC8vICAgICB0aGlzLnNhdmVQcml2YXRlVmFsdWVzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAvLyAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gICAgIHRoaXMuc2F2ZUN1cnNvcih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgLy8gICB9XG4gICAgICAgICAgLy8gICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQcyA7IFBzIDsgUHMgdFxuICAgICAgICAgIC8vIENTSSBQdDsgUGw7IFBiOyBQcjsgUHMkIHRcbiAgICAgICAgICAvLyBDU0kgPiBQczsgUHMgdFxuICAgICAgICAgIC8vIENTSSBQcyBTUCB0XG4gICAgICAgICAgLy8gY2FzZSAndCc6XG4gICAgICAgICAgLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnJCcpIHtcbiAgICAgICAgICAvLyAgICAgdGhpcy5yZXZlcnNlQXR0ckluUmVjdGFuZ2xlKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAvLyAgIH0gZWxzZSBpZiAodGhpcy5wb3N0Zml4ID09PSAnICcpIHtcbiAgICAgICAgICAvLyAgICAgdGhpcy5zZXRXYXJuaW5nQmVsbFZvbHVtZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgLy8gICB9IGVsc2Uge1xuICAgICAgICAgIC8vICAgICBpZiAodGhpcy5wcmVmaXggPT09ICc+Jykge1xuICAgICAgICAgIC8vICAgICAgIHRoaXMuc2V0VGl0bGVNb2RlRmVhdHVyZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgLy8gICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gICAgICAgdGhpcy5tYW5pcHVsYXRlV2luZG93KHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAvLyAgICAgfVxuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBDU0kgdSAgICAgUmVzdG9yZSBjdXJzb3IgKEFOU0kuU1lTKS5cbiAgICAgICAgICAvLyBDU0kgUHMgU1AgdVxuICAgICAgICAgIC8vIGNhc2UgJ3UnOiAvLyBkdXBsaWNhdGVcbiAgICAgICAgICAvLyAgIGlmICh0aGlzLnBvc3RmaXggPT09ICcgJykge1xuICAgICAgICAgIC8vICAgICB0aGlzLnNldE1hcmdpbkJlbGxWb2x1bWUodGhpcy5wYXJhbXMpO1xuICAgICAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAgICAgdGhpcy5yZXN0b3JlQ3Vyc29yKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFB0OyBQbDsgUGI7IFByOyBQcDsgUHQ7IFBsOyBQcCQgdlxuICAgICAgICAgIC8vIGNhc2UgJ3YnOlxuICAgICAgICAgIC8vICAgaWYgKHRoaXMucG9zdGZpeCA9PT0gJyQnKSB7XG4gICAgICAgICAgLy8gICAgIHRoaXMuY29weVJlY3RhZ2xlKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFB0IDsgUGwgOyBQYiA7IFByICcgd1xuICAgICAgICAgIC8vIGNhc2UgJ3cnOlxuICAgICAgICAgIC8vICAgaWYgKHRoaXMucG9zdGZpeCA9PT0gJ1xcJycpIHtcbiAgICAgICAgICAvLyAgICAgdGhpcy5lbmFibGVGaWx0ZXJSZWN0YW5nbGUodGhpcy5wYXJhbXMpO1xuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBDU0kgUHMgeCAgUmVxdWVzdCBUZXJtaW5hbCBQYXJhbWV0ZXJzIChERUNSRVFUUEFSTSkuXG4gICAgICAgICAgLy8gQ1NJIFBzIHggIFNlbGVjdCBBdHRyaWJ1dGUgQ2hhbmdlIEV4dGVudCAoREVDU0FDRSkuXG4gICAgICAgICAgLy8gQ1NJIFBjOyBQdDsgUGw7IFBiOyBQciQgeFxuICAgICAgICAgIC8vIGNhc2UgJ3gnOlxuICAgICAgICAgIC8vICAgaWYgKHRoaXMucG9zdGZpeCA9PT0gJyQnKSB7XG4gICAgICAgICAgLy8gICAgIHRoaXMuZmlsbFJlY3RhbmdsZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgLy8gICB9IGVsc2Uge1xuICAgICAgICAgIC8vICAgICB0aGlzLnJlcXVlc3RQYXJhbWV0ZXJzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAvLyAgICAgLy90aGlzLl9fKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBzIDsgUHUgJyB6XG4gICAgICAgICAgLy8gQ1NJIFB0OyBQbDsgUGI7IFByJCB6XG4gICAgICAgICAgLy8gY2FzZSAneic6XG4gICAgICAgICAgLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnXFwnJykge1xuICAgICAgICAgIC8vICAgICB0aGlzLmVuYWJsZUxvY2F0b3JSZXBvcnRpbmcodGhpcy5wYXJhbXMpO1xuICAgICAgICAgIC8vICAgfSBlbHNlIGlmICh0aGlzLnBvc3RmaXggPT09ICckJykge1xuICAgICAgICAgIC8vICAgICB0aGlzLmVyYXNlUmVjdGFuZ2xlKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gQ1NJIFBtICcge1xuICAgICAgICAgIC8vIENTSSBQdDsgUGw7IFBiOyBQciQge1xuICAgICAgICAgIC8vIGNhc2UgJ3snOlxuICAgICAgICAgIC8vICAgaWYgKHRoaXMucG9zdGZpeCA9PT0gJ1xcJycpIHtcbiAgICAgICAgICAvLyAgICAgdGhpcy5zZXRMb2NhdG9yRXZlbnRzKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAvLyAgIH0gZWxzZSBpZiAodGhpcy5wb3N0Zml4ID09PSAnJCcpIHtcbiAgICAgICAgICAvLyAgICAgdGhpcy5zZWxlY3RpdmVFcmFzZVJlY3RhbmdsZSh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgLy8gICB9XG4gICAgICAgICAgLy8gICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQcyAnIHxcbiAgICAgICAgICAvLyBjYXNlICd8JzpcbiAgICAgICAgICAvLyAgIGlmICh0aGlzLnBvc3RmaXggPT09ICdcXCcnKSB7XG4gICAgICAgICAgLy8gICAgIHRoaXMucmVxdWVzdExvY2F0b3JQb3NpdGlvbih0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgLy8gICB9XG4gICAgICAgICAgLy8gICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQIG0gU1AgfVxuICAgICAgICAgIC8vIEluc2VydCBQIHMgQ29sdW1uKHMpIChkZWZhdWx0ID0gMSkgKERFQ0lDKSwgVlQ0MjAgYW5kIHVwLlxuICAgICAgICAgIC8vIGNhc2UgJ30nOlxuICAgICAgICAgIC8vICAgaWYgKHRoaXMucG9zdGZpeCA9PT0gJyAnKSB7XG4gICAgICAgICAgLy8gICAgIHRoaXMuaW5zZXJ0Q29sdW1ucyh0aGlzLnBhcmFtcyk7XG4gICAgICAgICAgLy8gICB9XG4gICAgICAgICAgLy8gICBicmVhaztcblxuICAgICAgICAgIC8vIENTSSBQIG0gU1AgflxuICAgICAgICAgIC8vIERlbGV0ZSBQIHMgQ29sdW1uKHMpIChkZWZhdWx0ID0gMSkgKERFQ0RDKSwgVlQ0MjAgYW5kIHVwXG4gICAgICAgICAgLy8gY2FzZSAnfic6XG4gICAgICAgICAgLy8gICBpZiAodGhpcy5wb3N0Zml4ID09PSAnICcpIHtcbiAgICAgICAgICAvLyAgICAgdGhpcy5kZWxldGVDb2x1bW5zKHRoaXMucGFyYW1zKTtcbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRoaXMuZXJyb3IoJ1Vua25vd24gQ1NJIGNvZGU6ICVzLicsIGNoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcmVmaXggPSAnJztcbiAgICAgICAgdGhpcy5wb3N0Zml4ID0gJyc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGRjczpcbiAgICAgICAgaWYgKGNoID09PSAnXFx4MWInIHx8IGNoID09PSAnXFx4MDcnKSB7XG4gICAgICAgICAgaWYgKGNoID09PSAnXFx4MWInKSBpKys7XG5cbiAgICAgICAgICBzd2l0Y2ggKHRoaXMucHJlZml4KSB7XG4gICAgICAgICAgICAvLyBVc2VyLURlZmluZWQgS2V5cyAoREVDVURLKS5cbiAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAvLyBSZXF1ZXN0IFN0YXR1cyBTdHJpbmcgKERFQ1JRU1MpLlxuICAgICAgICAgICAgLy8gdGVzdDogZWNobyAtZSAnXFxlUCRxXCJwXFxlXFxcXCdcbiAgICAgICAgICAgIGNhc2UgJyRxJzpcbiAgICAgICAgICAgICAgdmFyIHB0ID0gdGhpcy5jdXJyZW50UGFyYW1cbiAgICAgICAgICAgICAgICAsIHZhbGlkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgc3dpdGNoIChwdCkge1xuICAgICAgICAgICAgICAgIC8vIERFQ1NDQVxuICAgICAgICAgICAgICAgIGNhc2UgJ1wicSc6XG4gICAgICAgICAgICAgICAgICBwdCA9ICcwXCJxJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLy8gREVDU0NMXG4gICAgICAgICAgICAgICAgY2FzZSAnXCJwJzpcbiAgICAgICAgICAgICAgICAgIHB0ID0gJzYxXCJwJztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgLy8gREVDU1RCTVxuICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgcHQgPSAnJ1xuICAgICAgICAgICAgICAgICAgICArICh0aGlzLnNjcm9sbFRvcCArIDEpXG4gICAgICAgICAgICAgICAgICAgICsgJzsnXG4gICAgICAgICAgICAgICAgICAgICsgKHRoaXMuc2Nyb2xsQm90dG9tICsgMSlcbiAgICAgICAgICAgICAgICAgICAgKyAncic7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8vIFNHUlxuICAgICAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgICAgcHQgPSAnMG0nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgdGhpcy5lcnJvcignVW5rbm93biBEQ1MgUHQ6ICVzLicsIHB0KTtcbiAgICAgICAgICAgICAgICAgIHB0ID0gJyc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuc2VuZCgnXFx4MWJQJyArICt2YWxpZCArICckcicgKyBwdCArICdcXHgxYlxcXFwnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIC8vIFNldCBUZXJtY2FwL1Rlcm1pbmZvIERhdGEgKHh0ZXJtLCBleHBlcmltZW50YWwpLlxuICAgICAgICAgICAgY2FzZSAnK3AnOlxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgLy8gUmVxdWVzdCBUZXJtY2FwL1Rlcm1pbmZvIFN0cmluZyAoeHRlcm0sIGV4cGVyaW1lbnRhbClcbiAgICAgICAgICAgIC8vIFJlZ3VsYXIgeHRlcm0gZG9lcyBub3QgZXZlbiByZXNwb25kIHRvIHRoaXMgc2VxdWVuY2UuXG4gICAgICAgICAgICAvLyBUaGlzIGNhbiBjYXVzZSBhIHNtYWxsIGdsaXRjaCBpbiB2aW0uXG4gICAgICAgICAgICAvLyB0ZXN0OiBlY2hvIC1uZSAnXFxlUCtxNmI2NFxcZVxcXFwnXG4gICAgICAgICAgICBjYXNlICcrcSc6XG4gICAgICAgICAgICAgIHZhciBwdCA9IHRoaXMuY3VycmVudFBhcmFtXG4gICAgICAgICAgICAgICAgLCB2YWxpZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIHRoaXMuc2VuZCgnXFx4MWJQJyArICt2YWxpZCArICcrcicgKyBwdCArICdcXHgxYlxcXFwnKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRoaXMuZXJyb3IoJ1Vua25vd24gRENTIHByZWZpeDogJXMuJywgdGhpcy5wcmVmaXgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmN1cnJlbnRQYXJhbSA9IDA7XG4gICAgICAgICAgdGhpcy5wcmVmaXggPSAnJztcbiAgICAgICAgICB0aGlzLnN0YXRlID0gbm9ybWFsO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmN1cnJlbnRQYXJhbSkge1xuICAgICAgICAgIGlmICghdGhpcy5wcmVmaXggJiYgY2ggIT09ICckJyAmJiBjaCAhPT0gJysnKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXJhbSA9IGNoO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmVmaXgubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXJhbSA9IGNoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnByZWZpeCArPSBjaDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50UGFyYW0gKz0gY2g7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgaWdub3JlOlxuICAgICAgICAvLyBGb3IgUE0gYW5kIEFQQy5cbiAgICAgICAgaWYgKGNoID09PSAnXFx4MWInIHx8IGNoID09PSAnXFx4MDcnKSB7XG4gICAgICAgICAgaWYgKGNoID09PSAnXFx4MWInKSBpKys7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IG5vcm1hbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMueSk7XG4gIHRoaXMucmVmcmVzaCh0aGlzLnJlZnJlc2hTdGFydCwgdGhpcy5yZWZyZXNoRW5kKTtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS53cml0ZWxuID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLndyaXRlKGRhdGEgKyAnXFxyXFxuJyk7XG59O1xuXG4vLyBLZXkgUmVzb3VyY2VzOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9ET00vS2V5Ym9hcmRFdmVudFxuVGVybWluYWwucHJvdG90eXBlLmtleURvd24gPSBmdW5jdGlvbihldikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGtleTtcblxuICBzd2l0Y2ggKGV2LmtleUNvZGUpIHtcbiAgICAvLyBiYWNrc3BhY2VcbiAgICBjYXNlIDg6XG4gICAgICBpZiAoZXYuc2hpZnRLZXkpIHtcbiAgICAgICAga2V5ID0gJ1xceDA4JzsgLy8gXkhcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBrZXkgPSAnXFx4N2YnOyAvLyBeP1xuICAgICAgYnJlYWs7XG4gICAgLy8gdGFiXG4gICAgY2FzZSA5OlxuICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgIGtleSA9ICdcXHgxYltaJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBrZXkgPSAnXFx0JztcbiAgICAgIGJyZWFrO1xuICAgIC8vIHJldHVybi9lbnRlclxuICAgIGNhc2UgMTM6XG4gICAgICBrZXkgPSAnXFxyJztcbiAgICAgIGJyZWFrO1xuICAgIC8vIGVzY2FwZVxuICAgIGNhc2UgMjc6XG4gICAgICBrZXkgPSAnXFx4MWInO1xuICAgICAgYnJlYWs7XG4gICAgLy8gbGVmdC1hcnJvd1xuICAgIGNhc2UgMzc6XG4gICAgICBpZiAodGhpcy5hcHBsaWNhdGlvbkN1cnNvcikge1xuICAgICAgICBrZXkgPSAnXFx4MWJPRCc7IC8vIFNTMyBhcyBeW08gZm9yIDctYml0XG4gICAgICAgIC8va2V5ID0gJ1xceDhmRCc7IC8vIFNTMyBhcyAweDhmIGZvciA4LWJpdFxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGtleSA9ICdcXHgxYltEJztcbiAgICAgIGJyZWFrO1xuICAgIC8vIHJpZ2h0LWFycm93XG4gICAgY2FzZSAzOTpcbiAgICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uQ3Vyc29yKSB7XG4gICAgICAgIGtleSA9ICdcXHgxYk9DJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBrZXkgPSAnXFx4MWJbQyc7XG4gICAgICBicmVhaztcbiAgICAvLyB1cC1hcnJvd1xuICAgIGNhc2UgMzg6XG4gICAgICBpZiAodGhpcy5hcHBsaWNhdGlvbkN1cnNvcikge1xuICAgICAgICBrZXkgPSAnXFx4MWJPQSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGV2LmN0cmxLZXkpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxEaXNwKC0xKTtcbiAgICAgICAgcmV0dXJuIGNhbmNlbChldik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSAnXFx4MWJbQSc7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAvLyBkb3duLWFycm93XG4gICAgY2FzZSA0MDpcbiAgICAgIGlmICh0aGlzLmFwcGxpY2F0aW9uQ3Vyc29yKSB7XG4gICAgICAgIGtleSA9ICdcXHgxYk9CJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZXYuY3RybEtleSkge1xuICAgICAgICB0aGlzLnNjcm9sbERpc3AoMSk7XG4gICAgICAgIHJldHVybiBjYW5jZWwoZXYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5ID0gJ1xceDFiW0InO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgLy8gZGVsZXRlXG4gICAgY2FzZSA0NjpcbiAgICAgIGtleSA9ICdcXHgxYlszfic7XG4gICAgICBicmVhaztcbiAgICAvLyBpbnNlcnRcbiAgICBjYXNlIDQ1OlxuICAgICAga2V5ID0gJ1xceDFiWzJ+JztcbiAgICAgIGJyZWFrO1xuICAgIC8vIGhvbWVcbiAgICBjYXNlIDM2OlxuICAgICAgaWYgKHRoaXMuYXBwbGljYXRpb25LZXlwYWQpIHtcbiAgICAgICAga2V5ID0gJ1xceDFiT0gnO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGtleSA9ICdcXHgxYk9IJztcbiAgICAgIGJyZWFrO1xuICAgIC8vIGVuZFxuICAgIGNhc2UgMzU6XG4gICAgICBpZiAodGhpcy5hcHBsaWNhdGlvbktleXBhZCkge1xuICAgICAgICBrZXkgPSAnXFx4MWJPRic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAga2V5ID0gJ1xceDFiT0YnO1xuICAgICAgYnJlYWs7XG4gICAgLy8gcGFnZSB1cFxuICAgIGNhc2UgMzM6XG4gICAgICBpZiAoZXYuc2hpZnRLZXkpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxEaXNwKC0odGhpcy5yb3dzIC0gMSkpO1xuICAgICAgICByZXR1cm4gY2FuY2VsKGV2KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleSA9ICdcXHgxYls1fic7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICAvLyBwYWdlIGRvd25cbiAgICBjYXNlIDM0OlxuICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsRGlzcCh0aGlzLnJvd3MgLSAxKTtcbiAgICAgICAgcmV0dXJuIGNhbmNlbChldik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrZXkgPSAnXFx4MWJbNn4nO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgLy8gRjFcbiAgICBjYXNlIDExMjpcbiAgICAgIGtleSA9ICdcXHgxYk9QJztcbiAgICAgIGJyZWFrO1xuICAgIC8vIEYyXG4gICAgY2FzZSAxMTM6XG4gICAgICBrZXkgPSAnXFx4MWJPUSc7XG4gICAgICBicmVhaztcbiAgICAvLyBGM1xuICAgIGNhc2UgMTE0OlxuICAgICAga2V5ID0gJ1xceDFiT1InO1xuICAgICAgYnJlYWs7XG4gICAgLy8gRjRcbiAgICBjYXNlIDExNTpcbiAgICAgIGtleSA9ICdcXHgxYk9TJztcbiAgICAgIGJyZWFrO1xuICAgIC8vIEY1XG4gICAgY2FzZSAxMTY6XG4gICAgICBrZXkgPSAnXFx4MWJbMTV+JztcbiAgICAgIGJyZWFrO1xuICAgIC8vIEY2XG4gICAgY2FzZSAxMTc6XG4gICAgICBrZXkgPSAnXFx4MWJbMTd+JztcbiAgICAgIGJyZWFrO1xuICAgIC8vIEY3XG4gICAgY2FzZSAxMTg6XG4gICAgICBrZXkgPSAnXFx4MWJbMTh+JztcbiAgICAgIGJyZWFrO1xuICAgIC8vIEY4XG4gICAgY2FzZSAxMTk6XG4gICAgICBrZXkgPSAnXFx4MWJbMTl+JztcbiAgICAgIGJyZWFrO1xuICAgIC8vIEY5XG4gICAgY2FzZSAxMjA6XG4gICAgICBrZXkgPSAnXFx4MWJbMjB+JztcbiAgICAgIGJyZWFrO1xuICAgIC8vIEYxMFxuICAgIGNhc2UgMTIxOlxuICAgICAga2V5ID0gJ1xceDFiWzIxfic7XG4gICAgICBicmVhaztcbiAgICAvLyBGMTFcbiAgICBjYXNlIDEyMjpcbiAgICAgIGtleSA9ICdcXHgxYlsyM34nO1xuICAgICAgYnJlYWs7XG4gICAgLy8gRjEyXG4gICAgY2FzZSAxMjM6XG4gICAgICBrZXkgPSAnXFx4MWJbMjR+JztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBhLXogYW5kIHNwYWNlXG4gICAgICBpZiAoZXYuY3RybEtleSkge1xuICAgICAgICBpZiAoZXYua2V5Q29kZSA+PSA2NSAmJiBldi5rZXlDb2RlIDw9IDkwKSB7XG4gICAgICAgICAgLy8gQ3RybC1BXG4gICAgICAgICAgaWYgKHRoaXMuc2NyZWVuS2V5cykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByZWZpeE1vZGUgJiYgIXRoaXMuc2VsZWN0TW9kZSAmJiBldi5rZXlDb2RlID09PSA2NSkge1xuICAgICAgICAgICAgICB0aGlzLmVudGVyUHJlZml4KCk7XG4gICAgICAgICAgICAgIHJldHVybiBjYW5jZWwoZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDdHJsLVZcbiAgICAgICAgICBpZiAodGhpcy5wcmVmaXhNb2RlICYmIGV2LmtleUNvZGUgPT09IDg2KSB7XG4gICAgICAgICAgICB0aGlzLmxlYXZlUHJlZml4KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEN0cmwtQ1xuICAgICAgICAgIGlmICgodGhpcy5wcmVmaXhNb2RlIHx8IHRoaXMuc2VsZWN0TW9kZSkgJiYgZXYua2V5Q29kZSA9PT0gNjcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmxlYXZlVmlzdWFsKCk7XG4gICAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2LmtleUNvZGUgLSA2NCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PT0gMzIpIHtcbiAgICAgICAgICAvLyBOVUxcbiAgICAgICAgICBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDApO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPj0gNTEgJiYgZXYua2V5Q29kZSA8PSA1NSkge1xuICAgICAgICAgIC8vIGVzY2FwZSwgZmlsZSBzZXAsIGdyb3VwIHNlcCwgcmVjb3JkIHNlcCwgdW5pdCBzZXBcbiAgICAgICAgICBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2LmtleUNvZGUgLSA1MSArIDI3KTtcbiAgICAgICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09PSA1Nikge1xuICAgICAgICAgIC8vIGRlbGV0ZVxuICAgICAgICAgIGtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMTI3KTtcbiAgICAgICAgfSBlbHNlIGlmIChldi5rZXlDb2RlID09PSAyMTkpIHtcbiAgICAgICAgICAvLyBeWyAtIGVzY2FwZVxuICAgICAgICAgIGtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMjcpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2LmtleUNvZGUgPT09IDIyMSkge1xuICAgICAgICAgIC8vIF5dIC0gZ3JvdXAgc2VwXG4gICAgICAgICAga2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgyOSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKCF0aGlzLmlzTWFjICYmIGV2LmFsdEtleSkgfHwgKHRoaXMuaXNNYWMgJiYgZXYubWV0YUtleSkpIHtcbiAgICAgICAgaWYgKGV2LmtleUNvZGUgPj0gNjUgJiYgZXYua2V5Q29kZSA8PSA5MCkge1xuICAgICAgICAgIGtleSA9ICdcXHgxYicgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGV2LmtleUNvZGUgKyAzMik7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA9PT0gMTkyKSB7XG4gICAgICAgICAga2V5ID0gJ1xceDFiYCc7XG4gICAgICAgIH0gZWxzZSBpZiAoZXYua2V5Q29kZSA+PSA0OCAmJiBldi5rZXlDb2RlIDw9IDU3KSB7XG4gICAgICAgICAga2V5ID0gJ1xceDFiJyArIChldi5rZXlDb2RlIC0gNDgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGlmICgha2V5KSByZXR1cm4gdHJ1ZTtcblxuICBpZiAodGhpcy5wcmVmaXhNb2RlKSB7XG4gICAgdGhpcy5sZWF2ZVByZWZpeCgpO1xuICAgIHJldHVybiBjYW5jZWwoZXYpO1xuICB9XG5cbiAgaWYgKHRoaXMuc2VsZWN0TW9kZSkge1xuICAgIHRoaXMua2V5U2VsZWN0KGV2LCBrZXkpO1xuICAgIHJldHVybiBjYW5jZWwoZXYpO1xuICB9XG5cbiAgdGhpcy5lbWl0KCdrZXlkb3duJywgZXYpO1xuICB0aGlzLmVtaXQoJ2tleScsIGtleSwgZXYpO1xuXG4gIHRoaXMuc2hvd0N1cnNvcigpO1xuICB0aGlzLmhhbmRsZXIoa2V5KTtcblxuICByZXR1cm4gY2FuY2VsKGV2KTtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5zZXRnTGV2ZWwgPSBmdW5jdGlvbihnKSB7XG4gIHRoaXMuZ2xldmVsID0gZztcbiAgdGhpcy5jaGFyc2V0ID0gdGhpcy5jaGFyc2V0c1tnXTtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5zZXRnQ2hhcnNldCA9IGZ1bmN0aW9uKGcsIGNoYXJzZXQpIHtcbiAgdGhpcy5jaGFyc2V0c1tnXSA9IGNoYXJzZXQ7XG4gIGlmICh0aGlzLmdsZXZlbCA9PT0gZykge1xuICAgIHRoaXMuY2hhcnNldCA9IGNoYXJzZXQ7XG4gIH1cbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5rZXlQcmVzcyA9IGZ1bmN0aW9uKGV2KSB7XG4gIHZhciBrZXk7XG5cbiAgY2FuY2VsKGV2KTtcblxuICBpZiAoZXYuY2hhckNvZGUpIHtcbiAgICBrZXkgPSBldi5jaGFyQ29kZTtcbiAgfSBlbHNlIGlmIChldi53aGljaCA9PSBudWxsKSB7XG4gICAga2V5ID0gZXYua2V5Q29kZTtcbiAgfSBlbHNlIGlmIChldi53aGljaCAhPT0gMCAmJiBldi5jaGFyQ29kZSAhPT0gMCkge1xuICAgIGtleSA9IGV2LndoaWNoO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICgha2V5IHx8IGV2LmN0cmxLZXkgfHwgZXYuYWx0S2V5IHx8IGV2Lm1ldGFLZXkpIHJldHVybiBmYWxzZTtcblxuICBrZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGtleSk7XG5cbiAgaWYgKHRoaXMucHJlZml4TW9kZSkge1xuICAgIHRoaXMubGVhdmVQcmVmaXgoKTtcbiAgICB0aGlzLmtleVByZWZpeChldiwga2V5KTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5zZWxlY3RNb2RlKSB7XG4gICAgdGhpcy5rZXlTZWxlY3QoZXYsIGtleSk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdGhpcy5lbWl0KCdrZXlwcmVzcycsIGtleSwgZXYpO1xuICB0aGlzLmVtaXQoJ2tleScsIGtleSwgZXYpO1xuXG4gIHRoaXMuc2hvd0N1cnNvcigpO1xuICB0aGlzLmhhbmRsZXIoa2V5KTtcblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5xdWV1ZSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmhhbmRsZXIoc2VsZi5xdWV1ZSk7XG4gICAgICBzZWxmLnF1ZXVlID0gJyc7XG4gICAgfSwgMSk7XG4gIH1cblxuICB0aGlzLnF1ZXVlICs9IGRhdGE7XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUuYmVsbCA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMudmlzdWFsQmVsbCkgcmV0dXJuO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS5ib3JkZXJDb2xvciA9ICd3aGl0ZSc7XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbGVtZW50LnN0eWxlLmJvcmRlckNvbG9yID0gJyc7XG4gIH0sIDEwKTtcbiAgaWYgKHRoaXMucG9wT25CZWxsKSB0aGlzLmZvY3VzKCk7XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kZWJ1ZykgcmV0dXJuO1xuICBpZiAoIXRoaXMuY29udGV4dC5jb25zb2xlIHx8ICF0aGlzLmNvbnRleHQuY29uc29sZS5sb2cpIHJldHVybjtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICB0aGlzLmNvbnRleHQuY29uc29sZS5sb2cuYXBwbHkodGhpcy5jb250ZXh0LmNvbnNvbGUsIGFyZ3MpO1xufTtcblxuVGVybWluYWwucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5kZWJ1ZykgcmV0dXJuO1xuICBpZiAoIXRoaXMuY29udGV4dC5jb25zb2xlIHx8ICF0aGlzLmNvbnRleHQuY29uc29sZS5lcnJvcikgcmV0dXJuO1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gIHRoaXMuY29udGV4dC5jb25zb2xlLmVycm9yLmFwcGx5KHRoaXMuY29udGV4dC5jb25zb2xlLCBhcmdzKTtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5yZXNpemUgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciBsaW5lXG4gICAgLCBlbFxuICAgICwgaVxuICAgICwgalxuICAgICwgY2g7XG5cbiAgaWYgKHggPCAxKSB4ID0gMTtcbiAgaWYgKHkgPCAxKSB5ID0gMTtcblxuICAvLyByZXNpemUgY29sc1xuICBqID0gdGhpcy5jb2xzO1xuICBpZiAoaiA8IHgpIHtcbiAgICBjaCA9IFt0aGlzLmRlZkF0dHIsICcgJ107IC8vIGRvZXMgeHRlcm0gdXNlIHRoZSBkZWZhdWx0IGF0dHI/XG4gICAgaSA9IHRoaXMubGluZXMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHdoaWxlICh0aGlzLmxpbmVzW2ldLmxlbmd0aCA8IHgpIHtcbiAgICAgICAgdGhpcy5saW5lc1tpXS5wdXNoKGNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaiA+IHgpIHtcbiAgICBpID0gdGhpcy5saW5lcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgd2hpbGUgKHRoaXMubGluZXNbaV0ubGVuZ3RoID4geCkge1xuICAgICAgICB0aGlzLmxpbmVzW2ldLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnNldHVwU3RvcHMoaik7XG4gIHRoaXMuY29scyA9IHg7XG5cbiAgLy8gcmVzaXplIHJvd3NcbiAgaiA9IHRoaXMucm93cztcbiAgaWYgKGogPCB5KSB7XG4gICAgZWwgPSB0aGlzLmVsZW1lbnQ7XG4gICAgd2hpbGUgKGorKyA8IHkpIHtcbiAgICAgIGlmICh0aGlzLmxpbmVzLmxlbmd0aCA8IHkgKyB0aGlzLnliYXNlKSB7XG4gICAgICAgIHRoaXMubGluZXMucHVzaCh0aGlzLmJsYW5rTGluZSgpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA8IHkpIHtcbiAgICAgICAgbGluZSA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKGxpbmUpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLnB1c2gobGluZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGogPiB5KSB7XG4gICAgd2hpbGUgKGotLSA+IHkpIHtcbiAgICAgIGlmICh0aGlzLmxpbmVzLmxlbmd0aCA+IHkgKyB0aGlzLnliYXNlKSB7XG4gICAgICAgIHRoaXMubGluZXMucG9wKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiB5KSB7XG4gICAgICAgIGVsID0gdGhpcy5jaGlsZHJlbi5wb3AoKTtcbiAgICAgICAgaWYgKCFlbCkgY29udGludWU7XG4gICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzLnJvd3MgPSB5O1xuXG4gIC8vIG1ha2Ugc3VyZSB0aGUgY3Vyc29yIHN0YXlzIG9uIHNjcmVlblxuICBpZiAodGhpcy55ID49IHkpIHRoaXMueSA9IHkgLSAxO1xuICBpZiAodGhpcy54ID49IHgpIHRoaXMueCA9IHggLSAxO1xuXG4gIHRoaXMuc2Nyb2xsVG9wID0gMDtcbiAgdGhpcy5zY3JvbGxCb3R0b20gPSB5IC0gMTtcblxuICB0aGlzLnJlZnJlc2goMCwgdGhpcy5yb3dzIC0gMSk7XG5cbiAgLy8gaXQncyBhIHJlYWwgbmlnaHRtYXJlIHRyeWluZ1xuICAvLyB0byByZXNpemUgdGhlIG9yaWdpbmFsXG4gIC8vIHNjcmVlbiBidWZmZXIuIGp1c3Qgc2V0IGl0XG4gIC8vIHRvIG51bGwgZm9yIG5vdy5cbiAgdGhpcy5ub3JtYWwgPSBudWxsO1xufTtcblxuVGVybWluYWwucHJvdG90eXBlLnVwZGF0ZVJhbmdlID0gZnVuY3Rpb24oeSkge1xuICBpZiAoeSA8IHRoaXMucmVmcmVzaFN0YXJ0KSB0aGlzLnJlZnJlc2hTdGFydCA9IHk7XG4gIGlmICh5ID4gdGhpcy5yZWZyZXNoRW5kKSB0aGlzLnJlZnJlc2hFbmQgPSB5O1xuICAvLyBpZiAoeSA+IHRoaXMucmVmcmVzaEVuZCkge1xuICAvLyAgIHRoaXMucmVmcmVzaEVuZCA9IHk7XG4gIC8vICAgaWYgKHkgPiB0aGlzLnJvd3MgLSAxKSB7XG4gIC8vICAgICB0aGlzLnJlZnJlc2hFbmQgPSB0aGlzLnJvd3MgLSAxO1xuICAvLyAgIH1cbiAgLy8gfVxufTtcblxuVGVybWluYWwucHJvdG90eXBlLm1heFJhbmdlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVmcmVzaFN0YXJ0ID0gMDtcbiAgdGhpcy5yZWZyZXNoRW5kID0gdGhpcy5yb3dzIC0gMTtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5zZXR1cFN0b3BzID0gZnVuY3Rpb24oaSkge1xuICBpZiAoaSAhPSBudWxsKSB7XG4gICAgaWYgKCF0aGlzLnRhYnNbaV0pIHtcbiAgICAgIGkgPSB0aGlzLnByZXZTdG9wKGkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLnRhYnMgPSB7fTtcbiAgICBpID0gMDtcbiAgfVxuXG4gIGZvciAoOyBpIDwgdGhpcy5jb2xzOyBpICs9IDgpIHtcbiAgICB0aGlzLnRhYnNbaV0gPSB0cnVlO1xuICB9XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUucHJldlN0b3AgPSBmdW5jdGlvbih4KSB7XG4gIGlmICh4ID09IG51bGwpIHggPSB0aGlzLng7XG4gIHdoaWxlICghdGhpcy50YWJzWy0teF0gJiYgeCA+IDApO1xuICByZXR1cm4geCA+PSB0aGlzLmNvbHNcbiAgICA/IHRoaXMuY29scyAtIDFcbiAgICA6IHggPCAwID8gMCA6IHg7XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUubmV4dFN0b3AgPSBmdW5jdGlvbih4KSB7XG4gIGlmICh4ID09IG51bGwpIHggPSB0aGlzLng7XG4gIHdoaWxlICghdGhpcy50YWJzWysreF0gJiYgeCA8IHRoaXMuY29scyk7XG4gIHJldHVybiB4ID49IHRoaXMuY29sc1xuICAgID8gdGhpcy5jb2xzIC0gMVxuICAgIDogeCA8IDAgPyAwIDogeDtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5lcmFzZVJpZ2h0ID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgbGluZSA9IHRoaXMubGluZXNbdGhpcy55YmFzZSArIHldXG4gICAgLCBjaCA9IFt0aGlzLmVyYXNlQXR0cigpLCAnICddOyAvLyB4dGVybVxuXG5cbiAgZm9yICg7IHggPCB0aGlzLmNvbHM7IHgrKykge1xuICAgIGxpbmVbeF0gPSBjaDtcbiAgfVxuXG4gIHRoaXMudXBkYXRlUmFuZ2UoeSk7XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUuZXJhc2VMZWZ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICB2YXIgbGluZSA9IHRoaXMubGluZXNbdGhpcy55YmFzZSArIHldXG4gICAgLCBjaCA9IFt0aGlzLmVyYXNlQXR0cigpLCAnICddOyAvLyB4dGVybVxuXG4gIHgrKztcbiAgd2hpbGUgKHgtLSkgbGluZVt4XSA9IGNoO1xuXG4gIHRoaXMudXBkYXRlUmFuZ2UoeSk7XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUuZXJhc2VMaW5lID0gZnVuY3Rpb24oeSkge1xuICB0aGlzLmVyYXNlUmlnaHQoMCwgeSk7XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUuYmxhbmtMaW5lID0gZnVuY3Rpb24oY3VyKSB7XG4gIHZhciBhdHRyID0gY3VyXG4gICAgPyB0aGlzLmVyYXNlQXR0cigpXG4gICAgOiB0aGlzLmRlZkF0dHI7XG5cbiAgdmFyIGNoID0gW2F0dHIsICcgJ11cbiAgICAsIGxpbmUgPSBbXVxuICAgICwgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCB0aGlzLmNvbHM7IGkrKykge1xuICAgIGxpbmVbaV0gPSBjaDtcbiAgfVxuXG4gIHJldHVybiBsaW5lO1xufTtcblxuVGVybWluYWwucHJvdG90eXBlLmNoID0gZnVuY3Rpb24oY3VyKSB7XG4gIHJldHVybiBjdXJcbiAgICA/IFt0aGlzLmVyYXNlQXR0cigpLCAnICddXG4gICAgOiBbdGhpcy5kZWZBdHRyLCAnICddO1xufTtcblxuVGVybWluYWwucHJvdG90eXBlLmlzID0gZnVuY3Rpb24odGVybSkge1xuICB2YXIgbmFtZSA9IHRoaXMudGVybU5hbWU7XG4gIHJldHVybiAobmFtZSArICcnKS5pbmRleE9mKHRlcm0pID09PSAwO1xufTtcblxuVGVybWluYWwucHJvdG90eXBlLmhhbmRsZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xufTtcblxuVGVybWluYWwucHJvdG90eXBlLmhhbmRsZVRpdGxlID0gZnVuY3Rpb24odGl0bGUpIHtcbiAgdGhpcy5lbWl0KCd0aXRsZScsIHRpdGxlKTtcbn07XG5cbi8qKlxuICogRVNDXG4gKi9cblxuLy8gRVNDIEQgSW5kZXggKElORCBpcyAweDg0KS5cblRlcm1pbmFsLnByb3RvdHlwZS5pbmRleCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnkrKztcbiAgaWYgKHRoaXMueSA+IHRoaXMuc2Nyb2xsQm90dG9tKSB7XG4gICAgdGhpcy55LS07XG4gICAgdGhpcy5zY3JvbGwoKTtcbiAgfVxuICB0aGlzLnN0YXRlID0gbm9ybWFsO1xufTtcblxuLy8gRVNDIE0gUmV2ZXJzZSBJbmRleCAoUkkgaXMgMHg4ZCkuXG5UZXJtaW5hbC5wcm90b3R5cGUucmV2ZXJzZUluZGV4ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBqO1xuICB0aGlzLnktLTtcbiAgaWYgKHRoaXMueSA8IHRoaXMuc2Nyb2xsVG9wKSB7XG4gICAgdGhpcy55Kys7XG4gICAgLy8gcG9zc2libHkgbW92ZSB0aGUgY29kZSBiZWxvdyB0byB0ZXJtLnJldmVyc2VTY3JvbGwoKTtcbiAgICAvLyB0ZXN0OiBlY2hvIC1uZSAnXFxlWzE7MUhcXGVbNDRtXFxlTVxcZVswbSdcbiAgICAvLyBibGFua0xpbmUodHJ1ZSkgaXMgeHRlcm0vbGludXggYmVoYXZpb3JcbiAgICB0aGlzLmxpbmVzLnNwbGljZSh0aGlzLnkgKyB0aGlzLnliYXNlLCAwLCB0aGlzLmJsYW5rTGluZSh0cnVlKSk7XG4gICAgaiA9IHRoaXMucm93cyAtIDEgLSB0aGlzLnNjcm9sbEJvdHRvbTtcbiAgICB0aGlzLmxpbmVzLnNwbGljZSh0aGlzLnJvd3MgLSAxICsgdGhpcy55YmFzZSAtIGogKyAxLCAxKTtcbiAgICAvLyB0aGlzLm1heFJhbmdlKCk7XG4gICAgdGhpcy51cGRhdGVSYW5nZSh0aGlzLnNjcm9sbFRvcCk7XG4gICAgdGhpcy51cGRhdGVSYW5nZSh0aGlzLnNjcm9sbEJvdHRvbSk7XG4gIH1cbiAgdGhpcy5zdGF0ZSA9IG5vcm1hbDtcbn07XG5cbi8vIEVTQyBjIEZ1bGwgUmVzZXQgKFJJUykuXG5UZXJtaW5hbC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5vcHRpb25zLnJvd3MgPSB0aGlzLnJvd3M7XG4gIHRoaXMub3B0aW9ucy5jb2xzID0gdGhpcy5jb2xzO1xuICBUZXJtaW5hbC5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gIHRoaXMucmVmcmVzaCgwLCB0aGlzLnJvd3MgLSAxKTtcbn07XG5cbi8vIEVTQyBIIFRhYiBTZXQgKEhUUyBpcyAweDg4KS5cblRlcm1pbmFsLnByb3RvdHlwZS50YWJTZXQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy50YWJzW3RoaXMueF0gPSB0cnVlO1xuICB0aGlzLnN0YXRlID0gbm9ybWFsO1xufTtcblxuLyoqXG4gKiBDU0lcbiAqL1xuXG4vLyBDU0kgUHMgQVxuLy8gQ3Vyc29yIFVwIFBzIFRpbWVzIChkZWZhdWx0ID0gMSkgKENVVSkuXG5UZXJtaW5hbC5wcm90b3R5cGUuY3Vyc29yVXAgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICBpZiAocGFyYW0gPCAxKSBwYXJhbSA9IDE7XG4gIHRoaXMueSAtPSBwYXJhbTtcbiAgaWYgKHRoaXMueSA8IDApIHRoaXMueSA9IDA7XG59O1xuXG4vLyBDU0kgUHMgQlxuLy8gQ3Vyc29yIERvd24gUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ1VEKS5cblRlcm1pbmFsLnByb3RvdHlwZS5jdXJzb3JEb3duID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciBwYXJhbSA9IHBhcmFtc1swXTtcbiAgaWYgKHBhcmFtIDwgMSkgcGFyYW0gPSAxO1xuICB0aGlzLnkgKz0gcGFyYW07XG4gIGlmICh0aGlzLnkgPj0gdGhpcy5yb3dzKSB7XG4gICAgdGhpcy55ID0gdGhpcy5yb3dzIC0gMTtcbiAgfVxufTtcblxuLy8gQ1NJIFBzIENcbi8vIEN1cnNvciBGb3J3YXJkIFBzIFRpbWVzIChkZWZhdWx0ID0gMSkgKENVRikuXG5UZXJtaW5hbC5wcm90b3R5cGUuY3Vyc29yRm9yd2FyZCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgcGFyYW0gPSBwYXJhbXNbMF07XG4gIGlmIChwYXJhbSA8IDEpIHBhcmFtID0gMTtcbiAgdGhpcy54ICs9IHBhcmFtO1xuICBpZiAodGhpcy54ID49IHRoaXMuY29scykge1xuICAgIHRoaXMueCA9IHRoaXMuY29scyAtIDE7XG4gIH1cbn07XG5cbi8vIENTSSBQcyBEXG4vLyBDdXJzb3IgQmFja3dhcmQgUHMgVGltZXMgKGRlZmF1bHQgPSAxKSAoQ1VCKS5cblRlcm1pbmFsLnByb3RvdHlwZS5jdXJzb3JCYWNrd2FyZCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgcGFyYW0gPSBwYXJhbXNbMF07XG4gIGlmIChwYXJhbSA8IDEpIHBhcmFtID0gMTtcbiAgdGhpcy54IC09IHBhcmFtO1xuICBpZiAodGhpcy54IDwgMCkgdGhpcy54ID0gMDtcbn07XG5cbi8vIENTSSBQcyA7IFBzIEhcbi8vIEN1cnNvciBQb3NpdGlvbiBbcm93O2NvbHVtbl0gKGRlZmF1bHQgPSBbMSwxXSkgKENVUCkuXG5UZXJtaW5hbC5wcm90b3R5cGUuY3Vyc29yUG9zID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciByb3csIGNvbDtcblxuICByb3cgPSBwYXJhbXNbMF0gLSAxO1xuXG4gIGlmIChwYXJhbXMubGVuZ3RoID49IDIpIHtcbiAgICBjb2wgPSBwYXJhbXNbMV0gLSAxO1xuICB9IGVsc2Uge1xuICAgIGNvbCA9IDA7XG4gIH1cblxuICBpZiAocm93IDwgMCkge1xuICAgIHJvdyA9IDA7XG4gIH0gZWxzZSBpZiAocm93ID49IHRoaXMucm93cykge1xuICAgIHJvdyA9IHRoaXMucm93cyAtIDE7XG4gIH1cblxuICBpZiAoY29sIDwgMCkge1xuICAgIGNvbCA9IDA7XG4gIH0gZWxzZSBpZiAoY29sID49IHRoaXMuY29scykge1xuICAgIGNvbCA9IHRoaXMuY29scyAtIDE7XG4gIH1cblxuICB0aGlzLnggPSBjb2w7XG4gIHRoaXMueSA9IHJvdztcbn07XG5cbi8vIENTSSBQcyBKICBFcmFzZSBpbiBEaXNwbGF5IChFRCkuXG4vLyAgICAgUHMgPSAwICAtPiBFcmFzZSBCZWxvdyAoZGVmYXVsdCkuXG4vLyAgICAgUHMgPSAxICAtPiBFcmFzZSBBYm92ZS5cbi8vICAgICBQcyA9IDIgIC0+IEVyYXNlIEFsbC5cbi8vICAgICBQcyA9IDMgIC0+IEVyYXNlIFNhdmVkIExpbmVzICh4dGVybSkuXG4vLyBDU0kgPyBQcyBKXG4vLyAgIEVyYXNlIGluIERpc3BsYXkgKERFQ1NFRCkuXG4vLyAgICAgUHMgPSAwICAtPiBTZWxlY3RpdmUgRXJhc2UgQmVsb3cgKGRlZmF1bHQpLlxuLy8gICAgIFBzID0gMSAgLT4gU2VsZWN0aXZlIEVyYXNlIEFib3ZlLlxuLy8gICAgIFBzID0gMiAgLT4gU2VsZWN0aXZlIEVyYXNlIEFsbC5cblRlcm1pbmFsLnByb3RvdHlwZS5lcmFzZUluRGlzcGxheSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgajtcbiAgc3dpdGNoIChwYXJhbXNbMF0pIHtcbiAgICBjYXNlIDA6XG4gICAgICB0aGlzLmVyYXNlUmlnaHQodGhpcy54LCB0aGlzLnkpO1xuICAgICAgaiA9IHRoaXMueSArIDE7XG4gICAgICBmb3IgKDsgaiA8IHRoaXMucm93czsgaisrKSB7XG4gICAgICAgIHRoaXMuZXJhc2VMaW5lKGopO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgdGhpcy5lcmFzZUxlZnQodGhpcy54LCB0aGlzLnkpO1xuICAgICAgaiA9IHRoaXMueTtcbiAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgdGhpcy5lcmFzZUxpbmUoaik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBqID0gdGhpcy5yb3dzO1xuICAgICAgd2hpbGUgKGotLSkgdGhpcy5lcmFzZUxpbmUoaik7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICA7IC8vIG5vIHNhdmVkIGxpbmVzXG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLy8gQ1NJIFBzIEsgIEVyYXNlIGluIExpbmUgKEVMKS5cbi8vICAgICBQcyA9IDAgIC0+IEVyYXNlIHRvIFJpZ2h0IChkZWZhdWx0KS5cbi8vICAgICBQcyA9IDEgIC0+IEVyYXNlIHRvIExlZnQuXG4vLyAgICAgUHMgPSAyICAtPiBFcmFzZSBBbGwuXG4vLyBDU0kgPyBQcyBLXG4vLyAgIEVyYXNlIGluIExpbmUgKERFQ1NFTCkuXG4vLyAgICAgUHMgPSAwICAtPiBTZWxlY3RpdmUgRXJhc2UgdG8gUmlnaHQgKGRlZmF1bHQpLlxuLy8gICAgIFBzID0gMSAgLT4gU2VsZWN0aXZlIEVyYXNlIHRvIExlZnQuXG4vLyAgICAgUHMgPSAyICAtPiBTZWxlY3RpdmUgRXJhc2UgQWxsLlxuVGVybWluYWwucHJvdG90eXBlLmVyYXNlSW5MaW5lID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHN3aXRjaCAocGFyYW1zWzBdKSB7XG4gICAgY2FzZSAwOlxuICAgICAgdGhpcy5lcmFzZVJpZ2h0KHRoaXMueCwgdGhpcy55KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHRoaXMuZXJhc2VMZWZ0KHRoaXMueCwgdGhpcy55KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjpcbiAgICAgIHRoaXMuZXJhc2VMaW5lKHRoaXMueSk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLy8gQ1NJIFBtIG0gIENoYXJhY3RlciBBdHRyaWJ1dGVzIChTR1IpLlxuLy8gICAgIFBzID0gMCAgLT4gTm9ybWFsIChkZWZhdWx0KS5cbi8vICAgICBQcyA9IDEgIC0+IEJvbGQuXG4vLyAgICAgUHMgPSA0ICAtPiBVbmRlcmxpbmVkLlxuLy8gICAgIFBzID0gNSAgLT4gQmxpbmsgKGFwcGVhcnMgYXMgQm9sZCkuXG4vLyAgICAgUHMgPSA3ICAtPiBJbnZlcnNlLlxuLy8gICAgIFBzID0gOCAgLT4gSW52aXNpYmxlLCBpLmUuLCBoaWRkZW4gKFZUMzAwKS5cbi8vICAgICBQcyA9IDIgMiAgLT4gTm9ybWFsIChuZWl0aGVyIGJvbGQgbm9yIGZhaW50KS5cbi8vICAgICBQcyA9IDIgNCAgLT4gTm90IHVuZGVybGluZWQuXG4vLyAgICAgUHMgPSAyIDUgIC0+IFN0ZWFkeSAobm90IGJsaW5raW5nKS5cbi8vICAgICBQcyA9IDIgNyAgLT4gUG9zaXRpdmUgKG5vdCBpbnZlcnNlKS5cbi8vICAgICBQcyA9IDIgOCAgLT4gVmlzaWJsZSwgaS5lLiwgbm90IGhpZGRlbiAoVlQzMDApLlxuLy8gICAgIFBzID0gMyAwICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBCbGFjay5cbi8vICAgICBQcyA9IDMgMSAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gUmVkLlxuLy8gICAgIFBzID0gMyAyICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBHcmVlbi5cbi8vICAgICBQcyA9IDMgMyAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gWWVsbG93LlxuLy8gICAgIFBzID0gMyA0ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBCbHVlLlxuLy8gICAgIFBzID0gMyA1ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBNYWdlbnRhLlxuLy8gICAgIFBzID0gMyA2ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBDeWFuLlxuLy8gICAgIFBzID0gMyA3ICAtPiBTZXQgZm9yZWdyb3VuZCBjb2xvciB0byBXaGl0ZS5cbi8vICAgICBQcyA9IDMgOSAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gZGVmYXVsdCAob3JpZ2luYWwpLlxuLy8gICAgIFBzID0gNCAwICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBCbGFjay5cbi8vICAgICBQcyA9IDQgMSAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gUmVkLlxuLy8gICAgIFBzID0gNCAyICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBHcmVlbi5cbi8vICAgICBQcyA9IDQgMyAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gWWVsbG93LlxuLy8gICAgIFBzID0gNCA0ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBCbHVlLlxuLy8gICAgIFBzID0gNCA1ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBNYWdlbnRhLlxuLy8gICAgIFBzID0gNCA2ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBDeWFuLlxuLy8gICAgIFBzID0gNCA3ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBXaGl0ZS5cbi8vICAgICBQcyA9IDQgOSAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gZGVmYXVsdCAob3JpZ2luYWwpLlxuXG4vLyAgIElmIDE2LWNvbG9yIHN1cHBvcnQgaXMgY29tcGlsZWQsIHRoZSBmb2xsb3dpbmcgYXBwbHkuICBBc3N1bWVcbi8vICAgdGhhdCB4dGVybSdzIHJlc291cmNlcyBhcmUgc2V0IHNvIHRoYXQgdGhlIElTTyBjb2xvciBjb2RlcyBhcmVcbi8vICAgdGhlIGZpcnN0IDggb2YgYSBzZXQgb2YgMTYuICBUaGVuIHRoZSBhaXh0ZXJtIGNvbG9ycyBhcmUgdGhlXG4vLyAgIGJyaWdodCB2ZXJzaW9ucyBvZiB0aGUgSVNPIGNvbG9yczpcbi8vICAgICBQcyA9IDkgMCAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gQmxhY2suXG4vLyAgICAgUHMgPSA5IDEgIC0+IFNldCBmb3JlZ3JvdW5kIGNvbG9yIHRvIFJlZC5cbi8vICAgICBQcyA9IDkgMiAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gR3JlZW4uXG4vLyAgICAgUHMgPSA5IDMgIC0+IFNldCBmb3JlZ3JvdW5kIGNvbG9yIHRvIFllbGxvdy5cbi8vICAgICBQcyA9IDkgNCAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gQmx1ZS5cbi8vICAgICBQcyA9IDkgNSAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gTWFnZW50YS5cbi8vICAgICBQcyA9IDkgNiAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gQ3lhbi5cbi8vICAgICBQcyA9IDkgNyAgLT4gU2V0IGZvcmVncm91bmQgY29sb3IgdG8gV2hpdGUuXG4vLyAgICAgUHMgPSAxIDAgMCAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gQmxhY2suXG4vLyAgICAgUHMgPSAxIDAgMSAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gUmVkLlxuLy8gICAgIFBzID0gMSAwIDIgIC0+IFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIEdyZWVuLlxuLy8gICAgIFBzID0gMSAwIDMgIC0+IFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIFllbGxvdy5cbi8vICAgICBQcyA9IDEgMCA0ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBCbHVlLlxuLy8gICAgIFBzID0gMSAwIDUgIC0+IFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIE1hZ2VudGEuXG4vLyAgICAgUHMgPSAxIDAgNiAgLT4gU2V0IGJhY2tncm91bmQgY29sb3IgdG8gQ3lhbi5cbi8vICAgICBQcyA9IDEgMCA3ICAtPiBTZXQgYmFja2dyb3VuZCBjb2xvciB0byBXaGl0ZS5cblxuLy8gICBJZiB4dGVybSBpcyBjb21waWxlZCB3aXRoIHRoZSAxNi1jb2xvciBzdXBwb3J0IGRpc2FibGVkLCBpdFxuLy8gICBzdXBwb3J0cyB0aGUgZm9sbG93aW5nLCBmcm9tIHJ4dnQ6XG4vLyAgICAgUHMgPSAxIDAgMCAgLT4gU2V0IGZvcmVncm91bmQgYW5kIGJhY2tncm91bmQgY29sb3IgdG9cbi8vICAgICBkZWZhdWx0LlxuXG4vLyAgIElmIDg4LSBvciAyNTYtY29sb3Igc3VwcG9ydCBpcyBjb21waWxlZCwgdGhlIGZvbGxvd2luZyBhcHBseS5cbi8vICAgICBQcyA9IDMgOCAgOyA1ICA7IFBzIC0+IFNldCBmb3JlZ3JvdW5kIGNvbG9yIHRvIHRoZSBzZWNvbmRcbi8vICAgICBQcy5cbi8vICAgICBQcyA9IDQgOCAgOyA1ICA7IFBzIC0+IFNldCBiYWNrZ3JvdW5kIGNvbG9yIHRvIHRoZSBzZWNvbmRcbi8vICAgICBQcy5cblRlcm1pbmFsLnByb3RvdHlwZS5jaGFyQXR0cmlidXRlcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAvLyBPcHRpbWl6ZSBhIHNpbmdsZSBTR1IwLlxuICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMSAmJiBwYXJhbXNbMF0gPT09IDApIHtcbiAgICB0aGlzLmN1ckF0dHIgPSB0aGlzLmRlZkF0dHI7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGwgPSBwYXJhbXMubGVuZ3RoXG4gICAgLCBpID0gMFxuICAgICwgZmxhZ3MgPSB0aGlzLmN1ckF0dHIgPj4gMThcbiAgICAsIGZnID0gKHRoaXMuY3VyQXR0ciA+PiA5KSAmIDB4MWZmXG4gICAgLCBiZyA9IHRoaXMuY3VyQXR0ciAmIDB4MWZmXG4gICAgLCBwO1xuXG4gIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgcCA9IHBhcmFtc1tpXTtcbiAgICBpZiAocCA+PSAzMCAmJiBwIDw9IDM3KSB7XG4gICAgICAvLyBmZyBjb2xvciA4XG4gICAgICBmZyA9IHAgLSAzMDtcbiAgICB9IGVsc2UgaWYgKHAgPj0gNDAgJiYgcCA8PSA0Nykge1xuICAgICAgLy8gYmcgY29sb3IgOFxuICAgICAgYmcgPSBwIC0gNDA7XG4gICAgfSBlbHNlIGlmIChwID49IDkwICYmIHAgPD0gOTcpIHtcbiAgICAgIC8vIGZnIGNvbG9yIDE2XG4gICAgICBwICs9IDg7XG4gICAgICBmZyA9IHAgLSA5MDtcbiAgICB9IGVsc2UgaWYgKHAgPj0gMTAwICYmIHAgPD0gMTA3KSB7XG4gICAgICAvLyBiZyBjb2xvciAxNlxuICAgICAgcCArPSA4O1xuICAgICAgYmcgPSBwIC0gMTAwO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gMCkge1xuICAgICAgLy8gZGVmYXVsdFxuICAgICAgZmxhZ3MgPSB0aGlzLmRlZkF0dHIgPj4gMTg7XG4gICAgICBmZyA9ICh0aGlzLmRlZkF0dHIgPj4gOSkgJiAweDFmZjtcbiAgICAgIGJnID0gdGhpcy5kZWZBdHRyICYgMHgxZmY7XG4gICAgICAvLyBmbGFncyA9IDA7XG4gICAgICAvLyBmZyA9IDB4MWZmO1xuICAgICAgLy8gYmcgPSAweDFmZjtcbiAgICB9IGVsc2UgaWYgKHAgPT09IDEpIHtcbiAgICAgIC8vIGJvbGQgdGV4dFxuICAgICAgZmxhZ3MgfD0gMTtcbiAgICB9IGVsc2UgaWYgKHAgPT09IDQpIHtcbiAgICAgIC8vIHVuZGVybGluZWQgdGV4dFxuICAgICAgZmxhZ3MgfD0gMjtcbiAgICB9IGVsc2UgaWYgKHAgPT09IDUpIHtcbiAgICAgIC8vIGJsaW5rXG4gICAgICBmbGFncyB8PSA0O1xuICAgIH0gZWxzZSBpZiAocCA9PT0gNykge1xuICAgICAgLy8gaW52ZXJzZSBhbmQgcG9zaXRpdmVcbiAgICAgIC8vIHRlc3Qgd2l0aDogZWNobyAtZSAnXFxlWzMxbVxcZVs0Mm1oZWxsb1xcZVs3bXdvcmxkXFxlWzI3bWhpXFxlW20nXG4gICAgICBmbGFncyB8PSA4O1xuICAgIH0gZWxzZSBpZiAocCA9PT0gOCkge1xuICAgICAgLy8gaW52aXNpYmxlXG4gICAgICBmbGFncyB8PSAxNjtcbiAgICB9IGVsc2UgaWYgKHAgPT09IDIyKSB7XG4gICAgICAvLyBub3QgYm9sZFxuICAgICAgZmxhZ3MgJj0gfjE7XG4gICAgfSBlbHNlIGlmIChwID09PSAyNCkge1xuICAgICAgLy8gbm90IHVuZGVybGluZWRcbiAgICAgIGZsYWdzICY9IH4yO1xuICAgIH0gZWxzZSBpZiAocCA9PT0gMjUpIHtcbiAgICAgIC8vIG5vdCBibGlua1xuICAgICAgZmxhZ3MgJj0gfjQ7XG4gICAgfSBlbHNlIGlmIChwID09PSAyNykge1xuICAgICAgLy8gbm90IGludmVyc2VcbiAgICAgIGZsYWdzICY9IH44O1xuICAgIH0gZWxzZSBpZiAocCA9PT0gMjgpIHtcbiAgICAgIC8vIG5vdCBpbnZpc2libGVcbiAgICAgIGZsYWdzICY9IH4xNjtcbiAgICB9IGVsc2UgaWYgKHAgPT09IDM5KSB7XG4gICAgICAvLyByZXNldCBmZ1xuICAgICAgZmcgPSAodGhpcy5kZWZBdHRyID4+IDkpICYgMHgxZmY7XG4gICAgfSBlbHNlIGlmIChwID09PSA0OSkge1xuICAgICAgLy8gcmVzZXQgYmdcbiAgICAgIGJnID0gdGhpcy5kZWZBdHRyICYgMHgxZmY7XG4gICAgfSBlbHNlIGlmIChwID09PSAzOCkge1xuICAgICAgLy8gZmcgY29sb3IgMjU2XG4gICAgICBpZiAocGFyYW1zW2kgKyAxXSA9PT0gMikge1xuICAgICAgICBpICs9IDI7XG4gICAgICAgIGZnID0gbWF0Y2hDb2xvcihcbiAgICAgICAgICBwYXJhbXNbaV0gJiAweGZmLFxuICAgICAgICAgIHBhcmFtc1tpICsgMV0gJiAweGZmLFxuICAgICAgICAgIHBhcmFtc1tpICsgMl0gJiAweGZmKTtcbiAgICAgICAgaWYgKGZnID09PSAtMSkgZmcgPSAweDFmZjtcbiAgICAgICAgaSArPSAyO1xuICAgICAgfSBlbHNlIGlmIChwYXJhbXNbaSArIDFdID09PSA1KSB7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgcCA9IHBhcmFtc1tpXSAmIDB4ZmY7XG4gICAgICAgIGZnID0gcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHAgPT09IDQ4KSB7XG4gICAgICAvLyBiZyBjb2xvciAyNTZcbiAgICAgIGlmIChwYXJhbXNbaSArIDFdID09PSAyKSB7XG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgYmcgPSBtYXRjaENvbG9yKFxuICAgICAgICAgIHBhcmFtc1tpXSAmIDB4ZmYsXG4gICAgICAgICAgcGFyYW1zW2kgKyAxXSAmIDB4ZmYsXG4gICAgICAgICAgcGFyYW1zW2kgKyAyXSAmIDB4ZmYpO1xuICAgICAgICBpZiAoYmcgPT09IC0xKSBiZyA9IDB4MWZmO1xuICAgICAgICBpICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKHBhcmFtc1tpICsgMV0gPT09IDUpIHtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBwID0gcGFyYW1zW2ldICYgMHhmZjtcbiAgICAgICAgYmcgPSBwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocCA9PT0gMTAwKSB7XG4gICAgICAvLyByZXNldCBmZy9iZ1xuICAgICAgZmcgPSAodGhpcy5kZWZBdHRyID4+IDkpICYgMHgxZmY7XG4gICAgICBiZyA9IHRoaXMuZGVmQXR0ciAmIDB4MWZmO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVycm9yKCdVbmtub3duIFNHUiBhdHRyaWJ1dGU6ICVkLicsIHApO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuY3VyQXR0ciA9IChmbGFncyA8PCAxOCkgfCAoZmcgPDwgOSkgfCBiZztcbn07XG5cbi8vIENTSSBQcyBuICBEZXZpY2UgU3RhdHVzIFJlcG9ydCAoRFNSKS5cbi8vICAgICBQcyA9IDUgIC0+IFN0YXR1cyBSZXBvcnQuICBSZXN1bHQgKGBgT0snJykgaXNcbi8vICAgQ1NJIDAgblxuLy8gICAgIFBzID0gNiAgLT4gUmVwb3J0IEN1cnNvciBQb3NpdGlvbiAoQ1BSKSBbcm93O2NvbHVtbl0uXG4vLyAgIFJlc3VsdCBpc1xuLy8gICBDU0kgciA7IGMgUlxuLy8gQ1NJID8gUHMgblxuLy8gICBEZXZpY2UgU3RhdHVzIFJlcG9ydCAoRFNSLCBERUMtc3BlY2lmaWMpLlxuLy8gICAgIFBzID0gNiAgLT4gUmVwb3J0IEN1cnNvciBQb3NpdGlvbiAoQ1BSKSBbcm93O2NvbHVtbl0gYXMgQ1NJXG4vLyAgICAgPyByIDsgYyBSIChhc3N1bWVzIHBhZ2UgaXMgemVybykuXG4vLyAgICAgUHMgPSAxIDUgIC0+IFJlcG9ydCBQcmludGVyIHN0YXR1cyBhcyBDU0kgPyAxIDAgIG4gIChyZWFkeSkuXG4vLyAgICAgb3IgQ1NJID8gMSAxICBuICAobm90IHJlYWR5KS5cbi8vICAgICBQcyA9IDIgNSAgLT4gUmVwb3J0IFVESyBzdGF0dXMgYXMgQ1NJID8gMiAwICBuICAodW5sb2NrZWQpXG4vLyAgICAgb3IgQ1NJID8gMiAxICBuICAobG9ja2VkKS5cbi8vICAgICBQcyA9IDIgNiAgLT4gUmVwb3J0IEtleWJvYXJkIHN0YXR1cyBhc1xuLy8gICBDU0kgPyAyIDcgIDsgIDEgIDsgIDAgIDsgIDAgIG4gIChOb3J0aCBBbWVyaWNhbikuXG4vLyAgIFRoZSBsYXN0IHR3byBwYXJhbWV0ZXJzIGFwcGx5IHRvIFZUNDAwICYgdXAsIGFuZCBkZW5vdGUga2V5LVxuLy8gICBib2FyZCByZWFkeSBhbmQgTEswMSByZXNwZWN0aXZlbHkuXG4vLyAgICAgUHMgPSA1IDMgIC0+IFJlcG9ydCBMb2NhdG9yIHN0YXR1cyBhc1xuLy8gICBDU0kgPyA1IDMgIG4gIExvY2F0b3IgYXZhaWxhYmxlLCBpZiBjb21waWxlZC1pbiwgb3Jcbi8vICAgQ1NJID8gNSAwICBuICBObyBMb2NhdG9yLCBpZiBub3QuXG5UZXJtaW5hbC5wcm90b3R5cGUuZGV2aWNlU3RhdHVzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIGlmICghdGhpcy5wcmVmaXgpIHtcbiAgICBzd2l0Y2ggKHBhcmFtc1swXSkge1xuICAgICAgY2FzZSA1OlxuICAgICAgICAvLyBzdGF0dXMgcmVwb3J0XG4gICAgICAgIHRoaXMuc2VuZCgnXFx4MWJbMG4nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIC8vIGN1cnNvciBwb3NpdGlvblxuICAgICAgICB0aGlzLnNlbmQoJ1xceDFiWydcbiAgICAgICAgICArICh0aGlzLnkgKyAxKVxuICAgICAgICAgICsgJzsnXG4gICAgICAgICAgKyAodGhpcy54ICsgMSlcbiAgICAgICAgICArICdSJyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLnByZWZpeCA9PT0gJz8nKSB7XG4gICAgLy8gbW9kZXJuIHh0ZXJtIGRvZXNudCBzZWVtIHRvXG4gICAgLy8gcmVzcG9uZCB0byBhbnkgb2YgdGhlc2UgZXhjZXB0ID82LCA2LCBhbmQgNVxuICAgIHN3aXRjaCAocGFyYW1zWzBdKSB7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIC8vIGN1cnNvciBwb3NpdGlvblxuICAgICAgICB0aGlzLnNlbmQoJ1xceDFiWz8nXG4gICAgICAgICAgKyAodGhpcy55ICsgMSlcbiAgICAgICAgICArICc7J1xuICAgICAgICAgICsgKHRoaXMueCArIDEpXG4gICAgICAgICAgKyAnUicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIC8vIG5vIHByaW50ZXJcbiAgICAgICAgLy8gdGhpcy5zZW5kKCdcXHgxYls/MTFuJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTpcbiAgICAgICAgLy8gZG9udCBzdXBwb3J0IHVzZXIgZGVmaW5lZCBrZXlzXG4gICAgICAgIC8vIHRoaXMuc2VuZCgnXFx4MWJbPzIxbicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjY6XG4gICAgICAgIC8vIG5vcnRoIGFtZXJpY2FuIGtleWJvYXJkXG4gICAgICAgIC8vIHRoaXMuc2VuZCgnXFx4MWJbPzI3OzE7MDswbicpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNTM6XG4gICAgICAgIC8vIG5vIGRlYyBsb2NhdG9yL21vdXNlXG4gICAgICAgIC8vIHRoaXMuc2VuZCgnXFx4MWJbPzUwbicpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkaXRpb25zXG4gKi9cblxuLy8gQ1NJIFBzIEBcbi8vIEluc2VydCBQcyAoQmxhbmspIENoYXJhY3RlcihzKSAoZGVmYXVsdCA9IDEpIChJQ0gpLlxuVGVybWluYWwucHJvdG90eXBlLmluc2VydENoYXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciBwYXJhbSwgcm93LCBqLCBjaDtcblxuICBwYXJhbSA9IHBhcmFtc1swXTtcbiAgaWYgKHBhcmFtIDwgMSkgcGFyYW0gPSAxO1xuXG4gIHJvdyA9IHRoaXMueSArIHRoaXMueWJhc2U7XG4gIGogPSB0aGlzLng7XG4gIGNoID0gW3RoaXMuZXJhc2VBdHRyKCksICcgJ107IC8vIHh0ZXJtXG5cbiAgd2hpbGUgKHBhcmFtLS0gJiYgaiA8IHRoaXMuY29scykge1xuICAgIHRoaXMubGluZXNbcm93XS5zcGxpY2UoaisrLCAwLCBjaCk7XG4gICAgdGhpcy5saW5lc1tyb3ddLnBvcCgpO1xuICB9XG59O1xuXG4vLyBDU0kgUHMgRVxuLy8gQ3Vyc29yIE5leHQgTGluZSBQcyBUaW1lcyAoZGVmYXVsdCA9IDEpIChDTkwpLlxuLy8gc2FtZSBhcyBDU0kgUHMgQiA/XG5UZXJtaW5hbC5wcm90b3R5cGUuY3Vyc29yTmV4dExpbmUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgdmFyIHBhcmFtID0gcGFyYW1zWzBdO1xuICBpZiAocGFyYW0gPCAxKSBwYXJhbSA9IDE7XG4gIHRoaXMueSArPSBwYXJhbTtcbiAgaWYgKHRoaXMueSA+PSB0aGlzLnJvd3MpIHtcbiAgICB0aGlzLnkgPSB0aGlzLnJvd3MgLSAxO1xuICB9XG4gIHRoaXMueCA9IDA7XG59O1xuXG4vLyBDU0kgUHMgRlxuLy8gQ3Vyc29yIFByZWNlZGluZyBMaW5lIFBzIFRpbWVzIChkZWZhdWx0ID0gMSkgKENOTCkuXG4vLyByZXVzZSBDU0kgUHMgQSA/XG5UZXJtaW5hbC5wcm90b3R5cGUuY3Vyc29yUHJlY2VkaW5nTGluZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgcGFyYW0gPSBwYXJhbXNbMF07XG4gIGlmIChwYXJhbSA8IDEpIHBhcmFtID0gMTtcbiAgdGhpcy55IC09IHBhcmFtO1xuICBpZiAodGhpcy55IDwgMCkgdGhpcy55ID0gMDtcbiAgdGhpcy54ID0gMDtcbn07XG5cbi8vIENTSSBQcyBHXG4vLyBDdXJzb3IgQ2hhcmFjdGVyIEFic29sdXRlICBbY29sdW1uXSAoZGVmYXVsdCA9IFtyb3csMV0pIChDSEEpLlxuVGVybWluYWwucHJvdG90eXBlLmN1cnNvckNoYXJBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgcGFyYW0gPSBwYXJhbXNbMF07XG4gIGlmIChwYXJhbSA8IDEpIHBhcmFtID0gMTtcbiAgdGhpcy54ID0gcGFyYW0gLSAxO1xufTtcblxuLy8gQ1NJIFBzIExcbi8vIEluc2VydCBQcyBMaW5lKHMpIChkZWZhdWx0ID0gMSkgKElMKS5cblRlcm1pbmFsLnByb3RvdHlwZS5pbnNlcnRMaW5lcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgcGFyYW0sIHJvdywgajtcblxuICBwYXJhbSA9IHBhcmFtc1swXTtcbiAgaWYgKHBhcmFtIDwgMSkgcGFyYW0gPSAxO1xuICByb3cgPSB0aGlzLnkgKyB0aGlzLnliYXNlO1xuXG4gIGogPSB0aGlzLnJvd3MgLSAxIC0gdGhpcy5zY3JvbGxCb3R0b207XG4gIGogPSB0aGlzLnJvd3MgLSAxICsgdGhpcy55YmFzZSAtIGogKyAxO1xuXG4gIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgLy8gdGVzdDogZWNobyAtZSAnXFxlWzQ0bVxcZVsxTFxcZVswbSdcbiAgICAvLyBibGFua0xpbmUodHJ1ZSkgLSB4dGVybS9saW51eCBiZWhhdmlvclxuICAgIHRoaXMubGluZXMuc3BsaWNlKHJvdywgMCwgdGhpcy5ibGFua0xpbmUodHJ1ZSkpO1xuICAgIHRoaXMubGluZXMuc3BsaWNlKGosIDEpO1xuICB9XG5cbiAgLy8gdGhpcy5tYXhSYW5nZSgpO1xuICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMueSk7XG4gIHRoaXMudXBkYXRlUmFuZ2UodGhpcy5zY3JvbGxCb3R0b20pO1xufTtcblxuLy8gQ1NJIFBzIE1cbi8vIERlbGV0ZSBQcyBMaW5lKHMpIChkZWZhdWx0ID0gMSkgKERMKS5cblRlcm1pbmFsLnByb3RvdHlwZS5kZWxldGVMaW5lcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgcGFyYW0sIHJvdywgajtcblxuICBwYXJhbSA9IHBhcmFtc1swXTtcbiAgaWYgKHBhcmFtIDwgMSkgcGFyYW0gPSAxO1xuICByb3cgPSB0aGlzLnkgKyB0aGlzLnliYXNlO1xuXG4gIGogPSB0aGlzLnJvd3MgLSAxIC0gdGhpcy5zY3JvbGxCb3R0b207XG4gIGogPSB0aGlzLnJvd3MgLSAxICsgdGhpcy55YmFzZSAtIGo7XG5cbiAgd2hpbGUgKHBhcmFtLS0pIHtcbiAgICAvLyB0ZXN0OiBlY2hvIC1lICdcXGVbNDRtXFxlWzFNXFxlWzBtJ1xuICAgIC8vIGJsYW5rTGluZSh0cnVlKSAtIHh0ZXJtL2xpbnV4IGJlaGF2aW9yXG4gICAgdGhpcy5saW5lcy5zcGxpY2UoaiArIDEsIDAsIHRoaXMuYmxhbmtMaW5lKHRydWUpKTtcbiAgICB0aGlzLmxpbmVzLnNwbGljZShyb3csIDEpO1xuICB9XG5cbiAgLy8gdGhpcy5tYXhSYW5nZSgpO1xuICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMueSk7XG4gIHRoaXMudXBkYXRlUmFuZ2UodGhpcy5zY3JvbGxCb3R0b20pO1xufTtcblxuLy8gQ1NJIFBzIFBcbi8vIERlbGV0ZSBQcyBDaGFyYWN0ZXIocykgKGRlZmF1bHQgPSAxKSAoRENIKS5cblRlcm1pbmFsLnByb3RvdHlwZS5kZWxldGVDaGFycyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgcGFyYW0sIHJvdywgY2g7XG5cbiAgcGFyYW0gPSBwYXJhbXNbMF07XG4gIGlmIChwYXJhbSA8IDEpIHBhcmFtID0gMTtcblxuICByb3cgPSB0aGlzLnkgKyB0aGlzLnliYXNlO1xuICBjaCA9IFt0aGlzLmVyYXNlQXR0cigpLCAnICddOyAvLyB4dGVybVxuXG4gIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgdGhpcy5saW5lc1tyb3ddLnNwbGljZSh0aGlzLngsIDEpO1xuICAgIHRoaXMubGluZXNbcm93XS5wdXNoKGNoKTtcbiAgfVxufTtcblxuLy8gQ1NJIFBzIFhcbi8vIEVyYXNlIFBzIENoYXJhY3RlcihzKSAoZGVmYXVsdCA9IDEpIChFQ0gpLlxuVGVybWluYWwucHJvdG90eXBlLmVyYXNlQ2hhcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgdmFyIHBhcmFtLCByb3csIGosIGNoO1xuXG4gIHBhcmFtID0gcGFyYW1zWzBdO1xuICBpZiAocGFyYW0gPCAxKSBwYXJhbSA9IDE7XG5cbiAgcm93ID0gdGhpcy55ICsgdGhpcy55YmFzZTtcbiAgaiA9IHRoaXMueDtcbiAgY2ggPSBbdGhpcy5lcmFzZUF0dHIoKSwgJyAnXTsgLy8geHRlcm1cblxuICB3aGlsZSAocGFyYW0tLSAmJiBqIDwgdGhpcy5jb2xzKSB7XG4gICAgdGhpcy5saW5lc1tyb3ddW2orK10gPSBjaDtcbiAgfVxufTtcblxuLy8gQ1NJIFBtIGAgIENoYXJhY3RlciBQb3NpdGlvbiBBYnNvbHV0ZVxuLy8gICBbY29sdW1uXSAoZGVmYXVsdCA9IFtyb3csMV0pIChIUEEpLlxuVGVybWluYWwucHJvdG90eXBlLmNoYXJQb3NBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgcGFyYW0gPSBwYXJhbXNbMF07XG4gIGlmIChwYXJhbSA8IDEpIHBhcmFtID0gMTtcbiAgdGhpcy54ID0gcGFyYW0gLSAxO1xuICBpZiAodGhpcy54ID49IHRoaXMuY29scykge1xuICAgIHRoaXMueCA9IHRoaXMuY29scyAtIDE7XG4gIH1cbn07XG5cbi8vIDE0MSA2MSBhICogSFBSIC1cbi8vIEhvcml6b250YWwgUG9zaXRpb24gUmVsYXRpdmVcbi8vIHJldXNlIENTSSBQcyBDID9cblRlcm1pbmFsLnByb3RvdHlwZS5IUG9zaXRpb25SZWxhdGl2ZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgcGFyYW0gPSBwYXJhbXNbMF07XG4gIGlmIChwYXJhbSA8IDEpIHBhcmFtID0gMTtcbiAgdGhpcy54ICs9IHBhcmFtO1xuICBpZiAodGhpcy54ID49IHRoaXMuY29scykge1xuICAgIHRoaXMueCA9IHRoaXMuY29scyAtIDE7XG4gIH1cbn07XG5cbi8vIENTSSBQcyBjICBTZW5kIERldmljZSBBdHRyaWJ1dGVzIChQcmltYXJ5IERBKS5cbi8vICAgICBQcyA9IDAgIG9yIG9taXR0ZWQgLT4gcmVxdWVzdCBhdHRyaWJ1dGVzIGZyb20gdGVybWluYWwuICBUaGVcbi8vICAgICByZXNwb25zZSBkZXBlbmRzIG9uIHRoZSBkZWNUZXJtaW5hbElEIHJlc291cmNlIHNldHRpbmcuXG4vLyAgICAgLT4gQ1NJID8gMSA7IDIgYyAgKGBgVlQxMDAgd2l0aCBBZHZhbmNlZCBWaWRlbyBPcHRpb24nJylcbi8vICAgICAtPiBDU0kgPyAxIDsgMCBjICAoYGBWVDEwMSB3aXRoIE5vIE9wdGlvbnMnJylcbi8vICAgICAtPiBDU0kgPyA2IGMgIChgYFZUMTAyJycpXG4vLyAgICAgLT4gQ1NJID8gNiAwIDsgMSA7IDIgOyA2IDsgOCA7IDkgOyAxIDUgOyBjICAoYGBWVDIyMCcnKVxuLy8gICBUaGUgVlQxMDAtc3R5bGUgcmVzcG9uc2UgcGFyYW1ldGVycyBkbyBub3QgbWVhbiBhbnl0aGluZyBieVxuLy8gICB0aGVtc2VsdmVzLiAgVlQyMjAgcGFyYW1ldGVycyBkbywgdGVsbGluZyB0aGUgaG9zdCB3aGF0IGZlYS1cbi8vICAgdHVyZXMgdGhlIHRlcm1pbmFsIHN1cHBvcnRzOlxuLy8gICAgIFBzID0gMSAgLT4gMTMyLWNvbHVtbnMuXG4vLyAgICAgUHMgPSAyICAtPiBQcmludGVyLlxuLy8gICAgIFBzID0gNiAgLT4gU2VsZWN0aXZlIGVyYXNlLlxuLy8gICAgIFBzID0gOCAgLT4gVXNlci1kZWZpbmVkIGtleXMuXG4vLyAgICAgUHMgPSA5ICAtPiBOYXRpb25hbCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgc2V0cy5cbi8vICAgICBQcyA9IDEgNSAgLT4gVGVjaG5pY2FsIGNoYXJhY3RlcnMuXG4vLyAgICAgUHMgPSAyIDIgIC0+IEFOU0kgY29sb3IsIGUuZy4sIFZUNTI1LlxuLy8gICAgIFBzID0gMiA5ICAtPiBBTlNJIHRleHQgbG9jYXRvciAoaS5lLiwgREVDIExvY2F0b3IgbW9kZSkuXG4vLyBDU0kgPiBQcyBjXG4vLyAgIFNlbmQgRGV2aWNlIEF0dHJpYnV0ZXMgKFNlY29uZGFyeSBEQSkuXG4vLyAgICAgUHMgPSAwICBvciBvbWl0dGVkIC0+IHJlcXVlc3QgdGhlIHRlcm1pbmFsJ3MgaWRlbnRpZmljYXRpb25cbi8vICAgICBjb2RlLiAgVGhlIHJlc3BvbnNlIGRlcGVuZHMgb24gdGhlIGRlY1Rlcm1pbmFsSUQgcmVzb3VyY2Ugc2V0LVxuLy8gICAgIHRpbmcuICBJdCBzaG91bGQgYXBwbHkgb25seSB0byBWVDIyMCBhbmQgdXAsIGJ1dCB4dGVybSBleHRlbmRzXG4vLyAgICAgdGhpcyB0byBWVDEwMC5cbi8vICAgICAtPiBDU0kgID4gUHAgOyBQdiA7IFBjIGNcbi8vICAgd2hlcmUgUHAgZGVub3RlcyB0aGUgdGVybWluYWwgdHlwZVxuLy8gICAgIFBwID0gMCAgLT4gYGBWVDEwMCcnLlxuLy8gICAgIFBwID0gMSAgLT4gYGBWVDIyMCcnLlxuLy8gICBhbmQgUHYgaXMgdGhlIGZpcm13YXJlIHZlcnNpb24gKGZvciB4dGVybSwgdGhpcyB3YXMgb3JpZ2luYWxseVxuLy8gICB0aGUgWEZyZWU4NiBwYXRjaCBudW1iZXIsIHN0YXJ0aW5nIHdpdGggOTUpLiAgSW4gYSBERUMgdGVybWktXG4vLyAgIG5hbCwgUGMgaW5kaWNhdGVzIHRoZSBST00gY2FydHJpZGdlIHJlZ2lzdHJhdGlvbiBudW1iZXIgYW5kIGlzXG4vLyAgIGFsd2F5cyB6ZXJvLlxuLy8gTW9yZSBpbmZvcm1hdGlvbjpcbi8vICAgeHRlcm0vY2hhcnByb2MuYyAtIGxpbmUgMjAxMiwgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4vLyAgIHZpbSByZXNwb25kcyB3aXRoIF5bWz8wYyBvciBeW1s/MWMgYWZ0ZXIgdGhlIHRlcm1pbmFsJ3MgcmVzcG9uc2UgKD8pXG5UZXJtaW5hbC5wcm90b3R5cGUuc2VuZERldmljZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgaWYgKHBhcmFtc1swXSA+IDApIHJldHVybjtcblxuICBpZiAoIXRoaXMucHJlZml4KSB7XG4gICAgaWYgKHRoaXMuaXMoJ3h0ZXJtJylcbiAgICAgICAgfHwgdGhpcy5pcygncnh2dC11bmljb2RlJylcbiAgICAgICAgfHwgdGhpcy5pcygnc2NyZWVuJykpIHtcbiAgICAgIHRoaXMuc2VuZCgnXFx4MWJbPzE7MmMnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXMoJ2xpbnV4JykpIHtcbiAgICAgIHRoaXMuc2VuZCgnXFx4MWJbPzZjJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMucHJlZml4ID09PSAnPicpIHtcbiAgICAvLyB4dGVybSBhbmQgdXJ4dnRcbiAgICAvLyBzZWVtIHRvIHNwaXQgdGhpc1xuICAgIC8vIG91dCBhcm91bmQgfjM3MCB0aW1lcyAoPykuXG4gICAgaWYgKHRoaXMuaXMoJ3h0ZXJtJykpIHtcbiAgICAgIHRoaXMuc2VuZCgnXFx4MWJbPjA7Mjc2OzBjJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzKCdyeHZ0LXVuaWNvZGUnKSkge1xuICAgICAgdGhpcy5zZW5kKCdcXHgxYls+ODU7OTU7MGMnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXMoJ2xpbnV4JykpIHtcbiAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgYnkgbGludXggY29uc29sZS5cbiAgICAgIC8vIGxpbnV4IGNvbnNvbGUgZWNob2VzIHBhcmFtZXRlcnMuXG4gICAgICB0aGlzLnNlbmQocGFyYW1zWzBdICsgJ2MnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXMoJ3NjcmVlbicpKSB7XG4gICAgICB0aGlzLnNlbmQoJ1xceDFiWz44Mzs0MDAwMzswYycpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gQ1NJIFBtIGRcbi8vIExpbmUgUG9zaXRpb24gQWJzb2x1dGUgIFtyb3ddIChkZWZhdWx0ID0gWzEsY29sdW1uXSkgKFZQQSkuXG5UZXJtaW5hbC5wcm90b3R5cGUubGluZVBvc0Fic29sdXRlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciBwYXJhbSA9IHBhcmFtc1swXTtcbiAgaWYgKHBhcmFtIDwgMSkgcGFyYW0gPSAxO1xuICB0aGlzLnkgPSBwYXJhbSAtIDE7XG4gIGlmICh0aGlzLnkgPj0gdGhpcy5yb3dzKSB7XG4gICAgdGhpcy55ID0gdGhpcy5yb3dzIC0gMTtcbiAgfVxufTtcblxuLy8gMTQ1IDY1IGUgKiBWUFIgLSBWZXJ0aWNhbCBQb3NpdGlvbiBSZWxhdGl2ZVxuLy8gcmV1c2UgQ1NJIFBzIEIgP1xuVGVybWluYWwucHJvdG90eXBlLlZQb3NpdGlvblJlbGF0aXZlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciBwYXJhbSA9IHBhcmFtc1swXTtcbiAgaWYgKHBhcmFtIDwgMSkgcGFyYW0gPSAxO1xuICB0aGlzLnkgKz0gcGFyYW07XG4gIGlmICh0aGlzLnkgPj0gdGhpcy5yb3dzKSB7XG4gICAgdGhpcy55ID0gdGhpcy5yb3dzIC0gMTtcbiAgfVxufTtcblxuLy8gQ1NJIFBzIDsgUHMgZlxuLy8gICBIb3Jpem9udGFsIGFuZCBWZXJ0aWNhbCBQb3NpdGlvbiBbcm93O2NvbHVtbl0gKGRlZmF1bHQgPVxuLy8gICBbMSwxXSkgKEhWUCkuXG5UZXJtaW5hbC5wcm90b3R5cGUuSFZQb3NpdGlvbiA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBpZiAocGFyYW1zWzBdIDwgMSkgcGFyYW1zWzBdID0gMTtcbiAgaWYgKHBhcmFtc1sxXSA8IDEpIHBhcmFtc1sxXSA9IDE7XG5cbiAgdGhpcy55ID0gcGFyYW1zWzBdIC0gMTtcbiAgaWYgKHRoaXMueSA+PSB0aGlzLnJvd3MpIHtcbiAgICB0aGlzLnkgPSB0aGlzLnJvd3MgLSAxO1xuICB9XG5cbiAgdGhpcy54ID0gcGFyYW1zWzFdIC0gMTtcbiAgaWYgKHRoaXMueCA+PSB0aGlzLmNvbHMpIHtcbiAgICB0aGlzLnggPSB0aGlzLmNvbHMgLSAxO1xuICB9XG59O1xuXG4vLyBDU0kgUG0gaCAgU2V0IE1vZGUgKFNNKS5cbi8vICAgICBQcyA9IDIgIC0+IEtleWJvYXJkIEFjdGlvbiBNb2RlIChBTSkuXG4vLyAgICAgUHMgPSA0ICAtPiBJbnNlcnQgTW9kZSAoSVJNKS5cbi8vICAgICBQcyA9IDEgMiAgLT4gU2VuZC9yZWNlaXZlIChTUk0pLlxuLy8gICAgIFBzID0gMiAwICAtPiBBdXRvbWF0aWMgTmV3bGluZSAoTE5NKS5cbi8vIENTSSA/IFBtIGhcbi8vICAgREVDIFByaXZhdGUgTW9kZSBTZXQgKERFQ1NFVCkuXG4vLyAgICAgUHMgPSAxICAtPiBBcHBsaWNhdGlvbiBDdXJzb3IgS2V5cyAoREVDQ0tNKS5cbi8vICAgICBQcyA9IDIgIC0+IERlc2lnbmF0ZSBVU0FTQ0lJIGZvciBjaGFyYWN0ZXIgc2V0cyBHMC1HM1xuLy8gICAgIChERUNBTk0pLCBhbmQgc2V0IFZUMTAwIG1vZGUuXG4vLyAgICAgUHMgPSAzICAtPiAxMzIgQ29sdW1uIE1vZGUgKERFQ0NPTE0pLlxuLy8gICAgIFBzID0gNCAgLT4gU21vb3RoIChTbG93KSBTY3JvbGwgKERFQ1NDTE0pLlxuLy8gICAgIFBzID0gNSAgLT4gUmV2ZXJzZSBWaWRlbyAoREVDU0NOTSkuXG4vLyAgICAgUHMgPSA2ICAtPiBPcmlnaW4gTW9kZSAoREVDT00pLlxuLy8gICAgIFBzID0gNyAgLT4gV3JhcGFyb3VuZCBNb2RlIChERUNBV00pLlxuLy8gICAgIFBzID0gOCAgLT4gQXV0by1yZXBlYXQgS2V5cyAoREVDQVJNKS5cbi8vICAgICBQcyA9IDkgIC0+IFNlbmQgTW91c2UgWCAmIFkgb24gYnV0dG9uIHByZXNzLiAgU2VlIHRoZSBzZWMtXG4vLyAgICAgdGlvbiBNb3VzZSBUcmFja2luZy5cbi8vICAgICBQcyA9IDEgMCAgLT4gU2hvdyB0b29sYmFyIChyeHZ0KS5cbi8vICAgICBQcyA9IDEgMiAgLT4gU3RhcnQgQmxpbmtpbmcgQ3Vyc29yIChhdHQ2MTApLlxuLy8gICAgIFBzID0gMSA4ICAtPiBQcmludCBmb3JtIGZlZWQgKERFQ1BGRikuXG4vLyAgICAgUHMgPSAxIDkgIC0+IFNldCBwcmludCBleHRlbnQgdG8gZnVsbCBzY3JlZW4gKERFQ1BFWCkuXG4vLyAgICAgUHMgPSAyIDUgIC0+IFNob3cgQ3Vyc29yIChERUNUQ0VNKS5cbi8vICAgICBQcyA9IDMgMCAgLT4gU2hvdyBzY3JvbGxiYXIgKHJ4dnQpLlxuLy8gICAgIFBzID0gMyA1ICAtPiBFbmFibGUgZm9udC1zaGlmdGluZyBmdW5jdGlvbnMgKHJ4dnQpLlxuLy8gICAgIFBzID0gMyA4ICAtPiBFbnRlciBUZWt0cm9uaXggTW9kZSAoREVDVEVLKS5cbi8vICAgICBQcyA9IDQgMCAgLT4gQWxsb3cgODAgLT4gMTMyIE1vZGUuXG4vLyAgICAgUHMgPSA0IDEgIC0+IG1vcmUoMSkgZml4IChzZWUgY3Vyc2VzIHJlc291cmNlKS5cbi8vICAgICBQcyA9IDQgMiAgLT4gRW5hYmxlIE5hdGlvbiBSZXBsYWNlbWVudCBDaGFyYWN0ZXIgc2V0cyAoREVDTi1cbi8vICAgICBSQ00pLlxuLy8gICAgIFBzID0gNCA0ICAtPiBUdXJuIE9uIE1hcmdpbiBCZWxsLlxuLy8gICAgIFBzID0gNCA1ICAtPiBSZXZlcnNlLXdyYXBhcm91bmQgTW9kZS5cbi8vICAgICBQcyA9IDQgNiAgLT4gU3RhcnQgTG9nZ2luZy4gIFRoaXMgaXMgbm9ybWFsbHkgZGlzYWJsZWQgYnkgYVxuLy8gICAgIGNvbXBpbGUtdGltZSBvcHRpb24uXG4vLyAgICAgUHMgPSA0IDcgIC0+IFVzZSBBbHRlcm5hdGUgU2NyZWVuIEJ1ZmZlci4gIChUaGlzIG1heSBiZSBkaXMtXG4vLyAgICAgYWJsZWQgYnkgdGhlIHRpdGVJbmhpYml0IHJlc291cmNlKS5cbi8vICAgICBQcyA9IDYgNiAgLT4gQXBwbGljYXRpb24ga2V5cGFkIChERUNOS00pLlxuLy8gICAgIFBzID0gNiA3ICAtPiBCYWNrYXJyb3cga2V5IHNlbmRzIGJhY2tzcGFjZSAoREVDQktNKS5cbi8vICAgICBQcyA9IDEgMCAwIDAgIC0+IFNlbmQgTW91c2UgWCAmIFkgb24gYnV0dG9uIHByZXNzIGFuZFxuLy8gICAgIHJlbGVhc2UuICBTZWUgdGhlIHNlY3Rpb24gTW91c2UgVHJhY2tpbmcuXG4vLyAgICAgUHMgPSAxIDAgMCAxICAtPiBVc2UgSGlsaXRlIE1vdXNlIFRyYWNraW5nLlxuLy8gICAgIFBzID0gMSAwIDAgMiAgLT4gVXNlIENlbGwgTW90aW9uIE1vdXNlIFRyYWNraW5nLlxuLy8gICAgIFBzID0gMSAwIDAgMyAgLT4gVXNlIEFsbCBNb3Rpb24gTW91c2UgVHJhY2tpbmcuXG4vLyAgICAgUHMgPSAxIDAgMCA0ICAtPiBTZW5kIEZvY3VzSW4vRm9jdXNPdXQgZXZlbnRzLlxuLy8gICAgIFBzID0gMSAwIDAgNSAgLT4gRW5hYmxlIEV4dGVuZGVkIE1vdXNlIE1vZGUuXG4vLyAgICAgUHMgPSAxIDAgMSAwICAtPiBTY3JvbGwgdG8gYm90dG9tIG9uIHR0eSBvdXRwdXQgKHJ4dnQpLlxuLy8gICAgIFBzID0gMSAwIDEgMSAgLT4gU2Nyb2xsIHRvIGJvdHRvbSBvbiBrZXkgcHJlc3MgKHJ4dnQpLlxuLy8gICAgIFBzID0gMSAwIDMgNCAgLT4gSW50ZXJwcmV0IFwibWV0YVwiIGtleSwgc2V0cyBlaWdodGggYml0LlxuLy8gICAgIChlbmFibGVzIHRoZSBlaWdodEJpdElucHV0IHJlc291cmNlKS5cbi8vICAgICBQcyA9IDEgMCAzIDUgIC0+IEVuYWJsZSBzcGVjaWFsIG1vZGlmaWVycyBmb3IgQWx0IGFuZCBOdW0tXG4vLyAgICAgTG9jayBrZXlzLiAgKFRoaXMgZW5hYmxlcyB0aGUgbnVtTG9jayByZXNvdXJjZSkuXG4vLyAgICAgUHMgPSAxIDAgMyA2ICAtPiBTZW5kIEVTQyAgIHdoZW4gTWV0YSBtb2RpZmllcyBhIGtleS4gIChUaGlzXG4vLyAgICAgZW5hYmxlcyB0aGUgbWV0YVNlbmRzRXNjYXBlIHJlc291cmNlKS5cbi8vICAgICBQcyA9IDEgMCAzIDcgIC0+IFNlbmQgREVMIGZyb20gdGhlIGVkaXRpbmcta2V5cGFkIERlbGV0ZVxuLy8gICAgIGtleS5cbi8vICAgICBQcyA9IDEgMCAzIDkgIC0+IFNlbmQgRVNDICB3aGVuIEFsdCBtb2RpZmllcyBhIGtleS4gIChUaGlzXG4vLyAgICAgZW5hYmxlcyB0aGUgYWx0U2VuZHNFc2NhcGUgcmVzb3VyY2UpLlxuLy8gICAgIFBzID0gMSAwIDQgMCAgLT4gS2VlcCBzZWxlY3Rpb24gZXZlbiBpZiBub3QgaGlnaGxpZ2h0ZWQuXG4vLyAgICAgKFRoaXMgZW5hYmxlcyB0aGUga2VlcFNlbGVjdGlvbiByZXNvdXJjZSkuXG4vLyAgICAgUHMgPSAxIDAgNCAxICAtPiBVc2UgdGhlIENMSVBCT0FSRCBzZWxlY3Rpb24uICAoVGhpcyBlbmFibGVzXG4vLyAgICAgdGhlIHNlbGVjdFRvQ2xpcGJvYXJkIHJlc291cmNlKS5cbi8vICAgICBQcyA9IDEgMCA0IDIgIC0+IEVuYWJsZSBVcmdlbmN5IHdpbmRvdyBtYW5hZ2VyIGhpbnQgd2hlblxuLy8gICAgIENvbnRyb2wtRyBpcyByZWNlaXZlZC4gIChUaGlzIGVuYWJsZXMgdGhlIGJlbGxJc1VyZ2VudFxuLy8gICAgIHJlc291cmNlKS5cbi8vICAgICBQcyA9IDEgMCA0IDMgIC0+IEVuYWJsZSByYWlzaW5nIG9mIHRoZSB3aW5kb3cgd2hlbiBDb250cm9sLUdcbi8vICAgICBpcyByZWNlaXZlZC4gIChlbmFibGVzIHRoZSBwb3BPbkJlbGwgcmVzb3VyY2UpLlxuLy8gICAgIFBzID0gMSAwIDQgNyAgLT4gVXNlIEFsdGVybmF0ZSBTY3JlZW4gQnVmZmVyLiAgKFRoaXMgbWF5IGJlXG4vLyAgICAgZGlzYWJsZWQgYnkgdGhlIHRpdGVJbmhpYml0IHJlc291cmNlKS5cbi8vICAgICBQcyA9IDEgMCA0IDggIC0+IFNhdmUgY3Vyc29yIGFzIGluIERFQ1NDLiAgKFRoaXMgbWF5IGJlIGRpcy1cbi8vICAgICBhYmxlZCBieSB0aGUgdGl0ZUluaGliaXQgcmVzb3VyY2UpLlxuLy8gICAgIFBzID0gMSAwIDQgOSAgLT4gU2F2ZSBjdXJzb3IgYXMgaW4gREVDU0MgYW5kIHVzZSBBbHRlcm5hdGVcbi8vICAgICBTY3JlZW4gQnVmZmVyLCBjbGVhcmluZyBpdCBmaXJzdC4gIChUaGlzIG1heSBiZSBkaXNhYmxlZCBieVxuLy8gICAgIHRoZSB0aXRlSW5oaWJpdCByZXNvdXJjZSkuICBUaGlzIGNvbWJpbmVzIHRoZSBlZmZlY3RzIG9mIHRoZSAxXG4vLyAgICAgMCA0IDcgIGFuZCAxIDAgNCA4ICBtb2Rlcy4gIFVzZSB0aGlzIHdpdGggdGVybWluZm8tYmFzZWRcbi8vICAgICBhcHBsaWNhdGlvbnMgcmF0aGVyIHRoYW4gdGhlIDQgNyAgbW9kZS5cbi8vICAgICBQcyA9IDEgMCA1IDAgIC0+IFNldCB0ZXJtaW5mby90ZXJtY2FwIGZ1bmN0aW9uLWtleSBtb2RlLlxuLy8gICAgIFBzID0gMSAwIDUgMSAgLT4gU2V0IFN1biBmdW5jdGlvbi1rZXkgbW9kZS5cbi8vICAgICBQcyA9IDEgMCA1IDIgIC0+IFNldCBIUCBmdW5jdGlvbi1rZXkgbW9kZS5cbi8vICAgICBQcyA9IDEgMCA1IDMgIC0+IFNldCBTQ08gZnVuY3Rpb24ta2V5IG1vZGUuXG4vLyAgICAgUHMgPSAxIDAgNiAwICAtPiBTZXQgbGVnYWN5IGtleWJvYXJkIGVtdWxhdGlvbiAoWDExUjYpLlxuLy8gICAgIFBzID0gMSAwIDYgMSAgLT4gU2V0IFZUMjIwIGtleWJvYXJkIGVtdWxhdGlvbi5cbi8vICAgICBQcyA9IDIgMCAwIDQgIC0+IFNldCBicmFja2V0ZWQgcGFzdGUgbW9kZS5cbi8vIE1vZGVzOlxuLy8gICBodHRwOi8vdnQxMDAubmV0L2RvY3MvdnQyMjAtcm0vY2hhcHRlcjQuaHRtbFxuVGVybWluYWwucHJvdG90eXBlLnNldE1vZGUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGwgPSBwYXJhbXMubGVuZ3RoXG4gICAgICAsIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuc2V0TW9kZShwYXJhbXNbaV0pO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghdGhpcy5wcmVmaXgpIHtcbiAgICBzd2l0Y2ggKHBhcmFtcykge1xuICAgICAgY2FzZSA0OlxuICAgICAgICB0aGlzLmluc2VydE1vZGUgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjA6XG4gICAgICAgIC8vdGhpcy5jb252ZXJ0RW9sID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2UgaWYgKHRoaXMucHJlZml4ID09PSAnPycpIHtcbiAgICBzd2l0Y2ggKHBhcmFtcykge1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uQ3Vyc29yID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHRoaXMuc2V0Z0NoYXJzZXQoMCwgVGVybWluYWwuY2hhcnNldHMuVVMpO1xuICAgICAgICB0aGlzLnNldGdDaGFyc2V0KDEsIFRlcm1pbmFsLmNoYXJzZXRzLlVTKTtcbiAgICAgICAgdGhpcy5zZXRnQ2hhcnNldCgyLCBUZXJtaW5hbC5jaGFyc2V0cy5VUyk7XG4gICAgICAgIHRoaXMuc2V0Z0NoYXJzZXQoMywgVGVybWluYWwuY2hhcnNldHMuVVMpO1xuICAgICAgICAvLyBzZXQgVlQxMDAgbW9kZSBoZXJlXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOiAvLyAxMzIgY29sIG1vZGVcbiAgICAgICAgdGhpcy5zYXZlZENvbHMgPSB0aGlzLmNvbHM7XG4gICAgICAgIHRoaXMucmVzaXplKDEzMiwgdGhpcy5yb3dzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIHRoaXMub3JpZ2luTW9kZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA3OlxuICAgICAgICB0aGlzLndyYXBhcm91bmRNb2RlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEyOlxuICAgICAgICAvLyB0aGlzLmN1cnNvckJsaW5rID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDY2OlxuICAgICAgICB0aGlzLmxvZygnU2VyaWFsIHBvcnQgcmVxdWVzdGVkIGFwcGxpY2F0aW9uIGtleXBhZC4nKTtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbktleXBhZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5OiAvLyBYMTAgTW91c2VcbiAgICAgICAgLy8gbm8gcmVsZWFzZSwgbm8gbW90aW9uLCBubyB3aGVlbCwgbm8gbW9kaWZpZXJzLlxuICAgICAgY2FzZSAxMDAwOiAvLyB2dDIwMCBtb3VzZVxuICAgICAgICAvLyBubyBtb3Rpb24uXG4gICAgICAgIC8vIG5vIG1vZGlmaWVycywgZXhjZXB0IGNvbnRyb2wgb24gdGhlIHdoZWVsLlxuICAgICAgY2FzZSAxMDAyOiAvLyBidXR0b24gZXZlbnQgbW91c2VcbiAgICAgIGNhc2UgMTAwMzogLy8gYW55IGV2ZW50IG1vdXNlXG4gICAgICAgIC8vIGFueSBldmVudCAtIHNlbmRzIG1vdGlvbiBldmVudHMsXG4gICAgICAgIC8vIGV2ZW4gaWYgdGhlcmUgaXMgbm8gYnV0dG9uIGhlbGQgZG93bi5cbiAgICAgICAgdGhpcy54MTBNb3VzZSA9IHBhcmFtcyA9PT0gOTtcbiAgICAgICAgdGhpcy52dDIwME1vdXNlID0gcGFyYW1zID09PSAxMDAwO1xuICAgICAgICB0aGlzLm5vcm1hbE1vdXNlID0gcGFyYW1zID4gMTAwMDtcbiAgICAgICAgdGhpcy5tb3VzZUV2ZW50cyA9IHRydWU7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG4gICAgICAgIHRoaXMubG9nKCdCaW5kaW5nIHRvIG1vdXNlIGV2ZW50cy4nKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwMDQ6IC8vIHNlbmQgZm9jdXNpbi9mb2N1c291dCBldmVudHNcbiAgICAgICAgLy8gZm9jdXNpbjogXltbSVxuICAgICAgICAvLyBmb2N1c291dDogXltbT1xuICAgICAgICB0aGlzLnNlbmRGb2N1cyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDA1OiAvLyB1dGY4IGV4dCBtb2RlIG1vdXNlXG4gICAgICAgIHRoaXMudXRmTW91c2UgPSB0cnVlO1xuICAgICAgICAvLyBmb3Igd2lkZSB0ZXJtaW5hbHNcbiAgICAgICAgLy8gc2ltcGx5IGVuY29kZXMgbGFyZ2UgdmFsdWVzIGFzIHV0ZjggY2hhcmFjdGVyc1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwNjogLy8gc2dyIGV4dCBtb2RlIG1vdXNlXG4gICAgICAgIHRoaXMuc2dyTW91c2UgPSB0cnVlO1xuICAgICAgICAvLyBmb3Igd2lkZSB0ZXJtaW5hbHNcbiAgICAgICAgLy8gZG9lcyBub3QgYWRkIDMyIHRvIGZpZWxkc1xuICAgICAgICAvLyBwcmVzczogXltbPGI7eDt5TVxuICAgICAgICAvLyByZWxlYXNlOiBeW1s8Yjt4O3ltXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDE1OiAvLyB1cnh2dCBleHQgbW9kZSBtb3VzZVxuICAgICAgICB0aGlzLnVyeHZ0TW91c2UgPSB0cnVlO1xuICAgICAgICAvLyBmb3Igd2lkZSB0ZXJtaW5hbHNcbiAgICAgICAgLy8gbnVtYmVycyBmb3IgZmllbGRzXG4gICAgICAgIC8vIHByZXNzOiBeW1tiO3g7eU1cbiAgICAgICAgLy8gbW90aW9uOiBeW1tiO3g7eVRcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI1OiAvLyBzaG93IGN1cnNvclxuICAgICAgICB0aGlzLmN1cnNvckhpZGRlbiA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA0OTogLy8gYWx0IHNjcmVlbiBidWZmZXIgY3Vyc29yXG4gICAgICAgIC8vdGhpcy5zYXZlQ3Vyc29yKCk7XG4gICAgICAgIDsgLy8gRkFMTC1USFJPVUdIXG4gICAgICBjYXNlIDQ3OiAvLyBhbHQgc2NyZWVuIGJ1ZmZlclxuICAgICAgY2FzZSAxMDQ3OiAvLyBhbHQgc2NyZWVuIGJ1ZmZlclxuICAgICAgICBpZiAoIXRoaXMubm9ybWFsKSB7XG4gICAgICAgICAgdmFyIG5vcm1hbCA9IHtcbiAgICAgICAgICAgIGxpbmVzOiB0aGlzLmxpbmVzLFxuICAgICAgICAgICAgeWJhc2U6IHRoaXMueWJhc2UsXG4gICAgICAgICAgICB5ZGlzcDogdGhpcy55ZGlzcCxcbiAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgIHk6IHRoaXMueSxcbiAgICAgICAgICAgIHNjcm9sbFRvcDogdGhpcy5zY3JvbGxUb3AsXG4gICAgICAgICAgICBzY3JvbGxCb3R0b206IHRoaXMuc2Nyb2xsQm90dG9tLFxuICAgICAgICAgICAgdGFiczogdGhpcy50YWJzXG4gICAgICAgICAgICAvLyBYWFggc2F2ZSBjaGFyc2V0KHMpIGhlcmU/XG4gICAgICAgICAgICAvLyBjaGFyc2V0OiB0aGlzLmNoYXJzZXQsXG4gICAgICAgICAgICAvLyBnbGV2ZWw6IHRoaXMuZ2xldmVsLFxuICAgICAgICAgICAgLy8gY2hhcnNldHM6IHRoaXMuY2hhcnNldHNcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcbiAgICAgICAgICB0aGlzLnNob3dDdXJzb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn07XG5cbi8vIENTSSBQbSBsICBSZXNldCBNb2RlIChSTSkuXG4vLyAgICAgUHMgPSAyICAtPiBLZXlib2FyZCBBY3Rpb24gTW9kZSAoQU0pLlxuLy8gICAgIFBzID0gNCAgLT4gUmVwbGFjZSBNb2RlIChJUk0pLlxuLy8gICAgIFBzID0gMSAyICAtPiBTZW5kL3JlY2VpdmUgKFNSTSkuXG4vLyAgICAgUHMgPSAyIDAgIC0+IE5vcm1hbCBMaW5lZmVlZCAoTE5NKS5cbi8vIENTSSA/IFBtIGxcbi8vICAgREVDIFByaXZhdGUgTW9kZSBSZXNldCAoREVDUlNUKS5cbi8vICAgICBQcyA9IDEgIC0+IE5vcm1hbCBDdXJzb3IgS2V5cyAoREVDQ0tNKS5cbi8vICAgICBQcyA9IDIgIC0+IERlc2lnbmF0ZSBWVDUyIG1vZGUgKERFQ0FOTSkuXG4vLyAgICAgUHMgPSAzICAtPiA4MCBDb2x1bW4gTW9kZSAoREVDQ09MTSkuXG4vLyAgICAgUHMgPSA0ICAtPiBKdW1wIChGYXN0KSBTY3JvbGwgKERFQ1NDTE0pLlxuLy8gICAgIFBzID0gNSAgLT4gTm9ybWFsIFZpZGVvIChERUNTQ05NKS5cbi8vICAgICBQcyA9IDYgIC0+IE5vcm1hbCBDdXJzb3IgTW9kZSAoREVDT00pLlxuLy8gICAgIFBzID0gNyAgLT4gTm8gV3JhcGFyb3VuZCBNb2RlIChERUNBV00pLlxuLy8gICAgIFBzID0gOCAgLT4gTm8gQXV0by1yZXBlYXQgS2V5cyAoREVDQVJNKS5cbi8vICAgICBQcyA9IDkgIC0+IERvbid0IHNlbmQgTW91c2UgWCAmIFkgb24gYnV0dG9uIHByZXNzLlxuLy8gICAgIFBzID0gMSAwICAtPiBIaWRlIHRvb2xiYXIgKHJ4dnQpLlxuLy8gICAgIFBzID0gMSAyICAtPiBTdG9wIEJsaW5raW5nIEN1cnNvciAoYXR0NjEwKS5cbi8vICAgICBQcyA9IDEgOCAgLT4gRG9uJ3QgcHJpbnQgZm9ybSBmZWVkIChERUNQRkYpLlxuLy8gICAgIFBzID0gMSA5ICAtPiBMaW1pdCBwcmludCB0byBzY3JvbGxpbmcgcmVnaW9uIChERUNQRVgpLlxuLy8gICAgIFBzID0gMiA1ICAtPiBIaWRlIEN1cnNvciAoREVDVENFTSkuXG4vLyAgICAgUHMgPSAzIDAgIC0+IERvbid0IHNob3cgc2Nyb2xsYmFyIChyeHZ0KS5cbi8vICAgICBQcyA9IDMgNSAgLT4gRGlzYWJsZSBmb250LXNoaWZ0aW5nIGZ1bmN0aW9ucyAocnh2dCkuXG4vLyAgICAgUHMgPSA0IDAgIC0+IERpc2FsbG93IDgwIC0+IDEzMiBNb2RlLlxuLy8gICAgIFBzID0gNCAxICAtPiBObyBtb3JlKDEpIGZpeCAoc2VlIGN1cnNlcyByZXNvdXJjZSkuXG4vLyAgICAgUHMgPSA0IDIgIC0+IERpc2FibGUgTmF0aW9uIFJlcGxhY2VtZW50IENoYXJhY3RlciBzZXRzIChERUMtXG4vLyAgICAgTlJDTSkuXG4vLyAgICAgUHMgPSA0IDQgIC0+IFR1cm4gT2ZmIE1hcmdpbiBCZWxsLlxuLy8gICAgIFBzID0gNCA1ICAtPiBObyBSZXZlcnNlLXdyYXBhcm91bmQgTW9kZS5cbi8vICAgICBQcyA9IDQgNiAgLT4gU3RvcCBMb2dnaW5nLiAgKFRoaXMgaXMgbm9ybWFsbHkgZGlzYWJsZWQgYnkgYVxuLy8gICAgIGNvbXBpbGUtdGltZSBvcHRpb24pLlxuLy8gICAgIFBzID0gNCA3ICAtPiBVc2UgTm9ybWFsIFNjcmVlbiBCdWZmZXIuXG4vLyAgICAgUHMgPSA2IDYgIC0+IE51bWVyaWMga2V5cGFkIChERUNOS00pLlxuLy8gICAgIFBzID0gNiA3ICAtPiBCYWNrYXJyb3cga2V5IHNlbmRzIGRlbGV0ZSAoREVDQktNKS5cbi8vICAgICBQcyA9IDEgMCAwIDAgIC0+IERvbid0IHNlbmQgTW91c2UgWCAmIFkgb24gYnV0dG9uIHByZXNzIGFuZFxuLy8gICAgIHJlbGVhc2UuICBTZWUgdGhlIHNlY3Rpb24gTW91c2UgVHJhY2tpbmcuXG4vLyAgICAgUHMgPSAxIDAgMCAxICAtPiBEb24ndCB1c2UgSGlsaXRlIE1vdXNlIFRyYWNraW5nLlxuLy8gICAgIFBzID0gMSAwIDAgMiAgLT4gRG9uJ3QgdXNlIENlbGwgTW90aW9uIE1vdXNlIFRyYWNraW5nLlxuLy8gICAgIFBzID0gMSAwIDAgMyAgLT4gRG9uJ3QgdXNlIEFsbCBNb3Rpb24gTW91c2UgVHJhY2tpbmcuXG4vLyAgICAgUHMgPSAxIDAgMCA0ICAtPiBEb24ndCBzZW5kIEZvY3VzSW4vRm9jdXNPdXQgZXZlbnRzLlxuLy8gICAgIFBzID0gMSAwIDAgNSAgLT4gRGlzYWJsZSBFeHRlbmRlZCBNb3VzZSBNb2RlLlxuLy8gICAgIFBzID0gMSAwIDEgMCAgLT4gRG9uJ3Qgc2Nyb2xsIHRvIGJvdHRvbSBvbiB0dHkgb3V0cHV0XG4vLyAgICAgKHJ4dnQpLlxuLy8gICAgIFBzID0gMSAwIDEgMSAgLT4gRG9uJ3Qgc2Nyb2xsIHRvIGJvdHRvbSBvbiBrZXkgcHJlc3MgKHJ4dnQpLlxuLy8gICAgIFBzID0gMSAwIDMgNCAgLT4gRG9uJ3QgaW50ZXJwcmV0IFwibWV0YVwiIGtleS4gIChUaGlzIGRpc2FibGVzXG4vLyAgICAgdGhlIGVpZ2h0Qml0SW5wdXQgcmVzb3VyY2UpLlxuLy8gICAgIFBzID0gMSAwIDMgNSAgLT4gRGlzYWJsZSBzcGVjaWFsIG1vZGlmaWVycyBmb3IgQWx0IGFuZCBOdW0tXG4vLyAgICAgTG9jayBrZXlzLiAgKFRoaXMgZGlzYWJsZXMgdGhlIG51bUxvY2sgcmVzb3VyY2UpLlxuLy8gICAgIFBzID0gMSAwIDMgNiAgLT4gRG9uJ3Qgc2VuZCBFU0MgIHdoZW4gTWV0YSBtb2RpZmllcyBhIGtleS5cbi8vICAgICAoVGhpcyBkaXNhYmxlcyB0aGUgbWV0YVNlbmRzRXNjYXBlIHJlc291cmNlKS5cbi8vICAgICBQcyA9IDEgMCAzIDcgIC0+IFNlbmQgVlQyMjAgUmVtb3ZlIGZyb20gdGhlIGVkaXRpbmcta2V5cGFkXG4vLyAgICAgRGVsZXRlIGtleS5cbi8vICAgICBQcyA9IDEgMCAzIDkgIC0+IERvbid0IHNlbmQgRVNDICB3aGVuIEFsdCBtb2RpZmllcyBhIGtleS5cbi8vICAgICAoVGhpcyBkaXNhYmxlcyB0aGUgYWx0U2VuZHNFc2NhcGUgcmVzb3VyY2UpLlxuLy8gICAgIFBzID0gMSAwIDQgMCAgLT4gRG8gbm90IGtlZXAgc2VsZWN0aW9uIHdoZW4gbm90IGhpZ2hsaWdodGVkLlxuLy8gICAgIChUaGlzIGRpc2FibGVzIHRoZSBrZWVwU2VsZWN0aW9uIHJlc291cmNlKS5cbi8vICAgICBQcyA9IDEgMCA0IDEgIC0+IFVzZSB0aGUgUFJJTUFSWSBzZWxlY3Rpb24uICAoVGhpcyBkaXNhYmxlc1xuLy8gICAgIHRoZSBzZWxlY3RUb0NsaXBib2FyZCByZXNvdXJjZSkuXG4vLyAgICAgUHMgPSAxIDAgNCAyICAtPiBEaXNhYmxlIFVyZ2VuY3kgd2luZG93IG1hbmFnZXIgaGludCB3aGVuXG4vLyAgICAgQ29udHJvbC1HIGlzIHJlY2VpdmVkLiAgKFRoaXMgZGlzYWJsZXMgdGhlIGJlbGxJc1VyZ2VudFxuLy8gICAgIHJlc291cmNlKS5cbi8vICAgICBQcyA9IDEgMCA0IDMgIC0+IERpc2FibGUgcmFpc2luZyBvZiB0aGUgd2luZG93IHdoZW4gQ29udHJvbC1cbi8vICAgICBHIGlzIHJlY2VpdmVkLiAgKFRoaXMgZGlzYWJsZXMgdGhlIHBvcE9uQmVsbCByZXNvdXJjZSkuXG4vLyAgICAgUHMgPSAxIDAgNCA3ICAtPiBVc2UgTm9ybWFsIFNjcmVlbiBCdWZmZXIsIGNsZWFyaW5nIHNjcmVlblxuLy8gICAgIGZpcnN0IGlmIGluIHRoZSBBbHRlcm5hdGUgU2NyZWVuLiAgKFRoaXMgbWF5IGJlIGRpc2FibGVkIGJ5XG4vLyAgICAgdGhlIHRpdGVJbmhpYml0IHJlc291cmNlKS5cbi8vICAgICBQcyA9IDEgMCA0IDggIC0+IFJlc3RvcmUgY3Vyc29yIGFzIGluIERFQ1JDLiAgKFRoaXMgbWF5IGJlXG4vLyAgICAgZGlzYWJsZWQgYnkgdGhlIHRpdGVJbmhpYml0IHJlc291cmNlKS5cbi8vICAgICBQcyA9IDEgMCA0IDkgIC0+IFVzZSBOb3JtYWwgU2NyZWVuIEJ1ZmZlciBhbmQgcmVzdG9yZSBjdXJzb3Jcbi8vICAgICBhcyBpbiBERUNSQy4gIChUaGlzIG1heSBiZSBkaXNhYmxlZCBieSB0aGUgdGl0ZUluaGliaXRcbi8vICAgICByZXNvdXJjZSkuICBUaGlzIGNvbWJpbmVzIHRoZSBlZmZlY3RzIG9mIHRoZSAxIDAgNCA3ICBhbmQgMSAwXG4vLyAgICAgNCA4ICBtb2Rlcy4gIFVzZSB0aGlzIHdpdGggdGVybWluZm8tYmFzZWQgYXBwbGljYXRpb25zIHJhdGhlclxuLy8gICAgIHRoYW4gdGhlIDQgNyAgbW9kZS5cbi8vICAgICBQcyA9IDEgMCA1IDAgIC0+IFJlc2V0IHRlcm1pbmZvL3Rlcm1jYXAgZnVuY3Rpb24ta2V5IG1vZGUuXG4vLyAgICAgUHMgPSAxIDAgNSAxICAtPiBSZXNldCBTdW4gZnVuY3Rpb24ta2V5IG1vZGUuXG4vLyAgICAgUHMgPSAxIDAgNSAyICAtPiBSZXNldCBIUCBmdW5jdGlvbi1rZXkgbW9kZS5cbi8vICAgICBQcyA9IDEgMCA1IDMgIC0+IFJlc2V0IFNDTyBmdW5jdGlvbi1rZXkgbW9kZS5cbi8vICAgICBQcyA9IDEgMCA2IDAgIC0+IFJlc2V0IGxlZ2FjeSBrZXlib2FyZCBlbXVsYXRpb24gKFgxMVI2KS5cbi8vICAgICBQcyA9IDEgMCA2IDEgIC0+IFJlc2V0IGtleWJvYXJkIGVtdWxhdGlvbiB0byBTdW4vUEMgc3R5bGUuXG4vLyAgICAgUHMgPSAyIDAgMCA0ICAtPiBSZXNldCBicmFja2V0ZWQgcGFzdGUgbW9kZS5cblRlcm1pbmFsLnByb3RvdHlwZS5yZXNldE1vZGUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGwgPSBwYXJhbXMubGVuZ3RoXG4gICAgICAsIGkgPSAwO1xuXG4gICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucmVzZXRNb2RlKHBhcmFtc1tpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF0aGlzLnByZWZpeCkge1xuICAgIHN3aXRjaCAocGFyYW1zKSB7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHRoaXMuaW5zZXJ0TW9kZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjA6XG4gICAgICAgIC8vdGhpcy5jb252ZXJ0RW9sID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLnByZWZpeCA9PT0gJz8nKSB7XG4gICAgc3dpdGNoIChwYXJhbXMpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbkN1cnNvciA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaWYgKHRoaXMuY29scyA9PT0gMTMyICYmIHRoaXMuc2F2ZWRDb2xzKSB7XG4gICAgICAgICAgdGhpcy5yZXNpemUodGhpcy5zYXZlZENvbHMsIHRoaXMucm93cyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuc2F2ZWRDb2xzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjpcbiAgICAgICAgdGhpcy5vcmlnaW5Nb2RlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA3OlxuICAgICAgICB0aGlzLndyYXBhcm91bmRNb2RlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMjpcbiAgICAgICAgLy8gdGhpcy5jdXJzb3JCbGluayA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNjY6XG4gICAgICAgIHRoaXMubG9nKCdTd2l0Y2hpbmcgYmFjayB0byBub3JtYWwga2V5cGFkLicpO1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uS2V5cGFkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5OiAvLyBYMTAgTW91c2VcbiAgICAgIGNhc2UgMTAwMDogLy8gdnQyMDAgbW91c2VcbiAgICAgIGNhc2UgMTAwMjogLy8gYnV0dG9uIGV2ZW50IG1vdXNlXG4gICAgICBjYXNlIDEwMDM6IC8vIGFueSBldmVudCBtb3VzZVxuICAgICAgICB0aGlzLngxME1vdXNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMudnQyMDBNb3VzZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vcm1hbE1vdXNlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubW91c2VFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmN1cnNvciA9ICcnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwNDogLy8gc2VuZCBmb2N1c2luL2ZvY3Vzb3V0IGV2ZW50c1xuICAgICAgICB0aGlzLnNlbmRGb2N1cyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAwNTogLy8gdXRmOCBleHQgbW9kZSBtb3VzZVxuICAgICAgICB0aGlzLnV0Zk1vdXNlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxMDA2OiAvLyBzZ3IgZXh0IG1vZGUgbW91c2VcbiAgICAgICAgdGhpcy5zZ3JNb3VzZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTAxNTogLy8gdXJ4dnQgZXh0IG1vZGUgbW91c2VcbiAgICAgICAgdGhpcy51cnh2dE1vdXNlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNTogLy8gaGlkZSBjdXJzb3JcbiAgICAgICAgdGhpcy5jdXJzb3JIaWRkZW4gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTA0OTogLy8gYWx0IHNjcmVlbiBidWZmZXIgY3Vyc29yXG4gICAgICAgIDsgLy8gRkFMTC1USFJPVUdIXG4gICAgICBjYXNlIDQ3OiAvLyBub3JtYWwgc2NyZWVuIGJ1ZmZlclxuICAgICAgY2FzZSAxMDQ3OiAvLyBub3JtYWwgc2NyZWVuIGJ1ZmZlciAtIGNsZWFyaW5nIGl0IGZpcnN0XG4gICAgICAgIGlmICh0aGlzLm5vcm1hbCkge1xuICAgICAgICAgIHRoaXMubGluZXMgPSB0aGlzLm5vcm1hbC5saW5lcztcbiAgICAgICAgICB0aGlzLnliYXNlID0gdGhpcy5ub3JtYWwueWJhc2U7XG4gICAgICAgICAgdGhpcy55ZGlzcCA9IHRoaXMubm9ybWFsLnlkaXNwO1xuICAgICAgICAgIHRoaXMueCA9IHRoaXMubm9ybWFsLng7XG4gICAgICAgICAgdGhpcy55ID0gdGhpcy5ub3JtYWwueTtcbiAgICAgICAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMubm9ybWFsLnNjcm9sbFRvcDtcbiAgICAgICAgICB0aGlzLnNjcm9sbEJvdHRvbSA9IHRoaXMubm9ybWFsLnNjcm9sbEJvdHRvbTtcbiAgICAgICAgICB0aGlzLnRhYnMgPSB0aGlzLm5vcm1hbC50YWJzO1xuICAgICAgICAgIHRoaXMubm9ybWFsID0gbnVsbDtcbiAgICAgICAgICAvLyBpZiAocGFyYW1zID09PSAxMDQ5KSB7XG4gICAgICAgICAgLy8gICB0aGlzLnggPSB0aGlzLnNhdmVkWDtcbiAgICAgICAgICAvLyAgIHRoaXMueSA9IHRoaXMuc2F2ZWRZO1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgICB0aGlzLnJlZnJlc2goMCwgdGhpcy5yb3dzIC0gMSk7XG4gICAgICAgICAgdGhpcy5zaG93Q3Vyc29yKCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG4vLyBDU0kgUHMgOyBQcyByXG4vLyAgIFNldCBTY3JvbGxpbmcgUmVnaW9uIFt0b3A7Ym90dG9tXSAoZGVmYXVsdCA9IGZ1bGwgc2l6ZSBvZiB3aW4tXG4vLyAgIGRvdykgKERFQ1NUQk0pLlxuLy8gQ1NJID8gUG0gclxuVGVybWluYWwucHJvdG90eXBlLnNldFNjcm9sbFJlZ2lvbiA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICBpZiAodGhpcy5wcmVmaXgpIHJldHVybjtcbiAgdGhpcy5zY3JvbGxUb3AgPSAocGFyYW1zWzBdIHx8IDEpIC0gMTtcbiAgdGhpcy5zY3JvbGxCb3R0b20gPSAocGFyYW1zWzFdIHx8IHRoaXMucm93cykgLSAxO1xuICB0aGlzLnggPSAwO1xuICB0aGlzLnkgPSAwO1xufTtcblxuLy8gQ1NJIHNcbi8vICAgU2F2ZSBjdXJzb3IgKEFOU0kuU1lTKS5cblRlcm1pbmFsLnByb3RvdHlwZS5zYXZlQ3Vyc29yID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHRoaXMuc2F2ZWRYID0gdGhpcy54O1xuICB0aGlzLnNhdmVkWSA9IHRoaXMueTtcbn07XG5cbi8vIENTSSB1XG4vLyAgIFJlc3RvcmUgY3Vyc29yIChBTlNJLlNZUykuXG5UZXJtaW5hbC5wcm90b3R5cGUucmVzdG9yZUN1cnNvciA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB0aGlzLnggPSB0aGlzLnNhdmVkWCB8fCAwO1xuICB0aGlzLnkgPSB0aGlzLnNhdmVkWSB8fCAwO1xufTtcblxuLyoqXG4gKiBMZXNzZXIgVXNlZFxuICovXG5cbi8vIENTSSBQcyBJXG4vLyAgIEN1cnNvciBGb3J3YXJkIFRhYnVsYXRpb24gUHMgdGFiIHN0b3BzIChkZWZhdWx0ID0gMSkgKENIVCkuXG5UZXJtaW5hbC5wcm90b3R5cGUuY3Vyc29yRm9yd2FyZFRhYiA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgcGFyYW0gPSBwYXJhbXNbMF0gfHwgMTtcbiAgd2hpbGUgKHBhcmFtLS0pIHtcbiAgICB0aGlzLnggPSB0aGlzLm5leHRTdG9wKCk7XG4gIH1cbn07XG5cbi8vIENTSSBQcyBTICBTY3JvbGwgdXAgUHMgbGluZXMgKGRlZmF1bHQgPSAxKSAoU1UpLlxuVGVybWluYWwucHJvdG90eXBlLnNjcm9sbFVwID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciBwYXJhbSA9IHBhcmFtc1swXSB8fCAxO1xuICB3aGlsZSAocGFyYW0tLSkge1xuICAgIHRoaXMubGluZXMuc3BsaWNlKHRoaXMueWJhc2UgKyB0aGlzLnNjcm9sbFRvcCwgMSk7XG4gICAgdGhpcy5saW5lcy5zcGxpY2UodGhpcy55YmFzZSArIHRoaXMuc2Nyb2xsQm90dG9tLCAwLCB0aGlzLmJsYW5rTGluZSgpKTtcbiAgfVxuICAvLyB0aGlzLm1heFJhbmdlKCk7XG4gIHRoaXMudXBkYXRlUmFuZ2UodGhpcy5zY3JvbGxUb3ApO1xuICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMuc2Nyb2xsQm90dG9tKTtcbn07XG5cbi8vIENTSSBQcyBUICBTY3JvbGwgZG93biBQcyBsaW5lcyAoZGVmYXVsdCA9IDEpIChTRCkuXG5UZXJtaW5hbC5wcm90b3R5cGUuc2Nyb2xsRG93biA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgcGFyYW0gPSBwYXJhbXNbMF0gfHwgMTtcbiAgd2hpbGUgKHBhcmFtLS0pIHtcbiAgICB0aGlzLmxpbmVzLnNwbGljZSh0aGlzLnliYXNlICsgdGhpcy5zY3JvbGxCb3R0b20sIDEpO1xuICAgIHRoaXMubGluZXMuc3BsaWNlKHRoaXMueWJhc2UgKyB0aGlzLnNjcm9sbFRvcCwgMCwgdGhpcy5ibGFua0xpbmUoKSk7XG4gIH1cbiAgLy8gdGhpcy5tYXhSYW5nZSgpO1xuICB0aGlzLnVwZGF0ZVJhbmdlKHRoaXMuc2Nyb2xsVG9wKTtcbiAgdGhpcy51cGRhdGVSYW5nZSh0aGlzLnNjcm9sbEJvdHRvbSk7XG59O1xuXG4vLyBDU0kgUHMgOyBQcyA7IFBzIDsgUHMgOyBQcyBUXG4vLyAgIEluaXRpYXRlIGhpZ2hsaWdodCBtb3VzZSB0cmFja2luZy4gIFBhcmFtZXRlcnMgYXJlXG4vLyAgIFtmdW5jO3N0YXJ0eDtzdGFydHk7Zmlyc3Ryb3c7bGFzdHJvd10uICBTZWUgdGhlIHNlY3Rpb24gTW91c2Vcbi8vICAgVHJhY2tpbmcuXG5UZXJtaW5hbC5wcm90b3R5cGUuaW5pdE1vdXNlVHJhY2tpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgLy8gUmVsZXZhbnQ6IERFQ1NFVCAxMDAxXG59O1xuXG4vLyBDU0kgPiBQczsgUHMgVFxuLy8gICBSZXNldCBvbmUgb3IgbW9yZSBmZWF0dXJlcyBvZiB0aGUgdGl0bGUgbW9kZXMgdG8gdGhlIGRlZmF1bHRcbi8vICAgdmFsdWUuICBOb3JtYWxseSwgXCJyZXNldFwiIGRpc2FibGVzIHRoZSBmZWF0dXJlLiAgSXQgaXMgcG9zc2ktXG4vLyAgIGJsZSB0byBkaXNhYmxlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IGZlYXR1cmVzIGJ5IGNvbXBpbGluZyBhXG4vLyAgIGRpZmZlcmVudCBkZWZhdWx0IGZvciB0aGUgdGl0bGUgbW9kZXMgaW50byB4dGVybS5cbi8vICAgICBQcyA9IDAgIC0+IERvIG5vdCBzZXQgd2luZG93L2ljb24gbGFiZWxzIHVzaW5nIGhleGFkZWNpbWFsLlxuLy8gICAgIFBzID0gMSAgLT4gRG8gbm90IHF1ZXJ5IHdpbmRvdy9pY29uIGxhYmVscyB1c2luZyBoZXhhZGVjaS1cbi8vICAgICBtYWwuXG4vLyAgICAgUHMgPSAyICAtPiBEbyBub3Qgc2V0IHdpbmRvdy9pY29uIGxhYmVscyB1c2luZyBVVEYtOC5cbi8vICAgICBQcyA9IDMgIC0+IERvIG5vdCBxdWVyeSB3aW5kb3cvaWNvbiBsYWJlbHMgdXNpbmcgVVRGLTguXG4vLyAgIChTZWUgZGlzY3Vzc2lvbiBvZiBcIlRpdGxlIE1vZGVzXCIpLlxuVGVybWluYWwucHJvdG90eXBlLnJlc2V0VGl0bGVNb2RlcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICA7XG59O1xuXG4vLyBDU0kgUHMgWiAgQ3Vyc29yIEJhY2t3YXJkIFRhYnVsYXRpb24gUHMgdGFiIHN0b3BzIChkZWZhdWx0ID0gMSkgKENCVCkuXG5UZXJtaW5hbC5wcm90b3R5cGUuY3Vyc29yQmFja3dhcmRUYWIgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgdmFyIHBhcmFtID0gcGFyYW1zWzBdIHx8IDE7XG4gIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgdGhpcy54ID0gdGhpcy5wcmV2U3RvcCgpO1xuICB9XG59O1xuXG4vLyBDU0kgUHMgYiAgUmVwZWF0IHRoZSBwcmVjZWRpbmcgZ3JhcGhpYyBjaGFyYWN0ZXIgUHMgdGltZXMgKFJFUCkuXG5UZXJtaW5hbC5wcm90b3R5cGUucmVwZWF0UHJlY2VkaW5nQ2hhcmFjdGVyID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciBwYXJhbSA9IHBhcmFtc1swXSB8fCAxXG4gICAgLCBsaW5lID0gdGhpcy5saW5lc1t0aGlzLnliYXNlICsgdGhpcy55XVxuICAgICwgY2ggPSBsaW5lW3RoaXMueCAtIDFdIHx8IFt0aGlzLmRlZkF0dHIsICcgJ107XG5cbiAgd2hpbGUgKHBhcmFtLS0pIGxpbmVbdGhpcy54KytdID0gY2g7XG59O1xuXG4vLyBDU0kgUHMgZyAgVGFiIENsZWFyIChUQkMpLlxuLy8gICAgIFBzID0gMCAgLT4gQ2xlYXIgQ3VycmVudCBDb2x1bW4gKGRlZmF1bHQpLlxuLy8gICAgIFBzID0gMyAgLT4gQ2xlYXIgQWxsLlxuLy8gUG90ZW50aWFsbHk6XG4vLyAgIFBzID0gMiAgLT4gQ2xlYXIgU3RvcHMgb24gTGluZS5cbi8vICAgaHR0cDovL3Z0MTAwLm5ldC9hbm5hcmJvci9hYWEtdWcvc2VjdGlvbjYuaHRtbFxuVGVybWluYWwucHJvdG90eXBlLnRhYkNsZWFyID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciBwYXJhbSA9IHBhcmFtc1swXTtcbiAgaWYgKHBhcmFtIDw9IDApIHtcbiAgICBkZWxldGUgdGhpcy50YWJzW3RoaXMueF07XG4gIH0gZWxzZSBpZiAocGFyYW0gPT09IDMpIHtcbiAgICB0aGlzLnRhYnMgPSB7fTtcbiAgfVxufTtcblxuLy8gQ1NJIFBtIGkgIE1lZGlhIENvcHkgKE1DKS5cbi8vICAgICBQcyA9IDAgIC0+IFByaW50IHNjcmVlbiAoZGVmYXVsdCkuXG4vLyAgICAgUHMgPSA0ICAtPiBUdXJuIG9mZiBwcmludGVyIGNvbnRyb2xsZXIgbW9kZS5cbi8vICAgICBQcyA9IDUgIC0+IFR1cm4gb24gcHJpbnRlciBjb250cm9sbGVyIG1vZGUuXG4vLyBDU0kgPyBQbSBpXG4vLyAgIE1lZGlhIENvcHkgKE1DLCBERUMtc3BlY2lmaWMpLlxuLy8gICAgIFBzID0gMSAgLT4gUHJpbnQgbGluZSBjb250YWluaW5nIGN1cnNvci5cbi8vICAgICBQcyA9IDQgIC0+IFR1cm4gb2ZmIGF1dG9wcmludCBtb2RlLlxuLy8gICAgIFBzID0gNSAgLT4gVHVybiBvbiBhdXRvcHJpbnQgbW9kZS5cbi8vICAgICBQcyA9IDEgIDAgIC0+IFByaW50IGNvbXBvc2VkIGRpc3BsYXksIGlnbm9yZXMgREVDUEVYLlxuLy8gICAgIFBzID0gMSAgMSAgLT4gUHJpbnQgYWxsIHBhZ2VzLlxuVGVybWluYWwucHJvdG90eXBlLm1lZGlhQ29weSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICA7XG59O1xuXG4vLyBDU0kgPiBQczsgUHMgbVxuLy8gICBTZXQgb3IgcmVzZXQgcmVzb3VyY2UtdmFsdWVzIHVzZWQgYnkgeHRlcm0gdG8gZGVjaWRlIHdoZXRoZXJcbi8vICAgdG8gY29uc3RydWN0IGVzY2FwZSBzZXF1ZW5jZXMgaG9sZGluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGVcbi8vICAgbW9kaWZpZXJzIHByZXNzZWQgd2l0aCBhIGdpdmVuIGtleS4gIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaWRlbi1cbi8vICAgdGlmaWVzIHRoZSByZXNvdXJjZSB0byBzZXQvcmVzZXQuICBUaGUgc2Vjb25kIHBhcmFtZXRlciBpcyB0aGVcbi8vICAgdmFsdWUgdG8gYXNzaWduIHRvIHRoZSByZXNvdXJjZS4gIElmIHRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzXG4vLyAgIG9taXR0ZWQsIHRoZSByZXNvdXJjZSBpcyByZXNldCB0byBpdHMgaW5pdGlhbCB2YWx1ZS5cbi8vICAgICBQcyA9IDEgIC0+IG1vZGlmeUN1cnNvcktleXMuXG4vLyAgICAgUHMgPSAyICAtPiBtb2RpZnlGdW5jdGlvbktleXMuXG4vLyAgICAgUHMgPSA0ICAtPiBtb2RpZnlPdGhlcktleXMuXG4vLyAgIElmIG5vIHBhcmFtZXRlcnMgYXJlIGdpdmVuLCBhbGwgcmVzb3VyY2VzIGFyZSByZXNldCB0byB0aGVpclxuLy8gICBpbml0aWFsIHZhbHVlcy5cblRlcm1pbmFsLnByb3RvdHlwZS5zZXRSZXNvdXJjZXMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgO1xufTtcblxuLy8gQ1NJID4gUHMgblxuLy8gICBEaXNhYmxlIG1vZGlmaWVycyB3aGljaCBtYXkgYmUgZW5hYmxlZCB2aWEgdGhlIENTSSA+IFBzOyBQcyBtXG4vLyAgIHNlcXVlbmNlLiAgVGhpcyBjb3JyZXNwb25kcyB0byBhIHJlc291cmNlIHZhbHVlIG9mIFwiLTFcIiwgd2hpY2hcbi8vICAgY2Fubm90IGJlIHNldCB3aXRoIHRoZSBvdGhlciBzZXF1ZW5jZS4gIFRoZSBwYXJhbWV0ZXIgaWRlbnRpLVxuLy8gICBmaWVzIHRoZSByZXNvdXJjZSB0byBiZSBkaXNhYmxlZDpcbi8vICAgICBQcyA9IDEgIC0+IG1vZGlmeUN1cnNvcktleXMuXG4vLyAgICAgUHMgPSAyICAtPiBtb2RpZnlGdW5jdGlvbktleXMuXG4vLyAgICAgUHMgPSA0ICAtPiBtb2RpZnlPdGhlcktleXMuXG4vLyAgIElmIHRoZSBwYXJhbWV0ZXIgaXMgb21pdHRlZCwgbW9kaWZ5RnVuY3Rpb25LZXlzIGlzIGRpc2FibGVkLlxuLy8gICBXaGVuIG1vZGlmeUZ1bmN0aW9uS2V5cyBpcyBkaXNhYmxlZCwgeHRlcm0gdXNlcyB0aGUgbW9kaWZpZXJcbi8vICAga2V5cyB0byBtYWtlIGFuIGV4dGVuZGVkIHNlcXVlbmNlIG9mIGZ1bmN0aW9ucyByYXRoZXIgdGhhblxuLy8gICBhZGRpbmcgYSBwYXJhbWV0ZXIgdG8gZWFjaCBmdW5jdGlvbiBrZXkgdG8gZGVub3RlIHRoZSBtb2RpLVxuLy8gICBmaWVycy5cblRlcm1pbmFsLnByb3RvdHlwZS5kaXNhYmxlTW9kaWZpZXJzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIDtcbn07XG5cbi8vIENTSSA+IFBzIHBcbi8vICAgU2V0IHJlc291cmNlIHZhbHVlIHBvaW50ZXJNb2RlLiAgVGhpcyBpcyB1c2VkIGJ5IHh0ZXJtIHRvXG4vLyAgIGRlY2lkZSB3aGV0aGVyIHRvIGhpZGUgdGhlIHBvaW50ZXIgY3Vyc29yIGFzIHRoZSB1c2VyIHR5cGVzLlxuLy8gICBWYWxpZCB2YWx1ZXMgZm9yIHRoZSBwYXJhbWV0ZXI6XG4vLyAgICAgUHMgPSAwICAtPiBuZXZlciBoaWRlIHRoZSBwb2ludGVyLlxuLy8gICAgIFBzID0gMSAgLT4gaGlkZSBpZiB0aGUgbW91c2UgdHJhY2tpbmcgbW9kZSBpcyBub3QgZW5hYmxlZC5cbi8vICAgICBQcyA9IDIgIC0+IGFsd2F5cyBoaWRlIHRoZSBwb2ludGVyLiAgSWYgbm8gcGFyYW1ldGVyIGlzXG4vLyAgICAgZ2l2ZW4sIHh0ZXJtIHVzZXMgdGhlIGRlZmF1bHQsIHdoaWNoIGlzIDEgLlxuVGVybWluYWwucHJvdG90eXBlLnNldFBvaW50ZXJNb2RlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIDtcbn07XG5cbi8vIENTSSAhIHAgICBTb2Z0IHRlcm1pbmFsIHJlc2V0IChERUNTVFIpLlxuLy8gaHR0cDovL3Z0MTAwLm5ldC9kb2NzL3Z0MjIwLXJtL3RhYmxlNC0xMC5odG1sXG5UZXJtaW5hbC5wcm90b3R5cGUuc29mdFJlc2V0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHRoaXMuY3Vyc29ySGlkZGVuID0gZmFsc2U7XG4gIHRoaXMuaW5zZXJ0TW9kZSA9IGZhbHNlO1xuICB0aGlzLm9yaWdpbk1vZGUgPSBmYWxzZTtcbiAgdGhpcy53cmFwYXJvdW5kTW9kZSA9IGZhbHNlOyAvLyBhdXRvd3JhcFxuICB0aGlzLmFwcGxpY2F0aW9uS2V5cGFkID0gZmFsc2U7IC8vID9cbiAgdGhpcy5hcHBsaWNhdGlvbkN1cnNvciA9IGZhbHNlO1xuICB0aGlzLnNjcm9sbFRvcCA9IDA7XG4gIHRoaXMuc2Nyb2xsQm90dG9tID0gdGhpcy5yb3dzIC0gMTtcbiAgdGhpcy5jdXJBdHRyID0gdGhpcy5kZWZBdHRyO1xuICB0aGlzLnggPSB0aGlzLnkgPSAwOyAvLyA/XG4gIHRoaXMuY2hhcnNldCA9IG51bGw7XG4gIHRoaXMuZ2xldmVsID0gMDsgLy8gPz9cbiAgdGhpcy5jaGFyc2V0cyA9IFtudWxsXTsgLy8gPz9cbn07XG5cbi8vIENTSSBQcyQgcFxuLy8gICBSZXF1ZXN0IEFOU0kgbW9kZSAoREVDUlFNKS4gIEZvciBWVDMwMCBhbmQgdXAsIHJlcGx5IGlzXG4vLyAgICAgQ1NJIFBzOyBQbSQgeVxuLy8gICB3aGVyZSBQcyBpcyB0aGUgbW9kZSBudW1iZXIgYXMgaW4gUk0sIGFuZCBQbSBpcyB0aGUgbW9kZVxuLy8gICB2YWx1ZTpcbi8vICAgICAwIC0gbm90IHJlY29nbml6ZWRcbi8vICAgICAxIC0gc2V0XG4vLyAgICAgMiAtIHJlc2V0XG4vLyAgICAgMyAtIHBlcm1hbmVudGx5IHNldFxuLy8gICAgIDQgLSBwZXJtYW5lbnRseSByZXNldFxuVGVybWluYWwucHJvdG90eXBlLnJlcXVlc3RBbnNpTW9kZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICA7XG59O1xuXG4vLyBDU0kgPyBQcyQgcFxuLy8gICBSZXF1ZXN0IERFQyBwcml2YXRlIG1vZGUgKERFQ1JRTSkuICBGb3IgVlQzMDAgYW5kIHVwLCByZXBseSBpc1xuLy8gICAgIENTSSA/IFBzOyBQbSQgcFxuLy8gICB3aGVyZSBQcyBpcyB0aGUgbW9kZSBudW1iZXIgYXMgaW4gREVDU0VULCBQbSBpcyB0aGUgbW9kZSB2YWx1ZVxuLy8gICBhcyBpbiB0aGUgQU5TSSBERUNSUU0uXG5UZXJtaW5hbC5wcm90b3R5cGUucmVxdWVzdFByaXZhdGVNb2RlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIDtcbn07XG5cbi8vIENTSSBQcyA7IFBzIFwiIHBcbi8vICAgU2V0IGNvbmZvcm1hbmNlIGxldmVsIChERUNTQ0wpLiAgVmFsaWQgdmFsdWVzIGZvciB0aGUgZmlyc3Rcbi8vICAgcGFyYW1ldGVyOlxuLy8gICAgIFBzID0gNiAxICAtPiBWVDEwMC5cbi8vICAgICBQcyA9IDYgMiAgLT4gVlQyMDAuXG4vLyAgICAgUHMgPSA2IDMgIC0+IFZUMzAwLlxuLy8gICBWYWxpZCB2YWx1ZXMgZm9yIHRoZSBzZWNvbmQgcGFyYW1ldGVyOlxuLy8gICAgIFBzID0gMCAgLT4gOC1iaXQgY29udHJvbHMuXG4vLyAgICAgUHMgPSAxICAtPiA3LWJpdCBjb250cm9scyAoYWx3YXlzIHNldCBmb3IgVlQxMDApLlxuLy8gICAgIFBzID0gMiAgLT4gOC1iaXQgY29udHJvbHMuXG5UZXJtaW5hbC5wcm90b3R5cGUuc2V0Q29uZm9ybWFuY2VMZXZlbCA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICA7XG59O1xuXG4vLyBDU0kgUHMgcSAgTG9hZCBMRURzIChERUNMTCkuXG4vLyAgICAgUHMgPSAwICAtPiBDbGVhciBhbGwgTEVEUyAoZGVmYXVsdCkuXG4vLyAgICAgUHMgPSAxICAtPiBMaWdodCBOdW0gTG9jay5cbi8vICAgICBQcyA9IDIgIC0+IExpZ2h0IENhcHMgTG9jay5cbi8vICAgICBQcyA9IDMgIC0+IExpZ2h0IFNjcm9sbCBMb2NrLlxuLy8gICAgIFBzID0gMiAgMSAgLT4gRXh0aW5ndWlzaCBOdW0gTG9jay5cbi8vICAgICBQcyA9IDIgIDIgIC0+IEV4dGluZ3Vpc2ggQ2FwcyBMb2NrLlxuLy8gICAgIFBzID0gMiAgMyAgLT4gRXh0aW5ndWlzaCBTY3JvbGwgTG9jay5cblRlcm1pbmFsLnByb3RvdHlwZS5sb2FkTEVEcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICA7XG59O1xuXG4vLyBDU0kgUHMgU1AgcVxuLy8gICBTZXQgY3Vyc29yIHN0eWxlIChERUNTQ1VTUiwgVlQ1MjApLlxuLy8gICAgIFBzID0gMCAgLT4gYmxpbmtpbmcgYmxvY2suXG4vLyAgICAgUHMgPSAxICAtPiBibGlua2luZyBibG9jayAoZGVmYXVsdCkuXG4vLyAgICAgUHMgPSAyICAtPiBzdGVhZHkgYmxvY2suXG4vLyAgICAgUHMgPSAzICAtPiBibGlua2luZyB1bmRlcmxpbmUuXG4vLyAgICAgUHMgPSA0ICAtPiBzdGVhZHkgdW5kZXJsaW5lLlxuVGVybWluYWwucHJvdG90eXBlLnNldEN1cnNvclN0eWxlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIDtcbn07XG5cbi8vIENTSSBQcyBcIiBxXG4vLyAgIFNlbGVjdCBjaGFyYWN0ZXIgcHJvdGVjdGlvbiBhdHRyaWJ1dGUgKERFQ1NDQSkuICBWYWxpZCB2YWx1ZXNcbi8vICAgZm9yIHRoZSBwYXJhbWV0ZXI6XG4vLyAgICAgUHMgPSAwICAtPiBERUNTRUQgYW5kIERFQ1NFTCBjYW4gZXJhc2UgKGRlZmF1bHQpLlxuLy8gICAgIFBzID0gMSAgLT4gREVDU0VEIGFuZCBERUNTRUwgY2Fubm90IGVyYXNlLlxuLy8gICAgIFBzID0gMiAgLT4gREVDU0VEIGFuZCBERUNTRUwgY2FuIGVyYXNlLlxuVGVybWluYWwucHJvdG90eXBlLnNldENoYXJQcm90ZWN0aW9uQXR0ciA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICA7XG59O1xuXG4vLyBDU0kgPyBQbSByXG4vLyAgIFJlc3RvcmUgREVDIFByaXZhdGUgTW9kZSBWYWx1ZXMuICBUaGUgdmFsdWUgb2YgUHMgcHJldmlvdXNseVxuLy8gICBzYXZlZCBpcyByZXN0b3JlZC4gIFBzIHZhbHVlcyBhcmUgdGhlIHNhbWUgYXMgZm9yIERFQ1NFVC5cblRlcm1pbmFsLnByb3RvdHlwZS5yZXN0b3JlUHJpdmF0ZVZhbHVlcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICA7XG59O1xuXG4vLyBDU0kgUHQ7IFBsOyBQYjsgUHI7IFBzJCByXG4vLyAgIENoYW5nZSBBdHRyaWJ1dGVzIGluIFJlY3Rhbmd1bGFyIEFyZWEgKERFQ0NBUkEpLCBWVDQwMCBhbmQgdXAuXG4vLyAgICAgUHQ7IFBsOyBQYjsgUHIgZGVub3RlcyB0aGUgcmVjdGFuZ2xlLlxuLy8gICAgIFBzIGRlbm90ZXMgdGhlIFNHUiBhdHRyaWJ1dGVzIHRvIGNoYW5nZTogMCwgMSwgNCwgNSwgNy5cbi8vIE5PVEU6IHh0ZXJtIGRvZXNuJ3QgZW5hYmxlIHRoaXMgY29kZSBieSBkZWZhdWx0LlxuVGVybWluYWwucHJvdG90eXBlLnNldEF0dHJJblJlY3RhbmdsZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgdCA9IHBhcmFtc1swXVxuICAgICwgbCA9IHBhcmFtc1sxXVxuICAgICwgYiA9IHBhcmFtc1syXVxuICAgICwgciA9IHBhcmFtc1szXVxuICAgICwgYXR0ciA9IHBhcmFtc1s0XTtcblxuICB2YXIgbGluZVxuICAgICwgaTtcblxuICBmb3IgKDsgdCA8IGIgKyAxOyB0KyspIHtcbiAgICBsaW5lID0gdGhpcy5saW5lc1t0aGlzLnliYXNlICsgdF07XG4gICAgZm9yIChpID0gbDsgaSA8IHI7IGkrKykge1xuICAgICAgbGluZVtpXSA9IFthdHRyLCBsaW5lW2ldWzFdXTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGlzLm1heFJhbmdlKCk7XG4gIHRoaXMudXBkYXRlUmFuZ2UocGFyYW1zWzBdKTtcbiAgdGhpcy51cGRhdGVSYW5nZShwYXJhbXNbMl0pO1xufTtcblxuLy8gQ1NJID8gUG0gc1xuLy8gICBTYXZlIERFQyBQcml2YXRlIE1vZGUgVmFsdWVzLiAgUHMgdmFsdWVzIGFyZSB0aGUgc2FtZSBhcyBmb3Jcbi8vICAgREVDU0VULlxuVGVybWluYWwucHJvdG90eXBlLnNhdmVQcml2YXRlVmFsdWVzID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIDtcbn07XG5cbi8vIENTSSBQcyA7IFBzIDsgUHMgdFxuLy8gICBXaW5kb3cgbWFuaXB1bGF0aW9uIChmcm9tIGR0dGVybSwgYXMgd2VsbCBhcyBleHRlbnNpb25zKS5cbi8vICAgVGhlc2UgY29udHJvbHMgbWF5IGJlIGRpc2FibGVkIHVzaW5nIHRoZSBhbGxvd1dpbmRvd09wc1xuLy8gICByZXNvdXJjZS4gIFZhbGlkIHZhbHVlcyBmb3IgdGhlIGZpcnN0IChhbmQgYW55IGFkZGl0aW9uYWxcbi8vICAgcGFyYW1ldGVycykgYXJlOlxuLy8gICAgIFBzID0gMSAgLT4gRGUtaWNvbmlmeSB3aW5kb3cuXG4vLyAgICAgUHMgPSAyICAtPiBJY29uaWZ5IHdpbmRvdy5cbi8vICAgICBQcyA9IDMgIDsgIHggOyAgeSAtPiBNb3ZlIHdpbmRvdyB0byBbeCwgeV0uXG4vLyAgICAgUHMgPSA0ICA7ICBoZWlnaHQgOyAgd2lkdGggLT4gUmVzaXplIHRoZSB4dGVybSB3aW5kb3cgdG9cbi8vICAgICBoZWlnaHQgYW5kIHdpZHRoIGluIHBpeGVscy5cbi8vICAgICBQcyA9IDUgIC0+IFJhaXNlIHRoZSB4dGVybSB3aW5kb3cgdG8gdGhlIGZyb250IG9mIHRoZSBzdGFjay1cbi8vICAgICBpbmcgb3JkZXIuXG4vLyAgICAgUHMgPSA2ICAtPiBMb3dlciB0aGUgeHRlcm0gd2luZG93IHRvIHRoZSBib3R0b20gb2YgdGhlXG4vLyAgICAgc3RhY2tpbmcgb3JkZXIuXG4vLyAgICAgUHMgPSA3ICAtPiBSZWZyZXNoIHRoZSB4dGVybSB3aW5kb3cuXG4vLyAgICAgUHMgPSA4ICA7ICBoZWlnaHQgOyAgd2lkdGggLT4gUmVzaXplIHRoZSB0ZXh0IGFyZWEgdG9cbi8vICAgICBbaGVpZ2h0O3dpZHRoXSBpbiBjaGFyYWN0ZXJzLlxuLy8gICAgIFBzID0gOSAgOyAgMCAgLT4gUmVzdG9yZSBtYXhpbWl6ZWQgd2luZG93LlxuLy8gICAgIFBzID0gOSAgOyAgMSAgLT4gTWF4aW1pemUgd2luZG93IChpLmUuLCByZXNpemUgdG8gc2NyZWVuXG4vLyAgICAgc2l6ZSkuXG4vLyAgICAgUHMgPSAxIDAgIDsgIDAgIC0+IFVuZG8gZnVsbC1zY3JlZW4gbW9kZS5cbi8vICAgICBQcyA9IDEgMCAgOyAgMSAgLT4gQ2hhbmdlIHRvIGZ1bGwtc2NyZWVuLlxuLy8gICAgIFBzID0gMSAxICAtPiBSZXBvcnQgeHRlcm0gd2luZG93IHN0YXRlLiAgSWYgdGhlIHh0ZXJtIHdpbmRvd1xuLy8gICAgIGlzIG9wZW4gKG5vbi1pY29uaWZpZWQpLCBpdCByZXR1cm5zIENTSSAxIHQgLiAgSWYgdGhlIHh0ZXJtXG4vLyAgICAgd2luZG93IGlzIGljb25pZmllZCwgaXQgcmV0dXJucyBDU0kgMiB0IC5cbi8vICAgICBQcyA9IDEgMyAgLT4gUmVwb3J0IHh0ZXJtIHdpbmRvdyBwb3NpdGlvbi4gIFJlc3VsdCBpcyBDU0kgM1xuLy8gICAgIDsgeCA7IHkgdFxuLy8gICAgIFBzID0gMSA0ICAtPiBSZXBvcnQgeHRlcm0gd2luZG93IGluIHBpeGVscy4gIFJlc3VsdCBpcyBDU0lcbi8vICAgICA0ICA7ICBoZWlnaHQgOyAgd2lkdGggdFxuLy8gICAgIFBzID0gMSA4ICAtPiBSZXBvcnQgdGhlIHNpemUgb2YgdGhlIHRleHQgYXJlYSBpbiBjaGFyYWN0ZXJzLlxuLy8gICAgIFJlc3VsdCBpcyBDU0kgIDggIDsgIGhlaWdodCA7ICB3aWR0aCB0XG4vLyAgICAgUHMgPSAxIDkgIC0+IFJlcG9ydCB0aGUgc2l6ZSBvZiB0aGUgc2NyZWVuIGluIGNoYXJhY3RlcnMuXG4vLyAgICAgUmVzdWx0IGlzIENTSSAgOSAgOyAgaGVpZ2h0IDsgIHdpZHRoIHRcbi8vICAgICBQcyA9IDIgMCAgLT4gUmVwb3J0IHh0ZXJtIHdpbmRvdydzIGljb24gbGFiZWwuICBSZXN1bHQgaXNcbi8vICAgICBPU0MgIEwgIGxhYmVsIFNUXG4vLyAgICAgUHMgPSAyIDEgIC0+IFJlcG9ydCB4dGVybSB3aW5kb3cncyB0aXRsZS4gIFJlc3VsdCBpcyBPU0MgIGxcbi8vICAgICBsYWJlbCBTVFxuLy8gICAgIFBzID0gMiAyICA7ICAwICAtPiBTYXZlIHh0ZXJtIGljb24gYW5kIHdpbmRvdyB0aXRsZSBvblxuLy8gICAgIHN0YWNrLlxuLy8gICAgIFBzID0gMiAyICA7ICAxICAtPiBTYXZlIHh0ZXJtIGljb24gdGl0bGUgb24gc3RhY2suXG4vLyAgICAgUHMgPSAyIDIgIDsgIDIgIC0+IFNhdmUgeHRlcm0gd2luZG93IHRpdGxlIG9uIHN0YWNrLlxuLy8gICAgIFBzID0gMiAzICA7ICAwICAtPiBSZXN0b3JlIHh0ZXJtIGljb24gYW5kIHdpbmRvdyB0aXRsZSBmcm9tXG4vLyAgICAgc3RhY2suXG4vLyAgICAgUHMgPSAyIDMgIDsgIDEgIC0+IFJlc3RvcmUgeHRlcm0gaWNvbiB0aXRsZSBmcm9tIHN0YWNrLlxuLy8gICAgIFBzID0gMiAzICA7ICAyICAtPiBSZXN0b3JlIHh0ZXJtIHdpbmRvdyB0aXRsZSBmcm9tIHN0YWNrLlxuLy8gICAgIFBzID49IDIgNCAgLT4gUmVzaXplIHRvIFBzIGxpbmVzIChERUNTTFBQKS5cblRlcm1pbmFsLnByb3RvdHlwZS5tYW5pcHVsYXRlV2luZG93ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIDtcbn07XG5cbi8vIENTSSBQdDsgUGw7IFBiOyBQcjsgUHMkIHRcbi8vICAgUmV2ZXJzZSBBdHRyaWJ1dGVzIGluIFJlY3Rhbmd1bGFyIEFyZWEgKERFQ1JBUkEpLCBWVDQwMCBhbmRcbi8vICAgdXAuXG4vLyAgICAgUHQ7IFBsOyBQYjsgUHIgZGVub3RlcyB0aGUgcmVjdGFuZ2xlLlxuLy8gICAgIFBzIGRlbm90ZXMgdGhlIGF0dHJpYnV0ZXMgdG8gcmV2ZXJzZSwgaS5lLiwgIDEsIDQsIDUsIDcuXG4vLyBOT1RFOiB4dGVybSBkb2Vzbid0IGVuYWJsZSB0aGlzIGNvZGUgYnkgZGVmYXVsdC5cblRlcm1pbmFsLnByb3RvdHlwZS5yZXZlcnNlQXR0ckluUmVjdGFuZ2xlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIDtcbn07XG5cbi8vIENTSSA+IFBzOyBQcyB0XG4vLyAgIFNldCBvbmUgb3IgbW9yZSBmZWF0dXJlcyBvZiB0aGUgdGl0bGUgbW9kZXMuICBFYWNoIHBhcmFtZXRlclxuLy8gICBlbmFibGVzIGEgc2luZ2xlIGZlYXR1cmUuXG4vLyAgICAgUHMgPSAwICAtPiBTZXQgd2luZG93L2ljb24gbGFiZWxzIHVzaW5nIGhleGFkZWNpbWFsLlxuLy8gICAgIFBzID0gMSAgLT4gUXVlcnkgd2luZG93L2ljb24gbGFiZWxzIHVzaW5nIGhleGFkZWNpbWFsLlxuLy8gICAgIFBzID0gMiAgLT4gU2V0IHdpbmRvdy9pY29uIGxhYmVscyB1c2luZyBVVEYtOC5cbi8vICAgICBQcyA9IDMgIC0+IFF1ZXJ5IHdpbmRvdy9pY29uIGxhYmVscyB1c2luZyBVVEYtOC4gIChTZWUgZGlzLVxuLy8gICAgIGN1c3Npb24gb2YgXCJUaXRsZSBNb2Rlc1wiKVxuVGVybWluYWwucHJvdG90eXBlLnNldFRpdGxlTW9kZUZlYXR1cmUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgO1xufTtcblxuLy8gQ1NJIFBzIFNQIHRcbi8vICAgU2V0IHdhcm5pbmctYmVsbCB2b2x1bWUgKERFQ1NXQlYsIFZUNTIwKS5cbi8vICAgICBQcyA9IDAgIG9yIDEgIC0+IG9mZi5cbi8vICAgICBQcyA9IDIgLCAzICBvciA0ICAtPiBsb3cuXG4vLyAgICAgUHMgPSA1ICwgNiAsIDcgLCBvciA4ICAtPiBoaWdoLlxuVGVybWluYWwucHJvdG90eXBlLnNldFdhcm5pbmdCZWxsVm9sdW1lID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIDtcbn07XG5cbi8vIENTSSBQcyBTUCB1XG4vLyAgIFNldCBtYXJnaW4tYmVsbCB2b2x1bWUgKERFQ1NNQlYsIFZUNTIwKS5cbi8vICAgICBQcyA9IDEgIC0+IG9mZi5cbi8vICAgICBQcyA9IDIgLCAzICBvciA0ICAtPiBsb3cuXG4vLyAgICAgUHMgPSAwICwgNSAsIDYgLCA3ICwgb3IgOCAgLT4gaGlnaC5cblRlcm1pbmFsLnByb3RvdHlwZS5zZXRNYXJnaW5CZWxsVm9sdW1lID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIDtcbn07XG5cbi8vIENTSSBQdDsgUGw7IFBiOyBQcjsgUHA7IFB0OyBQbDsgUHAkIHZcbi8vICAgQ29weSBSZWN0YW5ndWxhciBBcmVhIChERUNDUkEsIFZUNDAwIGFuZCB1cCkuXG4vLyAgICAgUHQ7IFBsOyBQYjsgUHIgZGVub3RlcyB0aGUgcmVjdGFuZ2xlLlxuLy8gICAgIFBwIGRlbm90ZXMgdGhlIHNvdXJjZSBwYWdlLlxuLy8gICAgIFB0OyBQbCBkZW5vdGVzIHRoZSB0YXJnZXQgbG9jYXRpb24uXG4vLyAgICAgUHAgZGVub3RlcyB0aGUgdGFyZ2V0IHBhZ2UuXG4vLyBOT1RFOiB4dGVybSBkb2Vzbid0IGVuYWJsZSB0aGlzIGNvZGUgYnkgZGVmYXVsdC5cblRlcm1pbmFsLnByb3RvdHlwZS5jb3B5UmVjdGFuZ2xlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIDtcbn07XG5cbi8vIENTSSBQdCA7IFBsIDsgUGIgOyBQciAnIHdcbi8vICAgRW5hYmxlIEZpbHRlciBSZWN0YW5nbGUgKERFQ0VGUiksIFZUNDIwIGFuZCB1cC5cbi8vICAgUGFyYW1ldGVycyBhcmUgW3RvcDtsZWZ0O2JvdHRvbTtyaWdodF0uXG4vLyAgIERlZmluZXMgdGhlIGNvb3JkaW5hdGVzIG9mIGEgZmlsdGVyIHJlY3RhbmdsZSBhbmQgYWN0aXZhdGVzXG4vLyAgIGl0LiAgQW55dGltZSB0aGUgbG9jYXRvciBpcyBkZXRlY3RlZCBvdXRzaWRlIG9mIHRoZSBmaWx0ZXJcbi8vICAgcmVjdGFuZ2xlLCBhbiBvdXRzaWRlIHJlY3RhbmdsZSBldmVudCBpcyBnZW5lcmF0ZWQgYW5kIHRoZVxuLy8gICByZWN0YW5nbGUgaXMgZGlzYWJsZWQuICBGaWx0ZXIgcmVjdGFuZ2xlcyBhcmUgYWx3YXlzIHRyZWF0ZWRcbi8vICAgYXMgXCJvbmUtc2hvdFwiIGV2ZW50cy4gIEFueSBwYXJhbWV0ZXJzIHRoYXQgYXJlIG9taXR0ZWQgZGVmYXVsdFxuLy8gICB0byB0aGUgY3VycmVudCBsb2NhdG9yIHBvc2l0aW9uLiAgSWYgYWxsIHBhcmFtZXRlcnMgYXJlIG9taXQtXG4vLyAgIHRlZCwgYW55IGxvY2F0b3IgbW90aW9uIHdpbGwgYmUgcmVwb3J0ZWQuICBERUNFTFIgYWx3YXlzIGNhbi1cbi8vICAgY2VscyBhbnkgcHJldm91cyByZWN0YW5nbGUgZGVmaW5pdGlvbi5cblRlcm1pbmFsLnByb3RvdHlwZS5lbmFibGVGaWx0ZXJSZWN0YW5nbGUgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgO1xufTtcblxuLy8gQ1NJIFBzIHggIFJlcXVlc3QgVGVybWluYWwgUGFyYW1ldGVycyAoREVDUkVRVFBBUk0pLlxuLy8gICBpZiBQcyBpcyBhIFwiMFwiIChkZWZhdWx0KSBvciBcIjFcIiwgYW5kIHh0ZXJtIGlzIGVtdWxhdGluZyBWVDEwMCxcbi8vICAgdGhlIGNvbnRyb2wgc2VxdWVuY2UgZWxpY2l0cyBhIHJlc3BvbnNlIG9mIHRoZSBzYW1lIGZvcm0gd2hvc2Vcbi8vICAgcGFyYW1ldGVycyBkZXNjcmliZSB0aGUgdGVybWluYWw6XG4vLyAgICAgUHMgLT4gdGhlIGdpdmVuIFBzIGluY3JlbWVudGVkIGJ5IDIuXG4vLyAgICAgUG4gPSAxICA8LSBubyBwYXJpdHkuXG4vLyAgICAgUG4gPSAxICA8LSBlaWdodCBiaXRzLlxuLy8gICAgIFBuID0gMSAgPC0gMiAgOCAgdHJhbnNtaXQgMzguNGsgYmF1ZC5cbi8vICAgICBQbiA9IDEgIDwtIDIgIDggIHJlY2VpdmUgMzguNGsgYmF1ZC5cbi8vICAgICBQbiA9IDEgIDwtIGNsb2NrIG11bHRpcGxpZXIuXG4vLyAgICAgUG4gPSAwICA8LSBTVFAgZmxhZ3MuXG5UZXJtaW5hbC5wcm90b3R5cGUucmVxdWVzdFBhcmFtZXRlcnMgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgO1xufTtcblxuLy8gQ1NJIFBzIHggIFNlbGVjdCBBdHRyaWJ1dGUgQ2hhbmdlIEV4dGVudCAoREVDU0FDRSkuXG4vLyAgICAgUHMgPSAwICAtPiBmcm9tIHN0YXJ0IHRvIGVuZCBwb3NpdGlvbiwgd3JhcHBlZC5cbi8vICAgICBQcyA9IDEgIC0+IGZyb20gc3RhcnQgdG8gZW5kIHBvc2l0aW9uLCB3cmFwcGVkLlxuLy8gICAgIFBzID0gMiAgLT4gcmVjdGFuZ2xlIChleGFjdCkuXG5UZXJtaW5hbC5wcm90b3R5cGUuc2VsZWN0Q2hhbmdlRXh0ZW50ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIDtcbn07XG5cbi8vIENTSSBQYzsgUHQ7IFBsOyBQYjsgUHIkIHhcbi8vICAgRmlsbCBSZWN0YW5ndWxhciBBcmVhIChERUNGUkEpLCBWVDQyMCBhbmQgdXAuXG4vLyAgICAgUGMgaXMgdGhlIGNoYXJhY3RlciB0byB1c2UuXG4vLyAgICAgUHQ7IFBsOyBQYjsgUHIgZGVub3RlcyB0aGUgcmVjdGFuZ2xlLlxuLy8gTk9URTogeHRlcm0gZG9lc24ndCBlbmFibGUgdGhpcyBjb2RlIGJ5IGRlZmF1bHQuXG5UZXJtaW5hbC5wcm90b3R5cGUuZmlsbFJlY3RhbmdsZSA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICB2YXIgY2ggPSBwYXJhbXNbMF1cbiAgICAsIHQgPSBwYXJhbXNbMV1cbiAgICAsIGwgPSBwYXJhbXNbMl1cbiAgICAsIGIgPSBwYXJhbXNbM11cbiAgICAsIHIgPSBwYXJhbXNbNF07XG5cbiAgdmFyIGxpbmVcbiAgICAsIGk7XG5cbiAgZm9yICg7IHQgPCBiICsgMTsgdCsrKSB7XG4gICAgbGluZSA9IHRoaXMubGluZXNbdGhpcy55YmFzZSArIHRdO1xuICAgIGZvciAoaSA9IGw7IGkgPCByOyBpKyspIHtcbiAgICAgIGxpbmVbaV0gPSBbbGluZVtpXVswXSwgU3RyaW5nLmZyb21DaGFyQ29kZShjaCldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoaXMubWF4UmFuZ2UoKTtcbiAgdGhpcy51cGRhdGVSYW5nZShwYXJhbXNbMV0pO1xuICB0aGlzLnVwZGF0ZVJhbmdlKHBhcmFtc1szXSk7XG59O1xuXG4vLyBDU0kgUHMgOyBQdSAnIHpcbi8vICAgRW5hYmxlIExvY2F0b3IgUmVwb3J0aW5nIChERUNFTFIpLlxuLy8gICBWYWxpZCB2YWx1ZXMgZm9yIHRoZSBmaXJzdCBwYXJhbWV0ZXI6XG4vLyAgICAgUHMgPSAwICAtPiBMb2NhdG9yIGRpc2FibGVkIChkZWZhdWx0KS5cbi8vICAgICBQcyA9IDEgIC0+IExvY2F0b3IgZW5hYmxlZC5cbi8vICAgICBQcyA9IDIgIC0+IExvY2F0b3IgZW5hYmxlZCBmb3Igb25lIHJlcG9ydCwgdGhlbiBkaXNhYmxlZC5cbi8vICAgVGhlIHNlY29uZCBwYXJhbWV0ZXIgc3BlY2lmaWVzIHRoZSBjb29yZGluYXRlIHVuaXQgZm9yIGxvY2F0b3Jcbi8vICAgcmVwb3J0cy5cbi8vICAgVmFsaWQgdmFsdWVzIGZvciB0aGUgc2Vjb25kIHBhcmFtZXRlcjpcbi8vICAgICBQdSA9IDAgIDwtIG9yIG9taXR0ZWQgLT4gZGVmYXVsdCB0byBjaGFyYWN0ZXIgY2VsbHMuXG4vLyAgICAgUHUgPSAxICA8LSBkZXZpY2UgcGh5c2ljYWwgcGl4ZWxzLlxuLy8gICAgIFB1ID0gMiAgPC0gY2hhcmFjdGVyIGNlbGxzLlxuVGVybWluYWwucHJvdG90eXBlLmVuYWJsZUxvY2F0b3JSZXBvcnRpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcbiAgdmFyIHZhbCA9IHBhcmFtc1swXSA+IDA7XG4gIC8vdGhpcy5tb3VzZUV2ZW50cyA9IHZhbDtcbiAgLy90aGlzLmRlY0xvY2F0b3IgPSB2YWw7XG59O1xuXG4vLyBDU0kgUHQ7IFBsOyBQYjsgUHIkIHpcbi8vICAgRXJhc2UgUmVjdGFuZ3VsYXIgQXJlYSAoREVDRVJBKSwgVlQ0MDAgYW5kIHVwLlxuLy8gICAgIFB0OyBQbDsgUGI7IFByIGRlbm90ZXMgdGhlIHJlY3RhbmdsZS5cbi8vIE5PVEU6IHh0ZXJtIGRvZXNuJ3QgZW5hYmxlIHRoaXMgY29kZSBieSBkZWZhdWx0LlxuVGVybWluYWwucHJvdG90eXBlLmVyYXNlUmVjdGFuZ2xlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIHZhciB0ID0gcGFyYW1zWzBdXG4gICAgLCBsID0gcGFyYW1zWzFdXG4gICAgLCBiID0gcGFyYW1zWzJdXG4gICAgLCByID0gcGFyYW1zWzNdO1xuXG4gIHZhciBsaW5lXG4gICAgLCBpXG4gICAgLCBjaDtcblxuICBjaCA9IFt0aGlzLmVyYXNlQXR0cigpLCAnICddOyAvLyB4dGVybT9cblxuICBmb3IgKDsgdCA8IGIgKyAxOyB0KyspIHtcbiAgICBsaW5lID0gdGhpcy5saW5lc1t0aGlzLnliYXNlICsgdF07XG4gICAgZm9yIChpID0gbDsgaSA8IHI7IGkrKykge1xuICAgICAgbGluZVtpXSA9IGNoO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRoaXMubWF4UmFuZ2UoKTtcbiAgdGhpcy51cGRhdGVSYW5nZShwYXJhbXNbMF0pO1xuICB0aGlzLnVwZGF0ZVJhbmdlKHBhcmFtc1syXSk7XG59O1xuXG4vLyBDU0kgUG0gJyB7XG4vLyAgIFNlbGVjdCBMb2NhdG9yIEV2ZW50cyAoREVDU0xFKS5cbi8vICAgVmFsaWQgdmFsdWVzIGZvciB0aGUgZmlyc3QgKGFuZCBhbnkgYWRkaXRpb25hbCBwYXJhbWV0ZXJzKVxuLy8gICBhcmU6XG4vLyAgICAgUHMgPSAwICAtPiBvbmx5IHJlc3BvbmQgdG8gZXhwbGljaXQgaG9zdCByZXF1ZXN0cyAoREVDUlFMUCkuXG4vLyAgICAgICAgICAgICAgICAoVGhpcyBpcyBkZWZhdWx0KS4gIEl0IGFsc28gY2FuY2VscyBhbnkgZmlsdGVyXG4vLyAgIHJlY3RhbmdsZS5cbi8vICAgICBQcyA9IDEgIC0+IHJlcG9ydCBidXR0b24gZG93biB0cmFuc2l0aW9ucy5cbi8vICAgICBQcyA9IDIgIC0+IGRvIG5vdCByZXBvcnQgYnV0dG9uIGRvd24gdHJhbnNpdGlvbnMuXG4vLyAgICAgUHMgPSAzICAtPiByZXBvcnQgYnV0dG9uIHVwIHRyYW5zaXRpb25zLlxuLy8gICAgIFBzID0gNCAgLT4gZG8gbm90IHJlcG9ydCBidXR0b24gdXAgdHJhbnNpdGlvbnMuXG5UZXJtaW5hbC5wcm90b3R5cGUuc2V0TG9jYXRvckV2ZW50cyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICA7XG59O1xuXG4vLyBDU0kgUHQ7IFBsOyBQYjsgUHIkIHtcbi8vICAgU2VsZWN0aXZlIEVyYXNlIFJlY3Rhbmd1bGFyIEFyZWEgKERFQ1NFUkEpLCBWVDQwMCBhbmQgdXAuXG4vLyAgICAgUHQ7IFBsOyBQYjsgUHIgZGVub3RlcyB0aGUgcmVjdGFuZ2xlLlxuVGVybWluYWwucHJvdG90eXBlLnNlbGVjdGl2ZUVyYXNlUmVjdGFuZ2xlID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIDtcbn07XG5cbi8vIENTSSBQcyAnIHxcbi8vICAgUmVxdWVzdCBMb2NhdG9yIFBvc2l0aW9uIChERUNSUUxQKS5cbi8vICAgVmFsaWQgdmFsdWVzIGZvciB0aGUgcGFyYW1ldGVyIGFyZTpcbi8vICAgICBQcyA9IDAgLCAxIG9yIG9taXR0ZWQgLT4gdHJhbnNtaXQgYSBzaW5nbGUgREVDTFJQIGxvY2F0b3Jcbi8vICAgICByZXBvcnQuXG5cbi8vICAgSWYgTG9jYXRvciBSZXBvcnRpbmcgaGFzIGJlZW4gZW5hYmxlZCBieSBhIERFQ0VMUiwgeHRlcm0gd2lsbFxuLy8gICByZXNwb25kIHdpdGggYSBERUNMUlAgTG9jYXRvciBSZXBvcnQuICBUaGlzIHJlcG9ydCBpcyBhbHNvXG4vLyAgIGdlbmVyYXRlZCBvbiBidXR0b24gdXAgYW5kIGRvd24gZXZlbnRzIGlmIHRoZXkgaGF2ZSBiZWVuXG4vLyAgIGVuYWJsZWQgd2l0aCBhIERFQ1NMRSwgb3Igd2hlbiB0aGUgbG9jYXRvciBpcyBkZXRlY3RlZCBvdXRzaWRlXG4vLyAgIG9mIGEgZmlsdGVyIHJlY3RhbmdsZSwgaWYgZmlsdGVyIHJlY3RhbmdsZXMgaGF2ZSBiZWVuIGVuYWJsZWRcbi8vICAgd2l0aCBhIERFQ0VGUi5cblxuLy8gICAgIC0+IENTSSBQZSA7IFBiIDsgUHIgOyBQYyA7IFBwICYgIHdcblxuLy8gICBQYXJhbWV0ZXJzIGFyZSBbZXZlbnQ7YnV0dG9uO3Jvdztjb2x1bW47cGFnZV0uXG4vLyAgIFZhbGlkIHZhbHVlcyBmb3IgdGhlIGV2ZW50OlxuLy8gICAgIFBlID0gMCAgLT4gbG9jYXRvciB1bmF2YWlsYWJsZSAtIG5vIG90aGVyIHBhcmFtZXRlcnMgc2VudC5cbi8vICAgICBQZSA9IDEgIC0+IHJlcXVlc3QgLSB4dGVybSByZWNlaXZlZCBhIERFQ1JRTFAuXG4vLyAgICAgUGUgPSAyICAtPiBsZWZ0IGJ1dHRvbiBkb3duLlxuLy8gICAgIFBlID0gMyAgLT4gbGVmdCBidXR0b24gdXAuXG4vLyAgICAgUGUgPSA0ICAtPiBtaWRkbGUgYnV0dG9uIGRvd24uXG4vLyAgICAgUGUgPSA1ICAtPiBtaWRkbGUgYnV0dG9uIHVwLlxuLy8gICAgIFBlID0gNiAgLT4gcmlnaHQgYnV0dG9uIGRvd24uXG4vLyAgICAgUGUgPSA3ICAtPiByaWdodCBidXR0b24gdXAuXG4vLyAgICAgUGUgPSA4ICAtPiBNNCBidXR0b24gZG93bi5cbi8vICAgICBQZSA9IDkgIC0+IE00IGJ1dHRvbiB1cC5cbi8vICAgICBQZSA9IDEgMCAgLT4gbG9jYXRvciBvdXRzaWRlIGZpbHRlciByZWN0YW5nbGUuXG4vLyAgIGBgYnV0dG9uJycgcGFyYW1ldGVyIGlzIGEgYml0bWFzayBpbmRpY2F0aW5nIHdoaWNoIGJ1dHRvbnMgYXJlXG4vLyAgICAgcHJlc3NlZDpcbi8vICAgICBQYiA9IDAgIDwtIG5vIGJ1dHRvbnMgZG93bi5cbi8vICAgICBQYiAmIDEgIDwtIHJpZ2h0IGJ1dHRvbiBkb3duLlxuLy8gICAgIFBiICYgMiAgPC0gbWlkZGxlIGJ1dHRvbiBkb3duLlxuLy8gICAgIFBiICYgNCAgPC0gbGVmdCBidXR0b24gZG93bi5cbi8vICAgICBQYiAmIDggIDwtIE00IGJ1dHRvbiBkb3duLlxuLy8gICBgYHJvdycnIGFuZCBgYGNvbHVtbicnIHBhcmFtZXRlcnMgYXJlIHRoZSBjb29yZGluYXRlcyBvZiB0aGVcbi8vICAgICBsb2NhdG9yIHBvc2l0aW9uIGluIHRoZSB4dGVybSB3aW5kb3csIGVuY29kZWQgYXMgQVNDSUkgZGVjaS1cbi8vICAgICBtYWwuXG4vLyAgIFRoZSBgYHBhZ2UnJyBwYXJhbWV0ZXIgaXMgbm90IHVzZWQgYnkgeHRlcm0sIGFuZCB3aWxsIGJlIG9taXQtXG4vLyAgIHRlZC5cblRlcm1pbmFsLnByb3RvdHlwZS5yZXF1ZXN0TG9jYXRvclBvc2l0aW9uID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gIDtcbn07XG5cbi8vIENTSSBQIG0gU1AgfVxuLy8gSW5zZXJ0IFAgcyBDb2x1bW4ocykgKGRlZmF1bHQgPSAxKSAoREVDSUMpLCBWVDQyMCBhbmQgdXAuXG4vLyBOT1RFOiB4dGVybSBkb2Vzbid0IGVuYWJsZSB0aGlzIGNvZGUgYnkgZGVmYXVsdC5cblRlcm1pbmFsLnByb3RvdHlwZS5pbnNlcnRDb2x1bW5zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJhbSA9IHBhcmFtc1swXVxuICAgICwgbCA9IHRoaXMueWJhc2UgKyB0aGlzLnJvd3NcbiAgICAsIGNoID0gW3RoaXMuZXJhc2VBdHRyKCksICcgJ10gLy8geHRlcm0/XG4gICAgLCBpO1xuXG4gIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgZm9yIChpID0gdGhpcy55YmFzZTsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5saW5lc1tpXS5zcGxpY2UodGhpcy54ICsgMSwgMCwgY2gpO1xuICAgICAgdGhpcy5saW5lc1tpXS5wb3AoKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm1heFJhbmdlKCk7XG59O1xuXG4vLyBDU0kgUCBtIFNQIH5cbi8vIERlbGV0ZSBQIHMgQ29sdW1uKHMpIChkZWZhdWx0ID0gMSkgKERFQ0RDKSwgVlQ0MjAgYW5kIHVwXG4vLyBOT1RFOiB4dGVybSBkb2Vzbid0IGVuYWJsZSB0aGlzIGNvZGUgYnkgZGVmYXVsdC5cblRlcm1pbmFsLnByb3RvdHlwZS5kZWxldGVDb2x1bW5zID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXJhbSA9IHBhcmFtc1swXVxuICAgICwgbCA9IHRoaXMueWJhc2UgKyB0aGlzLnJvd3NcbiAgICAsIGNoID0gW3RoaXMuZXJhc2VBdHRyKCksICcgJ10gLy8geHRlcm0/XG4gICAgLCBpO1xuXG4gIHdoaWxlIChwYXJhbS0tKSB7XG4gICAgZm9yIChpID0gdGhpcy55YmFzZTsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5saW5lc1tpXS5zcGxpY2UodGhpcy54LCAxKTtcbiAgICAgIHRoaXMubGluZXNbaV0ucHVzaChjaCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5tYXhSYW5nZSgpO1xufTtcblxuLyoqXG4gKiBQcmVmaXgvU2VsZWN0L1Zpc3VhbC9TZWFyY2ggTW9kZXNcbiAqL1xuXG5UZXJtaW5hbC5wcm90b3R5cGUuZW50ZXJQcmVmaXggPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5wcmVmaXhNb2RlID0gdHJ1ZTtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5sZWF2ZVByZWZpeCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnByZWZpeE1vZGUgPSBmYWxzZTtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5lbnRlclNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yZWFsID0ge1xuICAgIHg6IHRoaXMueCxcbiAgICB5OiB0aGlzLnksXG4gICAgeWRpc3A6IHRoaXMueWRpc3AsXG4gICAgeWJhc2U6IHRoaXMueWJhc2UsXG4gICAgY3Vyc29ySGlkZGVuOiB0aGlzLmN1cnNvckhpZGRlbixcbiAgICBsaW5lczogdGhpcy5jb3B5QnVmZmVyKHRoaXMubGluZXMpLFxuICAgIHdyaXRlOiB0aGlzLndyaXRlXG4gIH07XG4gIHRoaXMud3JpdGUgPSBmdW5jdGlvbigpIHt9O1xuICB0aGlzLnNlbGVjdE1vZGUgPSB0cnVlO1xuICB0aGlzLnZpc3VhbE1vZGUgPSBmYWxzZTtcbiAgdGhpcy5jdXJzb3JIaWRkZW4gPSBmYWxzZTtcbiAgdGhpcy5yZWZyZXNoKHRoaXMueSwgdGhpcy55KTtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5sZWF2ZVNlbGVjdCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnggPSB0aGlzLl9yZWFsLng7XG4gIHRoaXMueSA9IHRoaXMuX3JlYWwueTtcbiAgdGhpcy55ZGlzcCA9IHRoaXMuX3JlYWwueWRpc3A7XG4gIHRoaXMueWJhc2UgPSB0aGlzLl9yZWFsLnliYXNlO1xuICB0aGlzLmN1cnNvckhpZGRlbiA9IHRoaXMuX3JlYWwuY3Vyc29ySGlkZGVuO1xuICB0aGlzLmxpbmVzID0gdGhpcy5fcmVhbC5saW5lcztcbiAgdGhpcy53cml0ZSA9IHRoaXMuX3JlYWwud3JpdGU7XG4gIGRlbGV0ZSB0aGlzLl9yZWFsO1xuICB0aGlzLnNlbGVjdE1vZGUgPSBmYWxzZTtcbiAgdGhpcy52aXN1YWxNb2RlID0gZmFsc2U7XG4gIHRoaXMucmVmcmVzaCgwLCB0aGlzLnJvd3MgLSAxKTtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5lbnRlclZpc3VhbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yZWFsLnByZVZpc3VhbCA9IHRoaXMuY29weUJ1ZmZlcih0aGlzLmxpbmVzKTtcbiAgdGhpcy5zZWxlY3RUZXh0KHRoaXMueCwgdGhpcy54LCB0aGlzLnlkaXNwICsgdGhpcy55LCB0aGlzLnlkaXNwICsgdGhpcy55KTtcbiAgdGhpcy52aXN1YWxNb2RlID0gdHJ1ZTtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5sZWF2ZVZpc3VhbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmxpbmVzID0gdGhpcy5fcmVhbC5wcmVWaXN1YWw7XG4gIGRlbGV0ZSB0aGlzLl9yZWFsLnByZVZpc3VhbDtcbiAgZGVsZXRlIHRoaXMuX3NlbGVjdGVkO1xuICB0aGlzLnZpc3VhbE1vZGUgPSBmYWxzZTtcbiAgdGhpcy5yZWZyZXNoKDAsIHRoaXMucm93cyAtIDEpO1xufTtcblxuVGVybWluYWwucHJvdG90eXBlLmVudGVyU2VhcmNoID0gZnVuY3Rpb24oZG93bikge1xuICB0aGlzLmVudHJ5ID0gJyc7XG4gIHRoaXMuc2VhcmNoTW9kZSA9IHRydWU7XG4gIHRoaXMuc2VhcmNoRG93biA9IGRvd247XG4gIHRoaXMuX3JlYWwucHJlU2VhcmNoID0gdGhpcy5jb3B5QnVmZmVyKHRoaXMubGluZXMpO1xuICB0aGlzLl9yZWFsLnByZVNlYXJjaFggPSB0aGlzLng7XG4gIHRoaXMuX3JlYWwucHJlU2VhcmNoWSA9IHRoaXMueTtcblxuICB2YXIgYm90dG9tID0gdGhpcy55ZGlzcCArIHRoaXMucm93cyAtIDE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5lbnRyeVByZWZpeC5sZW5ndGg7IGkrKykge1xuICAgIC8vdGhpcy5saW5lc1tib3R0b21dW2ldWzBdID0gKHRoaXMuZGVmQXR0ciAmIH4weDFmZikgfCA0O1xuICAgIC8vdGhpcy5saW5lc1tib3R0b21dW2ldWzFdID0gdGhpcy5lbnRyeVByZWZpeFtpXTtcbiAgICB0aGlzLmxpbmVzW2JvdHRvbV1baV0gPSBbXG4gICAgICAodGhpcy5kZWZBdHRyICYgfjB4MWZmKSB8IDQsXG4gICAgICB0aGlzLmVudHJ5UHJlZml4W2ldXG4gICAgXTtcbiAgfVxuXG4gIHRoaXMueSA9IHRoaXMucm93cyAtIDE7XG4gIHRoaXMueCA9IHRoaXMuZW50cnlQcmVmaXgubGVuZ3RoO1xuXG4gIHRoaXMucmVmcmVzaCh0aGlzLnJvd3MgLSAxLCB0aGlzLnJvd3MgLSAxKTtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5sZWF2ZVNlYXJjaCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNlYXJjaE1vZGUgPSBmYWxzZTtcblxuICBpZiAodGhpcy5fcmVhbC5wcmVTZWFyY2gpIHtcbiAgICB0aGlzLmxpbmVzID0gdGhpcy5fcmVhbC5wcmVTZWFyY2g7XG4gICAgdGhpcy54ID0gdGhpcy5fcmVhbC5wcmVTZWFyY2hYO1xuICAgIHRoaXMueSA9IHRoaXMuX3JlYWwucHJlU2VhcmNoWTtcbiAgICBkZWxldGUgdGhpcy5fcmVhbC5wcmVTZWFyY2g7XG4gICAgZGVsZXRlIHRoaXMuX3JlYWwucHJlU2VhcmNoWDtcbiAgICBkZWxldGUgdGhpcy5fcmVhbC5wcmVTZWFyY2hZO1xuICB9XG5cbiAgdGhpcy5yZWZyZXNoKHRoaXMucm93cyAtIDEsIHRoaXMucm93cyAtIDEpO1xufTtcblxuVGVybWluYWwucHJvdG90eXBlLmNvcHlCdWZmZXIgPSBmdW5jdGlvbihsaW5lcykge1xuICB2YXIgbGluZXMgPSBsaW5lcyB8fCB0aGlzLmxpbmVzXG4gICAgLCBvdXQgPSBbXTtcblxuICBmb3IgKHZhciB5ID0gMDsgeSA8IGxpbmVzLmxlbmd0aDsgeSsrKSB7XG4gICAgb3V0W3ldID0gW107XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBsaW5lc1t5XS5sZW5ndGg7IHgrKykge1xuICAgICAgb3V0W3ldW3hdID0gW2xpbmVzW3ldW3hdWzBdLCBsaW5lc1t5XVt4XVsxXV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5nZXRDb3B5VGV4dGFyZWEgPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHZhciB0ZXh0YXJlYSA9IHRoaXMuX2NvcHlUZXh0YXJlYVxuICAgICwgZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50O1xuXG4gIGlmICghdGV4dGFyZWEpIHtcbiAgICB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdGV4dGFyZWEuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIHRleHRhcmVhLnN0eWxlLmxlZnQgPSAnLTMyMDAwcHgnO1xuICAgIHRleHRhcmVhLnN0eWxlLnRvcCA9ICctMzIwMDBweCc7XG4gICAgdGV4dGFyZWEuc3R5bGUud2lkdGggPSAnMHB4JztcbiAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSAnMHB4JztcbiAgICB0ZXh0YXJlYS5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgIHRleHRhcmVhLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICd0cmFuc3BhcmVudCc7XG4gICAgdGV4dGFyZWEuc3R5bGUuYm9yZGVyU3R5bGUgPSAnbm9uZSc7XG4gICAgdGV4dGFyZWEuc3R5bGUub3V0bGluZVN0eWxlID0gJ25vbmUnO1xuXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXS5hcHBlbmRDaGlsZCh0ZXh0YXJlYSk7XG5cbiAgICB0aGlzLl9jb3B5VGV4dGFyZWEgPSB0ZXh0YXJlYTtcbiAgfVxuXG4gIHJldHVybiB0ZXh0YXJlYTtcbn07XG5cbi8vIE5PVEU6IE9ubHkgd29ya3MgZm9yIHByaW1hcnkgc2VsZWN0aW9uIG9uIFgxMS5cbi8vIE5vbi1YMTEgdXNlcnMgc2hvdWxkIHVzZSBDdHJsLUMgaW5zdGVhZC5cblRlcm1pbmFsLnByb3RvdHlwZS5jb3B5VGV4dCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB0ZXh0YXJlYSA9IHRoaXMuZ2V0Q29weVRleHRhcmVhKCk7XG5cbiAgdGhpcy5lbWl0KCdjb3B5JywgdGV4dCk7XG5cbiAgdGV4dGFyZWEuZm9jdXMoKTtcbiAgdGV4dGFyZWEudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB0ZXh0YXJlYS52YWx1ZSA9IHRleHQ7XG4gIHRleHRhcmVhLnNldFNlbGVjdGlvblJhbmdlKDAsIHRleHQubGVuZ3RoKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZWxlbWVudC5mb2N1cygpO1xuICAgIHNlbGYuZm9jdXMoKTtcbiAgfSwgMSk7XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUuc2VsZWN0VGV4dCA9IGZ1bmN0aW9uKHgxLCB4MiwgeTEsIHkyKSB7XG4gIHZhciBveDFcbiAgICAsIG94MlxuICAgICwgb3kxXG4gICAgLCBveTJcbiAgICAsIHRtcFxuICAgICwgeFxuICAgICwgeVxuICAgICwgeGxcbiAgICAsIGF0dHI7XG5cbiAgaWYgKHRoaXMuX3NlbGVjdGVkKSB7XG4gICAgb3gxID0gdGhpcy5fc2VsZWN0ZWQueDE7XG4gICAgb3gyID0gdGhpcy5fc2VsZWN0ZWQueDI7XG4gICAgb3kxID0gdGhpcy5fc2VsZWN0ZWQueTE7XG4gICAgb3kyID0gdGhpcy5fc2VsZWN0ZWQueTI7XG5cbiAgICBpZiAob3kyIDwgb3kxKSB7XG4gICAgICB0bXAgPSBveDI7XG4gICAgICBveDIgPSBveDE7XG4gICAgICBveDEgPSB0bXA7XG4gICAgICB0bXAgPSBveTI7XG4gICAgICBveTIgPSBveTE7XG4gICAgICBveTEgPSB0bXA7XG4gICAgfVxuXG4gICAgaWYgKG94MiA8IG94MSAmJiBveTEgPT09IG95Mikge1xuICAgICAgdG1wID0gb3gyO1xuICAgICAgb3gyID0gb3gxO1xuICAgICAgb3gxID0gdG1wO1xuICAgIH1cblxuICAgIGZvciAoeSA9IG95MTsgeSA8PSBveTI7IHkrKykge1xuICAgICAgeCA9IDA7XG4gICAgICB4bCA9IHRoaXMuY29scyAtIDE7XG4gICAgICBpZiAoeSA9PT0gb3kxKSB7XG4gICAgICAgIHggPSBveDE7XG4gICAgICB9XG4gICAgICBpZiAoeSA9PT0gb3kyKSB7XG4gICAgICAgIHhsID0gb3gyO1xuICAgICAgfVxuICAgICAgZm9yICg7IHggPD0geGw7IHgrKykge1xuICAgICAgICBpZiAodGhpcy5saW5lc1t5XVt4XS5vbGQgIT0gbnVsbCkge1xuICAgICAgICAgIC8vdGhpcy5saW5lc1t5XVt4XVswXSA9IHRoaXMubGluZXNbeV1beF0ub2xkO1xuICAgICAgICAgIC8vZGVsZXRlIHRoaXMubGluZXNbeV1beF0ub2xkO1xuICAgICAgICAgIGF0dHIgPSB0aGlzLmxpbmVzW3ldW3hdLm9sZDtcbiAgICAgICAgICBkZWxldGUgdGhpcy5saW5lc1t5XVt4XS5vbGQ7XG4gICAgICAgICAgdGhpcy5saW5lc1t5XVt4XSA9IFthdHRyLCB0aGlzLmxpbmVzW3ldW3hdWzFdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHkxID0gdGhpcy5fc2VsZWN0ZWQueTE7XG4gICAgeDEgPSB0aGlzLl9zZWxlY3RlZC54MTtcbiAgfVxuXG4gIHkxID0gTWF0aC5tYXgoeTEsIDApO1xuICB5MSA9IE1hdGgubWluKHkxLCB0aGlzLnlkaXNwICsgdGhpcy5yb3dzIC0gMSk7XG5cbiAgeTIgPSBNYXRoLm1heCh5MiwgMCk7XG4gIHkyID0gTWF0aC5taW4oeTIsIHRoaXMueWRpc3AgKyB0aGlzLnJvd3MgLSAxKTtcblxuICB0aGlzLl9zZWxlY3RlZCA9IHsgeDE6IHgxLCB4MjogeDIsIHkxOiB5MSwgeTI6IHkyIH07XG5cbiAgaWYgKHkyIDwgeTEpIHtcbiAgICB0bXAgPSB4MjtcbiAgICB4MiA9IHgxO1xuICAgIHgxID0gdG1wO1xuICAgIHRtcCA9IHkyO1xuICAgIHkyID0geTE7XG4gICAgeTEgPSB0bXA7XG4gIH1cblxuICBpZiAoeDIgPCB4MSAmJiB5MSA9PT0geTIpIHtcbiAgICB0bXAgPSB4MjtcbiAgICB4MiA9IHgxO1xuICAgIHgxID0gdG1wO1xuICB9XG5cbiAgZm9yICh5ID0geTE7IHkgPD0geTI7IHkrKykge1xuICAgIHggPSAwO1xuICAgIHhsID0gdGhpcy5jb2xzIC0gMTtcbiAgICBpZiAoeSA9PT0geTEpIHtcbiAgICAgIHggPSB4MTtcbiAgICB9XG4gICAgaWYgKHkgPT09IHkyKSB7XG4gICAgICB4bCA9IHgyO1xuICAgIH1cbiAgICBmb3IgKDsgeCA8PSB4bDsgeCsrKSB7XG4gICAgICAvL3RoaXMubGluZXNbeV1beF0ub2xkID0gdGhpcy5saW5lc1t5XVt4XVswXTtcbiAgICAgIC8vdGhpcy5saW5lc1t5XVt4XVswXSAmPSB+MHgxZmY7XG4gICAgICAvL3RoaXMubGluZXNbeV1beF1bMF0gfD0gKDB4MWZmIDw8IDkpIHwgNDtcbiAgICAgIGF0dHIgPSB0aGlzLmxpbmVzW3ldW3hdWzBdO1xuICAgICAgdGhpcy5saW5lc1t5XVt4XSA9IFtcbiAgICAgICAgKGF0dHIgJiB+MHgxZmYpIHwgKCgweDFmZiA8PCA5KSB8IDQpLFxuICAgICAgICB0aGlzLmxpbmVzW3ldW3hdWzFdXG4gICAgICBdO1xuICAgICAgdGhpcy5saW5lc1t5XVt4XS5vbGQgPSBhdHRyO1xuICAgIH1cbiAgfVxuXG4gIHkxID0geTEgLSB0aGlzLnlkaXNwO1xuICB5MiA9IHkyIC0gdGhpcy55ZGlzcDtcblxuICB5MSA9IE1hdGgubWF4KHkxLCAwKTtcbiAgeTEgPSBNYXRoLm1pbih5MSwgdGhpcy5yb3dzIC0gMSk7XG5cbiAgeTIgPSBNYXRoLm1heCh5MiwgMCk7XG4gIHkyID0gTWF0aC5taW4oeTIsIHRoaXMucm93cyAtIDEpO1xuXG4gIC8vdGhpcy5yZWZyZXNoKHkxLCB5Mik7XG4gIHRoaXMucmVmcmVzaCgwLCB0aGlzLnJvd3MgLSAxKTtcbn07XG5cblRlcm1pbmFsLnByb3RvdHlwZS5ncmFiVGV4dCA9IGZ1bmN0aW9uKHgxLCB4MiwgeTEsIHkyKSB7XG4gIHZhciBvdXQgPSAnJ1xuICAgICwgYnVmID0gJydcbiAgICAsIGNoXG4gICAgLCB4XG4gICAgLCB5XG4gICAgLCB4bFxuICAgICwgdG1wO1xuXG4gIGlmICh5MiA8IHkxKSB7XG4gICAgdG1wID0geDI7XG4gICAgeDIgPSB4MTtcbiAgICB4MSA9IHRtcDtcbiAgICB0bXAgPSB5MjtcbiAgICB5MiA9IHkxO1xuICAgIHkxID0gdG1wO1xuICB9XG5cbiAgaWYgKHgyIDwgeDEgJiYgeTEgPT09IHkyKSB7XG4gICAgdG1wID0geDI7XG4gICAgeDIgPSB4MTtcbiAgICB4MSA9IHRtcDtcbiAgfVxuXG4gIGZvciAoeSA9IHkxOyB5IDw9IHkyOyB5KyspIHtcbiAgICB4ID0gMDtcbiAgICB4bCA9IHRoaXMuY29scyAtIDE7XG4gICAgaWYgKHkgPT09IHkxKSB7XG4gICAgICB4ID0geDE7XG4gICAgfVxuICAgIGlmICh5ID09PSB5Mikge1xuICAgICAgeGwgPSB4MjtcbiAgICB9XG4gICAgZm9yICg7IHggPD0geGw7IHgrKykge1xuICAgICAgY2ggPSB0aGlzLmxpbmVzW3ldW3hdWzFdO1xuICAgICAgaWYgKGNoID09PSAnICcpIHtcbiAgICAgICAgYnVmICs9IGNoO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChidWYpIHtcbiAgICAgICAgb3V0ICs9IGJ1ZjtcbiAgICAgICAgYnVmID0gJyc7XG4gICAgICB9XG4gICAgICBvdXQgKz0gY2g7XG4gICAgICBpZiAoaXNXaWRlKGNoKSkgeCsrO1xuICAgIH1cbiAgICBidWYgPSAnJztcbiAgICBvdXQgKz0gJ1xcbic7XG4gIH1cblxuICAvLyBJZiB3ZSdyZSBub3QgYXQgdGhlIGVuZCBvZiB0aGVcbiAgLy8gbGluZSwgZG9uJ3QgYWRkIGEgbmV3bGluZS5cbiAgZm9yICh4ID0geDIsIHkgPSB5MjsgeCA8IHRoaXMuY29sczsgeCsrKSB7XG4gICAgaWYgKHRoaXMubGluZXNbeV1beF1bMV0gIT09ICcgJykge1xuICAgICAgb3V0ID0gb3V0LnNsaWNlKDAsIC0xKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUua2V5UHJlZml4ID0gZnVuY3Rpb24oZXYsIGtleSkge1xuICBpZiAoa2V5ID09PSAnaycgfHwga2V5ID09PSAnJicpIHtcbiAgICB0aGlzLmRlc3Ryb3koKTtcbiAgfSBlbHNlIGlmIChrZXkgPT09ICdwJyB8fCBrZXkgPT09ICddJykge1xuICAgIHRoaXMuZW1pdCgncmVxdWVzdCBwYXN0ZScpO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gJ2MnKSB7XG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0IGNyZWF0ZScpO1xuICB9IGVsc2UgaWYgKGtleSA+PSAnMCcgJiYga2V5IDw9ICc5Jykge1xuICAgIGtleSA9ICtrZXkgLSAxO1xuICAgIGlmICghfmtleSkga2V5ID0gOTtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3QgdGVybScsIGtleSk7XG4gIH0gZWxzZSBpZiAoa2V5ID09PSAnbicpIHtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3QgdGVybSBuZXh0Jyk7XG4gIH0gZWxzZSBpZiAoa2V5ID09PSAnUCcpIHtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3QgdGVybSBwcmV2aW91cycpO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gJzonKSB7XG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0IGNvbW1hbmQgbW9kZScpO1xuICB9IGVsc2UgaWYgKGtleSA9PT0gJ1snKSB7XG4gICAgdGhpcy5lbnRlclNlbGVjdCgpO1xuICB9XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUua2V5U2VsZWN0ID0gZnVuY3Rpb24oZXYsIGtleSkge1xuICB0aGlzLnNob3dDdXJzb3IoKTtcblxuICBpZiAodGhpcy5zZWFyY2hNb2RlIHx8IGtleSA9PT0gJ24nIHx8IGtleSA9PT0gJ04nKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5U2VhcmNoKGV2LCBrZXkpO1xuICB9XG5cbiAgaWYgKGtleSA9PT0gJ1xceDA0JykgeyAvLyBjdHJsLWRcbiAgICB2YXIgeSA9IHRoaXMueWRpc3AgKyB0aGlzLnk7XG4gICAgaWYgKHRoaXMueWRpc3AgPT09IHRoaXMueWJhc2UpIHtcbiAgICAgIC8vIE1pbWljIHZpbSBiZWhhdmlvclxuICAgICAgdGhpcy55ID0gTWF0aC5taW4odGhpcy55ICsgKHRoaXMucm93cyAtIDEpIC8gMiB8IDAsIHRoaXMucm93cyAtIDEpO1xuICAgICAgdGhpcy5yZWZyZXNoKDAsIHRoaXMucm93cyAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjcm9sbERpc3AoKHRoaXMucm93cyAtIDEpIC8gMiB8IDApO1xuICAgIH1cbiAgICBpZiAodGhpcy52aXN1YWxNb2RlKSB7XG4gICAgICB0aGlzLnNlbGVjdFRleHQodGhpcy54LCB0aGlzLngsIHksIHRoaXMueWRpc3AgKyB0aGlzLnkpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09PSAnXFx4MTUnKSB7IC8vIGN0cmwtdVxuICAgIHZhciB5ID0gdGhpcy55ZGlzcCArIHRoaXMueTtcbiAgICBpZiAodGhpcy55ZGlzcCA9PT0gMCkge1xuICAgICAgLy8gTWltaWMgdmltIGJlaGF2aW9yXG4gICAgICB0aGlzLnkgPSBNYXRoLm1heCh0aGlzLnkgLSAodGhpcy5yb3dzIC0gMSkgLyAyIHwgMCwgMCk7XG4gICAgICB0aGlzLnJlZnJlc2goMCwgdGhpcy5yb3dzIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2Nyb2xsRGlzcCgtKHRoaXMucm93cyAtIDEpIC8gMiB8IDApO1xuICAgIH1cbiAgICBpZiAodGhpcy52aXN1YWxNb2RlKSB7XG4gICAgICB0aGlzLnNlbGVjdFRleHQodGhpcy54LCB0aGlzLngsIHksIHRoaXMueWRpc3AgKyB0aGlzLnkpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09PSAnXFx4MDYnKSB7IC8vIGN0cmwtZlxuICAgIHZhciB5ID0gdGhpcy55ZGlzcCArIHRoaXMueTtcbiAgICB0aGlzLnNjcm9sbERpc3AodGhpcy5yb3dzIC0gMSk7XG4gICAgaWYgKHRoaXMudmlzdWFsTW9kZSkge1xuICAgICAgdGhpcy5zZWxlY3RUZXh0KHRoaXMueCwgdGhpcy54LCB5LCB0aGlzLnlkaXNwICsgdGhpcy55KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PT0gJ1xceDAyJykgeyAvLyBjdHJsLWJcbiAgICB2YXIgeSA9IHRoaXMueWRpc3AgKyB0aGlzLnk7XG4gICAgdGhpcy5zY3JvbGxEaXNwKC0odGhpcy5yb3dzIC0gMSkpO1xuICAgIGlmICh0aGlzLnZpc3VhbE1vZGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0VGV4dCh0aGlzLngsIHRoaXMueCwgeSwgdGhpcy55ZGlzcCArIHRoaXMueSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT09ICdrJyB8fCBrZXkgPT09ICdcXHgxYltBJykge1xuICAgIHZhciB5ID0gdGhpcy55ZGlzcCArIHRoaXMueTtcbiAgICB0aGlzLnktLTtcbiAgICBpZiAodGhpcy55IDwgMCkge1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIHRoaXMuc2Nyb2xsRGlzcCgtMSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnZpc3VhbE1vZGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0VGV4dCh0aGlzLngsIHRoaXMueCwgeSwgdGhpcy55ZGlzcCArIHRoaXMueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVmcmVzaCh0aGlzLnksIHRoaXMueSArIDEpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09PSAnaicgfHwga2V5ID09PSAnXFx4MWJbQicpIHtcbiAgICB2YXIgeSA9IHRoaXMueWRpc3AgKyB0aGlzLnk7XG4gICAgdGhpcy55Kys7XG4gICAgaWYgKHRoaXMueSA+PSB0aGlzLnJvd3MpIHtcbiAgICAgIHRoaXMueSA9IHRoaXMucm93cyAtIDE7XG4gICAgICB0aGlzLnNjcm9sbERpc3AoMSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnZpc3VhbE1vZGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0VGV4dCh0aGlzLngsIHRoaXMueCwgeSwgdGhpcy55ZGlzcCArIHRoaXMueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVmcmVzaCh0aGlzLnkgLSAxLCB0aGlzLnkpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09PSAnaCcgfHwga2V5ID09PSAnXFx4MWJbRCcpIHtcbiAgICB2YXIgeCA9IHRoaXMueDtcbiAgICB0aGlzLngtLTtcbiAgICBpZiAodGhpcy54IDwgMCkge1xuICAgICAgdGhpcy54ID0gMDtcbiAgICB9XG4gICAgaWYgKHRoaXMudmlzdWFsTW9kZSkge1xuICAgICAgdGhpcy5zZWxlY3RUZXh0KHgsIHRoaXMueCwgdGhpcy55ZGlzcCArIHRoaXMueSwgdGhpcy55ZGlzcCArIHRoaXMueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVmcmVzaCh0aGlzLnksIHRoaXMueSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT09ICdsJyB8fCBrZXkgPT09ICdcXHgxYltDJykge1xuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHRoaXMueCsrO1xuICAgIGlmICh0aGlzLnggPj0gdGhpcy5jb2xzKSB7XG4gICAgICB0aGlzLnggPSB0aGlzLmNvbHMgLSAxO1xuICAgIH1cbiAgICBpZiAodGhpcy52aXN1YWxNb2RlKSB7XG4gICAgICB0aGlzLnNlbGVjdFRleHQoeCwgdGhpcy54LCB0aGlzLnlkaXNwICsgdGhpcy55LCB0aGlzLnlkaXNwICsgdGhpcy55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWZyZXNoKHRoaXMueSwgdGhpcy55KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PT0gJ3YnIHx8IGtleSA9PT0gJyAnKSB7XG4gICAgaWYgKCF0aGlzLnZpc3VhbE1vZGUpIHtcbiAgICAgIHRoaXMuZW50ZXJWaXN1YWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sZWF2ZVZpc3VhbCgpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09PSAneScpIHtcbiAgICBpZiAodGhpcy52aXN1YWxNb2RlKSB7XG4gICAgICB2YXIgdGV4dCA9IHRoaXMuZ3JhYlRleHQoXG4gICAgICAgIHRoaXMuX3NlbGVjdGVkLngxLCB0aGlzLl9zZWxlY3RlZC54MixcbiAgICAgICAgdGhpcy5fc2VsZWN0ZWQueTEsIHRoaXMuX3NlbGVjdGVkLnkyKTtcbiAgICAgIHRoaXMuY29weVRleHQodGV4dCk7XG4gICAgICB0aGlzLmxlYXZlVmlzdWFsKCk7XG4gICAgICAvLyB0aGlzLmxlYXZlU2VsZWN0KCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT09ICdxJyB8fCBrZXkgPT09ICdcXHgxYicpIHtcbiAgICBpZiAodGhpcy52aXN1YWxNb2RlKSB7XG4gICAgICB0aGlzLmxlYXZlVmlzdWFsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVhdmVTZWxlY3QoKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PT0gJ3cnIHx8IGtleSA9PT0gJ1cnKSB7XG4gICAgdmFyIG94ID0gdGhpcy54O1xuICAgIHZhciBveSA9IHRoaXMueTtcbiAgICB2YXIgb3lkID0gdGhpcy55ZGlzcDtcblxuICAgIHZhciB4ID0gdGhpcy54O1xuICAgIHZhciB5ID0gdGhpcy55O1xuICAgIHZhciB5YiA9IHRoaXMueWRpc3A7XG4gICAgdmFyIHNhd19zcGFjZSA9IGZhbHNlO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW3liICsgeV07XG4gICAgICB3aGlsZSAoeCA8IHRoaXMuY29scykge1xuICAgICAgICBpZiAobGluZVt4XVsxXSA8PSAnICcpIHtcbiAgICAgICAgICBzYXdfc3BhY2UgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHNhd19zcGFjZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHgrKztcbiAgICAgIH1cbiAgICAgIGlmICh4ID49IHRoaXMuY29scykgeCA9IHRoaXMuY29scyAtIDE7XG4gICAgICBpZiAoeCA9PT0gdGhpcy5jb2xzIC0gMSAmJiBsaW5lW3hdWzFdIDw9ICcgJykge1xuICAgICAgICB4ID0gMDtcbiAgICAgICAgaWYgKCsreSA+PSB0aGlzLnJvd3MpIHtcbiAgICAgICAgICB5LS07XG4gICAgICAgICAgaWYgKCsreWIgPiB0aGlzLnliYXNlKSB7XG4gICAgICAgICAgICB5YiA9IHRoaXMueWJhc2U7XG4gICAgICAgICAgICB4ID0gdGhpcy54O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy54ID0geCwgdGhpcy55ID0geTtcbiAgICB0aGlzLnNjcm9sbERpc3AoLXRoaXMueWRpc3AgKyB5Yik7XG5cbiAgICBpZiAodGhpcy52aXN1YWxNb2RlKSB7XG4gICAgICB0aGlzLnNlbGVjdFRleHQob3gsIHRoaXMueCwgb3kgKyBveWQsIHRoaXMueWRpc3AgKyB0aGlzLnkpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09PSAnYicgfHwga2V5ID09PSAnQicpIHtcbiAgICB2YXIgb3ggPSB0aGlzLng7XG4gICAgdmFyIG95ID0gdGhpcy55O1xuICAgIHZhciBveWQgPSB0aGlzLnlkaXNwO1xuXG4gICAgdmFyIHggPSB0aGlzLng7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHliID0gdGhpcy55ZGlzcDtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1t5YiArIHldO1xuICAgICAgdmFyIHNhd19zcGFjZSA9IHggPiAwICYmIGxpbmVbeF1bMV0gPiAnICcgJiYgbGluZVt4IC0gMV1bMV0gPiAnICc7XG4gICAgICB3aGlsZSAoeCA+PSAwKSB7XG4gICAgICAgIGlmIChsaW5lW3hdWzFdIDw9ICcgJykge1xuICAgICAgICAgIGlmIChzYXdfc3BhY2UgJiYgKHggKyAxIDwgdGhpcy5jb2xzICYmIGxpbmVbeCArIDFdWzFdID4gJyAnKSkge1xuICAgICAgICAgICAgeCsrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNhd19zcGFjZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHgtLTtcbiAgICAgIH1cbiAgICAgIGlmICh4IDwgMCkgeCA9IDA7XG4gICAgICBpZiAoeCA9PT0gMCAmJiAobGluZVt4XVsxXSA8PSAnICcgfHwgIXNhd19zcGFjZSkpIHtcbiAgICAgICAgeCA9IHRoaXMuY29scyAtIDE7XG4gICAgICAgIGlmICgtLXkgPCAwKSB7XG4gICAgICAgICAgeSsrO1xuICAgICAgICAgIGlmICgtLXliIDwgMCkge1xuICAgICAgICAgICAgeWIrKztcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy54ID0geCwgdGhpcy55ID0geTtcbiAgICB0aGlzLnNjcm9sbERpc3AoLXRoaXMueWRpc3AgKyB5Yik7XG5cbiAgICBpZiAodGhpcy52aXN1YWxNb2RlKSB7XG4gICAgICB0aGlzLnNlbGVjdFRleHQob3gsIHRoaXMueCwgb3kgKyBveWQsIHRoaXMueWRpc3AgKyB0aGlzLnkpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09PSAnZScgfHwga2V5ID09PSAnRScpIHtcbiAgICB2YXIgeCA9IHRoaXMueCArIDE7XG4gICAgdmFyIHkgPSB0aGlzLnk7XG4gICAgdmFyIHliID0gdGhpcy55ZGlzcDtcbiAgICBpZiAoeCA+PSB0aGlzLmNvbHMpIHgtLTtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1t5YiArIHldO1xuICAgICAgd2hpbGUgKHggPCB0aGlzLmNvbHMpIHtcbiAgICAgICAgaWYgKGxpbmVbeF1bMV0gPD0gJyAnKSB7XG4gICAgICAgICAgeCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3aGlsZSAoeCA8IHRoaXMuY29scykge1xuICAgICAgICBpZiAobGluZVt4XVsxXSA8PSAnICcpIHtcbiAgICAgICAgICBpZiAoeCAtIDEgPj0gMCAmJiBsaW5lW3ggLSAxXVsxXSA+ICcgJykge1xuICAgICAgICAgICAgeC0tO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHgrKztcbiAgICAgIH1cbiAgICAgIGlmICh4ID49IHRoaXMuY29scykgeCA9IHRoaXMuY29scyAtIDE7XG4gICAgICBpZiAoeCA9PT0gdGhpcy5jb2xzIC0gMSAmJiBsaW5lW3hdWzFdIDw9ICcgJykge1xuICAgICAgICB4ID0gMDtcbiAgICAgICAgaWYgKCsreSA+PSB0aGlzLnJvd3MpIHtcbiAgICAgICAgICB5LS07XG4gICAgICAgICAgaWYgKCsreWIgPiB0aGlzLnliYXNlKSB7XG4gICAgICAgICAgICB5YiA9IHRoaXMueWJhc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLnggPSB4LCB0aGlzLnkgPSB5O1xuICAgIHRoaXMuc2Nyb2xsRGlzcCgtdGhpcy55ZGlzcCArIHliKTtcblxuICAgIGlmICh0aGlzLnZpc3VhbE1vZGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0VGV4dChveCwgdGhpcy54LCBveSArIG95ZCwgdGhpcy55ZGlzcCArIHRoaXMueSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT09ICdeJyB8fCBrZXkgPT09ICcwJykge1xuICAgIHZhciBveCA9IHRoaXMueDtcblxuICAgIGlmIChrZXkgPT09ICcwJykge1xuICAgICAgdGhpcy54ID0gMDtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ14nKSB7XG4gICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbdGhpcy55ZGlzcCArIHRoaXMueV07XG4gICAgICB2YXIgeCA9IDA7XG4gICAgICB3aGlsZSAoeCA8IHRoaXMuY29scykge1xuICAgICAgICBpZiAobGluZVt4XVsxXSA+ICcgJykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHgrKztcbiAgICAgIH1cbiAgICAgIGlmICh4ID49IHRoaXMuY29scykgeCA9IHRoaXMuY29scyAtIDE7XG4gICAgICB0aGlzLnggPSB4O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnZpc3VhbE1vZGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0VGV4dChveCwgdGhpcy54LCB0aGlzLnlkaXNwICsgdGhpcy55LCB0aGlzLnlkaXNwICsgdGhpcy55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWZyZXNoKHRoaXMueSwgdGhpcy55KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PT0gJyQnKSB7XG4gICAgdmFyIG94ID0gdGhpcy54O1xuICAgIHZhciBsaW5lID0gdGhpcy5saW5lc1t0aGlzLnlkaXNwICsgdGhpcy55XTtcbiAgICB2YXIgeCA9IHRoaXMuY29scyAtIDE7XG4gICAgd2hpbGUgKHggPj0gMCkge1xuICAgICAgaWYgKGxpbmVbeF1bMV0gPiAnICcpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzdWFsTW9kZSAmJiB4IDwgdGhpcy5jb2xzIC0gMSkgeCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHgtLTtcbiAgICB9XG4gICAgaWYgKHggPCAwKSB4ID0gMDtcbiAgICB0aGlzLnggPSB4O1xuICAgIGlmICh0aGlzLnZpc3VhbE1vZGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0VGV4dChveCwgdGhpcy54LCB0aGlzLnlkaXNwICsgdGhpcy55LCB0aGlzLnlkaXNwICsgdGhpcy55KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWZyZXNoKHRoaXMueSwgdGhpcy55KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PT0gJ2cnIHx8IGtleSA9PT0gJ0cnKSB7XG4gICAgdmFyIG94ID0gdGhpcy54O1xuICAgIHZhciBveSA9IHRoaXMueTtcbiAgICB2YXIgb3lkID0gdGhpcy55ZGlzcDtcbiAgICBpZiAoa2V5ID09PSAnZycpIHtcbiAgICAgIHRoaXMueCA9IDAsIHRoaXMueSA9IDA7XG4gICAgICB0aGlzLnNjcm9sbERpc3AoLXRoaXMueWRpc3ApO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnRycpIHtcbiAgICAgIHRoaXMueCA9IDAsIHRoaXMueSA9IHRoaXMucm93cyAtIDE7XG4gICAgICB0aGlzLnNjcm9sbERpc3AodGhpcy55YmFzZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnZpc3VhbE1vZGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0VGV4dChveCwgdGhpcy54LCBveSArIG95ZCwgdGhpcy55ZGlzcCArIHRoaXMueSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT09ICdIJyB8fCBrZXkgPT09ICdNJyB8fCBrZXkgPT09ICdMJykge1xuICAgIHZhciBveCA9IHRoaXMueDtcbiAgICB2YXIgb3kgPSB0aGlzLnk7XG4gICAgaWYgKGtleSA9PT0gJ0gnKSB7XG4gICAgICB0aGlzLnggPSAwLCB0aGlzLnkgPSAwO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnTScpIHtcbiAgICAgIHRoaXMueCA9IDAsIHRoaXMueSA9IHRoaXMucm93cyAvIDIgfCAwO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnTCcpIHtcbiAgICAgIHRoaXMueCA9IDAsIHRoaXMueSA9IHRoaXMucm93cyAtIDE7XG4gICAgfVxuICAgIGlmICh0aGlzLnZpc3VhbE1vZGUpIHtcbiAgICAgIHRoaXMuc2VsZWN0VGV4dChveCwgdGhpcy54LCB0aGlzLnlkaXNwICsgb3ksIHRoaXMueWRpc3AgKyB0aGlzLnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZnJlc2gob3ksIG95KTtcbiAgICAgIHRoaXMucmVmcmVzaCh0aGlzLnksIHRoaXMueSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT09ICd7JyB8fCBrZXkgPT09ICd9Jykge1xuICAgIHZhciBveCA9IHRoaXMueDtcbiAgICB2YXIgb3kgPSB0aGlzLnk7XG4gICAgdmFyIG95ZCA9IHRoaXMueWRpc3A7XG5cbiAgICB2YXIgbGluZTtcbiAgICB2YXIgc2F3X2Z1bGwgPSBmYWxzZTtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICB2YXIgZmlyc3RfaXNfc3BhY2UgPSAtMTtcbiAgICB2YXIgeSA9IHRoaXMueSArIChrZXkgPT09ICd7JyA/IC0xIDogMSk7XG4gICAgdmFyIHliID0gdGhpcy55ZGlzcDtcbiAgICB2YXIgaTtcblxuICAgIGlmIChrZXkgPT09ICd7Jykge1xuICAgICAgaWYgKHkgPCAwKSB7XG4gICAgICAgIHkrKztcbiAgICAgICAgaWYgKHliID4gMCkgeWItLTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ30nKSB7XG4gICAgICBpZiAoeSA+PSB0aGlzLnJvd3MpIHtcbiAgICAgICAgeS0tO1xuICAgICAgICBpZiAoeWIgPCB0aGlzLnliYXNlKSB5YisrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOzspIHtcbiAgICAgIGxpbmUgPSB0aGlzLmxpbmVzW3liICsgeV07XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbHM7IGkrKykge1xuICAgICAgICBpZiAobGluZVtpXVsxXSA+ICcgJykge1xuICAgICAgICAgIGlmIChmaXJzdF9pc19zcGFjZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGZpcnN0X2lzX3NwYWNlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2F3X2Z1bGwgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKGkgPT09IHRoaXMuY29scyAtIDEpIHtcbiAgICAgICAgICBpZiAoZmlyc3RfaXNfc3BhY2UgPT09IC0xKSB7XG4gICAgICAgICAgICBmaXJzdF9pc19zcGFjZSA9IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaXJzdF9pc19zcGFjZSA9PT0gMCkge1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZmlyc3RfaXNfc3BhY2UgPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChzYXdfZnVsbCkgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmQpIGJyZWFrO1xuXG4gICAgICBpZiAoa2V5ID09PSAneycpIHtcbiAgICAgICAgeS0tO1xuICAgICAgICBpZiAoeSA8IDApIHtcbiAgICAgICAgICB5Kys7XG4gICAgICAgICAgaWYgKHliID4gMCkgeWItLTtcbiAgICAgICAgICBlbHNlIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ30nKSB7XG4gICAgICAgIHkrKztcbiAgICAgICAgaWYgKHkgPj0gdGhpcy5yb3dzKSB7XG4gICAgICAgICAgeS0tO1xuICAgICAgICAgIGlmICh5YiA8IHRoaXMueWJhc2UpIHliKys7XG4gICAgICAgICAgZWxzZSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZm91bmQpIHtcbiAgICAgIGlmIChrZXkgPT09ICd7Jykge1xuICAgICAgICB5ID0gMDtcbiAgICAgICAgeWIgPSAwO1xuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICd9Jykge1xuICAgICAgICB5ID0gdGhpcy5yb3dzIC0gMTtcbiAgICAgICAgeWIgPSB0aGlzLnliYXNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMueCA9IDAsIHRoaXMueSA9IHk7XG4gICAgdGhpcy5zY3JvbGxEaXNwKC10aGlzLnlkaXNwICsgeWIpO1xuXG4gICAgaWYgKHRoaXMudmlzdWFsTW9kZSkge1xuICAgICAgdGhpcy5zZWxlY3RUZXh0KG94LCB0aGlzLngsIG95ICsgb3lkLCB0aGlzLnlkaXNwICsgdGhpcy55KTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGtleSA9PT0gJy8nIHx8IGtleSA9PT0gJz8nKSB7XG4gICAgaWYgKCF0aGlzLnZpc3VhbE1vZGUpIHtcbiAgICAgIHRoaXMuZW50ZXJTZWFyY2goa2V5ID09PSAnLycpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5UZXJtaW5hbC5wcm90b3R5cGUua2V5U2VhcmNoID0gZnVuY3Rpb24oZXYsIGtleSkge1xuICBpZiAoa2V5ID09PSAnXFx4MWInKSB7XG4gICAgdGhpcy5sZWF2ZVNlYXJjaCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkgPT09ICdcXHInIHx8ICghdGhpcy5zZWFyY2hNb2RlICYmIChrZXkgPT09ICduJyB8fCBrZXkgPT09ICdOJykpKSB7XG4gICAgdGhpcy5sZWF2ZVNlYXJjaCgpO1xuXG4gICAgdmFyIGVudHJ5ID0gdGhpcy5lbnRyeTtcblxuICAgIGlmICghZW50cnkpIHtcbiAgICAgIHRoaXMucmVmcmVzaCgwLCB0aGlzLnJvd3MgLSAxKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3ggPSB0aGlzLng7XG4gICAgdmFyIG95ID0gdGhpcy55O1xuICAgIHZhciBveWQgPSB0aGlzLnlkaXNwO1xuXG4gICAgdmFyIGxpbmU7XG4gICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgdmFyIHdyYXBwZWQgPSBmYWxzZTtcbiAgICB2YXIgeCA9IHRoaXMueCArIDE7XG4gICAgdmFyIHkgPSB0aGlzLnlkaXNwICsgdGhpcy55O1xuICAgIHZhciB5YiwgaTtcbiAgICB2YXIgdXAgPSBrZXkgPT09ICdOJ1xuICAgICAgPyB0aGlzLnNlYXJjaERvd25cbiAgICAgIDogIXRoaXMuc2VhcmNoRG93bjtcblxuICAgIGZvciAoOzspIHtcbiAgICAgIGxpbmUgPSB0aGlzLmxpbmVzW3ldO1xuXG4gICAgICB3aGlsZSAoeCA8IHRoaXMuY29scykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZW50cnkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoeCArIGkgPj0gdGhpcy5jb2xzKSBicmVhaztcbiAgICAgICAgICBpZiAobGluZVt4ICsgaV1bMV0gIT09IGVudHJ5W2ldKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmVbeCArIGldWzFdID09PSBlbnRyeVtpXSAmJiBpID09PSBlbnRyeS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kKSBicmVhaztcbiAgICAgICAgeCArPSBpICsgMTtcbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgYnJlYWs7XG5cbiAgICAgIHggPSAwO1xuXG4gICAgICBpZiAoIXVwKSB7XG4gICAgICAgIHkrKztcbiAgICAgICAgaWYgKHkgPiB0aGlzLnliYXNlICsgdGhpcy5yb3dzIC0gMSkge1xuICAgICAgICAgIGlmICh3cmFwcGVkKSBicmVhaztcbiAgICAgICAgICAvLyB0aGlzLnNldE1lc3NhZ2UoJ1NlYXJjaCB3cmFwcGVkLiBDb250aW51aW5nIGF0IFRPUC4nKTtcbiAgICAgICAgICB3cmFwcGVkID0gdHJ1ZTtcbiAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS0tO1xuICAgICAgICBpZiAoeSA8IDApIHtcbiAgICAgICAgICBpZiAod3JhcHBlZCkgYnJlYWs7XG4gICAgICAgICAgLy8gdGhpcy5zZXRNZXNzYWdlKCdTZWFyY2ggd3JhcHBlZC4gQ29udGludWluZyBhdCBCT1RUT00uJyk7XG4gICAgICAgICAgd3JhcHBlZCA9IHRydWU7XG4gICAgICAgICAgeSA9IHRoaXMueWJhc2UgKyB0aGlzLnJvd3MgLSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICBpZiAoeSAtIHRoaXMueWJhc2UgPCAwKSB7XG4gICAgICAgIHliID0geTtcbiAgICAgICAgeSA9IDA7XG4gICAgICAgIGlmICh5YiA+IHRoaXMueWJhc2UpIHtcbiAgICAgICAgICB5ID0geWIgLSB0aGlzLnliYXNlO1xuICAgICAgICAgIHliID0gdGhpcy55YmFzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWIgPSB0aGlzLnliYXNlO1xuICAgICAgICB5IC09IHRoaXMueWJhc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMueCA9IHgsIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLnNjcm9sbERpc3AoLXRoaXMueWRpc3AgKyB5Yik7XG5cbiAgICAgIGlmICh0aGlzLnZpc3VhbE1vZGUpIHtcbiAgICAgICAgdGhpcy5zZWxlY3RUZXh0KG94LCB0aGlzLngsIG95ICsgb3lkLCB0aGlzLnlkaXNwICsgdGhpcy55KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0aGlzLnNldE1lc3NhZ2UoXCJObyBtYXRjaGVzIGZvdW5kLlwiKTtcbiAgICB0aGlzLnJlZnJlc2goMCwgdGhpcy5yb3dzIC0gMSk7XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09PSAnXFxiJyB8fCBrZXkgPT09ICdcXHg3ZicpIHtcbiAgICBpZiAodGhpcy5lbnRyeS5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgYm90dG9tID0gdGhpcy55ZGlzcCArIHRoaXMucm93cyAtIDE7XG4gICAgdGhpcy5lbnRyeSA9IHRoaXMuZW50cnkuc2xpY2UoMCwgLTEpO1xuICAgIHZhciBpID0gdGhpcy5lbnRyeVByZWZpeC5sZW5ndGggKyB0aGlzLmVudHJ5Lmxlbmd0aDtcbiAgICAvL3RoaXMubGluZXNbYm90dG9tXVtpXVsxXSA9ICcgJztcbiAgICB0aGlzLmxpbmVzW2JvdHRvbV1baV0gPSBbXG4gICAgICB0aGlzLmxpbmVzW2JvdHRvbV1baV1bMF0sXG4gICAgICAnICdcbiAgICBdO1xuICAgIHRoaXMueC0tO1xuICAgIHRoaXMucmVmcmVzaCh0aGlzLnJvd3MgLSAxLCB0aGlzLnJvd3MgLSAxKTtcbiAgICB0aGlzLnJlZnJlc2godGhpcy55LCB0aGlzLnkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChrZXkubGVuZ3RoID09PSAxICYmIGtleSA+PSAnICcgJiYga2V5IDw9ICd+Jykge1xuICAgIHZhciBib3R0b20gPSB0aGlzLnlkaXNwICsgdGhpcy5yb3dzIC0gMTtcbiAgICB0aGlzLmVudHJ5ICs9IGtleTtcbiAgICB2YXIgaSA9IHRoaXMuZW50cnlQcmVmaXgubGVuZ3RoICsgdGhpcy5lbnRyeS5sZW5ndGggLSAxO1xuICAgIC8vdGhpcy5saW5lc1tib3R0b21dW2ldWzBdID0gKHRoaXMuZGVmQXR0ciAmIH4weDFmZikgfCA0O1xuICAgIC8vdGhpcy5saW5lc1tib3R0b21dW2ldWzFdID0ga2V5O1xuICAgIHRoaXMubGluZXNbYm90dG9tXVtpXSA9IFtcbiAgICAgICh0aGlzLmRlZkF0dHIgJiB+MHgxZmYpIHwgNCxcbiAgICAgIGtleVxuICAgIF07XG4gICAgdGhpcy54Kys7XG4gICAgdGhpcy5yZWZyZXNoKHRoaXMucm93cyAtIDEsIHRoaXMucm93cyAtIDEpO1xuICAgIHRoaXMucmVmcmVzaCh0aGlzLnksIHRoaXMueSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDaGFyYWN0ZXIgU2V0c1xuICovXG5cblRlcm1pbmFsLmNoYXJzZXRzID0ge307XG5cbi8vIERFQyBTcGVjaWFsIENoYXJhY3RlciBhbmQgTGluZSBEcmF3aW5nIFNldC5cbi8vIGh0dHA6Ly92dDEwMC5uZXQvZG9jcy92dDEwMi11Zy90YWJsZTUtMTMuaHRtbFxuLy8gQSBsb3Qgb2YgY3Vyc2VzIGFwcHMgdXNlIHRoaXMgaWYgdGhleSBzZWUgVEVSTT14dGVybS5cbi8vIHRlc3Rpbmc6IGVjaG8gLWUgJ1xcZSgwYVxcZShCJ1xuLy8gVGhlIHh0ZXJtIG91dHB1dCBzb21ldGltZXMgc2VlbXMgdG8gY29uZmxpY3Qgd2l0aCB0aGVcbi8vIHJlZmVyZW5jZSBhYm92ZS4geHRlcm0gc2VlbXMgaW4gbGluZSB3aXRoIHRoZSByZWZlcmVuY2Vcbi8vIHdoZW4gcnVubmluZyB2dHRlc3QgaG93ZXZlci5cbi8vIFRoZSB0YWJsZSBiZWxvdyBub3cgdXNlcyB4dGVybSdzIG91dHB1dCBmcm9tIHZ0dGVzdC5cblRlcm1pbmFsLmNoYXJzZXRzLlNDTEQgPSB7IC8vICgwXG4gICdgJzogJ1xcdTI1YzYnLCAvLyAn4peGJ1xuICAnYSc6ICdcXHUyNTkyJywgLy8gJ+KWkidcbiAgJ2InOiAnXFx1MDAwOScsIC8vICdcXHQnXG4gICdjJzogJ1xcdTAwMGMnLCAvLyAnXFxmJ1xuICAnZCc6ICdcXHUwMDBkJywgLy8gJ1xccidcbiAgJ2UnOiAnXFx1MDAwYScsIC8vICdcXG4nXG4gICdmJzogJ1xcdTAwYjAnLCAvLyAnwrAnXG4gICdnJzogJ1xcdTAwYjEnLCAvLyAnwrEnXG4gICdoJzogJ1xcdTI0MjQnLCAvLyAnXFx1MjQyNCcgKE5MKVxuICAnaSc6ICdcXHUwMDBiJywgLy8gJ1xcdidcbiAgJ2onOiAnXFx1MjUxOCcsIC8vICfilJgnXG4gICdrJzogJ1xcdTI1MTAnLCAvLyAn4pSQJ1xuICAnbCc6ICdcXHUyNTBjJywgLy8gJ+KUjCdcbiAgJ20nOiAnXFx1MjUxNCcsIC8vICfilJQnXG4gICduJzogJ1xcdTI1M2MnLCAvLyAn4pS8J1xuICAnbyc6ICdcXHUyM2JhJywgLy8gJ+KOuidcbiAgJ3AnOiAnXFx1MjNiYicsIC8vICfijrsnXG4gICdxJzogJ1xcdTI1MDAnLCAvLyAn4pSAJ1xuICAncic6ICdcXHUyM2JjJywgLy8gJ+KOvCdcbiAgJ3MnOiAnXFx1MjNiZCcsIC8vICfijr0nXG4gICd0JzogJ1xcdTI1MWMnLCAvLyAn4pScJ1xuICAndSc6ICdcXHUyNTI0JywgLy8gJ+KUpCdcbiAgJ3YnOiAnXFx1MjUzNCcsIC8vICfilLQnXG4gICd3JzogJ1xcdTI1MmMnLCAvLyAn4pSsJ1xuICAneCc6ICdcXHUyNTAyJywgLy8gJ+KUgidcbiAgJ3knOiAnXFx1MjI2NCcsIC8vICfiiaQnXG4gICd6JzogJ1xcdTIyNjUnLCAvLyAn4omlJ1xuICAneyc6ICdcXHUwM2MwJywgLy8gJ8+AJ1xuICAnfCc6ICdcXHUyMjYwJywgLy8gJ+KJoCdcbiAgJ30nOiAnXFx1MDBhMycsIC8vICfCoydcbiAgJ34nOiAnXFx1MDBiNycgIC8vICfCtydcbn07XG5cblRlcm1pbmFsLmNoYXJzZXRzLlVLID0gbnVsbDsgLy8gKEFcblRlcm1pbmFsLmNoYXJzZXRzLlVTID0gbnVsbDsgLy8gKEIgKFVTQVNDSUkpXG5UZXJtaW5hbC5jaGFyc2V0cy5EdXRjaCA9IG51bGw7IC8vICg0XG5UZXJtaW5hbC5jaGFyc2V0cy5GaW5uaXNoID0gbnVsbDsgLy8gKEMgb3IgKDVcblRlcm1pbmFsLmNoYXJzZXRzLkZyZW5jaCA9IG51bGw7IC8vIChSXG5UZXJtaW5hbC5jaGFyc2V0cy5GcmVuY2hDYW5hZGlhbiA9IG51bGw7IC8vIChRXG5UZXJtaW5hbC5jaGFyc2V0cy5HZXJtYW4gPSBudWxsOyAvLyAoS1xuVGVybWluYWwuY2hhcnNldHMuSXRhbGlhbiA9IG51bGw7IC8vIChZXG5UZXJtaW5hbC5jaGFyc2V0cy5Ob3J3ZWdpYW5EYW5pc2ggPSBudWxsOyAvLyAoRSBvciAoNlxuVGVybWluYWwuY2hhcnNldHMuU3BhbmlzaCA9IG51bGw7IC8vIChaXG5UZXJtaW5hbC5jaGFyc2V0cy5Td2VkaXNoID0gbnVsbDsgLy8gKEggb3IgKDdcblRlcm1pbmFsLmNoYXJzZXRzLlN3aXNzID0gbnVsbDsgLy8gKD1cblRlcm1pbmFsLmNoYXJzZXRzLklTT0xhdGluID0gbnVsbDsgLy8gL0FcblxuLyoqXG4gKiBIZWxwZXJzXG4gKi9cblxuZnVuY3Rpb24gb24oZWwsIHR5cGUsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBjYXB0dXJlIHx8IGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gb2ZmKGVsLCB0eXBlLCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgY2FwdHVyZSB8fCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGNhbmNlbChldikge1xuICBpZiAoZXYucHJldmVudERlZmF1bHQpIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gIGV2LnJldHVyblZhbHVlID0gZmFsc2U7XG4gIGlmIChldi5zdG9wUHJvcGFnYXRpb24pIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICBldi5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGluaGVyaXRzKGNoaWxkLCBwYXJlbnQpIHtcbiAgZnVuY3Rpb24gZigpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gIH1cbiAgZi5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgZjtcbn1cblxuLy8gaWYgYm9sZCBpcyBicm9rZW4sIHdlIGNhbid0XG4vLyB1c2UgaXQgaW4gdGhlIHRlcm1pbmFsLlxuZnVuY3Rpb24gaXNCb2xkQnJva2VuKGRvY3VtZW50KSB7XG4gIHZhciBib2R5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2JvZHknKVswXTtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICBlbC5pbm5lckhUTUwgPSAnaGVsbG8gd29ybGQnO1xuICBib2R5LmFwcGVuZENoaWxkKGVsKTtcbiAgdmFyIHcxID0gZWwuc2Nyb2xsV2lkdGg7XG4gIGVsLnN0eWxlLmZvbnRXZWlnaHQgPSAnYm9sZCc7XG4gIHZhciB3MiA9IGVsLnNjcm9sbFdpZHRoO1xuICBib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgcmV0dXJuIHcxICE9PSB3Mjtcbn1cblxudmFyIFN0cmluZyA9IHRoaXMuU3RyaW5nO1xudmFyIHNldFRpbWVvdXQgPSB0aGlzLnNldFRpbWVvdXQ7XG52YXIgc2V0SW50ZXJ2YWwgPSB0aGlzLnNldEludGVydmFsO1xuXG5mdW5jdGlvbiBpbmRleE9mKG9iaiwgZWwpIHtcbiAgdmFyIGkgPSBvYmoubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKG9ialtpXSA9PT0gZWwpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gaXNXaWRlKGNoKSB7XG4gIGlmIChjaCA8PSAnXFx1ZmYwMCcpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIChjaCA+PSAnXFx1ZmYwMScgJiYgY2ggPD0gJ1xcdWZmYmUnKVxuICAgICAgfHwgKGNoID49ICdcXHVmZmMyJyAmJiBjaCA8PSAnXFx1ZmZjNycpXG4gICAgICB8fCAoY2ggPj0gJ1xcdWZmY2EnICYmIGNoIDw9ICdcXHVmZmNmJylcbiAgICAgIHx8IChjaCA+PSAnXFx1ZmZkMicgJiYgY2ggPD0gJ1xcdWZmZDcnKVxuICAgICAgfHwgKGNoID49ICdcXHVmZmRhJyAmJiBjaCA8PSAnXFx1ZmZkYycpXG4gICAgICB8fCAoY2ggPj0gJ1xcdWZmZTAnICYmIGNoIDw9ICdcXHVmZmU2JylcbiAgICAgIHx8IChjaCA+PSAnXFx1ZmZlOCcgJiYgY2ggPD0gJ1xcdWZmZWUnKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hDb2xvcihyMSwgZzEsIGIxKSB7XG4gIHZhciBoYXNoID0gKHIxIDw8IDE2KSB8IChnMSA8PCA4KSB8IGIxO1xuXG4gIGlmIChtYXRjaENvbG9yLl9jYWNoZVtoYXNoXSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG1hdGNoQ29sb3IuX2NhY2hlW2hhc2hdO1xuICB9XG5cbiAgdmFyIGxkaWZmID0gSW5maW5pdHlcbiAgICAsIGxpID0gLTFcbiAgICAsIGkgPSAwXG4gICAgLCBjXG4gICAgLCByMlxuICAgICwgZzJcbiAgICAsIGIyXG4gICAgLCBkaWZmO1xuXG4gIGZvciAoOyBpIDwgVGVybWluYWwudmNvbG9ycy5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBUZXJtaW5hbC52Y29sb3JzW2ldO1xuICAgIHIyID0gY1swXTtcbiAgICBnMiA9IGNbMV07XG4gICAgYjIgPSBjWzJdO1xuXG4gICAgZGlmZiA9IG1hdGNoQ29sb3IuZGlzdGFuY2UocjEsIGcxLCBiMSwgcjIsIGcyLCBiMik7XG5cbiAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgbGkgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGRpZmYgPCBsZGlmZikge1xuICAgICAgbGRpZmYgPSBkaWZmO1xuICAgICAgbGkgPSBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaENvbG9yLl9jYWNoZVtoYXNoXSA9IGxpO1xufVxuXG5tYXRjaENvbG9yLl9jYWNoZSA9IHt9O1xuXG4vLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2MzM4Mjhcbm1hdGNoQ29sb3IuZGlzdGFuY2UgPSBmdW5jdGlvbihyMSwgZzEsIGIxLCByMiwgZzIsIGIyKSB7XG4gIHJldHVybiBNYXRoLnBvdygzMCAqIChyMSAtIHIyKSwgMilcbiAgICArIE1hdGgucG93KDU5ICogKGcxIC0gZzIpLCAyKVxuICAgICsgTWF0aC5wb3coMTEgKiAoYjEgLSBiMiksIDIpO1xufTtcblxuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXIsIGNvbikge1xuICBpZiAob2JqLmZvckVhY2gpIHJldHVybiBvYmouZm9yRWFjaChpdGVyLCBjb24pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgIGl0ZXIuY2FsbChjb24sIG9ialtpXSwgaSwgb2JqKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBrZXlzKG9iaikge1xuICBpZiAoT2JqZWN0LmtleXMpIHJldHVybiBPYmplY3Qua2V5cyhvYmopO1xuICB2YXIga2V5LCBrZXlzID0gW107XG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbi8qKlxuICogRXhwb3NlXG4gKi9cblxuVGVybWluYWwuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuVGVybWluYWwuaW5oZXJpdHMgPSBpbmhlcml0cztcblRlcm1pbmFsLm9uID0gb247XG5UZXJtaW5hbC5vZmYgPSBvZmY7XG5UZXJtaW5hbC5jYW5jZWwgPSBjYW5jZWw7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IFRlcm1pbmFsO1xufSBlbHNlIHtcbiAgdGhpcy5UZXJtaW5hbCA9IFRlcm1pbmFsO1xufVxuXG59KS5jYWxsKGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcyB8fCAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpO1xufSgpKTtcbiJdfQ==
